<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Freenx-cvs] r503 - in trunk/freenx-redesign/server: .	compatibility lib lib/nxparser test test/include utility
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/freenx-cvs/2008-March/index.html" >
   <LINK REL="made" HREF="mailto:freenx-cvs%40lists.berlios.de?Subject=Re%3A%20%5BFreenx-cvs%5D%20r503%20-%20in%20trunk/freenx-redesign/server%3A%20.%0A%09compatibility%20lib%20lib/nxparser%20test%20test/include%20utility&In-Reply-To=%3C200803102223.m2AMN1vY003644%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000628.html">
   <LINK REL="Next"  HREF="000629.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Freenx-cvs] r503 - in trunk/freenx-redesign/server: .	compatibility lib lib/nxparser test test/include utility</H1>
    <B>fabianx at BerliOS</B> 
    <A HREF="mailto:freenx-cvs%40lists.berlios.de?Subject=Re%3A%20%5BFreenx-cvs%5D%20r503%20-%20in%20trunk/freenx-redesign/server%3A%20.%0A%09compatibility%20lib%20lib/nxparser%20test%20test/include%20utility&In-Reply-To=%3C200803102223.m2AMN1vY003644%40sheep.berlios.de%3E"
       TITLE="[Freenx-cvs] r503 - in trunk/freenx-redesign/server: .	compatibility lib lib/nxparser test test/include utility">fabianx at mail.berlios.de
       </A><BR>
    <I>Mon Mar 10 23:24:41 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000628.html">[Freenx-cvs] r502 - / tags trunk
</A></li>
        <LI>Next message: <A HREF="000629.html">[Freenx-cvs] r504 - in tags: . nx-utils nxcl qtnx
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#670">[ date ]</a>
              <a href="thread.html#670">[ thread ]</a>
              <a href="subject.html#670">[ subject ]</a>
              <a href="author.html#670">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: fabianx
Date: 2008-03-10 23:22:58 +0100 (Mon, 10 Mar 2008)
New Revision: 503

Added:
   trunk/freenx-redesign/server/COPYING
   trunk/freenx-redesign/server/Makefile
   trunk/freenx-redesign/server/compatibility/nxagent
   trunk/freenx-redesign/server/compatibility/nxnode
   trunk/freenx-redesign/server/compatibility/nxserver
   trunk/freenx-redesign/server/compatibility/nxservice
   trunk/freenx-redesign/server/compatibility/nxsession
   trunk/freenx-redesign/server/compatibility/nxshadow
   trunk/freenx-redesign/server/compatibility/nxstart
   trunk/freenx-redesign/server/lib/
   trunk/freenx-redesign/server/lib/nxloadconfig.py
   trunk/freenx-redesign/server/lib/nxloadconfig_test.py
   trunk/freenx-redesign/server/lib/nxlog.py
   trunk/freenx-redesign/server/lib/nxlog_test.py
   trunk/freenx-redesign/server/lib/nxparser.py.orig
   trunk/freenx-redesign/server/lib/nxparser/
   trunk/freenx-redesign/server/lib/nxparser/__init__.py
   trunk/freenx-redesign/server/lib/nxparser/base.py
   trunk/freenx-redesign/server/lib/nxparser/base_test.py
   trunk/freenx-redesign/server/lib/nxparser/node.py
   trunk/freenx-redesign/server/lib/nxparser/server.py
   trunk/freenx-redesign/server/lib/nxsession.py
   trunk/freenx-redesign/server/lib/nxsession_test.py
   trunk/freenx-redesign/server/test/
   trunk/freenx-redesign/server/test/README.TXT
   trunk/freenx-redesign/server/test/client2server-regression.run
   trunk/freenx-redesign/server/test/client2server-regression.template
   trunk/freenx-redesign/server/test/include/
   trunk/freenx-redesign/server/test/include/commercial-nx-3.0-functions
   trunk/freenx-redesign/server/test/include/nxserver-fuctions.inc
   trunk/freenx-redesign/server/test/include/test-functions.inc
   trunk/freenx-redesign/server/test/run-test-suite
   trunk/freenx-redesign/server/test/testClient2server-regression-1.5.0
   trunk/freenx-redesign/server/test/testClient2server-regression-2.0.0
   trunk/freenx-redesign/server/test/testClient2server-regression-2.1.0
   trunk/freenx-redesign/server/test/testClient2server-regression-3.0.0
   trunk/freenx-redesign/server/test/testNxloadconfig
   trunk/freenx-redesign/server/test/testNxlog
   trunk/freenx-redesign/server/test/testNxserver-login
   trunk/freenx-redesign/server/test/testTest-functions
   trunk/freenx-redesign/server/utility/log4sh
   trunk/freenx-redesign/server/utility/nxagent-helper
   trunk/freenx-redesign/server/utility/nxloadconfig-helper.sh
   trunk/freenx-redesign/server/utility/nxserver-suid.c
   trunk/freenx-redesign/server/utility/shunit2
Modified:
   trunk/freenx-redesign/server/compatibility/nxserver-login
   trunk/freenx-redesign/server/compatibility/nxserver-login-helper
   trunk/freenx-redesign/server/compatibility/nxserver-login-hook
   trunk/freenx-redesign/server/utility/nxloadconfig
   trunk/freenx-redesign/server/utility/nxlog
Log:
Imported redesign snapshot by Google.

Thanks to <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">diamond at google.com.</A>



Added: trunk/freenx-redesign/server/COPYING
===================================================================
--- trunk/freenx-redesign/server/COPYING	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/COPYING	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,339 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The &quot;Program&quot;, below,
+refers to any such program or work, and a &quot;work based on the Program&quot;
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term &quot;modification&quot;.)  Each licensee is addressed as &quot;you&quot;.
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and &quot;any
+later version&quot;, you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM &quot;AS IS&quot; WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the &quot;copyright&quot; line and a pointer to where the full notice is found.
+
+    &lt;one line to give the program's name and a brief idea of what it does.&gt;
+    Copyright (C) &lt;year&gt;  &lt;name of author&gt;
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a &quot;copyright disclaimer&quot; for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  &lt;signature of Ty Coon&gt;, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.

Added: trunk/freenx-redesign/server/Makefile
===================================================================
--- trunk/freenx-redesign/server/Makefile	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/Makefile	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,104 @@
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">alriddoch at google.com</A> (Alistair Riddoch)
+
+.PHONY: all install dist
+
+SUDO_PROMPT = Your password for sudo access:
+
+PACKAGE = freenx
+VERSION = 0.0.0
+CC = gcc
+CFLAGS = -Wall -g
+
+INSTALL = install
+TAR = tar
+PREFIX = /usr/freenx
+BINDIR = $(PREFIX)/bin
+LIBDIR = $(PREFIX)/lib
+PARSERLIBDIR = $(LIBDIR)/nxparser
+ETCDIR = $(PREFIX)/etc
+VARDIR = $(PREFIX)/var
+SESSDBDIR = $(VARDIR)/sessdb
+TMPNXDIR = /tmp/nx
+COMPATABILITY = compatibility/nxagent \
+                compatibility/nxnode \
+                compatibility/nxserver \
+                compatibility/nxserver-login \
+                compatibility/nxserver-login-helper \
+                compatibility/nxserver-login-hook \
+                compatibility/nxserver-login-userhook \
+                compatibility/nxservice \
+                compatibility/nxshadow \
+                compatibility/nxstart
+UTILITY = utility/nxloadconfig \
+          utility/nxloadconfig-helper.sh \
+          utility/nxlog \
+          utility/log4sh \
+          utility/nxagent-helper
+SOURCES = utility/nxserver-suid.c
+PROGRAMS = utility/nxserver-suid
+BINARIES = $(COMPATABILITY) $(UTILITY) $(PROGRAMS)
+LIBRARIES = lib/nxloadconfig.py \
+            lib/nxlog.py \
+            lib/nxsession.py
+PARSER_LIB = lib/nxparser/__init__.py \
+             lib/nxparser/base.py \
+             lib/nxparser/node.py \
+             lib/nxparser/server.py
+
+all: $(PROGRAMS)
+
+ARCHIVE=$(PWD)/$(PACKAGE)-$(VERSION).tar.gz
+DISTDIR=$${TMPDIR-/tmp}/$(PACKAGE)-$(VERSION)
+dist:
+	$(RM) -r $(DISTDIR)
+	$(INSTALL) -d $(DISTDIR)
+	$(INSTALL) -m 644 Makefile $(DISTDIR)
+	$(INSTALL) -d $(DISTDIR)/utility
+	$(INSTALL) -m 755 $(UTILITY) $(DISTDIR)/utility
+	$(INSTALL) -d $(DISTDIR)/compatability
+	$(INSTALL) -m 755 $(COMPATABILITY) $(DISTDIR)/compatability
+	$(INSTALL) -m 644 $(SOURCES) $(DISTDIR)/utility
+	$(INSTALL) -d $(DISTDIR)/lib
+	$(INSTALL) -m 644 $(LIBRARIES) $(DISTDIR)/lib
+	$(INSTALL) -d $(DISTDIR)/lib/nxparser
+	$(INSTALL) -m 644 $(PARSER_LIB) $(DISTDIR)/lib/nxparser
+	(cd $${TMPDIR-/tmp} &amp;&amp; $(TAR) chozf $(ARCHIVE) $(PACKAGE)-$(VERSION))
+	$(RM) -r $(DISTDIR)
+
+install: utility/nxserver-suid
+	@sudo -p &quot;$(SUDO_PROMPT)&quot; true
+	sudo $(INSTALL) -o $(LOGNAME) -d -m 755 $(BINDIR)
+	sudo $(INSTALL) -o nx -d -m 755 $(VARDIR)
+	sudo $(INSTALL) -o nx -d -m 700 $(SESSDBDIR)
+	$(INSTALL) -m 755 $(BINARIES) $(BINDIR)
+	$(INSTALL) -d -m 755 $(LIBDIR)
+	$(INSTALL) -m 644 $(LIBRARIES) $(LIBDIR)
+	$(INSTALL) -d -m 755 $(PARSERLIBDIR)
+	$(INSTALL) -m 644 $(PARSER_LIB) $(PARSERLIBDIR)
+	$(INSTALL) -d -m 755 $(ETCDIR)
+	echo -e &quot;PATH_BIN=\&quot;$(BINDIR)\&quot;\nPATH=\&quot;$$PATH:$(BINDIR)\&quot;\nLOG_LEVEL=DEBUG&quot; &gt; $(ETCDIR)/general.conf
+	echo -e &quot;LOG_LEVEL=NOTICE&quot; &gt; $(ETCDIR)/nxstart.conf
+	echo -e &quot;COMMAND_START_GNOME='/usr/bin/dbus-launch --exit-with-session gnome-session'\n\
+	COMMAND_START_KDE='/usr/bin/dbus-launch --exit-with-session startkde'&quot; &gt; $(ETCDIR)/nxagent-helper.conf
+	chmod 644 $(ETCDIR)/general.conf
+	sudo chown nx $(BINDIR)/nxserver-suid
+	sudo chmod 4755 $(BINDIR)/nxserver-suid
+	[ ! -e $(TMPNXDIR] &amp;&amp; sudo mkdir $(TMPNXDIR)
+	sudo chown root:root $(TMPNXDIR)
+	sudo chmod 1777 $(TMPNXDIR)

Added: trunk/freenx-redesign/server/compatibility/nxagent
===================================================================
--- trunk/freenx-redesign/server/compatibility/nxagent	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/compatibility/nxagent	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,43 @@
+#!/bin/bash
+
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# nxfoo - Provides functionality for the freenx redesign
+#
+# Authors: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">diamond at google.com</A> (Stephen Shirley)
+#          <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">alriddoch at google.com</A> (Alistair Riddoch)
+#
+# Used configuration keys:
+#
+# Used internal subfunctions:
+#
+# Used internal variables:
+#
+# Used internal components:
+#
+# Used external programs:
+#
+# Accepted protocol requests from client:
+#
+# Used protocol responses to client:
+#
+# FAQ-Questions:
+#
+# SVN: $Id: $
+#
+
+exec /usr/NX/bin/nxagent &quot;$@&quot;


Property changes on: trunk/freenx-redesign/server/compatibility/nxagent
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/compatibility/nxnode
===================================================================
--- trunk/freenx-redesign/server/compatibility/nxnode	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/compatibility/nxnode	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,55 @@
+#!/usr/bin/python2.4
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">alriddoch at google.com</A> (Alistair Riddoch)
+
+&quot;&quot;&quot;nxnode program for handling nx nodes.
+
+&quot;&quot;&quot;
+
+import sys
+import signal
+
+sys.path.append('/usr/freenx/lib')
+import nxlog
+import nxparser
+
+
+def signal_handler(signum, unused_frame):
+  nxlog.log(nxlog.LOG_DEBUG, 'Going down on signal %d' % signum)
+  sys.exit(1)
+
+
+def main():
+  nxlog.setup('nxnode')
+  nxlog.set_log_level(nxlog.LOG_DEBUG)
+  nxlog.log(nxlog.LOG_DEBUG, 'Startup')
+  nxlog.log(nxlog.LOG_DEBUG, 'Args %r' % sys.argv)
+
+  signal.signal(signal.SIGINT, signal_handler)
+  signal.signal(signal.SIGTERM, signal_handler)
+  signal.signal(signal.SIGHUP, signal.SIG_IGN)
+
+  parser = nxparser.node.parser(sys.stdin, sys.stdout)
+  parser.banner()
+  parser.loop()
+  nxlog.log(nxlog.LOG_DEBUG, 'Finished')
+
+
+if __name__ == '__main__':
+  main()


Property changes on: trunk/freenx-redesign/server/compatibility/nxnode
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/compatibility/nxserver
===================================================================
--- trunk/freenx-redesign/server/compatibility/nxserver	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/compatibility/nxserver	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,55 @@
+#!/usr/bin/python2.4
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">alriddoch at google.com</A> (Alistair Riddoch)
+
+&quot;&quot;&quot;nxserver program for accepting nx connections.
+
+&quot;&quot;&quot;
+
+import sys
+import signal
+
+sys.path.append('/usr/freenx/lib')
+import nxlog
+import nxparser
+
+
+def signal_handler(signum, unused_frame):
+  nxlog.log(nxlog.LOG_DEBUG, 'Going down on signal %d' % signum)
+  sys.exit(1)
+
+
+def main():
+  nxlog.setup('nxserver')
+  nxlog.set_log_level(nxlog.LOG_DEBUG)
+  nxlog.log(nxlog.LOG_DEBUG, 'Startup')
+  nxlog.log(nxlog.LOG_DEBUG, 'Args %r' % sys.argv)
+
+  signal.signal(signal.SIGINT, signal_handler)
+  signal.signal(signal.SIGTERM, signal_handler)
+  signal.signal(signal.SIGHUP, signal_handler)
+
+  parser = nxparser.server.parser(sys.stdin, sys.stdout)
+  parser.banner()
+  parser.loop()
+  nxlog.log(nxlog.LOG_DEBUG, 'Finished')
+
+
+if __name__ == '__main__':
+  main()


Property changes on: trunk/freenx-redesign/server/compatibility/nxserver
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/freenx-redesign/server/compatibility/nxserver-login
===================================================================
--- trunk/freenx-redesign/server/compatibility/nxserver-login	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/compatibility/nxserver-login	2008-03-10 22:22:58 UTC (rev 503)
@@ -17,7 +17,6 @@
 # @sub echo_x echo and possibly log and/or translate
 # @sub read_x read with specified timeout
 # @sub &quot;read_x_prompt &lt;prompt&gt; &quot; like read_x but show &lt;prompt&gt; first
-# @sub &quot;log n&quot; log to (sys)log with loglevel n
 #
 # Used internal variables:
 #
@@ -53,9 +52,9 @@
 # @rsp 102	&quot;NX&gt; 404 ERROR: wrong password or login&quot; Answer for wrong user or wrong password.
 # @rsp 102	&quot;NX&gt; 103 Welcome&quot; Used implicitely as nxserver-login-helper will go into interact mode on 103.
 # @rsp *	&quot;NX&gt; 996 ERROR: Operation timeout in server protocol&quot; Thrown if the read_x times out.
-# @rsp bye	&quot;NX&gt; 999 Bye.&quot;
-# @rsp exit	&quot;NX&gt; 999 Bye.&quot;
-# @rsp quit	&quot;NX&gt; 999 Bye.&quot;
+# @rsp bye	&quot;NX&gt; 999 Bye&quot;
+# @rsp exit	&quot;NX&gt; 999 Bye&quot;
+# @rsp quit	&quot;NX&gt; 999 Bye&quot;
 # 
 # FAQ-Questions:
 #
@@ -72,26 +71,21 @@
 NXSERVER_LOGIN_HOOK_LOGIN_USER=&quot;&quot;
 NXSERVER_LOGIN_AUTHENTICATION_METHOD=&quot;su&quot;
 
+_NXLOADCONFIG=&quot;$(cd $(dirname $0) &amp;&amp; pwd -L)/nxloadconfig&quot;
+[ -f &quot;$_NXLOADCONFIG&quot; ] || _NXLOADCONFIG='nxloadconfig'
+
 #Read the nxserver-login.cfg file and load some helper functions
-#. $(PATH=$(cd $(dirname $0) &amp;&amp; pwd):$PATH which nxloadconfig) -- --config=nxserver-login || { echo &quot;NX 503&gt; Internal server error. nxloadconfig could not be loaded.&quot;; exit 1; }
+. &quot;$_NXLOADCONFIG&quot; --config=&quot;nxserver-login&quot; || { echo &quot;NX 503&gt; Internal server error. nxloadconfig could not be loaded.&quot;; exit 1; }
 
-# FIXME: Remove this section once nxloadconfig above works
-
-PATH_BIN=$(cd $(dirname $0) &amp;&amp; pwd)
-COMMAND_NETCAT=&quot;$(which netcat)&quot;
-
 echo_x() 
 {
 	echo &quot;$@&quot;
+  nxlog_log DEBUG &quot;Sent: $@&quot;
 }
 
-log()
-{
-	echo &quot;LOG: $@&quot;
-} 
 read_x()
 {
-	read -t 10 &quot;$@&quot;
+	read -t &quot;${READ_X_TIMEOUT:-10}&quot; &quot;$@&quot; || { echo_x; return 1; }
 }
 
 read_x_prompt() 
@@ -101,24 +95,6 @@
 	read_x &quot;$@&quot;
 }
 
-# Re-check configuration keys
-
-if [ -n &quot;$NXSERVER_LOGIN_HOOK_LOGIN_USER&quot; -a ! -x &quot;$NXSERVER_LOGIN_HOOK_LOGIN_USER&quot; ]
-then
-	log $LOG_WARN $&quot;Warning: Configuration key NXSERVER_LOGIN_HOOK_LOGIN_USER=$NXSERVER_LOGIN_HOOK_LOGIN_USER is invalid. Reset to \&quot;\&quot;.&quot;
-	NXSERVER_LOGIN_HOOK_LOGIN_USER=&quot;&quot;
-fi
-
-case &quot;$NXSERVER_LOGIN_AUTHENTICATION_METHOD&quot; in
-	ssh|su)
-	;;
-	*)
-		log $LOG_WARN $&quot;Warning: Configuration key NXSERVER_LOGIN_AUTHENTICATION_METHOD=$NXSERVER_LOGIN_AUTHENTICATION_METHOD is invalid. Reset to su.&quot;
-		NXSERVER_LOGIN_AUTHENTICATION_METHOD=&quot;su&quot;
-	;;
-esac
-
-
 # helper functions
 
 timeout()
@@ -128,76 +104,140 @@
 	exit 1
 }
 
-# main program
+config_check()
+{
+  # Re-check configuration keys
 
-echo_x &quot;HELLO NXSERVER - Version $NX_VERSION $NX_LICENSE&quot;
+  if [ -n &quot;$NXSERVER_LOGIN_HOOK_LOGIN_USER&quot; -a ! -x &quot;$NXSERVER_LOGIN_HOOK_LOGIN_USER&quot; ]
+  then
+    nxlog_log WARNING $&quot;Warning: Configuration key NXSERVER_LOGIN_HOOK_LOGIN_USER=$NXSERVER_LOGIN_HOOK_LOGIN_USER is invalid. Reset to \&quot;\&quot;.&quot;
+    NXSERVER_LOGIN_HOOK_LOGIN_USER=&quot;&quot;
+  fi
 
-# Login stage
-while read_x_prompt &quot;NX&gt; 105 &quot; CMD
-do
-	echo_x &quot;$CMD&quot;
-	
-	case &quot;$CMD&quot; in 
-		quit|QUIT)
-			echo_x &quot;Quit&quot;
-			break
-		;;
-		exit|EXIT)
-			echo_x &quot;Exit&quot;
-			break
-		;;
-		bye|BYE)
-			echo_x &quot;Bye&quot;
-			break
-		;;
-		hello*|HELLO*)
-			PROTO=$(echo $CMD | sed 's/.*Version \(.*\)/\1/g')
-			echo_x $&quot;NX&gt; 134 Accepted protocol: $PROTO&quot;
-		;;
-		&quot;set auth_mode*&quot;|&quot;SET AUTH_MODE*&quot;)
-			if [ &quot;$CMD&quot; = &quot;set auth_mode password&quot; -o &quot;$CMD&quot; = &quot;SET AUTH_MODE PASSWORD&quot; ]
-			then
-				echo_x &quot;Set auth_mode: password&quot;
-			else
-				echo_x $&quot;NX&gt; 500 ERROR: unknown auth mode ''&quot;
-			fi
-		;;
-		login|LOGIN)
-			LOGIN_SUCCESS=&quot;0&quot;
-			
-			echo_x -n $&quot;NX&gt; 101 User: &quot;
-			read_x USER || timeout
-			echo_x $USER
-			
-			echo_x -n $&quot;NX&gt; 102 Password: &quot;
-			read_x -s PASS || timeout
-			echo_x &quot;&quot;
-			log $LOG_INFO $&quot;Info: Using authentication method $NXSERVER_LOGIN_AUTHENTICATION_METHOD for user $USER.&quot;
+  case &quot;$NXSERVER_LOGIN_AUTHENTICATION_METHOD&quot; in
+    ssh|su)
+    ;;
+    *)
+      nxlog_log WARNING $&quot;Warning: Configuration key NXSERVER_LOGIN_AUTHENTICATION_METHOD=$NXSERVER_LOGIN_AUTHENTICATION_METHOD is invalid. Reset to su.&quot;
+      NXSERVER_LOGIN_AUTHENTICATION_METHOD=&quot;su&quot;
+    ;;
+  esac
+}
 
-			NODE_HOOK_LOGIN=&quot;$PATH_BIN/nxserver-login-hook&quot;
-			[ -n &quot;$NXSERVER_LOGIN_HOOK_LOGIN_USER&quot; ] &amp;&amp; NODE_HOOK_LOGIN=&quot;$NXSERVER_LOGIN_HOOK_LOGIN_USER&quot;
-			export NODE_HOOK_LOGIN
+nxserver-login_main()
+{
+  # main program
 
-			NODE_PASSWORD=&quot;$PASS&quot; $PATH_BIN/nxserver-login-helper -- &quot;$NXSERVER_LOGIN_AUTHENTICATION_METHOD&quot; &quot;$USER&quot; &quot;$PATH_BIN/nxserver-suid&quot; &quot;--proto=$PROTO&quot;
-			AUTHENTICATION_FAILED=&quot;$?&quot;
-			
-			if [ &quot;$AUTHENTICATION_FAILED&quot; = &quot;1&quot; ]
-			then
-				echo_x $&quot;NX&gt; 404 ERROR: wrong password or login&quot;
-				echo_x $&quot;NX&gt; 999 Bye.&quot;
-				exit 1
-			fi
-			
-			if [ &quot;$AUTHENTICATION_FAILED&quot; = &quot;2&quot; ]
-			then
-				echo_x $&quot;NX&gt; 503 ERROR: Redirection to nxagent failed.&quot;
-				echo_x $&quot;NX&gt; 999 Bye.&quot;
-				exit 2
-			fi
+  echo_x &quot;HELLO NXSERVER - Version $NX_VERSION $NX_LICENSE&quot;
+  nxlog_log INFO &quot;Started&quot;
 
-			exit 0
-		;;
-	esac
-done
-echo_x $&quot;NX&gt; 999 Bye.&quot;
-exit 0
+  # Login stage
+  while read_x_prompt &quot;NX&gt; 105 &quot; CMD
+  do
+    nxlog_log DEBUG &quot;Got: $CMD&quot;
+    CMD=$(echo $CMD | tr '[A-Z]' '[a-z]')
+    case &quot;$CMD&quot; in
+      quit)
+        echo_x &quot;Quit&quot;
+        nxlog_log DEBUG &quot;Exiting&quot;
+        break
+      ;;
+      exit)
+        echo_x &quot;Exit&quot;
+        nxlog_log DEBUG &quot;Exiting&quot;
+        break
+      ;;
+      bye)
+        echo_x &quot;Bye&quot;
+        nxlog_log DEBUG &quot;Exiting&quot;
+        break
+      ;;
+      hello*)
+        echo_x &quot;$CMD&quot;
+        CLIENT_PROTO=&quot;$(echo $CMD | sed 's/.*[Vv]ersion \(.*\)/\1/g')&quot;
+        PROTO=&quot;$(echo -e &quot;$NX_VERSION\n$CLIENT_PROTO&quot; | \
+            sort -n -t. -k1,1 -k2,2 -k3 | head -1)&quot;
+        echo_x $&quot;NX&gt; 134 Accepted protocol: $PROTO&quot;
+      ;;
+      set\ auth_mode\ *)
+        mode=$(echo &quot;$CMD&quot; | sed 's/^[^[:blank:]]\+ [^[:blank:]]\+ \(.*\)/\1/')
+        echo_x &quot;Set auth_mode: $mode&quot;
+        if ! echo &quot;$mode&quot; | egrep -q &quot;password&quot;; then
+          echo_x &quot;NX&gt; 500 ERROR: unknown auth mode ''&quot;
+        fi
+      ;;
+      set\ shell_mode\ *)
+        mode=$(echo &quot;$CMD&quot; | sed 's/^[^[:blank:]]\+ [^[:blank:]]\+ \(.*\)/\1/')
+        echo_x &quot;Set shell_mode: $mode&quot;
+        if ! echo &quot;$mode&quot; | egrep -q &quot;shell&quot;; then
+          echo_x &quot;NX&gt; 500 ERROR: unknown shell mode ''&quot;
+        fi
+      ;;
+      login)
+        echo_x &quot;$CMD&quot;
+        LOGIN_SUCCESS=&quot;0&quot;
+
+        echo_x -n $&quot;NX&gt; 101 User: &quot;
+        read_x USER || timeout
+        echo_x $USER
+
+        echo_x -n $&quot;NX&gt; 102 Password: &quot;
+        read_x -s PASS || timeout
+        echo_x &quot;**********&quot;
+        nxlog_log INFO &quot;Info: Using authentication method $NXSERVER_LOGIN_AUTHENTICATION_METHOD for user $USER.&quot;
+
+        NODE_HOOK_LOGIN=&quot;$PATH_BIN/nxserver-login-hook&quot;
+        [ -n &quot;$NXSERVER_LOGIN_HOOK_LOGIN_USER&quot; ] &amp;&amp; \
+            NODE_HOOK_LOGIN=&quot;$NXSERVER_LOGIN_HOOK_LOGIN_USER&quot;
+        export NODE_HOOK_LOGIN
+
+        # Redirection is used to get around | only being useful for stdout.
+        nxlog_log INFO &quot;Info: Invoking nxserver-login-helper&quot;
+        # This fifo is opened by nxserver-login-helper to log through
+        export SERVER_LOGIN_HELPER_LOG=&quot;$(mktemp -d /tmp/nxserver-login.XXXXXX)/fifo&quot;
+        mkfifo &quot;$SERVER_LOGIN_HELPER_LOG&quot;
+        (
+          nxlog_log DEBUG &quot;Starting to log nxserver-login-helper debug output $SERVER_LOGIN_HELPER_LOG&quot;
+          NXLOG_LOG_PIPE_PREFIX=&quot;helper output:&quot; nxlog_log_pipe DEBUG &lt; &quot;$SERVER_LOGIN_HELPER_LOG&quot;
+          nxlog_log DEBUG &quot;Finished logging nxserver-login-helper debug output&quot;
+          # Cleanup after the fifo
+          rm &quot;$SERVER_LOGIN_HELPER_LOG&quot;
+          rmdir $(dirname &quot;$SERVER_LOGIN_HELPER_LOG&quot;)
+        ) &amp;
+        NODE_PASSWORD=&quot;$PASS&quot; &quot;$PATH_BIN/nxserver-login-helper&quot; -- \
+          &quot;$NXSERVER_LOGIN_AUTHENTICATION_METHOD&quot; &quot;$USER&quot; \
+          &quot;$PATH_BIN/nxserver-suid&quot; &quot;--proto=${PROTO:-}&quot;
+
+        AUTHENTICATION_FAILED=&quot;$?&quot;
+
+        if [ &quot;$AUTHENTICATION_FAILED&quot; = &quot;0&quot; ]
+        then
+          true
+        elif [ &quot;$AUTHENTICATION_FAILED&quot; = &quot;1&quot; ]
+        then
+          echo_x $&quot;NX&gt; 404 ERROR: wrong password or login.&quot;
+          echo_x $&quot;NX&gt; 999 Bye.&quot;
+          exit 1
+        elif [ &quot;$AUTHENTICATION_FAILED&quot; = &quot;2&quot; ]
+        then
+          echo_x $&quot;NX&gt; 503 ERROR: Redirection to nxagent failed.&quot;
+          echo_x $&quot;NX&gt; 999 Bye.&quot;
+          exit 2
+        else
+          echo_x $&quot;NX&gt; 500 ERROR: Unknown error \&quot;$AUTHENTICATION_FAILED\&quot; occurred while logging in.&quot;
+          echo_x $&quot;NX&gt; 999 Bye.&quot;
+          exit 3
+        fi
+
+        exit 0
+      ;;
+    esac
+  done
+  echo_x &quot;NX&gt; 999 Bye.&quot;
+  exit 0
+}
+
+if [ -z &quot;${UNITTESTING:-}&quot; ]; then
+  config_check
+  nxserver-login_main
+fi

Modified: trunk/freenx-redesign/server/compatibility/nxserver-login-helper
===================================================================
--- trunk/freenx-redesign/server/compatibility/nxserver-login-helper	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/compatibility/nxserver-login-helper	2008-03-10 22:22:58 UTC (rev 503)
@@ -58,6 +58,14 @@
 # SVN: $Id$
 #
 
+## Uncomment for debugging:
+#exp_internal 1
+
+#Log the interaction to a fifo, and not to stdout.
+catch {set helper_log_fifo $env(SERVER_LOGIN_HELPER_LOG)}
+log_file -a -noappend $helper_log_fifo
+log_user 0
+
 set auth_method [lindex $argv 0]
 set user [lindex $argv 1]
 set executable [lindex $argv 2]
@@ -69,14 +77,14 @@
 set command_netcat &quot;netcat&quot;
 catch {set command_netcat $env(COMMAND_NETCAT)}
 set host &quot;127.0.0.1&quot;
-set timeout 2
+set timeout 20
 
 #
 # Special test-nx instruction for nxsetup
 #
 
 if { &quot;$auth_method&quot;==&quot;test-nx&quot; } {
-	set stty_init &quot;raw icrnl -echo&quot;
+	set stty_init &quot;raw -echo&quot;
 
 	set publickey &quot;&quot;
 	catch {set publickey $env(NODE_PUBLICKEY)}
@@ -85,10 +93,10 @@
 	expect {
 		timeout { exit 1 }
 		eof { exit 1 }
-		&quot;Are you sure you want to continue connecting (yes/no)?&quot; { send &quot;yes\r&quot;; exp_continue }
+		&quot;Are you sure you want to continue connecting (yes/no)?&quot; { send &quot;yes\n&quot;; exp_continue }
 		&quot;Permission denied*&quot; { exit 1 }
 		&quot;HELLO NXSERVER - Version&quot; { 
-			expect &quot;NX&gt; 105&quot; { send &quot;quit\r&quot; }
+			expect &quot;NX&gt; 105&quot; { send &quot;quit\n&quot; }
 			expect &quot;NX&gt; 999 Bye&quot; { exit 0 }
 		}
 	}
@@ -101,9 +109,9 @@
 
 set password &quot;&quot;
 catch {set password $env(NODE_PASSWORD)}
+set env(NODE_PASSWORD) &quot;&quot;
+set stty_init &quot;raw -echo&quot;
 
-set stty_init &quot;raw icrnl -echo&quot;
-
 if { &quot;$auth_method&quot;!=&quot;test-nx&quot; } {
 	set pid [ spawn -noecho $command_login &quot;$auth_method&quot; &quot;$user&quot; &quot;$executable&quot; &quot;$parameters&quot; ]
 } else {
@@ -113,11 +121,17 @@
 expect {
 	timeout { exit 1 }
 	eof { exit 1 }
-	&quot;Are you sure you want to continue connecting (yes/no)?&quot; { send &quot;yes\r&quot;; exp_continue }
-	&quot;assword*:&quot;  { sleep 0.3; send &quot;$password\r&quot;; set password &quot;&quot;; exp_continue }
+	&quot;Are you sure you want to continue connecting (yes/no)?&quot; { send &quot;yes\n&quot;; exp_continue }
+	&quot;assword*:&quot;  { sleep 0.3; send &quot;$password\n&quot;; set password &quot;&quot;; exp_continue }
 	&quot;Permission denied*&quot; { exit 1 }
 	&quot;su: Authentication failure&quot; { exit 1 }
-	&quot;NX&gt; 103&quot; {
+	&quot;Unknown id:*&quot; { exit 1 }
+	-notransfer &quot;NX&gt; 103*&quot; {
+		# Stop logging to stderr:
+		log_file
+		send_user &quot;$expect_out(buffer)&quot;
+		# Send all output to the user:
+		log_user 1
 		set redir &quot;0&quot;
 		interact {
 			-o &quot;FREENX&gt; 100 &quot; {

Modified: trunk/freenx-redesign/server/compatibility/nxserver-login-hook
===================================================================
--- trunk/freenx-redesign/server/compatibility/nxserver-login-hook	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/compatibility/nxserver-login-hook	2008-03-10 22:22:58 UTC (rev 503)
@@ -12,7 +12,7 @@
 # FIXME: Read general config
 
 SSH_PORT=&quot;22&quot;
-SSH_HOST=&quot;127.0.0.1&quot;
+SSH_HOST=&quot;$HOSTNAME&quot;
 COMMAND_SU=&quot;su&quot;
 COMMAND_SSH=&quot;ssh&quot;
 
@@ -23,10 +23,10 @@
 
 case &quot;$1&quot; in
 	ssh)
-		exec $COMMAND_SSH -2 -x -l &quot;$2&quot; &quot;$SSH_HOST&quot; -p &quot;$SSH_PORT&quot; -o &quot;NumberOfPasswordPrompts 1&quot; &quot;$3&quot; &quot;$4&quot;
+		exec $COMMAND_SSH -2 -x -l &quot;$2&quot; &quot;$SSH_HOST&quot; -p &quot;$SSH_PORT&quot; -o &quot;NumberOfPasswordPrompts 1&quot; &quot;PATH=$PATH&quot; &quot;$3&quot; &quot;$4&quot;
 	;;
 	su)
-		exec $COMMAND_SU - &quot;$2&quot; -c &quot;$3 $4&quot;
+		exec $COMMAND_SU - &quot;$2&quot; -c &quot;PATH=$PATH $3 $4&quot;
 	;;
 esac
 

Added: trunk/freenx-redesign/server/compatibility/nxservice
===================================================================
--- trunk/freenx-redesign/server/compatibility/nxservice	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/compatibility/nxservice	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,44 @@
+#!/bin/bash
+
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# nxfoo - Provides functionality for the freenx redesign
+#
+# Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">alriddoch at google.com</A> (Alistair Riddoch)
+#
+# Used configuration keys:
+#
+# Used internal subfunctions:
+#
+# Used internal variables:
+#
+# Used internal components:
+#
+# Used external programs:
+#
+# Accepted protocol requests from client:
+#
+# Used protocol responses to client:
+#
+# FAQ-Questions:
+#
+# SVN: $Id: $
+#
+
+export LOG_LEVEL=7
+
+nxlog 7 Unimplemented command $0 invoked with arguments $@


Property changes on: trunk/freenx-redesign/server/compatibility/nxservice
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/compatibility/nxsession
===================================================================
--- trunk/freenx-redesign/server/compatibility/nxsession	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/compatibility/nxsession	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,44 @@
+#!/bin/bash
+
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# nxfoo - Provides functionality for the freenx redesign
+#
+# Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">alriddoch at google.com</A> (Alistair Riddoch)
+#
+# Used configuration keys:
+#
+# Used internal subfunctions:
+#
+# Used internal variables:
+#
+# Used internal components:
+#
+# Used external programs:
+#
+# Accepted protocol requests from client:
+#
+# Used protocol responses to client:
+#
+# FAQ-Questions:
+#
+# SVN: $Id: $
+#
+
+export LOG_LEVEL=7
+
+nxlog 7 Unimplemented command $0 invoked with arguments $@


Property changes on: trunk/freenx-redesign/server/compatibility/nxsession
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/compatibility/nxshadow
===================================================================
--- trunk/freenx-redesign/server/compatibility/nxshadow	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/compatibility/nxshadow	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,44 @@
+#!/bin/bash
+
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# nxfoo - Provides functionality for the freenx redesign
+#
+# Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">alriddoch at google.com</A> (Alistair Riddoch)
+#
+# Used configuration keys:
+#
+# Used internal subfunctions:
+#
+# Used internal variables:
+#
+# Used internal components:
+#
+# Used external programs:
+#
+# Accepted protocol requests from client:
+#
+# Used protocol responses to client:
+#
+# FAQ-Questions:
+#
+# SVN: $Id: $
+#
+
+export LOG_LEVEL=7
+
+nxlog 7 Unimplemented command $0 invoked with arguments $@


Property changes on: trunk/freenx-redesign/server/compatibility/nxshadow
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/compatibility/nxstart
===================================================================
--- trunk/freenx-redesign/server/compatibility/nxstart	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/compatibility/nxstart	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,61 @@
+#!/bin/bash
+
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# nxfoo - Provides functionality for the freenx redesign
+#
+# Authors: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">diamond at google.com</A> (Stephen Shirley)
+#
+# License: GNU GPL, version 2
+#
+# Used configuration keys:
+#
+# Used internal subfunctions:
+#
+# Used internal variables:
+#
+# Used internal components:
+#
+# Used external programs:
+#
+# Accepted protocol requests from client:
+#
+# Used protocol responses to client:
+#
+# FAQ-Questions:
+#
+# SVN: $Id: $
+#
+
+. nxloadconfig --config=&quot;nxstart&quot; || { echo &quot;NX 503&gt; Internal server error. nxloadconfig could not be loaded by nxstart.&quot;; exit 1; }
+
+AGENT_PID=&quot;$1&quot;
+shift
+
+nxlog_log NOTICE &quot;Agent: $AGENT_PID Cmd: $@&quot;
+
+echo &quot;Xft.dpi: 96&quot; | LANG=C xrdb -merge 2&gt;&amp;1 | nxlog_log_pipe DEBUG
+
+&quot;$@&quot; 2&gt;&amp;1 | nxlog_log_pipe DEBUG
+
+msg=&quot;Cmd exited, nxagent (pid $AGENT_PID)&quot;
+if kill -0 &quot;$AGENT_PID&quot; &amp;&gt;/dev/null; then
+  nxlog_log DEBUG &quot;$msg still exists, killing&quot;
+  kill &quot;$AGENT_PID&quot; || nxlog_log ERR &quot;Killing nxagent returned error $?&quot;
+else
+  nxlog_log NOTICE &quot;$msg already exited&quot;
+fi


Property changes on: trunk/freenx-redesign/server/compatibility/nxstart
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/lib/nxloadconfig.py
===================================================================
--- trunk/freenx-redesign/server/lib/nxloadconfig.py	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/lib/nxloadconfig.py	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,150 @@
+#!/usr/bin/python2.4
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">diamond at google.com</A> (Stephen Shirley)
+
+&quot;&quot;&quot;nxloadconfg module&quot;&quot;&quot;
+
+__author__ = '<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">diamond at google.com</A> (Stephen Shirley)'
+__copyright__ = 'Copyright 2007 Google Inc.'
+
+import os
+import subprocess
+import sys
+
+import nxlog
+
+
+__default_prefix = '/usr/freenx'
+__conf_errors = False
+
+conf={'PATH_BASE': __default_prefix,
+  'PATH_ETC': os.path.join(__default_prefix, 'etc'),
+  'PATH': os.getenv('PATH')}
+
+
+def setup(conf_file=None):
+  global __conf_errors
+  __conf_errors = False
+
+  __conf_load(&quot;general&quot;)
+  if conf_file: __conf_load(conf_file)
+  __check_command_vars()
+  __check_dir_vars()
+
+  if __conf_errors:
+    nxlog.log(nxlog.LOG_CRIT, &quot;Configuration errors, exiting\n&quot;)
+    sys.exit(1)
+
+
+def __conf_load(conf_file):
+  conf_file_path = os.path.join(conf[&quot;PATH_ETC&quot;], &quot;%s.conf&quot; % conf_file)
+  if not os.path.exists(conf_file_path):
+    nxlog.log(nxlog.LOG_DEBUG, &quot;Requested file %s doesn't exist\n&quot; % conf_file_path)
+    return
+  for line in subprocess.Popen('nxloadconfig-helper.sh %s' % conf_file_path,
+    shell=True, stdout=subprocess.PIPE, env=conf).stdout:
+    var, val = line.split('=')
+    conf[var] = val.rstrip()
+
+
+def __check_command_vars():
+  check_command_var(&quot;COMMAND_START_KDE&quot;, which(&quot;startkde&quot;))
+  check_command_var(&quot;COMMAND_START_GNOME&quot;, which(&quot;gnome-session&quot;))
+  check_command_var(&quot;COMMAND_START_CDE&quot;, which(&quot;cdwm&quot;))
+  check_command_var(&quot;COMMAND_XTERM&quot;, which(&quot;xterm&quot;))
+  check_command_var(&quot;COMMAND_XAUTH&quot;, which(&quot;xauth&quot;))
+  check_command_var(&quot;COMMAND_SMBMOUNT&quot;, which(&quot;smbmount&quot;))
+  check_command_var(&quot;COMMAND_SMBUMOUNT&quot;, which(&quot;smbumount&quot;))
+  check_command_var(&quot;COMMAND_NETCAT&quot;, which(&quot;netcat&quot;))
+  check_command_var(&quot;COMMAND_SSH&quot;, which(&quot;ssh&quot;))
+  check_command_var(&quot;COMMAND_SSH_KEYGEN&quot;, which(&quot;ssh-keygen&quot;))
+  check_command_var(&quot;COMMAND_CUPSD&quot;, which(&quot;cupsd&quot;))
+  check_command_var(&quot;COMMAND_MD5SUM&quot;, which(&quot;md5sum&quot;))
+
+
+def __check_dir_vars():
+  check_dir_var(&quot;PATH_BASE&quot;, conf.get(&quot;PATH_BASE&quot;))
+  check_dir_var(&quot;PATH_BIN&quot;, os.path.join(conf.get(&quot;PATH_BASE&quot;), &quot;bin&quot;))
+  check_dir_var(&quot;PATH_ETC&quot;, os.path.join(conf.get(&quot;PATH_BASE&quot;), &quot;etc&quot;))
+  check_dir_var(&quot;PATH_LIB&quot;, os.path.join(conf.get(&quot;PATH_BASE&quot;), &quot;lib&quot;))
+
+
+def check_command_var(varname, defval):
+  def is_valid(path):
+    try:
+      cmd = path.split()[0]
+    except IndexError:
+      # Can happen if path is None, or &quot;&quot; etc
+      cmd = path
+    return cmd is not None and os.path.isfile(cmd) and os.access(cmd, os.X_OK)
+
+  global __conf_errors
+  varval = conf.get(varname)
+
+  if varval is not None: # Is there a value set already?
+    if is_valid(varval):
+      return True # Everything checks out.
+    else:
+      nxlog.log(nxlog.LOG_WARNING, &quot;Invalid command variable %s: \&quot;%s\&quot;\n&quot; %
+          (varname, varval))
+
+  if defval == &quot;&quot; or is_valid(defval):
+    # Everything ok now, we assume it's blank if deliberately unset
+    # (or if the command isn't available
+    conf[varname] = defval
+    return True
+  else:
+    nxlog.log(nxlog.LOG_ERR, &quot;Invalid default command variable %s: \&quot;%s\&quot;\n&quot; %
+        (varname, defval))
+    __conf_errors = True
+    return False
+
+
+def check_dir_var(varname, defval):
+  def is_valid(path):
+    return path is not None and os.path.isdir(path)
+
+  global __conf_errors
+  varval = conf.get(varname)
+
+  if varval is not None: # Is there a value set already?
+    if is_valid(varval):
+      return True # Everything checks out.
+    else:
+      nxlog.log(nxlog.LOG_WARNING, &quot;Invalid directory variable %s: \&quot;%s\&quot;\n&quot; %
+          (varname, varval))
+
+  if is_valid(defval):
+    # Everything ok now
+    conf[varname] = defval
+    return True
+  else:
+    nxlog.log(nxlog.LOG_ERR, &quot;Invalid default directory variable %s: \&quot;%s\&quot;\n&quot; %
+        (varname, defval))
+    __conf_errors = True
+    return False
+
+
+def which(cmd):
+  return os.popen(&quot;which %s&quot; % cmd).read().rstrip()
+
+
+if __name__ == '__main__':
+  print 'This is a library. Please use it from python using import.'
+  sys.exit(0)


Property changes on: trunk/freenx-redesign/server/lib/nxloadconfig.py
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/lib/nxloadconfig_test.py
===================================================================
--- trunk/freenx-redesign/server/lib/nxloadconfig_test.py	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/lib/nxloadconfig_test.py	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,117 @@
+#!/usr/bin/python2.4
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">diamond at google.com</A> (Stephen Shirley)
+
+&quot;&quot;&quot;nxloadconfig module unit tests&quot;&quot;&quot;
+
+import copy
+import unittest
+
+import nxlog
+import nxloadconfig
+
+__author__ = '<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">diamond at google.com</A> (Stephen Shirley)'
+__copyright__ = 'Copyright 2007 Google Inc.'
+
+nxlog.setup(&quot;nxloadconfig_test&quot;)
+
+
+class NXLoadConifgUnitTest(unittest.TestCase):
+  &quot;&quot;&quot;Unit test for nxloadconfig module.&quot;&quot;&quot;
+
+  def setUp(self):
+    # Not actually needed for every test, but it handy to have.
+    self.conf = nxloadconfig.conf
+    self.orig_conf = copy.copy(self.conf)
+
+  def tearDown(self):
+    # Cleanup after ourselves. See note on setUp()
+    nxloadconfig.copy = copy.copy(self.orig_conf)
+
+  def testWhich(self):
+    self.assertEquals('/bin/bash', nxloadconfig.which(&quot;bash&quot;))
+    self.assertEquals('', nxloadconfig.which(&quot;somethingwhichdoesntexist&quot;))
+
+  def testCheckCommandVar(self):
+    # Var is unset, default value is valid
+    if 'TEST' in self.conf: del self.conf['TEST']
+    ret = nxloadconfig.check_command_var(&quot;TEST&quot;, &quot;/bin/bash&quot;)
+    self.assertEquals(True, ret)
+    self.assertEquals(&quot;/bin/bash&quot;, self.conf['TEST'])
+
+    # Var points to unexecutable file, default value is valid.
+    nxloadconfig.copy = copy.copy(self.orig_conf)
+    self.conf['TEST'] = '/etc/fstab'
+    ret = nxloadconfig.check_command_var(&quot;TEST&quot;, &quot;/bin/bash&quot;)
+    self.assertEquals(True, ret)
+    self.assertEquals(&quot;/bin/bash&quot;, self.conf['TEST'])
+
+    # Var points to executable dir, default value is valid.
+    nxloadconfig.copy = copy.copy(self.orig_conf)
+    self.conf['TEST'] = '/bin'
+    ret = nxloadconfig.check_command_var(&quot;TEST&quot;, &quot;/bin/bash&quot;)
+    self.assertEquals(True, ret)
+    self.assertEquals(&quot;/bin/bash&quot;, self.conf['TEST'])
+
+    # Test valid value with valid default
+    nxloadconfig.copy = copy.copy(self.orig_conf)
+    self.conf['TEST'] = '/bin/sh'
+    ret = nxloadconfig.check_command_var(&quot;TEST&quot;, &quot;/bin/bash&quot;)
+    self.assertEquals(True, ret)
+    self.assertEquals(&quot;/bin/sh&quot;, self.conf['TEST'])
+
+    # Test invalid value with invalid default
+    nxloadconfig.copy = copy.copy(self.orig_conf)
+    self.conf['TEST'] = '/etc/fstab'
+    ret = nxloadconfig.check_command_var(&quot;TEST&quot;, &quot;/etc/hosts&quot;)
+    self.assertEquals(False, ret)
+    self.assertEquals(&quot;/etc/fstab&quot;, self.conf['TEST'])
+
+
+  def testCheckDirVar(self):
+    # Var is unset, default value is valid
+    if 'TEST' in self.conf: del self.conf['TEST']
+    ret = nxloadconfig.check_dir_var(&quot;TEST&quot;, &quot;/bin&quot;)
+    self.assertEquals(True, ret)
+    self.assertEquals(&quot;/bin&quot;, self.conf['TEST'])
+
+    # Var points to file, default value is valid.
+    nxloadconfig.copy = copy.copy(self.orig_conf)
+    self.conf['TEST'] = '/etc/fstab'
+    ret = nxloadconfig.check_dir_var(&quot;TEST&quot;, &quot;/bin&quot;)
+    self.assertEquals(True, ret)
+    self.assertEquals(&quot;/bin&quot;, self.conf['TEST'])
+
+    # Test valid value with valid default
+    nxloadconfig.copy = copy.copy(self.orig_conf)
+    self.conf['TEST'] = '/bin'
+    ret = nxloadconfig.check_dir_var(&quot;TEST&quot;, &quot;/usr&quot;)
+    self.assertEquals(True, ret)
+    self.assertEquals(&quot;/bin&quot;, self.conf['TEST'])
+
+    # Test invalid value with invalid default
+    nxloadconfig.copy = copy.copy(self.orig_conf)
+    self.conf['TEST'] = '/etc/fstab'
+    ret = nxloadconfig.check_dir_var(&quot;TEST&quot;, &quot;/etc/hosts&quot;)
+    self.assertEquals(False, ret)
+    self.assertEquals(&quot;/etc/fstab&quot;, self.conf['TEST'])
+
+
+if __name__ == '__main__':
+  unittest.main()


Property changes on: trunk/freenx-redesign/server/lib/nxloadconfig_test.py
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/lib/nxlog.py
===================================================================
--- trunk/freenx-redesign/server/lib/nxlog.py	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/lib/nxlog.py	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,227 @@
+#!/usr/bin/python2.4
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">alriddoch at google.com</A> (Alistair Riddoch)
+
+&quot;&quot;&quot;nxlog module for logging to syslog and stderr.
+
+  __setup_syslog: Function for setting up logging to syslog.
+  __log_syslog: Function for logging to syslog.
+  __setup_stderr: Function for setting up logging to stderr.
+  __log_stderr: Function for logging to stderr.
+  __setup: Function for setting up the logging systems.
+
+  setup: Function for setting the faciltiy name.
+  set_log_level: Function for setting the log level.
+  log: Function for writing logs.
+&quot;&quot;&quot;
+
+import os
+import sys
+import syslog
+
+__author__ = '<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">alriddoch at google.com</A> (Alistair Riddoch)'
+__copyright__ = 'Copyright 2007 Google Inc.'
+
+__pychecker__ = 'no-miximport'
+
+from syslog import LOG_EMERG
+from syslog import LOG_ALERT
+from syslog import LOG_CRIT
+from syslog import LOG_ERR
+from syslog import LOG_WARNING
+from syslog import LOG_NOTICE
+from syslog import LOG_INFO
+from syslog import LOG_DEBUG
+
+
+__level = LOG_INFO
+__handlers = []
+__stderr_name = ''
+_level_names = {
+    'EMERG': LOG_EMERG,
+    'ALERT': LOG_ALERT,
+    'CRIT': LOG_CRIT,
+    'ERR': LOG_ERR,
+    'WARNING': LOG_WARNING,
+    'NOTICE': LOG_NOTICE,
+    'INFO': LOG_INFO,
+    'DEBUG': LOG_DEBUG
+  }
+
+
+
+def __setup_syslog(name):
+  &quot;&quot;&quot;Initialize logging to the syslog.
+  
+  Args:
+    name: The name to be used for the logging facility.
+
+  Returns:
+    None
+  &quot;&quot;&quot;
+
+  syslog.openlog(name, syslog.LOG_PID)
+
+
+def __log_syslog(level, message):
+  &quot;&quot;&quot;Write a message to syslog.
+
+  Args:
+    level: Number giving the level of this message.
+    message: String giving the message to be logged.
+
+  Returns:
+    None
+  &quot;&quot;&quot;
+
+  syslog.syslog(level, message)
+
+
+def __setup_stderr(name):
+  &quot;&quot;&quot;Initialize loggin to stderr.
+  
+  Args:
+    name: The name to be used for the logging facility.
+
+  Returns:
+    None
+  &quot;&quot;&quot;
+  global __stderr_name
+
+  __stderr_name = name
+
+
+def __log_stderr(level, message):
+  &quot;&quot;&quot;Write a message to stderr.
+
+  Args:
+    level: Number giving the level of this message.
+    message: String giving the message to be logged.
+
+  Returns:
+    None
+  &quot;&quot;&quot;
+  global __stderr_name
+  global __level
+
+  if level &lt;= __level:
+    sys.stderr.write('%s: %s' % (__stderr_name, message))
+
+
+def __setup(name):
+  &quot;&quot;&quot;Set up the library.
+  
+  Args:
+    name: The name to be used for the logging facility.
+
+  Returns:
+    None
+  &quot;&quot;&quot;
+  global __level
+
+  level = os.getenv('LOG_LEVEL')
+  if level is not None:
+    __level = _name_to_level(level)
+
+  __setup_syslog(name)
+  __handlers.append(__log_syslog)
+
+#  __setup_stderr(name)
+#  __handlers.append(__log_stderr)
+
+
+def setup(name):
+  &quot;&quot;&quot;Set the facility name for logging.
+
+  Note: this can be called multiple times, to change the name.
+
+  Args:
+    name: The name to be used for the logging facility.
+
+  Returns:
+    None
+  &quot;&quot;&quot;
+
+  __setup_syslog(name)
+  __setup_stderr(name)
+  
+
+def set_log_level(level):
+  &quot;&quot;&quot;Set the log level.
+
+  Args:
+    level: Number giving the highest level to log at.
+
+  Returns:
+    None
+  &quot;&quot;&quot;
+  global __level
+
+  __level = _name_to_level(level)
+
+
+def log(level, message):
+  &quot;&quot;&quot;Handle a log message with a given level.
+
+  If the message is high enough level to be written, pass it to the
+  configured log channels.
+
+  Args:
+    level: Integer or string giving the level of this message.
+    message: String giving the message to be logged.
+
+  Returns:
+    None
+  &quot;&quot;&quot;
+  global __level
+
+  lev_num = _name_to_level(level)
+
+  if lev_num &lt;= __level:
+    for handler in __handlers:
+      handler(lev_num, message)
+
+
+def _name_to_level(level):
+  &quot;&quot;&quot;Translate from level number or name to log level
+
+  Args:
+    level: Integer, number string, or name string for log level
+
+  Returns:
+    The corresponding log level
+  &quot;&quot;&quot;
+  try:
+    return int(level)
+  except ValueError:
+    pass
+  # The value is not a number
+  try:
+    return _level_names[level]
+  except KeyError:
+    # ValueError makes more sense to raise for an invalid name
+    raise ValueError('invalid name for log level: %s' % level)
+
+
+if __name__ == '__main__':
+  print 'This is a library. Please use it from python using import.'
+  sys.exit(0)
+else:
+  __setup(__name__)
+

Added: trunk/freenx-redesign/server/lib/nxlog_test.py
===================================================================
--- trunk/freenx-redesign/server/lib/nxlog_test.py	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/lib/nxlog_test.py	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,172 @@
+#!/usr/bin/python2.4 -E
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">alriddoch at google.com</A> (Alistair Riddoch)
+
+&quot;&quot;&quot;nxlog module unit tests for logging to syslog and stderr.
+
+  NXLogUnitTest: Test log and set_log_level.
+&quot;&quot;&quot;
+
+import os
+import syslog
+import unittest
+
+import nxlog
+
+__author__ = '<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">alriddoch at google.com</A> (Alistair Riddoch)'
+__copyright__ = 'Copyright 2007 Google Inc.'
+
+
+class NXLogUnitTest(unittest.TestCase):
+  &quot;&quot;&quot;Unit test for nxlog module.&quot;&quot;&quot;
+
+  def mock_syslog_openlog(self, ident, opt = None, facility = None):
+    &quot;&quot;&quot;Flag that this mock syslog function has been called&quot;&quot;&quot;
+
+    self._openlog_called = True
+
+  def mock_syslog_syslog(self, level, message = None):
+    &quot;&quot;&quot;Flag that this mock syslog function has been called&quot;&quot;&quot;
+
+    self._syslog_called = True
+
+  def setUp(self):
+    &quot;&quot;&quot;Install mock versions of the syscall functions.&quot;&quot;&quot;
+
+    self._saved_openlog = syslog.openlog
+    self._saved_syslog = syslog.syslog
+    syslog.openlog = self.mock_syslog_openlog
+    syslog.syslog = self.mock_syslog_syslog
+    self._openlog_called = False
+    self._syslog_called = False
+
+  def tearDown(self):
+    &quot;&quot;&quot;Remove the mocked versions of the syscall functions.&quot;&quot;&quot;
+
+    syslog.openlog = self._saved_openlog 
+    syslog.syslog = self._saved_syslog 
+
+  def testSetupSyslog(self):
+    &quot;&quot;&quot;Test the code path through the syslog setup function.&quot;&quot;&quot;
+
+    nxlog.__dict__['__setup_syslog']('syslog_test')
+
+    self.failUnless(self._openlog_called)
+
+  def testLogSyslog(self):
+    &quot;&quot;&quot;Test the code path through the syslog log function.&quot;&quot;&quot;
+
+    nxlog.__dict__['__log_syslog'](0, 'syslog_test_message')
+
+    self.failUnless(self._syslog_called)
+
+  def testSetupStderr(self):
+    &quot;&quot;&quot;Test the code path through the stderr setup function.&quot;&quot;&quot;
+
+    name = 'stderr_test_name'
+
+    nxlog.__dict__['__setup_stderr'](name)
+
+    self.assertEqual(name, nxlog.__dict__['__stderr_name'])
+
+  def testLogStderr(self):
+    &quot;&quot;&quot;Test the code path through the stderr log function.&quot;&quot;&quot;
+
+    nxlog.__dict__['__log_stderr'](0, 'stderr_test_message')
+
+  def testInternalSetup(self):
+    &quot;&quot;&quot;Test calling __setup()&quot;&quot;&quot;
+
+    nxlog.__dict__['__setup']('setup_test_name')
+
+    log_level = nxlog.__dict__['__level']
+
+    self.failUnless(log_level in [nxlog.LOG_EMERG, nxlog.LOG_ALERT,
+                                  nxlog.LOG_CRIT, nxlog.LOG_ERR,
+                                  nxlog.LOG_WARNING, nxlog.LOG_NOTICE,
+                                  nxlog.LOG_INFO, nxlog.LOG_DEBUG])
+
+  def testInternalSetupEnvionment(self):
+    &quot;&quot;&quot;Test calling __setup() with a log level environment variable&quot;&quot;&quot;
+
+    os.environ['LOG_LEVEL'] = 'ERR'
+
+    nxlog.__dict__['__setup']('setup_test_name')
+
+    log_level = nxlog.__dict__['__level']
+
+    self.assertEqual(log_level, nxlog.LOG_ERR)
+
+    os.unsetenv('LOG_LEVEL')
+
+  def testLogLevelSet(self):
+    &quot;&quot;&quot;Test that the log level has been set to a valid value&quot;&quot;&quot;
+
+    # Ensure that before set_log_level has been called, the internal value
+    # of log level is sane.
+    log_level = nxlog.__dict__['__level']
+
+    self.failUnless(log_level in [nxlog.LOG_EMERG, nxlog.LOG_ALERT,
+                                  nxlog.LOG_CRIT, nxlog.LOG_ERR,
+                                  nxlog.LOG_WARNING, nxlog.LOG_NOTICE,
+                                  nxlog.LOG_INFO, nxlog.LOG_DEBUG])
+
+  def testLog(self):
+    &quot;&quot;&quot;Test calling log function&quot;&quot;&quot;
+
+    nxlog.log(0, 'test log message')
+
+  def testSetup(self):
+    &quot;&quot;&quot;Test calling external setup()&quot;&quot;&quot;
+
+    nxlog.setup('nxlog_test')
+
+  def testSetLogLevel(self):
+    &quot;&quot;&quot;Test the code path through set_log_level() with a valid level&quot;&quot;&quot;
+
+    nxlog.set_log_level(nxlog.LOG_INFO)
+
+  def testSetLogLevelRaises(self):
+    &quot;&quot;&quot;Test the code path through set_log_level() with an invalid level&quot;&quot;&quot;
+
+    self.assertRaises(ValueError, nxlog.set_log_level, 'not_a_level')
+
+  def testNameToLevelNameString(self):
+    &quot;&quot;&quot;Test calling _name_to_level with a string specifying a level&quot;&quot;&quot;
+
+    self.assertEquals(nxlog.LOG_DEBUG, nxlog._name_to_level('DEBUG'))
+
+  def testNametoLevelNumberString(self):
+    &quot;&quot;&quot;Test calling _name_to_level() with an integer represented as a string&quot;&quot;&quot;
+
+    self.assertEquals(nxlog.LOG_DEBUG, nxlog._name_to_level('7'))
+
+  def testNametoLevelInteger(self):
+    &quot;&quot;&quot;Test calling _name_to_level() with an integer.&quot;&quot;&quot;
+
+    self.assertEquals(nxlog.LOG_DEBUG, nxlog._name_to_level(nxlog.LOG_DEBUG))
+
+  def testNametoLevelInvalidNameString(self):
+    &quot;&quot;&quot;Test calling _name_to_level() on a meaningless string.&quot;&quot;&quot;
+
+    self.assertRaises(ValueError, nxlog._name_to_level, 'BLARG')
+
+
+if __name__ == '__main__':
+  unittest.main()


Property changes on: trunk/freenx-redesign/server/lib/nxlog_test.py
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/lib/nxparser/__init__.py
===================================================================
--- trunk/freenx-redesign/server/lib/nxparser/__init__.py	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/lib/nxparser/__init__.py	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,23 @@
+#!/usr/bin/python2.4
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">diamond at google.com</A> (Stephen Shirley)
+
+import base
+import node
+import server


Property changes on: trunk/freenx-redesign/server/lib/nxparser/__init__.py
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/lib/nxparser/base.py
===================================================================
--- trunk/freenx-redesign/server/lib/nxparser/base.py	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/lib/nxparser/base.py	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,213 @@
+#!/usr/bin/python2.4
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Authors: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">alriddoch at google.com</A> (Alistair Riddoch)
+#          <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">diamond at google.com</A> (Stephen Shirley)
+
+&quot;&quot;&quot;nxparser.base module for handling the nx protocol.
+&quot;&quot;&quot;
+
+import optparse
+import re
+import traceback
+import sys
+
+import nxlog
+
+__author__ = '<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">alriddoch at google.com</A> (Alistair Riddoch)'
+__copyright__ = 'Copyright 2007 Google Inc.'
+
+class parser:
+  &quot;&quot;&quot;Base parser for NX protocol parsers.
+
+  This class handles breaking up the messages into components,
+  and dispatching them.
+  &quot;&quot;&quot;
+
+  DEFAULT_VERSION = '3.0.0'
+  DEFAULT_PROGRAM = 'NXBASE'
+
+  NX_PROMPT = 'NX&gt;'
+  NX_COMMANDS = ['hello', 'login', 'bye', 'set', 'listsession',
+                 'restoresession', 'startsession', 'terminate']
+  NX_PARAM_RX = re.compile(r'^--(?P&lt;key&gt;[a-z]+)=&quot;(?P&lt;value&gt;.+)&quot;')
+
+  def __init__(self, input, output, version=DEFAULT_VERSION,
+               program=DEFAULT_PROGRAM):
+    &quot;&quot;&quot;base_parser constructor
+
+    Args:
+      input: The file object to read parser input from.
+      output: The file object to write the results to.
+      version: The version string used to negotiate the protocol.
+      program: The program name used in the protocol banner.
+    &quot;&quot;&quot;
+
+    self.input = input
+    self.output = output
+    self.state = 105
+    self.running = True
+    self.parse_args(version=version, program=program)
+    nxlog.log(nxlog.LOG_DEBUG, &quot;Version: %s Program: %s&quot; %
+        (self.version, self.program))
+
+  def banner(self):
+    &quot;&quot;&quot;Write the protocol banner to the output.&quot;&quot;&quot;
+
+    self.write('HELLO %s - Version %s - GPL' % (self.program, self.version))
+
+  def prompt(self, state, message='', override_newline=None):
+    &quot;&quot;&quot;Write the protocol prompt to the output.
+
+    If no message is given, just print the prompt &amp; state, no newline.
+    If a message is provided, by default append a newline.
+
+    Args:
+      state: The state number to put after the NX&gt; prompt
+      message: Optional message to print after the state
+      override_newline: Optional param to force a trailing newline on/off&quot;&quot;&quot;
+
+
+    newline = False
+    if override_newline is not None:
+      newline = override_newline
+    elif message:
+      newline=True
+    self.write('%s %d %s' % (self.NX_PROMPT, state, message), newline=newline)
+
+  def loop(self):
+    &quot;&quot;&quot;Write the protocol prompt to the output, and accept commands.&quot;&quot;&quot;
+
+    try:
+      while self.running:
+        self.prompt(self.state)
+        line = self.input.readline()
+        if not line:
+          nxlog.log(nxlog.LOG_DEBUG, &quot;Exiting due to EOF&quot;)
+          return
+        line = line.rstrip()
+        nxlog.log(nxlog.LOG_DEBUG, 'Got %r' % line)
+        command = line.split()
+        if not command:
+          # If the line was all whitespace this could happen.
+          continue
+        cmd = command[0].lower()
+        if cmd == 'set':
+          self.write(&quot;%s %s: %s&quot; % (cmd.capitalize(), command[1].lower(),
+            command[2].lower()))
+        elif cmd == 'startsession':
+          self.write(&quot;Start session with: %s&quot; % &quot; &quot;.join(command[1:]))
+        else:
+          self.write(line.capitalize())
+        if cmd not in self.NX_COMMANDS:
+          self.prompt(503, 'Error: undefined command: \'%s\'' % cmd)
+          continue
+        handler_name = '_nx_%s_handler' % cmd
+        try:
+          handler_method = getattr(self, handler_name)
+        except AttributeError:
+          nxlog.log(nxlog.LOG_DEBUG, 'Unhandled nx command %r' % cmd)
+          continue
+        handler_method(command)
+    except IOError, e:
+      nxlog.log(nxlog.LOG_ERR, 'IOError. Connection lost: %s' % e)
+    except Exception, e:
+      trace = traceback.format_exc()
+      nxlog.log(nxlog.LOG_ERR, 'Going down because exception caught '
+                               'at the top level.')
+      for line in trace.split('\n'):
+        nxlog.log(nxlog.LOG_ERR, '%s' % line)
+      self.prompt(500, 'Error: Fatal error in module %s, '
+          'check log file for more details.' % self.program.lower())
+      self.prompt(999, 'Bye.')
+
+  def write(self, output, newline=True, flush=True, log=True,
+      log_level=nxlog.LOG_DEBUG, fd=None):
+    &quot;&quot;&quot;Write given string to output, and optionally:
+      - append a newline
+      - flush output afterwards
+      - log the output, with a specified log level.&quot;&quot;&quot;
+
+    if newline:
+      output += '\n'
+    use_fd = self.output
+    if fd:
+      use_fd = fd
+    use_fd.write(output)
+    if flush:
+      use_fd.flush()
+    if log:
+      nxlog.log(log_level, 'Sent: %r\n' % output)
+
+  def parse_args(self, version=None, program=None):
+    &quot;&quot;&quot;Parse cmdline arguments&quot;&quot;&quot;
+
+    optparser = optparse.OptionParser()
+    optparser.add_option(&quot;--proto&quot;, action=&quot;store&quot;, type=&quot;string&quot;,
+        dest=&quot;version&quot;, default=version, metavar=&quot;PROTO_VER&quot;,
+        help=&quot;use the PROTO_VER version of the NX protocol&quot;)
+    optparser.add_option(&quot;--program&quot;, action=&quot;store&quot;, type=&quot;string&quot;,
+        dest=&quot;program&quot;, default=program, metavar=&quot;PROG_NAME&quot;,
+        help=&quot;the PROG_NAME name to announce&quot;)
+    options, args = optparser.parse_args()
+    self.version = options.version
+    self.program = options.program
+
+  def _diff_version(self, ver1, ver2):
+    &quot;&quot;&quot;Compare 2 version strings&quot;&quot;&quot;
+
+    for i,j in zip(ver1.split('.', 2), ver2.split('.', 2)):
+      try:
+        icomp = int(i)
+        jcomp = int(j)
+      except ValueError:
+        icomp = i
+        jcomp = j
+      if icomp &gt; jcomp:
+        return 1
+      elif icomp == jcomp:
+        continue
+      elif icomp &lt; jcomp:
+        return -1
+    return 0
+
+  def _parse_param(self, param):
+    &quot;&quot;&quot;Check that param is correctly formatted via the NX_PARAM_RX regex
+
+    Args:
+      param: parameter string to be checked, of the form --key=&quot;value&quot;
+
+    Returns:
+      key,value tuple if param was correctly formatted, returns None,None
+      otherwise.
+    &quot;&quot;&quot;
+
+    m = self.NX_PARAM_RX.search(param)
+    if m:
+      key = m.group('key')
+      value = m.group('value')
+      nxlog.log(nxlog.LOG_DEBUG, 'Param matched: %r=%r' % (key, value))
+    else:
+      key = value = None
+      nxlog.log(nxlog.LOG_WARNING, &quot;Param didn't match: %r&quot; % param)
+    return key,value
+
+
+if __name__ == '__main__':
+  print 'This is a library. Please use it from python using import.'
+  sys.exit(0)


Property changes on: trunk/freenx-redesign/server/lib/nxparser/base.py
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/lib/nxparser/base_test.py
===================================================================
--- trunk/freenx-redesign/server/lib/nxparser/base_test.py	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/lib/nxparser/base_test.py	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,398 @@
+#!/usr/bin/python2.4
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">diamond at google.com</A> (Stephen Shirley)
+
+&quot;&quot;&quot;Unittest for nxparser.base&quot;&quot;&quot;
+
+import os
+import StringIO
+import sys
+import unittest
+
+sys.path.append(os.path.join(os.path.dirname(__file__), '..'))
+
+import nxlog
+import nxparser.base
+
+__author__ = '<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">diamond at google.com</A> (Stephen Shirley)'
+__copyright__ = 'Copyright 2008 Google Inc.'
+
+class NxParserBaseUnitTest(unittest.TestCase):
+
+  class MockStringIO(StringIO.StringIO):
+    &quot;&quot;&quot;Mock file object to check to log what's written and whether it's flushed&quot;&quot;&quot;
+
+    def __init__(self, buf=None):
+      if buf:
+        StringIO.StringIO.__init__(self, buf)
+      else:
+        StringIO.StringIO.__init__(self)
+      self.flushed = False
+
+    def flush(self):
+      StringIO.StringIO.flush(self)
+      self.flushed = True
+
+  def MockLog(self, *args):
+    &quot;&quot;&quot;Mock logging function to replace nxlog.log and store all arguments&quot;&quot;&quot;
+
+    self.logged_data.append(args)
+
+  def MockLogFlush(self, *args):
+    &quot;&quot;&quot;Wipe the MockLog() history&quot;&quot;&quot;
+
+    self.logged_data = []
+
+  def utilCheckInitialAttributes(self, p, input, output, version, program):
+    &quot;&quot;&quot;Check if the nxparser.base instance has initialised correctly&quot;&quot;&quot;
+
+    self.assertEquals(input, p.input)
+    self.assertEquals(output, p.output)
+    self.assertEquals(105, p.state)
+    self.assertEquals(True, p.running)
+    self.assertEquals(version, p.version)
+    self.assertEquals(program, p.program)
+    self.assertEquals((nxlog.LOG_DEBUG,
+      &quot;Version: %(version)s Program: %(program)s&quot; % locals()),
+      self.logged_data.pop(0))
+    self.assertEquals([], self.logged_data)
+
+  def utilCheckOutput(self, out, exp_output, flush=True, log=True,
+      log_level=nxlog.LOG_DEBUG):
+    &quot;&quot;&quot;Check if output has been written, flushed, and/or logged&quot;&quot;&quot;
+
+    self.assertEquals(exp_output, out.getvalue())
+    if flush:
+      self.assertEquals(flush, out.flushed)
+    if log:
+      self.assertEquals((log_level, &quot;Sent: %(exp_output)r\n&quot; % locals()),
+        self.logged_data.pop(0))
+    else:
+      self.assertEquals(0, len(self.logged_data))
+
+  def setUp(self):
+    &quot;&quot;&quot;Before every test substitute Mocklog for nxlog.log&quot;&quot;&quot;
+
+    self.nxlog_log_old = nxlog.log
+    nxlog.log = self.MockLog
+    self.MockLogFlush()
+
+  def tearDown(self):
+    &quot;&quot;&quot;Restore the original nxlog.log&quot;&quot;&quot;
+
+    nxlog.log = self.nxlog_log_old
+
+  def testInitDefaults(self):
+    &quot;&quot;&quot;Does an instance with default args initialise correctly?&quot;&quot;&quot;
+
+    p = nxparser.base.parser(sys.stdin, sys.stdout)
+
+    self.utilCheckInitialAttributes(p, sys.stdin, sys.stdout, p.DEFAULT_VERSION,
+      p.DEFAULT_PROGRAM)
+
+  def testInitVersion(self):
+    &quot;&quot;&quot;Does an instance with an overridden version string initialise correctly?&quot;&quot;&quot;
+
+    ver_name = &quot;testverstring&quot;
+    p = nxparser.base.parser(sys.stdin, sys.stdout, version=ver_name)
+
+    self.utilCheckInitialAttributes(p, sys.stdin, sys.stdout, ver_name,
+      p.DEFAULT_PROGRAM)
+
+  def testInitProgram(self):
+    &quot;&quot;&quot;Does an instance with an overridden program name initialise correctly?&quot;&quot;&quot;
+
+    prog_name = &quot;testprogstring&quot;
+    p = nxparser.base.parser(sys.stdin, sys.stdout, program=prog_name)
+
+    self.utilCheckInitialAttributes(p, sys.stdin, sys.stdout, p.DEFAULT_VERSION,
+      prog_name)
+
+  def testInitVersionProgram(self):
+    &quot;&quot;&quot;Does an instance with an overridden program name and version string
+    initialise correctly?&quot;&quot;&quot;
+
+    ver_name = &quot;testverstring&quot;
+    prog_name = &quot;testprogstring&quot;
+    p = nxparser.base.parser(sys.stdin, sys.stdout,
+        version=ver_name, program=prog_name)
+
+    self.utilCheckInitialAttributes(p, sys.stdin, sys.stdout, ver_name, prog_name)
+
+  def testBannerDefaults(self):
+    &quot;&quot;&quot;Does base.banner() output correctly with no arguments?&quot;&quot;&quot;
+
+    out = self.MockStringIO()
+    exp_output = &quot;HELLO NXBASE - Version 3.0.0 - GPL\n&quot;
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    p.banner()
+
+    self.utilCheckOutput(out, exp_output)
+
+  def testBannerVersionProgram(self):
+    &quot;&quot;&quot;Does base.banner() output correctly with a specified version string
+    and program name?&quot;&quot;&quot;
+
+    ver_name = &quot;testverstring&quot;
+    prog_name = &quot;testprogstring&quot;
+    exp_output = &quot;HELLO %(prog_name)s - Version %(ver_name)s - GPL\n&quot; % locals()
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out,
+        version=ver_name, program=prog_name)
+    self.MockLogFlush()
+
+    p.banner()
+
+    self.utilCheckOutput(out, exp_output)
+
+  def testPromptDefaults(self):
+    &quot;&quot;&quot;Does base.prompt() output correctly with default arguments?&quot;&quot;&quot;
+
+    state = 101
+    out = self.MockStringIO()
+    exp_output = &quot;NX&gt; %(state)d &quot; % locals()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    p.prompt(state)
+
+    self.utilCheckOutput(out, exp_output)
+
+  def testPromptMessage(self):
+    &quot;&quot;&quot;Does base.prompt() output correctly with a message?&quot;&quot;&quot;
+
+    state = 101
+    send = &quot;Hello, World!&quot;
+    exp_output = &quot;NX&gt; %(state)d %(send)s\n&quot; % locals()
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    p.prompt(state, send)
+
+    self.utilCheckOutput(out, exp_output)
+
+  def testPromptOverrideNewlineTrueWithMsg(self):
+    &quot;&quot;&quot;Does base.prompt() output correctly with a message and forced newline?&quot;&quot;&quot;
+
+    state = 101
+    send = &quot;Hello, World!&quot;
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    exp_output = &quot;NX&gt; %(state)d %(send)s\n&quot; % locals()
+    p.prompt(state, send, override_newline=True)
+    self.utilCheckOutput(out, exp_output)
+
+  def testPromptOverrideNewlineFalseWithMsg(self):
+    &quot;&quot;&quot;Does base.prompt() output correctly with a message and forced no newline?&quot;&quot;&quot;
+
+    state = 101
+    send = &quot;Hello, World!&quot;
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    exp_output = &quot;NX&gt; %(state)d %(send)s&quot; % locals()
+    p.prompt(state, send, override_newline=False)
+    self.utilCheckOutput(out, exp_output)
+
+  def testPromptOverrideNewlineTrueWithoutMsg(self):
+    &quot;&quot;&quot;Does base.prompt() output correctly without a message and forced newline?&quot;&quot;&quot;
+
+    state = 101
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    exp_output = &quot;NX&gt; %(state)d \n&quot; % locals()
+    p.prompt(state, override_newline=True)
+    self.utilCheckOutput(out, exp_output)
+
+  def testPromptOverrideNewlineFalseWithoutMsg(self):
+    &quot;&quot;&quot;Does base.prompt() output correctly without a message and forced no newline?&quot;&quot;&quot;
+
+    state = 101
+    send = &quot;Hello, World!&quot;
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    exp_output = &quot;NX&gt; %(state)d &quot; % locals()
+    p.prompt(state, override_newline=False)
+    self.utilCheckOutput(out, exp_output)
+
+  def testWriteDefaults(self):
+    &quot;&quot;&quot;Does base.write() output correctly with a message?&quot;&quot;&quot;
+
+    send = &quot;Hello, World!&quot;
+    exp_output = &quot;%(send)s\n&quot; % locals()
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    p.write(send)
+
+    self.utilCheckOutput(out, exp_output)
+
+  def testWriteEmptyMsg(self):
+    &quot;&quot;&quot;Does base.write() output correctly with an empty message?&quot;&quot;&quot;
+
+    send=&quot;&quot;
+    exp_output = &quot;\n&quot;
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    p.write(send)
+
+    self.utilCheckOutput(out, exp_output)
+
+  def testWriteEmptyMsgNoNewline(self):
+    &quot;&quot;&quot;Does base.write() output correctly with an empty message and no newline?&quot;&quot;&quot;
+
+    send = exp_output = &quot;&quot;
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    p.write(send, newline=False)
+
+    self.utilCheckOutput(out, exp_output)
+
+  def testWriteNoNewline(self):
+    &quot;&quot;&quot;Does base.write() output correctly with a message and no newline?&quot;&quot;&quot;
+
+    send = exp_output = &quot;Hello, World!&quot;
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    p.write(send, newline=False)
+
+    self.utilCheckOutput(out, exp_output)
+
+  def testWriteNoFlush(self):
+    &quot;&quot;&quot;Does base.write() output correctly with a message and without flushing?&quot;&quot;&quot;
+
+    send = &quot;Hello, World!&quot;
+    exp_output = &quot;%(send)s\n&quot; % locals()
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    p.write(send, flush=False)
+
+    self.utilCheckOutput(out, exp_output, flush=False)
+
+  def testWriteNoLog(self):
+    &quot;&quot;&quot;Does base.write() output correctly with a message and without logging?&quot;&quot;&quot;
+
+    self.args = None
+    send = &quot;Hello, World!&quot;
+    exp_output = &quot;%(send)s\n&quot; % locals()
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    p.write(send, log=False)
+
+    self.utilCheckOutput(out, exp_output, log=False)
+
+  def testWriteLogLevel(self):
+    &quot;&quot;&quot;Does base.write() output correctly with a message and a specific log level?&quot;&quot;&quot;
+
+    self.args = None
+    send = &quot;Hello, World!&quot;
+    exp_output = &quot;%(send)s\n&quot; % locals()
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    p.write(send, log_level=nxlog.LOG_ERR)
+
+    self.utilCheckOutput(out, exp_output, log_level=nxlog.LOG_ERR)
+
+  def testWriteFd(self):
+    &quot;&quot;&quot;Does base.write() output correctly with a message and a specific fd?&quot;&quot;&quot;
+
+    self.args = None
+    send = &quot;Hello, World!&quot;
+    exp_output = &quot;%(send)s\n&quot; % locals()
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    p.write(send, fd=out)
+
+    self.utilCheckOutput(out, exp_output)
+
+  def testParseArgsNoArgsDefaults(self):
+    &quot;&quot;&quot;Does base.parse_args() parse correctly with no extra args?&quot;&quot;&quot;
+
+    sys.argv = ['argv0']
+    p = nxparser.base.parser(sys.stdin, sys.stdout)
+
+    p.parse_args()
+
+    self.assertEquals(None, p.version)
+    self.assertEquals(None, p.program)
+
+  def testParseArgsNoArgsVersionProgram(self):
+    &quot;&quot;&quot;Does base.parse_args() parse correctly with no extra args and specified
+    default version string and program name?&quot;&quot;&quot;
+
+    sys.argv = ['argv0']
+    ver_name = &quot;testverstring&quot;
+    prog_name = &quot;testprogstring&quot;
+    p = nxparser.base.parser(sys.stdin, sys.stdout)
+
+    p.parse_args(version=ver_name, program=prog_name)
+
+    self.assertEquals(ver_name, p.version)
+    self.assertEquals(prog_name, p.program)
+
+#Need to figure out how to test this:
+#  def testParseArgsWithArgsDefaults(self):
+#    sys.argv = ['argv0', '--help']
+#    p = nxparser.base.parser(sys.stdin, sys.stdout)
+#
+#    p.parse_args()
+#
+
+  def testParseArgsWithArgsVersionProgram(self):
+    &quot;&quot;&quot;Does base.parse_args() parse correctly with version string and program 
+    name specified by both args and defaults?&quot;&quot;&quot;
+
+    ver_name = &quot;testverstring&quot;
+    prog_name = &quot;testprogstring&quot;
+    sys.argv = ['argv0', '--proto', ver_name, '--program', prog_name]
+    p = nxparser.base.parser(sys.stdin, sys.stdout)
+
+    p.parse_args()
+
+    self.assertEquals(ver_name, p.version)
+    self.assertEquals(prog_name, p.program)
+
+
+if __name__ == '__main__':
+  unittest.main()


Property changes on: trunk/freenx-redesign/server/lib/nxparser/base_test.py
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/lib/nxparser/node.py
===================================================================
--- trunk/freenx-redesign/server/lib/nxparser/node.py	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/lib/nxparser/node.py	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,251 @@
+#!/usr/bin/python2.4
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Authors: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">diamond at google.com</A> (Stephen Shirley)
+#          <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">alriddoch at google.com</A> (Alistair Riddoch)
+
+import os
+import pwd
+import socket
+import subprocess
+import sys
+
+import nxlog
+import nxparser
+import nxsession
+
+class parser(nxparser.base.parser):
+  &quot;&quot;&quot;Node parser for NX protocol
+
+  This class handles the NX protocol messages required by a node.
+  &quot;&quot;&quot;
+
+  DEFAULT_PROGRAM = 'NXNODE'
+
+  class node_session:
+    &quot;&quot;&quot;Internal representation of a session
+
+    This class is used by nxnode to store session parameters, to create the
+    needed session args &amp; options file, and to print out the parameters for
+    transmission to nxserver-inner.
+    &quot;&quot;&quot;
+
+    def __init__(self, id, args):
+      &quot;&quot;&quot;node_session constructor
+
+      Args:
+        args: The id of the session, followed by all the other
+              parameters the client requested
+      &quot;&quot;&quot;
+
+      self.id = id
+      self.args = args
+      self.display = self._gen_disp_num()
+      self.hostname = socket.getfqdn()
+      self.full_id = &quot;%s-%s-%s&quot; % (self.hostname, self.display, self.id)
+      self.cookie = nxsession.gen_uniq_id()
+      self.dir = os.path.join('/tmp/nx', 'S-%s' % self.full_id)
+      #FIXME(diamond): needs error checking, maybe different mode
+      os.makedirs(self.dir, 0755)
+      self.opts_file_path = os.path.join(self.dir, 'options') 
+      self.args_file_path = os.path.join(self.dir, 'args') 
+      self.application = self.args.get('application')
+      self.user = pwd.getpwuid(os.getuid())[0]
+      self.name = self.args.get('session', &quot;%s:%s&quot; % (self.hostname, self.display))
+      self.keyboard = self.args.get('keyboard', 'pc105/gb')
+      self.geometry = self.args.get('geometry', '640x480')
+      self.client = self.args.get('client', 'unknown')
+      self.link = self.args.get('link', 'isdn')
+      self.fullscreen = self.args.get('fullscreen', '0')
+      #DEBUG, FIXME(diamond): all of these
+      self.type = self.args.get('type', 'unix-default')
+      self.options = '-----PSA' #FIXME(diamond): see note in self.info()
+      self.depth = 24
+      self.resolution = &quot;640x480&quot;
+      #FIXME(diamond): Not ipv6 compatible
+      self.proxyip = socket.gethostbyname(self.hostname)
+      self.ssl = 1
+      #End DEBUG/FIXME(diamond)
+
+      if self.type == 'unix-application':
+        assert(self.application)
+        self.mode = '-R' # Run nxagent in rootless mode
+      else:
+        self.mode = '-D' # Run nxagent in desktop mode
+
+      # We need to write the type without the 'unix-' prefix for nxagent.
+      if self.type.startswith('unix-'):
+        self.shorttype = self.type.split('-', 1)[1]
+      else:
+        self.shorttype = self.type
+
+      self._write_args()
+      self._write_opts()
+
+    def __getitem__(self, item):
+      &quot;&quot;&quot;Allow node_session instances to be treated as dicts
+
+      This is used in places like self.info(), to allow cleaner variable
+      substitution of variables in strings.
+      &quot;&quot;&quot;
+
+      return getattr(self, item)
+
+    def _gen_disp_num(self):
+      &quot;&quot;&quot;Return an unused display number (corresponding to an unused port)&quot;&quot;&quot;
+      return 20 #DEBUG, FIXME(diamond)
+
+    def _write_args(self):
+      &quot;&quot;&quot;Create the session's 'args' file
+
+      The args file is a newline-delimited list of arguments to be passed to
+      nxagent
+      &quot;&quot;&quot;
+
+      try:
+        args_file = open(self.args_file_path, 'w')
+        #DEBUG, FIXME(diamond):
+        args_file.write(&quot;\n&quot;.join([self.mode, '-options', self.opts_file_path,
+          '-name', 'FreeNX - %(user)s@%(hostname)s:%(display)s' % self,
+          '-nolisten', 'tcp', ':%d' % self.display]))
+        args_file.write(&quot;\n&quot;)
+        args_file.close()
+      except IOError, e:
+        nxlog.log(nxlog.LOG_ERR, 'IOError when writing '
+            'session args file: %s' % e)
+      except OSError, e:
+        nxlog.log(nxlog.LOG_ERR, 'OSError when writing '
+            'session args file: %s' % e)
+
+    def _write_opts(self):
+      &quot;&quot;&quot;Create the session's 'options' file
+
+      The options file is a comma-delimited list of options that are read in
+      by nxagent
+      &quot;&quot;&quot;
+
+      try:
+        opts_file = open(self.opts_file_path, 'w')
+        opts = ['nx/nx', 'keyboard=%(keyboard)s' % self,
+            'geometry=%(geometry)s' % self, 'client=%(client)s' % self,
+            'cache=8M', 'images=32M', 'link=%(link)s' % self,
+            'type=%(shorttype)s' % self, 'clipboard=both', 'composite=1',
+            'cleanup=0', 'accept=127.0.0.1', 'product=Freenx-gpl', 'shmem=1',
+            'backingstore=1', 'shpix=1', 'cookie=%s' % self.cookie,
+            'id=%s' % self.full_id, 'strict=0']
+        if self.type == 'unix-application':
+          opts.append('application=%(application)s' % self)
+        if self.fullscreen == '1':
+          opts.append('fullscreen=%(fullscreen)s' % self)
+        opts_file.write(&quot;%s:%d\n&quot; % (&quot;,&quot;.join(opts), self.display))
+        opts_file.close()
+      except IOError, e:
+        nxlog.log(nxlog.LOG_ERR, 'IOError when writing '
+            'session options file: %s' % e)
+      except OSError, e:
+        nxlog.log(nxlog.LOG_ERR, 'OSError when writing '
+            'session options file: %s' % e)
+
+    def info(self): #This is for reporting back to nxserver
+      &quot;&quot;&quot;Return a string with all parameter values encoded into it&quot;&quot;&quot;
+      # Needed for session list:
+      #   Display number
+      #   type
+      #   id
+      #   options(?) FRD--PSA (F=fullscreen, R=render,
+      #              D=non-rootless(Desktop?), PSA?)
+      #   depth
+      #   resolution
+      #   status
+      #   name
+      # Needed for session start:
+      #   hostname
+      #   cookie
+      #   proxy ip
+      #   ssl
+
+      return (&quot;display=%(display)d type=%(type)s id=%(id)s &quot;
+          &quot;options=%(options)s depth=%(depth)d resolution=%(resolution)s &quot;
+          &quot;name=%(name)s hostname=%(hostname)s cookie=%(cookie)s &quot;
+          &quot;proxyip=%(proxyip)s ssl=%(ssl)s&quot; % self)
+
+
+  def __init__(self, input, output, version=nxparser.base.parser.DEFAULT_VERSION,
+               program=DEFAULT_PROGRAM):
+    &quot;&quot;&quot;node_parser constructor
+
+    Args:
+      input: The file object to read parser input from.
+      output: The file object to write the results to.
+      version: The version string used to negotiate the protocol.
+      program: The program name used in the protocol banner.
+    &quot;&quot;&quot;
+    nxparser.base.parser.__init__(self, input, output, version=version, program=program)
+
+  def banner(self):
+    &quot;&quot;&quot;Write the protocol banner to the output.&quot;&quot;&quot;
+
+    self.prompt(1000, '%s - Version %s' % (self.program.upper(), self.version))
+
+  def _nx_startsession_handler(self, command):
+    # Remove 'startsession' from the front of the list of args
+    command.pop(0)
+
+    id = command.pop(0)
+    req = {}
+    for param in command:
+      key,val = self._parse_param(param)
+      if key: req[key] = val
+    sess = self.node_session(id, req)
+
+    # FIXME(diamond): change number to something sensible
+    self.write(&quot;NX&gt; 8888 sessioncreate %s&quot; % sess.info())
+    # Let stdout go directly to our stdout, i.e. to nxserver
+    # Check stderr for error messages if things go badly
+    p = subprocess.Popen('/usr/freenx/bin/nxagent-helper',
+                         stdin=subprocess.PIPE,
+                         stderr=subprocess.PIPE,
+                         shell=True)
+    p.stdin.write('start %s\n' % sess.full_id)
+    p.stdin.flush()
+    nxlog.log(nxlog.LOG_DEBUG, 'Starting session')
+    child_status = p.wait()
+    if child_status != 0:
+      lines = p.stderr.readlines()
+      if not lines:
+        out_msg = &quot;, no output printed&quot;
+      else:
+        out_msg = &quot;, with %d lines of output (shown below):&quot; % len(lines)
+      nxlog.log(nxlog.LOG_ERR, 'Start session failed %d%s' %
+          (child_status, out_msg))
+      for line in lines:
+        nxlog.log(nxlog.LOG_ERR, 'from nxagent-helper: %s' % line)
+      self.prompt(500, 'Error: Startsession failed')
+      self.running = False
+      return
+    nxlog.log(nxlog.LOG_ERR, 'Session completed %d' % child_status)
+    self.running = False
+    #FIXME(diamond): cleanup session dir here?
+
+  def _nx_resumesession_handler(self, unused_command):
+    nxlog.log(nxlog.LOG_DEBUG, 'Resuming session')
+
+
+if __name__ == '__main__':
+  print 'This is a library. Please use it from python using import.'
+  sys.exit(0)


Property changes on: trunk/freenx-redesign/server/lib/nxparser/node.py
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/lib/nxparser/server.py
===================================================================
--- trunk/freenx-redesign/server/lib/nxparser/server.py	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/lib/nxparser/server.py	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,695 @@
+#!/usr/bin/python2.4
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Authors: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">diamond at google.com</A> (Stephen Shirley)
+#          <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">alriddoch at google.com</A> (Alistair Riddoch)
+
+import errno
+import os
+import re
+import signal
+import socket
+import sys
+import termios
+import time
+import traceback
+
+import nxlog
+import nxparser
+import nxsession
+
+class parser(nxparser.base.parser):
+  &quot;&quot;&quot;Server parser for NX protocol.
+
+  This class handles the NX protocol messages required by a server.
+  &quot;&quot;&quot;
+
+  DEFAULT_PROGRAM = 'NXSERVER'
+
+  STATUS_CONNECTED, \
+  STATUS_LOGGEDIN = range(2)
+
+  SET_ACCEPTED_VARIABLES = ['AUTH_MODE', 'SHELL_MODE']
+
+  LISTSESSION_ACCEPTED_PARAMETERS = ['user', 'status', 'geometry', 'type']
+  LISTSESSION_COLUMNS = [[&quot;Display&quot;, 7, &quot;display&quot;], [&quot;Type&quot;, 16, &quot;type&quot;],
+      [&quot;Session ID&quot;, 32, &quot;id&quot;], [&quot;Options&quot;, 8, &quot;options&quot;],
+      [&quot;Depth&quot;, -5, &quot;depth&quot;], [&quot;Screen&quot;, 14, &quot;resolution&quot;],
+      [&quot;Status&quot;, 11, &quot;state&quot;], [&quot;Session Name&quot;, 30, 'name']]
+
+  STARTSESSION_ACCEPTED_PARAMETERS = [ 'backingstore', 'cache', 'client',
+                                       'composite', 'encryption', 'geometry',
+                                       'images', 'keyboard', 'link',
+                                       'media', 'screeninfo' 'session',
+                                       'shmem', 'shpix', 'strict', 'type', ]
+
+  def __init__(self, input, output, version=nxparser.base.parser.DEFAULT_VERSION,
+               program=DEFAULT_PROGRAM):
+    &quot;&quot;&quot;server_parser constructor
+
+    Args:
+      input: The file object to read parser input from.
+      output: The file object to write the results to.
+      version: The version string used to negotiate the protocol.
+      program: The program name used in the protocol banner.
+    &quot;&quot;&quot;
+    nxparser.base.parser.__init__(self, input, output, version=version, program=program)
+    self.port = 0
+
+    username = os.getenv('NX_TRUSTED_USER')
+
+    if username:
+      self.status = self.STATUS_LOGGEDIN
+      self.username = username
+    else:
+      self.status = self.STATUS_CONNECTED
+
+    commfd = os.getenv('NX_COMMFD')
+
+    if commfd:
+      self.nxnode_commfd = int(commfd)
+      self.nxnode_rfile = os.fdopen(self.nxnode_commfd, 'r')
+      self.nxnode_wfile = os.fdopen(self.nxnode_commfd, 'w')
+      nxlog.log(nxlog.LOG_DEBUG, 'Got commfd %d\n' % self.nxnode_commfd)
+
+  def __del__(self):
+    &quot;&quot;&quot;Destructor for the server_parser class
+
+    This is needed to cleanup after server_parser is done. In particular,
+    the file descriptors used for comms with nxnode may be in an errored state
+    if nxnode has exited.
+    &quot;&quot;&quot;
+
+    for i in ['r', 'w']:
+      var = &quot;nxnode_%sfile&quot; % i
+      try:
+        getattr(self, var).close()
+      except IOError, e:
+        if e.args[0] != errno.EBADF:
+          nxlog.log(nxlog.LOG_WARNING, &quot;Got error closing %s: %s\n&quot; %
+              (var, e))
+      except AttributeError:
+        pass # self.nxnode_(r|w)file doesn't exist
+
+  def banner(self):
+    &quot;&quot;&quot;Write the protocol banner to the output.&quot;&quot;&quot;
+
+    if self.status == self.STATUS_LOGGEDIN:
+      assert(hasattr(self, 'username'))
+      self.prompt(103, 'Welcome to: %s user: %s' % (socket.getfqdn().lower(),
+                                                      self.username))
+    else:
+      self.write('HELLO %s - Version %s - GPL' % (self.program, self.version))
+
+  def _nx_bye_handler(self, unused_command):
+    &quot;&quot;&quot;Handle the bye NX command.
+
+    'bye' signals the end of a commandline session. Currently it is ignored
+    as the other end typically closes the connection, causing termination.
+    It may be a good idea to explicitly exit.
+
+    Args:
+      command: The NX command and arguments invoked
+
+    Returns:
+      None
+    &quot;&quot;&quot;
+
+    # Basic checking of the right status
+    if self.status &lt; self.STATUS_LOGGEDIN:
+      self.prompt(554, 'Error: the command \'bye\' cannot '
+          'be called before login')
+      return
+    self.prompt(999, 'Bye.')
+    if self.port != 0:
+      os.execve(&quot;/bin/netcat&quot;, [&quot;netcat&quot;, &quot;localhost&quot;, str(self.port)], {})
+
+  def _nx_hello_handler(self, command):
+    &quot;&quot;&quot;Handle the hello NX command.
+
+    'hello' is used to handshake the commandline session, and appears to
+    support negotiation of the protocol version. We currently only
+    accept versions which look like 3.x.x, matched using a regex.
+
+    Args:
+      command: The NX command and arguments invoked
+
+    Returns:
+      None
+    &quot;&quot;&quot;
+
+    # Basic checking of the right status
+    if self.status &gt;= self.STATUS_LOGGEDIN:
+      self.prompt(554, 'Error: the command \'hello\' cannot '
+          'be called after login')
+      return
+    if len(command) &lt; 5:
+      nxlog.log(nxlog.LOG_DEBUG, 'Hello too short')
+      return
+    if not re.match('^3(\.[0-9]+(\.[0-9]+))', command[4]):
+      nxlog.log(nxlog.LOG_DEBUG, 'Version too fucked')
+      self.prompt(552, 'Protocol you requested is not supported')
+      return
+    # If the proffered version is the same as ours, or older..
+    if self._diff_version(self.version, command[4]) &lt; 1:
+      accept_ver = self.version
+    else:
+      accept_ver = command[4]
+    self.prompt(134, 'Accepted protocol: %s' % accept_ver)
+
+  def _nx_login_handler(self, unused_command):
+    &quot;&quot;&quot;Handle the login NX command.
+
+    'login' is used to start the process of authenticating to NX. The username
+    and password is send in response to requests from the server. If no
+    options have been set, nxserver will ask for the password, and will then
+    ask for an 'MD5 Password' if no password is given. If
+    'SET AUTH_MODE PASSWORD' has been sent by the client, it does not do this
+     however. This code currently never requests the MD5 Password. It is
+    possible that making use of this feature requires storing the users
+    password and verifying it with the hash.
+
+    Args:
+      command: The NX command and arguments invoked
+
+    Returns:
+      None
+    &quot;&quot;&quot;
+
+    # Basic checking of the right status
+    if self.status &gt;= self.STATUS_LOGGEDIN:
+      self.prompt(554, 'Error: the command \'login\' cannot be '
+          'called after login')
+      return
+    self.prompt(101, 'User: ', override_newline=False)
+    line = self.input.readline()
+    split_line = line.split()
+    if not line or len(split_line) != 1:
+      self.prompt(500, 'Error: Username is not in expected format')
+      return
+    self.write('') # Print newline after username
+    self.username = split_line[0]
+    nxlog.log(nxlog.LOG_DEBUG, 'Got user %r' % self.username)
+    self.prompt(102, 'Password: ', override_newline=False)
+
+    fd = self.input.fileno()
+    nxlog.log(nxlog.LOG_DEBUG, 'Got fd %r' % fd)
+    # Save the terminal settings
+    try:
+      old = termios.tcgetattr(fd)
+      new = old[:]
+
+      # Disable the echo flag
+      new[3] = new[3] &amp; ~termios.ECHO # 3 == 'lflags'
+      try:
+        termios.tcsetattr(fd, termios.TCSADRAIN, new)
+        passwd = self.input.readline()
+      finally:
+        termios.tcsetattr(fd, termios.TCSADRAIN, old)
+    except termios.error:
+      passwd = self.input.readline()
+
+    nxlog.log(nxlog.LOG_DEBUG, 'Got a passwd')
+
+    self.write('\n')
+    # FIXME(diamond): ssh to localhost to verify the username and password are
+    # correct. Also store the authentication information we need in a secure
+    # way.
+    del passwd
+    self.status = self.STATUS_LOGGEDIN
+    self.banner()
+
+  def _nx_set_handler(self, command):
+    &quot;&quot;&quot;Handle the SET NX command.
+
+    'SET' is used to configure the session in various ways. Two variables
+    have been seen.
+    'SET SHELL_MODE SHELL' has no known effect.
+    'SET AUTH_MODE PASSWORD' prevents nxserver fromm asking for an MD5
+    password if no password has been given.
+
+    Args:
+      command: The NX command and arguments invoked
+
+    Returns:
+      None
+    &quot;&quot;&quot;
+    if len(command) &lt; 2:
+      self.prompt(500, 'Error: missing parameter \'variable\'')
+      return
+    var = command[1].upper()
+    if var not in self.SET_ACCEPTED_VARIABLES:
+      self.prompt(500, 'Error: unknown variable \'%s\'' % var)
+      return
+
+  def _nx_listsession_handler(self, command):
+    &quot;&quot;&quot;Handle the listsession NX command.
+
+    'listsession' requests a table of session information for the current
+    user. It requires parameters be specified. The following parameters have
+    been seen.
+    '--user=&quot;alriddoch&quot;'
+    This seems to be ignored. No matter what is specified, the user given at
+    login is used.
+    '--status=&quot;suspended,running&quot;'
+    This seems to constrain the list to sessions in the given states.
+    '--geometry=&quot;3840x1200x24+render&quot;'
+    This seems to specify the desired geometry.
+    '--type=&quot;unix-gnome&quot;'
+    This seems to specify the desired type.
+    The format of the returned data is somewhat freeform, and looks hard to
+    parse. Currently this function returns an empty table, which forces the
+    the client to always start a new session
+
+    Args:
+      command: The NX command and arguments invoked
+
+    Returns:
+      None
+    &quot;&quot;&quot;
+
+    # Basic checking of the right status
+    if self.status &lt; self.STATUS_LOGGEDIN:
+      self.prompt(554, 'Error: the command \'listsession\' cannot '
+          'be called before login')
+      return
+    # Make sure the state is consistent
+    assert(hasattr(self, 'username'))
+    # Ask for parameters if none have been given
+    if len(command) &gt; 1:
+      parameters = command[1:]
+    else:
+      self.prompt(106, 'Parameters: ', override_newline=False)
+      response = self.input.readline()
+      self.write('') # Do newline after parameters.
+      parameters = response.split()
+    req = {}
+    # Check the parameters fit with the expected syntax
+    for param in parameters:
+      key,val = self._parse_param(param)
+      if key: req[key] = val
+    # Ignore --user, as per commercial implementation
+    req['user'] = [self.username]
+    if 'type' not in req:
+      # Default to showing any type
+      req['type'] = None
+    else:
+      req['type'] = req['type'].split(',')
+    if 'status' not in req:
+      # Default to showing any state
+      req['type'] = None
+    else:
+      req['status'] = req['status'].split(',')
+    self.prompt(127, 'Available sessions:')
+    self.__print_list_session(nxsession.db_find_sessions(
+      users=req['user'],
+      states=req['status'],
+      types=req['type']))
+    self.write('') # Print newline.
+    self.prompt(148, &quot;Server capacity: not reached for user: %s&quot; %
+        self.username)
+
+  def _nx_startsession_handler(self, command):
+    &quot;&quot;&quot;Handle the startsession NX command.
+
+    'startsession' seems to request a new session be started.
+    It requires parameters be specified. The following parameters have
+    been seen.
+    '--link=&quot;lan&quot;'
+    '--backingstore=&quot;1&quot;'
+    '--encryption=&quot;1&quot;'
+    '--cache=&quot;16M&quot;'
+    '--images=&quot;64M&quot;'
+    '--shmem=&quot;1&quot;'
+    '--shpix=&quot;1&quot;'
+    '--strict=&quot;0&quot;'
+    '--composite=&quot;1&quot;'
+    '--media=&quot;0&quot;'
+    '--session=&quot;localtest&quot;'
+    '--type=&quot;unix-gnome&quot;'
+    '--geometry=&quot;3840x1150&quot;'
+    '--client=&quot;linux&quot;'
+    '--keyboard=&quot;pc102/gb&quot;'
+    '--screeninfo=&quot;3840x1150x24+render&quot;'
+    Experiments with this command by directly invoked nxserver have not
+    worked, as it refuses to create a session saying the unencrypted sessions
+    are not supported. This is independent of whether the --encryption option
+    has been set, so probably is related to the fact the nxserver has not
+    been launched by sshd.
+
+    Args:
+      command: The NX command and arguments invoked
+
+    Returns:
+      None
+    &quot;&quot;&quot;
+
+    # Basic checking of the right status
+    if self.status &lt; self.STATUS_LOGGEDIN:
+      self.prompt(554, 'Error: the command \'%s\' cannot '
+          'be called before login' % command[0])
+      return
+    # Make sure the state is consistent
+    assert(hasattr(self, 'username'))
+    # Ask for parameters if none have been given
+    if len(command) &gt; 1:
+      parameters = command[1:]
+    else:
+      self.prompt(106, 'Parameters: ', override_newline=False)
+      response = self.input.readline()
+      self.write('') # Do newline after parameters.
+      parameters = response.split()
+    # Check the parameters fit with the expected syntax
+    for param in parameters:
+      key,val = self._parse_param(param)
+      # FIXME(diamond): DO something with the params.
+    # FIXME(diamond): Start the session.
+    if not hasattr(self, 'nxnode_commfd'):
+      nxlog.log(nxlog.LOG_ERR, 'Nxserver does not have an nxnode yet.')
+      return
+    # Send the command to the connected nxnode running
+    # FIXME(diamond): Convert the arguments to the form expected by nxnode.
+    sess_id = nxsession.gen_uniq_id()
+    self.write('startsession %s %s' %
+        (sess_id, &quot; &quot;.join(parameters)), fd=self.nxnode_wfile)
+
+    if self.daemonize():
+    # Two threads return here, one connected to the client, one connected to
+    # nxnode.
+      self.running = False
+      return
+
+    start_waiting = time.time()
+    wait_time = 30 #FIXME(diamond): make configurable
+    while True:
+      if time.time() - start_waiting &gt; wait_time:
+        nxlog.log(nxlog.LOG_ERR, &quot;Session %s has not appeared in session db &quot;
+            &quot;within %d seconds\n&quot; % (sess_id, wait_time))
+        sys.exit(1)
+        #FIXME(diamond): raise proper error
+      sessions = nxsession.db_find_sessions(id=sess_id)
+      if len(sessions) == 1:
+        sess = sessions[0]
+        nxlog.log(nxlog.LOG_DEBUG, &quot;Session %s has appeared in session db\n&quot; %
+            sess.params['full_id'])
+        break
+      elif len(sessions) &gt; 1:
+        nxlog.log(nxlog.LOG_DEBUG, &quot;Multiple sessions matching %d have been &quot;
+            &quot;found in the session db: %r\n&quot; % sess_id)
+        #FIXME(diamond): raise proper error
+        break
+      else:
+        time.sleep(1)
+
+    self.__print_sess_info(sess)
+
+    start_waiting = time.time()
+    wait_time = 30 #FIXME(diamond): make configurable
+    while True:
+      if time.time() - start_waiting &gt; wait_time:
+        nxlog.log(nxlog.LOG_ERR, &quot;Session %s has not achieved running status &quot;
+            &quot;within %d seconds\n&quot; % (sess_id, wait_time))
+        sys.exit(1)
+        #FIXME(diamond): raise proper error
+      sess.reload()
+      if sess.params['state'] == 'starting':
+        break
+      elif sess.params['state'] in ['terminating', 'terminated']:
+        nxlog.log(nxlog.LOG_ERR, &quot;Session %(full_id)s has status &quot;
+            &quot;'%(state)s', exiting.&quot; % sess.params)
+        self.prompt(500, &quot;Error: Session %(full_id)s has status '%(state)s'.&quot; %
+            sess.params)
+        self.prompt(999, &quot;Bye.&quot;)
+        self.running = False
+        return
+        #FIXME(diamond): raise proper error
+      else:
+        time.sleep(1)
+    self.prompt(710, 'Session status: %s' % sess.params['state'])
+    #FIXME(diamond): use configurable offset
+    self.port = int(sess.params['display']) + 4000
+
+  def _nx_restoresession_handler(self, command):
+    &quot;&quot;&quot;Handle the restoresession NX command.
+
+    'restoresession' requests an existing session be resume.
+    It requires parameters be specified. The following parameters have
+    been seen, at a minimum the session id must be specified:
+    '--link=&quot;lan&quot;'
+    '--backingstore=&quot;1&quot;'
+    '--encryption=&quot;1&quot;'
+    '--cache=&quot;16M&quot;'
+    '--images=&quot;64M&quot;'
+    '--shmem=&quot;1&quot;'
+    '--shpix=&quot;1&quot;'
+    '--strict=&quot;0&quot;'
+    '--composite=&quot;1&quot;'
+    '--media=&quot;0&quot;'
+    '--session=&quot;localtest&quot;'
+    '--type=&quot;unix-gnome&quot;'
+    '--geometry=&quot;3840x1150&quot;'
+    '--client=&quot;linux&quot;'
+    '--keyboard=&quot;pc102/gb&quot;'
+    '--screeninfo=&quot;3840x1150x24+render&quot;'
+    --id=&quot;A28EBF5AAC354E9EEAFEEB867980C543&quot;
+
+    Args:
+      command: The NX command and arguments invoked
+
+    Returns:
+      None
+    &quot;&quot;&quot;
+
+    # Basic checking of the right status
+    if self.status &lt; self.STATUS_LOGGEDIN:
+      self.prompt(554, 'Error: the command \'%s\' cannot '
+          'be called before login' % command[0])
+      return
+    # Make sure the state is consistent
+    assert(hasattr(self, 'username'))
+    # Ask for parameters if none have been given
+    if len(command) &gt; 1:
+      parameters = command[1:]
+    else:
+      self.prompt(106, 'Parameters: ', override_newline=False)
+      response = self.input.readline()
+      self.write('') # Do newline after parameters.
+      parameters = response.split()
+    req = {}
+    # Check the parameters fit with the expected syntax
+    for param in parameters:
+      key,val = self._parse_param(param)
+      if key: req[key] = val
+      # FIXME(diamond): DO something with the params.
+    if not req.has_key('id'):
+      msg = &quot;Restore session requested, but no session specified&quot;
+      nxlog.log(nxlog.LOG_ERR, &quot;%s (args: %r)\n&quot; % (msg, req))
+      self.prompt(500, 'Error: %s. check log file for more details.' % msg)
+      self.running = False
+      return
+    nxlog.log(nxlog.LOG_DEBUG, &quot;Got id param: %s&quot; % req['id'])
+    sessions = nxsession.db_find_sessions(id=req['id'], users=[self.username],
+        states=['suspended', 'running'])
+    if len(sessions) != 1:
+      nxlog.log(nxlog.LOG_ERR, &quot;%d sessions found matching %s in &quot;
+          &quot;session db %s\n&quot; % (len(sessions), req['id'], sessions))
+      self.prompt(500, 'Error: Fatal error in module %s, '
+          'check log file for more details.' % self.program.lower())
+      self.running = False
+      return
+
+    sess = sessions[0]
+    nxlog.log(nxlog.LOG_DEBUG, &quot;Session %s found in session db\n&quot; %
+        sess.params['full_id'])
+
+    # Needed to get nxagent to open it's port again.
+    try:
+      os.kill(int(sess.params['agent_pid']), signal.SIGHUP)
+    except OSError, e:
+      nxlog.log(nxlog.LOG_WARNING, &quot;Attempted to send SIGHUP to nxagent, &quot;
+          &quot;got error from kill[%d]: %s\n&quot; % e.args)
+      self.prompt(500, 'Error: Fatal error in module %s, '
+          'check log file for more details.' % self.program.lower())
+      self.prompt(999, 'Bye.')
+      self.running = False
+      return
+    except (TypeError, ValueError), e:
+      nxlog.log(nxlog.LOG_WARNING, &quot;Session does not have a valid nxagent pid &quot;
+          &quot;stored (instead has %r), got error: %s&quot; %
+          (sess.params['agent_pid'], e))
+      self.prompt(500, 'Error: Fatal error in module %s, '
+          'check log file for more details.' % self.program.lower())
+      self.prompt(999, 'Bye.')
+      self.running = False
+      return
+    else:
+      nxlog.log(nxlog.LOG_NOTICE, &quot;Sent SIGHUP to nxagent\n&quot;)
+
+    self.__print_sess_info(sess)
+    self.prompt(710, 'Session status: %s' % sess.params['state'])
+    #FIXME(diamond): use configurable offset
+    self.port = int(sess.params['display']) + 4000
+
+  def daemonize(self):
+    &quot;&quot;&quot;Drop into the background.&quot;&quot;&quot;
+
+    # I am assumuing this throws if fork fails.
+    pid = os.fork()
+    # In the parent, return.
+    if pid != 0:
+      # self.nxnode_rfile.close()
+      # self.nxnode_wfile.close()
+      os.close(self.nxnode_commfd)
+      # del(self.nxnode_rfile)
+      # del(self.nxnode_wfile)
+      # del(self.nxnode_commfd)
+      nxlog.setup('nxserver-outer')
+      nxlog.log(nxlog.LOG_INFO, &quot;Forked child to take care of nxsession stuff&quot;)
+      return False
+
+    # Dissociate from the nxserver terminal
+    os.setsid()
+
+    # If we need to change signal behavior, do it here.
+
+    # Close the stdio fds.
+    os.close(0)
+    os.close(1)
+    os.close(2)
+
+    self.input = self.nxnode_rfile
+    self.output = self.nxnode_wfile
+
+    # I'm not sure what to do here with self.nxnode_rfile and self.nxnode_wfile
+    # Closing the fd is enough, but the file objects would linger on.
+    del(self.nxnode_rfile)
+    del(self.nxnode_wfile)
+    del(self.nxnode_commfd)
+
+    nxlog.setup('nxserver-inner')
+    nxlog.log(nxlog.LOG_INFO, &quot;Successfully forked, &quot;
+        &quot;taking care of nxsession stuff\n&quot;)
+    try:
+      self._session_read_loop()
+    except Exception:
+      trace = traceback.format_exc()
+      nxlog.log(nxlog.LOG_ERR, 'Going down because exception caught '
+                               'at the top level.')
+      for line in trace.split('\n'):
+        nxlog.log(nxlog.LOG_ERR, '%s' % line)
+    return True
+
+  def _session_read_loop(self):
+    sess = None
+    while True:
+      line = self.input.readline()
+      if not line:
+        return
+      line = line.rstrip()
+      nxlog.log(nxlog.LOG_DEBUG, 'Got from nxnode %r\n' % line)
+      # FIXME(diamond): change number to something sensible
+      if line.startswith('NX&gt; 8888 sessioncreate'):
+        if sess:
+          nxlog.log(nxlog.LOG_ERR, 'Nxnode tried to create a session when one '
+              'already exists: %s\n' % line)
+        else:
+          args = line.split(' ', 3)[-1].replace(' ', '\n')
+          sess = nxsession.nxsession(args)
+      elif line.startswith('NX&gt; 8888 agentpid:'):
+        if not sess:
+          nxlog.log(nxlog.LOG_ERR, 'Nxagent-helper tried to change session '
+              'when none exists: %s\n' % line)
+        else:
+          agent_pid = line.rstrip().split(' ')[3]
+          sess.params['agent_pid'] = agent_pid
+          sess.save()
+          nxlog.log(nxlog.LOG_DEBUG, &quot;Agent pid set to '%s'\n&quot; %
+              sess.params['agent_pid'])
+      elif line.startswith('NX&gt; 1009 Session status:'):
+        if not sess:
+          nxlog.log(nxlog.LOG_ERR, 'Nxagent-helper tried to change session '
+              'when none exists: %s\n' % line)
+        else:
+          state_name = line.rstrip().split(' ')[4]
+          sess.set_state(state_name)
+          sess.save()
+          nxlog.log(nxlog.LOG_DEBUG, &quot;Session state updated to '%s'\n&quot; %
+              sess.params['state'])
+      elif line.startswith('NX&gt; 500 Error:'):
+        if sess:
+          sess.set_state('terminated')
+          sess.save()
+          nxlog.log(nxlog.LOG_DEBUG, &quot;Session state updated to '%s', exiting\n&quot;
+              % sess.params['state'])
+          break
+
+  def __print_list_session(self, sessions):
+    &quot;&quot;&quot;Given a list of sessions, print the listsession output
+
+    Args:
+      sessions: A list of nxsession.nxsesion() instances
+    &quot;&quot;&quot;
+
+    # Print headers
+    cols = []
+    for header,width,param in self.LISTSESSION_COLUMNS:
+      if width &gt;= 0:
+        text = header.ljust(width)
+      else:
+        text = header.rjust(abs(width))
+      cols.append(text)
+    self.write(&quot; &quot;.join(cols))
+
+    # Print dashes
+    cols = []
+    for header,width,param in self.LISTSESSION_COLUMNS:
+      cols.append(&quot;-&quot; * abs(width))
+    self.write(&quot; &quot;.join(cols))
+
+    # Print sessions
+    for sess in sessions:
+      cols = []
+      for header,width,param in self.LISTSESSION_COLUMNS:
+        if width &gt;= 0:
+          text = sess.params[param].ljust(width)
+        else:
+          text = sess.params[param].rjust(abs(width))
+        if param == 'state': text = text.capitalize()
+        cols.append(text)
+      self.write(&quot; &quot;.join(cols))
+
+  def __print_sess_info(self, sess):
+    &quot;&quot;&quot;Print out session information to the client
+
+    This is used for starting/resuming a session.
+    &quot;&quot;&quot;
+
+    self.prompt(700, 'Session id: %(full_id)s' % sess.params)
+    self.prompt(705, 'Session display: %(display)s' % sess.params)
+    self.prompt(703, 'Session type: %(type)s' % sess.params)
+    self.prompt(701, 'Proxy cookie: %(cookie)s' % sess.params)
+    self.prompt(702, 'Proxy IP: %(proxyip)s' % sess.params)
+    self.prompt(706, 'Agent cookie: %(cookie)s' % sess.params)
+    self.prompt(704, 'Session cache: %(cache)s' % sess.params)
+    self.prompt(707, 'SSL tunneling: %(ssl)s' % sess.params)
+    self.prompt(708, 'Subscription: GPL')
+
+
+if __name__ == '__main__':
+  print 'This is a library. Please use it from python using import.'
+  sys.exit(0)


Property changes on: trunk/freenx-redesign/server/lib/nxparser/server.py
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/lib/nxparser.py.orig
===================================================================
--- trunk/freenx-redesign/server/lib/nxparser.py.orig	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/lib/nxparser.py.orig	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,588 @@
+#!/usr/bin/python
+#
+# Copyright 2007 Google Inc. All Rights Reserved.
+#
+# $Id: $
+# $Author: $
+# $Date: $
+
+&quot;&quot;&quot;nxparser module for handling the nx protocol.
+&quot;&quot;&quot;
+
+import os
+import optparse
+import re
+import socket
+import subprocess
+import sys
+import termios
+import time
+import traceback
+
+import nxlog
+
+__author__ = '<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">alriddoch at google.com</A> (Alistair Riddoch)'
+__version__ = '$Revision: #1 $'
+__copyright__ = 'Copyright 2007 Google Inc. All rights reserved.'
+
+
+class base_parser:
+  &quot;&quot;&quot;Base parser for NX protocol parsers.
+
+  This class handles breaking up the messages into components,
+  and dispatching them.
+  &quot;&quot;&quot;
+
+  DEFAULT_VERSION = '3.0.0'
+  DEFAULT_PROGRAM = 'NXBASE'
+
+  NX_PROMPT = 'NX&gt;'
+  NX_COMMANDS = ['hello', 'login', 'bye', 'set', 'listsession',
+                 'restoresession', 'startsession', 'terminate']
+
+  def __init__(self, input, output, version=DEFAULT_VERSION,
+               program=DEFAULT_PROGRAM):
+    &quot;&quot;&quot;base_parser constructor
+
+    Args:
+      input: The file object to read parser input from.
+      output: The file object to write the results to.
+      version: The version string used to negotiate the protocol.
+      program: The program name used in the protocol banner.
+    &quot;&quot;&quot;
+
+    self.input = input
+    self.output = output
+    self.state = 105
+    self.running = True
+    self.parse_args(version=version, program=program)
+    nxlog.log(nxlog.LOG_DEBUG, &quot;Version: %s Program: %s&quot; %
+        (self.version, self.program))
+
+  def banner(self):
+    &quot;&quot;&quot;Write the protocol banner to the output.&quot;&quot;&quot;
+
+    self.write('HELLO %s - Version %s - GPL' % (self.program, self.version))
+
+  def prompt(self, state, message='', override_newline=None):
+    &quot;&quot;&quot;Write the protocol prompt to the output.&quot;&quot;&quot;
+
+    newline = False
+    if override_newline is not None:
+      newline = override_newline
+    elif message:
+      newline=True
+    self.write('%s %d %s' % (self.NX_PROMPT, state, message), newline=newline)
+
+  def loop(self):
+    &quot;&quot;&quot;Write the protocol prompt to the output, and accept commands.&quot;&quot;&quot;
+
+    try:
+      while self.running:
+        self.prompt(self.state)
+        line = self.input.readline().rstrip()
+        if not line:
+          return
+        nxlog.log(nxlog.LOG_DEBUG, 'Got %r' % line)
+        command = line.split()
+        if not command:
+          # If the line was all whitespace this could happen.
+          continue
+        cmd = command[0].lower()
+        if cmd == 'set':
+          self.write(&quot;%s %s: %s&quot; % (cmd.capitalize(), command[1].lower(), command[2].lower()))
+        elif cmd == 'startsession':
+          self.write(&quot;Start session with: %s&quot; % &quot; &quot;.join(command[1:]))
+        else:
+          self.write(line.capitalize())
+        if cmd not in self.NX_COMMANDS:
+          self.prompt(503, 'Error: undefined command: \'%s\'' % cmd)
+          continue
+        handler_name = '_nx_%s_handler' % cmd
+        try:
+          handler_method = getattr(self, handler_name)
+        except AttributeError:
+          nxlog.log(nxlog.LOG_DEBUG, 'Unhandled nx command %r' % cmd)
+          continue
+        handler_method(command)
+    except IOError, e:
+      nxlog.log(nxlog.LOG_ERR, 'IOError. Connection lost.')
+    except Exception, e:
+      trace = traceback.format_exc()
+      nxlog.log(nxlog.LOG_ERR, 'Going down because exception caught '
+                               'at the top level.')
+      for line in trace.split('\n'):
+        nxlog.log(nxlog.LOG_ERR, '%s' % line)
+
+  def write(self, output, newline=True, flush=True, log=True,
+      log_level=nxlog.LOG_DEBUG, fd=None):
+    &quot;&quot;&quot;Write given string to output, and optionally:
+      - append a newline
+      - flush output afterwards
+      - log the output, with a specified log level.&quot;&quot;&quot;
+
+    if newline:
+      output += '\n'
+    use_fd = self.output
+    if fd:
+      use_fd = fd
+    use_fd.write(output)
+    if flush:
+      use_fd.flush()
+    if log:
+      nxlog.log(log_level, 'Sent: %r' % output)
+
+  def parse_args(self, version=None, program=None):
+    &quot;&quot;&quot;Parse cmdline arguments&quot;&quot;&quot;
+    parser = optparse.OptionParser()
+    parser.add_option(&quot;--proto&quot;, action=&quot;store&quot;, type=&quot;string&quot;,
+        dest=&quot;version&quot;, default=version, metavar=&quot;PROTO_VER&quot;,
+        help=&quot;use the PROTO_VER version of the NX protocol&quot;)
+    parser.add_option(&quot;--program&quot;, action=&quot;store&quot;, type=&quot;string&quot;,
+        dest=&quot;program&quot;, default=program, metavar=&quot;PROG_NAME&quot;,
+        help=&quot;the PROG_NAME name to announce&quot;)
+    options, args = parser.parse_args()
+    self.version = options.version
+    self.program = options.program
+
+
+
+class node_parser(base_parser):
+  &quot;&quot;&quot;Node parser for NX protocol
+
+  This class handles the NX protocl messages requires by a node.
+  &quot;&quot;&quot;
+
+  DEFAULT_PROGRAM = 'NXNODE'
+
+  def __init__(self, input, output, version=base_parser.DEFAULT_VERSION,
+               program=DEFAULT_PROGRAM):
+    &quot;&quot;&quot;server_parser constructor
+
+    Args:
+      input: The file object to read parser input from.
+      output: The file object to write the results to.
+      version: The version string used to negotiate the protocol.
+      program: The program name used in the protocol banner.
+    &quot;&quot;&quot;
+    base_parser.__init__(self, input, output, version=version, program=program)
+
+  def banner(self):
+    &quot;&quot;&quot;Write the protocol banner to the output.&quot;&quot;&quot;
+
+    self.prompt(1000, '%s - Version %s' % (self.program.upper(), self.version))
+
+  def _nx_startsession_handler(self, command):
+    p = subprocess.Popen('/usr/freenx/bin/nxagent-helper',
+                         stdin=subprocess.PIPE,
+                         stdout=subprocess.PIPE,
+                         stderr=subprocess.STDOUT,
+                         shell=True)
+    p.stdin.write('start %s-1116-DA49F2B8F86161BAD68B5349D63AC1D3\n' %
+        socket.getfqdn().lower())
+    p.stdin.flush()
+    nxlog.log(nxlog.LOG_DEBUG, 'Starting session')
+    child_status = p.wait()
+    if child_status != 0:
+      lines = p.stdout.readlines()
+      if not lines:
+        out_msg = &quot;, no output printed&quot;
+      else:
+        out_msg = &quot;, with %d lines of output (shown below):&quot; % len(lines)
+      nxlog.log(nxlog.LOG_ERR, 'Start session failed %d%s' %
+          (child_status, out_msg))
+      for line in lines:
+        nxlog.log(nxlog.LOG_ERR, 'from nxagent-helper: %s' % line)
+      self.prompt(500, 'Error: Startsession failed')
+      return
+    nxlog.log(nxlog.LOG_ERR, 'Session completed %d' % child_status)
+    self.running = False
+
+  def _nx_resumesession_handler(self, command):
+    nxlog.log(nxlog.LOG_DEBUG, 'Resuming session')
+
+
+class server_parser(base_parser):
+  &quot;&quot;&quot;Server parser for NX protocol.
+
+  This class handles the NX protocol messages required by a server.
+  &quot;&quot;&quot;
+
+  DEFAULT_PROGRAM = 'NXSERVER'
+
+  STATUS_CONNECTED, \
+  STATUS_LOGGEDIN = range(2)
+
+  SET_ACCEPTED_VARIABLES = ['AUTH_MODE', 'SHELL_MODE']
+
+  LISTSESSION_ACCEPTED_PARAMETERS = ['user', 'status', 'geometry', 'type']
+  LISTSESSION_COLUMNS_HEADER = &quot;Display Type             Session ID                       Options  Depth Screen         Status      Session Name&quot;
+  LISTSESSION_COLUMNS_DASHES = &quot;------- ---------------- -------------------------------- -------- ----- -------------- ----------- ------------------------------&quot;
+
+  STARTSESSION_ACCEPTED_PARAMETERS = [ 'backingstore', 'cache', 'client',
+                                       'composite', 'encryption', 'geometry',
+                                       'images', 'keyboard', 'link',
+                                       'media', 'screeninfo' 'session',
+                                       'shmem', 'shpix', 'strict', 'type', ]
+
+  def __init__(self, input, output, version=base_parser.DEFAULT_VERSION,
+               program=DEFAULT_PROGRAM):
+    &quot;&quot;&quot;server_parser constructor
+
+    Args:
+      input: The file object to read parser input from.
+      output: The file object to write the results to.
+      version: The version string used to negotiate the protocol.
+      program: The program name used in the protocol banner.
+    &quot;&quot;&quot;
+    base_parser.__init__(self, input, output, version=version, program=program)
+
+    username = os.getenv('NX_TRUSTED_USER')
+    
+    if username:
+      self.status = self.STATUS_LOGGEDIN
+      self.username = username
+    else:
+      self.status = self.STATUS_CONNECTED
+
+    commfd = os.getenv('NX_COMMFD')
+
+    if commfd:
+      self.nxnode_commfd = int(commfd)
+      self.nxnode_rfile = os.fdopen(self.nxnode_commfd, 'r')
+      self.nxnode_wfile = os.fdopen(self.nxnode_commfd, 'w')
+      nxlog.log(nxlog.LOG_DEBUG, 'Got commfd %d' % self.nxnode_commfd)
+
+  def banner(self):
+    &quot;&quot;&quot;Write the protocol banner to the output.&quot;&quot;&quot;
+
+    if self.status == self.STATUS_LOGGEDIN:
+      assert(hasattr(self, 'username'))
+      self.prompt(103, 'Welcome to: %s user: %s' % (socket.getfqdn().lower(),
+                                                      self.username))
+    else:
+      self.write('HELLO %s - Version %s - GPL' % (self.program, self.version))
+
+  def _nx_bye_handler(self, command):
+    &quot;&quot;&quot;Handle the bye NX command.
+
+    'bye' signals the end of a commandline session. Currently it is ignored
+    as the other end typically closes the connection, causing termination.
+    It may be a good idea to explicitly exit.
+
+    Args:
+      command: The NX command and arguments invoked
+
+    Returns:
+      None
+    &quot;&quot;&quot;
+
+    # Basic checking of the right status
+    if self.status &lt; self.STATUS_LOGGEDIN:
+      self.prompt(554, 'Error: the command \'bye\' cannot be called before login')
+      return
+    try:
+      self.prompt(999, 'Bye.')
+    except:
+      pass #DEBUG: don't do this..
+    os.execve(&quot;/bin/netcat&quot;, [&quot;netcat&quot;, &quot;localhost&quot;, &quot;5116&quot;], {})
+
+  def _nx_hello_handler(self, command):
+    &quot;&quot;&quot;Handle the hello NX command.
+
+    'hello' is used to handshake the commandline session, and appears to
+    support negotiation of the protocol version. We currently only
+    accept versions which look like 3.x.x, matched using a regex.
+
+    Args:
+      command: The NX command and arguments invoked
+
+    Returns:
+      None
+    &quot;&quot;&quot;
+
+    # Basic checking of the right status
+    if self.status &gt;= self.STATUS_LOGGEDIN:
+      self.prompt(554, 'Error: the command \'hello\' cannot be called after login')
+      return
+    if len(command) &lt; 5:
+      nxlog.log(nxlog.LOG_DEBUG, 'Hello too short')
+      return
+    if not re.match('^3(\.[0-9]+(\.[0-9]+))', command[4]):
+      nxlog.log(nxlog.LOG_DEBUG, 'Version too fucked')
+      self.prompt(552, 'Protocol you requested is not supported')
+      return
+    self.prompt(134, 'Accepted protocol: %s' % command[4])
+
+  def _nx_login_handler(self, command):
+    &quot;&quot;&quot;Handle the login NX command.
+
+    'login' is used to start the process of authenticating to NX. The username
+    and password is send in response to requests from the server. If no
+    options have been set, nxserver will ask for the password, and will then
+    ask for an 'MD5 Password' if no password is given. If
+    'SET AUTH_MODE PASSWORD' has been sent by the client, it does not do this
+     however. This code currently never requests the MD5 Password. It is
+    possible that making use of this feature requires storing the users
+    password and verifying it with the hash.
+
+    Args:
+      command: The NX command and arguments invoked
+
+    Returns:
+      None
+    &quot;&quot;&quot;
+
+    # Basic checking of the right status
+    if self.status &gt;= self.STATUS_LOGGEDIN:
+      self.prompt(554, 'Error: the command \'login\' cannot be called after login')
+      return
+    self.prompt(101, 'User: ', override_newline=False)
+    line = self.input.readline()
+    split_line = line.split()
+    if not line or len(split_line) != 1:
+      self.prompt(500, 'Error: Username is not in expected format')
+      return
+    self.write('') # Print newline after username
+    self.username = split_line[0]
+    nxlog.log(nxlog.LOG_DEBUG, 'Got user %r' % self.username)
+    self.prompt(102, 'Password: ', override_newline=False)
+
+    fd = self.input.fileno()
+    nxlog.log(nxlog.LOG_DEBUG, 'Got fd %r' % fd)
+    # Save the terminal settings
+    try:
+      old = termios.tcgetattr(fd)
+      new = old[:]
+
+      # Disable the echo flag
+      new[3] = new[3] &amp; ~termios.ECHO # 3 == 'lflags'
+      try:
+        termios.tcsetattr(fd, termios.TCSADRAIN, new)
+        passwd = self.input.readline()
+      finally:
+        termios.tcsetattr(fd, termios.TCSADRAIN, old)
+    except termios.error:
+      passwd = self.input.readline()
+
+    nxlog.log(nxlog.LOG_DEBUG, 'Got a passwd')
+
+    self.write('\n')
+    # FIXME ssh to localhost to verify the username and password are correct.
+    # FIXME store the authentication information we need in a secure way.
+    del passwd
+    self.status = self.STATUS_LOGGEDIN
+    self.banner()
+
+  def _nx_set_handler(self, command):
+    &quot;&quot;&quot;Handle the SET NX command.
+
+    'SET' is used to configure the session in various ways. Two variables
+    have been seen.
+    'SET SHELL_MODE SHELL' has no known effect.
+    'SET AUTH_MODE PASSWORD' prevents nxserver fromm asking for an MD5
+    password if no password has been given.
+
+    Args:
+      command: The NX command and arguments invoked
+
+    Returns:
+      None
+    &quot;&quot;&quot;
+    if len(command) &lt; 2:
+      self.prompt(500, 'Error: missing parameter \'variable\'')
+      return
+    var = command[1].upper()
+    if var not in self.SET_ACCEPTED_VARIABLES:
+      self.prompt(500, 'Error: unknown variable \'%s\'' % var)
+      return
+      
+  def _nx_listsession_handler(self, command):
+    &quot;&quot;&quot;Handle the listsession NX command.
+
+    'listsession' requests a table of session information for the current
+    user. It requires parameters be specified. The following parameters have
+    been seen.
+    '--user=&quot;alriddoch&quot;'
+    This seems to be ignored. No matter what is specified, the user given at
+    login is used.
+    '--status=&quot;suspended,running&quot;'
+    This seems to constrain the list to sessions in the given states.
+    '--geometry=&quot;3840x1200x24+render&quot;'
+    This seems to specify the desired geometry.
+    '--type=&quot;unix-gnome&quot;'
+    This seems to specify the desired type.
+    The format of the returned data is somewhat freeform, and looks hard to
+    parse. Currently this function returns an empty table, which forces the
+    the client to always start a new session
+
+    Args:
+      command: The NX command and arguments invoked
+
+    Returns:
+      None
+    &quot;&quot;&quot;
+
+    # Basic checking of the right status
+    if self.status &lt; self.STATUS_LOGGEDIN:
+      self.prompt(554, 'Error: the command \'listsession\' cannot be called before login')
+      return
+    # Make sure the state is consistent
+    assert(hasattr(self, 'username'))
+    # Ask for parameters if none have been given
+    if len(command) &gt; 1:
+      parameters = command[1:]
+    else:
+      self.prompt(106, 'Parameters: ', override_newline=False)
+      response = self.input.readline()
+      self.write('') # Do newline after parameters.
+      parameters = response.split()
+    # Check the parameters fit with the expected syntax
+    for param in parameters:
+      p = re.match('^--([a-z]+)=&quot;(.+)&quot;', param)
+      if p:
+        nxlog.log(nxlog.LOG_DEBUG, 'Param %r matched' % param)
+      else:
+        nxlog.log(nxlog.LOG_DEBUG, 'Param %r missed' % param)
+      # FIXME DO something with the params.
+      # Note that --user is IGNORED
+    self.prompt(127, 'Available sessions:')
+    self.write(&quot;%s\n%s&quot; % (self.LISTSESSION_COLUMNS_HEADER, self.LISTSESSION_COLUMNS_DASHES))
+    #DEBUG: remove later
+    #self.write(&quot;1057    unix-kde         A28EBF5AAC354E9EEAFEEB867980C543 -RD--PSA    24 800x600        Suspended   warped0&quot;)
+    #self.write(&quot;1057    unix-kde         A28EBF5AAC354E9EEAFEEB867980C543 -RD--PSA    24 800x600        Suspended   warped0&quot;)
+    #END DEBUG
+    self.write('') # Print newline.
+    self.prompt(148, &quot;Server capacity: not reached for user: %s&quot; % self.username)
+
+  def _nx_startsession_handler(self, command):
+    &quot;&quot;&quot;Handle the startsession NX command.
+
+    'startsession' seems to request a new session be started.
+    It requires parameters be specified. The following parameters have
+    been seen.
+    '--link=&quot;lan&quot;'
+    '--backingstore=&quot;1&quot;'
+    '--encryption=&quot;1&quot;'
+    '--cache=&quot;16M&quot;'
+    '--images=&quot;64M&quot;'
+    '--shmem=&quot;1&quot;'
+    '--shpix=&quot;1&quot;'
+    '--strict=&quot;0&quot;'
+    '--composite=&quot;1&quot;'
+    '--media=&quot;0&quot;'
+    '--session=&quot;localtest&quot;'
+    '--type=&quot;unix-gnome&quot;'
+    '--geometry=&quot;3840x1150&quot;'
+    '--client=&quot;linux&quot;'
+    '--keyboard=&quot;pc102/gb&quot;'
+    '--screeninfo=&quot;3840x1150x24+render&quot;'
+    Experiments with this command by directly invoked nxserver have not
+    worked, as it refuses to create a session saying the unencrypted sessions
+    are not supported. This is independent of whether the --encryption option
+    has been set, so probably is related to the fact the nxserver has not
+    been launched by sshd.
+
+    Args:
+      command: The NX command and arguments invoked
+
+    Returns:
+      None
+    &quot;&quot;&quot;
+
+    # Basic checking of the right status
+    if self.status &lt; self.STATUS_LOGGEDIN:
+      self.prompt(554, 'Error: the command \'startsession\' cannot '
+          'be called before login')
+      return
+    # Make sure the state is consistent
+    assert(hasattr(self, 'username'))
+    # Ask for parameters if none have been given
+    if len(command) &gt; 1:
+      parameters = command[1:]
+    else:
+      self.prompt(106, 'Parameters: ', override_newline=False)
+      response = self.input.readline()
+      self.write('') # Do newline after parameters.
+      parameters = response.split()
+    # Check the parameters fit with the expected syntax
+    for param in parameters:
+      p = re.match('^--([a-z]+)=&quot;(.+)&quot;', param)
+      if p:
+        nxlog.log(nxlog.LOG_DEBUG, 'Param %r matched' % param)
+      else:
+        nxlog.log(nxlog.LOG_DEBUG, 'Param %r missed' % param)
+      # FIXME DO something with the params.
+    # FIXME Start the session.
+    if not hasattr(self, 'nxnode_commfd'):
+      nxlog.log(nxlog.LOG_ERR, 'Nxserver does not have an nxnode yet.')
+      return
+    # Send the command to the connected nxnode running
+    # FIXME Convert the arguments to the form expected by nxnode.
+    #DEBUG: remove later
+    self.write('startsession arguments', fd=self.nxnode_wfile)
+    self.prompt(700, 'Session id: %s-1116-DA49F2B8F86161BAD68B5349D63AC1D3' %
+        socket.getfqdn().lower())
+    self.prompt(705, 'Session display: 1116')
+    self.prompt(703, 'Session type: unix-kde')
+    self.prompt(701, 'Proxy cookie: C9B7CFDBC88A1138C698CBF44ADBC1E4')
+    self.prompt(702, 'Proxy IP: 172.26.170.56')
+    self.prompt(706, 'Agent cookie: C9B7CFDBC88A1138C698CBF44ADBC1E4')
+    self.prompt(704, 'Session cache: unix-kde')
+    self.prompt(707, 'SSL tunneling: 1')
+    self.prompt(708, 'Subscription: LFE/None/LFEN/None')
+    # Just to give nxagent time to start. The final version will wait for the
+    # status change message from nxnode/nxagent-helper.
+    time.sleep(10)
+    self.prompt(710, 'Session status: running')
+
+    #END DEBUG
+
+    self.daemonize()
+    # Two threads return here, one connected to the client, one connected to
+    # nxnode.
+  def daemonize(self):
+    &quot;&quot;&quot;Drop into the background.&quot;&quot;&quot;
+  
+    # I am assumuing this throws if fork fails.
+    pid = os.fork()
+    # In the parent, return.
+    if pid != 0:
+      # self.nxnode_rfile.close()
+      # self.nxnode_wfile.close()
+      os.close(self.nxnode_commfd)
+      # del(self.nxnode_rfile)
+      # del(self.nxnode_wfile)
+      # del(self.nxnode_commfd)
+      return
+
+    # Dissociate from the nxserver terminal
+    os.setsid()
+
+    # If we need to change signal behavior, do it here.
+
+    # Close the stdio fds.
+    # os.close(0)
+    # os.close(1)
+    # os.close(2)
+
+    self.input = self.nxnode_rfile
+    self.output = self.nxnode_wfile
+    
+    # I'm not sure what to do here with self.nxnode_rfile and self.nxnode_wfile
+    # Closing the fd is enough, but the file objects would linger on.
+    del(self.nxnode_rfile)
+    del(self.nxnode_wfile)
+    del(self.nxnode_commfd)
+
+    while True:
+      line = self.input.readline().rstrip()
+      if not line:
+        return
+      nxlog.log(nxlog.LOG_DEBUG, 'Got from nxnode %r' % line)
+    
+
+
+if __name__ == '__main__':
+  print 'This is a library. Please use it from python using import.'
+  sys.exit(0)

Added: trunk/freenx-redesign/server/lib/nxsession.py
===================================================================
--- trunk/freenx-redesign/server/lib/nxsession.py	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/lib/nxsession.py	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,225 @@
+#!/usr/bin/python2.4
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">diamond at google.com</A> (Stephen Shirley)
+
+&quot;&quot;&quot;nxsession module for handling nx sessions.&quot;&quot;&quot;
+
+import copy
+import glob
+import md5
+import os
+import pwd
+import socket
+import time
+
+import nxlog
+
+DB_TOPLEVEL=&quot;/usr/freenx/var/sessdb&quot;
+
+state_names = ['created', 'starting', 'running', 'suspending',
+    'suspended', 'terminating', 'terminated']
+
+# FIXME(diamond): make sure all defaults are sane
+default_params = {
+    'agent_pid': None,
+    'cache': None,
+    'cookie': None,
+    'depth': 24,
+    'display': 1,
+    'full_id': None,
+    'fullscreen': None,
+    'hostname': socket.getfqdn(),
+    'id': None,
+    'name': &quot;No name given&quot;,
+    'options': None,
+    #FIXME(diamond): Not ipv6 compatible:
+    'proxyip': socket.gethostbyname(socket.getfqdn()),
+    'resolution': None,
+    'ssl': '1',
+    'state': state_names[0],
+    'subscription': 'GPL',
+    'type': None,
+    'updated': None,
+    'user': None}
+
+
+def gen_uniq_id():
+  &quot;&quot;&quot;Generate a unique 32-character ID
+
+  This uses uses md5 to create a hash of the hostname, the time, and the 
+  process ID.
+
+  Return:
+    The generated ID
+  &quot;&quot;&quot;
+
+  #FIXME(diamond): time.time() can return the same time multiple times if
+  #called quickly enough, so we need to maybe keep a counter, add it
+  return md5.md5(socket.getfqdn() + str(time.time()) +
+      str(os.getpid())).hexdigest().upper()
+
+
+class nxsession:
+  &quot;&quot;&quot;nxsession database
+
+  This class handles parsing session parameters, and saving them into the
+  session database&quot;&quot;&quot;
+
+  def __init__(self, parameters):
+    &quot;&quot;&quot;nxsession constructor
+
+    Args:
+      parameters: A list of key=value strings
+    &quot;&quot;&quot;
+
+    self.__set_vars(parameters)
+
+  def __set_vars(self, parameters):
+    &quot;&quot;&quot;Set instances parameters from key=value string list
+
+    Args:
+      parameters: A list of key=value strings
+    &quot;&quot;&quot;
+    self.params = copy.deepcopy(default_params)
+
+    # Read values from supplied set
+    for pair in parameters.split('\n'):
+      if not pair: continue
+      name,val = pair.split('=', 1)
+      if name not in default_params:
+        nxlog.log(nxlog.LOG_ERR, &quot;Invalid session parameter passed in: %s&quot; % pair)
+      else:
+        self.params[name] = val
+
+    if not self.params['id']:
+      self.params['id'] = gen_uniq_id()
+    # Always generate full_id
+    self.params['full_id'] = &quot;%(hostname)s-%(display)s-%(id)s&quot; % self.params
+    if not self.params['cookie']:
+      self.params['cookie'] = gen_uniq_id()
+    if not self.params['user']:
+      self.params['user'] = pwd.getpwuid(os.getuid())[0]
+    if not self.params['cache']:
+      type = self.params['type']
+      if type.startswith('unix-'):
+        type = type.split('-', 1)[0]
+      self.params['cache'] = &quot;cache-%s&quot; % type
+
+  def set_state(self, name):
+    &quot;&quot;&quot;Set the state of the session
+
+    Does some sanity checking to make sure the new state is valid
+
+    Args:
+      name: Name of the state to set the session to.
+    Returns:
+      None
+    &quot;&quot;&quot;
+
+    if name not in state_names:
+      nxlog.log(nxlog.LOG_ERR, &quot;Invalid state name passed in: %r&quot; % name)
+      # FIXME(diamond): handle error better
+    else:
+      self.params['state'] = name
+
+  def save(self):
+    &quot;&quot;&quot;Save the session to the database
+
+    Sets the 'updated' parameter while saving
+    &quot;&quot;&quot;
+
+    sess_path = os.path.join(DB_TOPLEVEL, self.params['full_id'])
+    sess_save_path = sess_path + '.saving'
+    self.params['updated'] = int(time.time())
+    f = open(sess_save_path, 'w')
+    for name,val in self.params.iteritems():
+      f.write('%s=%s\n' % (name, val))
+    f.close()
+    os.rename(sess_save_path, sess_path)
+
+  def reload(self):
+    self.__set_vars(_db_read_session(self.params['full_id']))
+
+  def get_params(self):
+    &quot;&quot;&quot;Return an iterator over (key, value) the session parameters&quot;&quot;&quot;
+
+    return self.params.iteritems()
+
+
+def db_list():
+  &quot;&quot;&quot;List all sessions in the database&quot;&quot;&quot;
+
+  return os.listdir(DB_TOPLEVEL)
+
+def db_find_sessions(id=None, users=None, states=None, types=None):
+  &quot;&quot;&quot;Find sessions that match the specified parameters
+
+  Args:
+    id: 32-character unique session id
+    users: List of session owners
+    states: List of session states; 'running', 'suspended', etc
+
+  Returns:
+    A list of nxsession instances for any matching sessions in the database.
+    If none are found, the list is empty.
+  &quot;&quot;&quot;
+
+  found = []
+  file_glob = &quot;*&quot;
+  if id:
+    file_glob += id
+
+  for sess_full_id in map(os.path.basename,
+      glob.glob(os.path.join(DB_TOPLEVEL, file_glob))):
+    sess = db_get_session(sess_full_id)
+    if users and sess.params['user'] not in users:
+        continue
+    if states and sess.params['state'] not in states:
+        continue
+    if types and sess.params['type'] not in types:
+        continue
+    found.append(sess)
+
+  return found
+
+def _db_read_session(full_id):
+  &quot;&quot;&quot;Read in specified session from the database
+
+  Args:
+    full_id: The full session id (hostname-displaynum-id)
+
+  Returns:
+    A string containing the contents of the session's entry in the database.
+  &quot;&quot;&quot;
+
+  contents = open(os.path.join(DB_TOPLEVEL, full_id), 'r').read()
+  return contents
+
+
+def db_get_session(full_id):
+  &quot;&quot;&quot;Retrieve the specified session from the database
+
+  Args:
+    full_id: The full session id (hostname-displaynum-id)
+
+  Returns:
+    An instance of nxsession
+  &quot;&quot;&quot;
+
+  return nxsession(_db_read_session(full_id))


Property changes on: trunk/freenx-redesign/server/lib/nxsession.py
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/lib/nxsession_test.py
===================================================================
--- trunk/freenx-redesign/server/lib/nxsession_test.py	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/lib/nxsession_test.py	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,224 @@
+#!/usr/bin/python2.4 -E
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">alriddoch at google.com</A> (Alistair Riddoch)
+
+&quot;&quot;&quot;nxsession module unit tests
+
+  GenUniqIdTest: Test gen_uniq_id().
+  NXSessionUnitTest: Test nxsession.
+&quot;&quot;&quot;
+
+import time
+import unittest
+
+import nxsession
+
+__author__ = '<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">alriddoch at google.com</A> (Alistair Riddoch)'
+__version__ = '$Revision: #4 $'
+__copyright__ = 'Copyright 2008 Google Inc. All rights reserved.'
+
+
+class GlobalsTest(unittest.TestCase):
+  &quot;&quot;&quot;Unit test for global variables in nxsession&quot;&quot;&quot;
+
+  def testStateNames(self):
+    &quot;&quot;&quot;Test state names is not empty&quot;&quot;&quot;
+
+    self.failUnless(nxsession.state_names)
+
+  def testDefaultParams(self):
+    &quot;&quot;&quot;Test that default params is not empty&quot;&quot;&quot;
+
+    # In later tests we use the contents without bounds checking
+    # This is a canary to making those tests easier to debug if
+    # something changes.
+    self.failUnless(nxsession.default_params)
+
+
+class GenUniqIdTest(unittest.TestCase):
+  &quot;&quot;&quot;Unit test for nxsession.gen_uniq_id&quot;&quot;&quot;
+
+  def testGetUniqId(self):
+    &quot;&quot;&quot;Test case for nxsession.gen_uniq_id function&quot;&quot;&quot;
+
+    self.failUnless(nxsession.gen_uniq_id())
+
+  def testGetUniqIdUniq(self):
+    &quot;&quot;&quot;Test case for nxsession.gen_uniq_id to ensure ID is unique&quot;&quot;&quot;
+
+    first = nxsession.gen_uniq_id()
+
+    time.sleep(1)
+
+    second = nxsession.gen_uniq_id()
+
+    self.assertNotEqual(first, second)
+
+
+class NXSessionUnitTest(unittest.TestCase):
+  &quot;&quot;&quot;Unit test for nxsession.nxsession&quot;&quot;&quot;
+
+  def setUp(self): pass
+
+  def tearDown(self): pass
+
+  def testConstructor(self):
+    &quot;&quot;&quot;Test calling the nxsession constructor&quot;&quot;&quot;
+
+    nxsession.nxsession('')
+
+  def testConstructorBadParams(self):
+    &quot;&quot;&quot;Test calling the nxsession constructor with params containing no =&quot;&quot;&quot;
+
+    self.assertRaises(ValueError, nxsession.nxsession, 'foo')
+
+  def testConstructorUnknownParams(self):
+    &quot;&quot;&quot;Test calling the nxsession constructor with param not in defaults&quot;&quot;&quot;
+
+    nxsession.nxsession('foo=bar')
+
+  def testConstructorGoodParam(self):
+    &quot;&quot;&quot;Test calling the nxsession constructor with param which is ok&quot;&quot;&quot;
+
+    key = nxsession.default_params.keys()[0]
+
+    nxsession.nxsession('%s=bar' % key)
+
+  def testConstructorSetsUpId(self):
+    &quot;&quot;&quot;Test an ID parameter is set up by the constructor&quot;&quot;&quot;
+
+    o = nxsession.nxsession('')
+
+    self.failUnless('id' in o.params)
+
+  def testConstructorSetsUpId(self):
+    &quot;&quot;&quot;Test a default ID parameter is set up by the constructor&quot;&quot;&quot;
+
+    o = nxsession.nxsession('')
+
+    self.failUnless('id' in o.params)
+
+  def testConstructorAcceptsId(self):
+    &quot;&quot;&quot;Test an ID parameter is accepted in those passed to constructor&quot;&quot;&quot;
+
+    id = '23'
+
+    o = nxsession.nxsession('id=%s' % id)
+
+    self.assertEquals(id, o.params['id'])
+
+  def testConstructorPopulatesFullId(self):
+    &quot;&quot;&quot;Test a full_id parameter is set up by the constructor&quot;&quot;&quot;
+
+    o = nxsession.nxsession('')
+
+    self.failUnless('full_id' in o.params)
+
+  def testConstructorPopulatesReplacesId(self):
+    &quot;&quot;&quot;Test a full_id parameter provided in vars is overriden&quot;&quot;&quot;
+
+    test_full_id = 'hostname-1-ID'
+
+    o = nxsession.nxsession('full_id=%s' % test_full_id)
+
+    self.failUnless('full_id' in o.params)
+    self.assertNotEqual(o.params['full_id'], test_full_id)
+
+  def testConstructorPopulatesCookie(self):
+    &quot;&quot;&quot;Test a cookie parameter is set up&quot;&quot;&quot;
+
+    o = nxsession.nxsession('')
+
+    self.failUnless('cookie' in o.params)
+
+  def testConstructorCookieIsUniqId(self):
+
+    old_id = nxsession.gen_uniq_id()
+
+    time.sleep(1)
+
+    # Make sure the id from the generator is now different
+    self.assertNotEqual(old_id, nxsession.gen_uniq_id())
+
+    o = nxsession.nxsession('')
+
+    self.failUnless('cookie' in o.params)
+    self.assertNotEqual(old_id, o.params['cookie'])
+
+  def testConstructorAcceptsCookie(self):
+    &quot;&quot;&quot;Test a cookie paramete is read from vars&quot;&quot;&quot;
+
+    cookie = nxsession.gen_uniq_id()
+
+    time.sleep(1)
+
+    # Make sure the id from the generator is now different
+    self.assertNotEqual(cookie, nxsession.gen_uniq_id())
+
+    o = nxsession.nxsession('cookie=%s' % cookie)
+
+    self.failUnless('cookie' in o.params)
+    self.assertEqual(cookie, o.params['cookie'])
+    
+  def testConstructorSetUser(self):
+    &quot;&quot;&quot;Test a user parameter is set by constructor&quot;&quot;&quot;
+
+    o = nxsession.nxsession('')
+
+    self.failUnless('user' in o.params)
+
+  def testConstructorAcceptsUser(self):
+    &quot;&quot;&quot;Test a user paramater specified in vars is not replaced&quot;&quot;&quot;
+
+    username = 'dummy_user'
+
+    o = nxsession.nxsession('user=%s' % username)
+
+    self.failUnless('user' in o.params)
+    self.assertEquals(username, o.params['user'])
+
+  def testSetState(self):
+    &quot;&quot;&quot;Test setting state on a session&quot;&quot;&quot;
+
+    o = nxsession.nxsession('')
+
+    o.set_state(nxsession.state_names[0])
+
+  def testSetStateAllStates(self):
+
+    o = nxsession.nxsession('')
+
+    for state in nxsession.state_names:
+
+      o.set_state(state)
+
+      self.assertEquals(o.params['state'], state)
+
+  def testSetInvalidState(self):
+
+    o = nxsession.nxsession('')
+
+    state = 'invalud_state_name'
+
+    o.set_state(state)
+
+    self.assertNotEquals(o.params['state'], state)
+
+if __name__ == '__main__':
+  unittest.main()


Property changes on: trunk/freenx-redesign/server/lib/nxsession_test.py
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/test/README.TXT
===================================================================
--- trunk/freenx-redesign/server/test/README.TXT	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/README.TXT	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,7 @@
+include/        - Directory containing utility scripts/functions to be included in tests
+run-test-suite  - Run all tests
+testClient2server-regression-XXX - Run client2server regression tests for protocol version XXX
+testTest-functions - Unit tests for utility functions
+
+Requires:
+- local user with username 'nxtest' and password 'haha.yes.'

Added: trunk/freenx-redesign/server/test/client2server-regression.run
===================================================================
--- trunk/freenx-redesign/server/test/client2server-regression.run	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/client2server-regression.run	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,199 @@
+#!/bin/sh
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">diamond at google.com</A> (Stephen Shirley)
+
+. &quot;./include/test-functions.inc&quot; &amp;&amp; setupTestDirs
+
+NXSERVER=/usr/NX/bin/nxserver
+NXUSER=nx
+
+runNxServer()
+{
+  LD_LIBRARY_PATH=/usr/NX/lib /usr/NX/bin/nxssh -nx -i /usr/NX/share/keys/server.id_dsa.key &quot;$NXUSER&quot;@&quot;$HOSTNAME&quot;
+}
+
+doPrelim()
+{
+  recvCheckRegx &quot;Nxssh running line&quot; \
+    '^NX&gt; 203 NXSSH running with pid: [[:digit:]]+$'
+
+  recvCheck &quot;Nxssh connected line wrong&quot; \
+    &quot;NX&gt; 200 Connected to address: $(hostname -i) on port: 22&quot;
+
+  recvCheck &quot;Nxssh auth line wrong&quot; \
+   &quot;NX&gt; 202 Authenticating user: $NXUSER&quot;
+
+  recvCheck &quot;Nxssh using auth method line wrong&quot; \
+    &quot;NX&gt; 208 Using auth method: publickey&quot;
+
+  recvCheckRegx 'Banner' \
+    '^HELLO NXSERVER - Version [^[:blank:]]+ .*$'
+
+  NXCLIENTHELLO=&quot;hello nxclient - version $NXCLIENTVER&quot;
+  sendRecvCheck &quot;$NXCLIENTHELLO&quot; &quot;Client hello came back wrong&quot; \
+    &quot;NX&gt; 105 $NXCLIENTHELLO&quot;
+
+  recvCheck &quot;Client hello reply wrong&quot; &quot;NX&gt; 134 Accepted protocol: $NXCLIENTVER&quot;
+
+  sendRecvCheck &quot;set shell_mode shell&quot; &quot;Shell mode came back wrong&quot; &quot;NX&gt; 105 set shell_mode: shell&quot;
+
+  sendRecvCheck &quot;set auth_mode password&quot; &quot;Auth mode came back wrong&quot; &quot;NX&gt; 105 set auth_mode: password&quot;
+
+  NXLOGIN=&quot;login&quot;
+  sendRecvCheck &quot;$NXLOGIN&quot; &quot;Login came back wrong&quot; &quot;NX&gt; 105 $NXLOGIN &quot;
+}
+
+setupLoginCorrectUsernameWrongPassword() {
+  NXUSERNAME=&quot;nxtest&quot;
+  NXPASSWORD=&quot;haha.no.&quot;
+  NXPASSWORDREPLY=&quot;NX&gt; 404 ERROR: WRONG PASSWORD OR LOGIN.&quot;
+}
+
+setupLoginCorrectUsernameCorrectPassword() {
+  NXUSERNAME=&quot;nxtest&quot;
+  NXPASSWORD=&quot;haha.yes.&quot;
+  NXPASSWORDREPLY=&quot;NX&gt; 103 WELCOME TO: $HOSTNAME USER: $NXUSERNAME&quot;
+}
+
+setupLoginWrongUsername() {
+  NXUSERNAME=&quot;nxfail&quot;
+  NXPASSWORD=&quot;haha.no.&quot;
+  NXPASSWORDREPLY=&quot;NX&gt; 404 ERROR: WRONG PASSWORD OR LOGIN.&quot;
+}
+
+doLogin()
+{
+  NXUSERNAME_RESPONSE=&quot;user: $NXUSERNAME&quot;
+  NXPASSWORD_RESPONSE=&quot;password: $(echo $NXPASSWORD | sed 's/./*/g')&quot;
+
+  sendRecvCheck &quot;$NXUSERNAME&quot; &quot;Username came back wrong&quot; &quot;NX&gt; 101 $NXUSERNAME_RESPONSE&quot;
+
+  sendRecvCheck &quot;$NXPASSWORD&quot; &quot;Password came back wrong&quot; &quot;NX&gt; 102 $NXPASSWORD_RESPONSE&quot;
+
+  recvCheck &quot;Password reply wrong&quot; &quot;$NXPASSWORDREPLY&quot;
+}
+
+doListSessions()
+{
+  NXLISTSESSION=&quot;listsession&quot;
+  if [ &quot;$@&quot; ]; then
+    NXLISTSESSION=&quot;$NXLISTSESSION $@&quot;
+  fi
+
+  sendRecvCheck &quot;$NXLISTSESSION&quot; &quot;Listsession came back wrong&quot; &quot;NX&gt; 105 $NXLISTSESSION &quot;
+
+  recvCheck &quot;Listsession reply(0) wrong&quot; &quot;NX&gt; 127 SESSION LIST OF USER '$NXUSERNAME': &quot;
+  recvCheck &quot;Listsession reply(1) wrong&quot; &quot;&quot;
+  recvCheck &quot;Listsession reply(2) wrong&quot; &quot;DISPLAY USERNAME        REMOTE IP       SESSION ID                       NODE&quot;
+  recvCheck &quot;Listsession reply(3) wrong&quot; &quot;------- --------------- --------------- -------------------------------- -----------&quot;
+}
+
+doListNoSessions()
+{
+  doListSessions
+  recvCheck &quot;Listsession reply(4) wrong&quot; &quot;&quot;
+}
+
+doStartSession()
+{
+  MOSTARGS='--link=&quot;adsl&quot; --backingstore=&quot;1&quot; --streaming=&quot;1&quot; --nodelay=&quot;1&quot; --encryption=&quot;1&quot; --cache=&quot;8M&quot; --images=&quot;32M&quot; --shmem=&quot;1&quot; --shpix=&quot;1&quot; --strict=&quot;0&quot; --composite=&quot;1&quot; --media=&quot;0&quot; --session=&quot;graphite-euw&quot; --type=&quot;unix-kde&quot; --geometry=&quot;2400x1870&quot; --client=&quot;linux&quot;'
+
+  SESSIONARGS=&quot;$MOSTARGS --keyboard=\&quot;pc105/gb\&quot;&quot;
+  sendRecvCheck &quot;startsession $SESSIONARGS&quot; &quot;Startsession came back wrong&quot; \
+    &quot;NX&gt; 105 START SESSION WITH: $MOSTARGS --keyboard=\&quot;pc105057gb\&quot; &quot;
+
+  recvCheckRegx &quot;Session reply wrong&quot; 'NX&gt; 700 SESSION ID: '&quot;$HOSTNAME&quot;'-[[:digit:]]+-[[:digit:]ABCDEF]+$'
+}
+
+doNormalSetup()
+{
+  setupLoginCorrectUsernameCorrectPassword
+  doPrelim
+  doLogin
+}
+
+setUp()
+{
+  rm -f .extern.*
+  mkfifo .extern.stdin
+  mkfifo .extern.stdout
+  runNxServer &lt; .extern.stdin &amp;&gt; .extern.stdout &amp;
+  eval &quot;exec $EXTERN_STDIN&gt;.extern.stdin&quot;
+  eval &quot;exec $EXTERN_STDOUT&lt;.extern.stdout&quot;
+}
+
+tearDown()
+{
+  eval &quot;exec $EXTERN_STDIN&gt;&amp;-&quot;
+  eval &quot;exec $EXTERN_STDOUT&lt;&amp;-&quot;
+  rm -f .extern.*
+}
+
+testPrelim()
+{
+  doPrelim
+}
+
+testLoginCorrectUsernameWrongPassword()
+{
+  setupLoginCorrectUsernameWrongPassword
+
+  doPrelim
+  doLogin
+}
+
+testLoginCorrectUsernameCorrectPassword()
+{
+  setupLoginCorrectUsernameCorrectPassword
+  doPrelim
+  doLogin
+}
+
+testLoginWrongUsername()
+{
+  setupLoginWrongUsername
+  doPrelim
+  doLogin
+}
+
+# Everything after this point probably wants to call doNormalSetup first.
+
+testBlankLine()
+{
+  doNormalSetup
+
+  sendRecvCheck &quot;&quot; &quot;Blank line came back wrong&quot; &quot;NX&gt; 105 &quot;
+}
+
+testListNoSessions()
+{
+  doNormalSetup
+
+  doListNoSessions
+}
+
+testStartSession()
+{
+  doNormalSetup
+
+  doStartSession
+}
+
+# load shunit2
+. ../utility/shunit2


Property changes on: trunk/freenx-redesign/server/test/client2server-regression.run
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/test/client2server-regression.template
===================================================================
--- trunk/freenx-redesign/server/test/client2server-regression.template	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/client2server-regression.template	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,23 @@
+#!/bin/sh
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">diamond at google.com</A> (Stephen Shirley)
+
+progname=$(basename $0)
+export NXCLIENTVER=&quot;${progname##*-}&quot;
+./&quot;client2server-regression.run&quot;


Property changes on: trunk/freenx-redesign/server/test/client2server-regression.template
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/test/include/commercial-nx-3.0-functions
===================================================================
--- trunk/freenx-redesign/server/test/include/commercial-nx-3.0-functions	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/include/commercial-nx-3.0-functions	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,2 @@
+#!/bin/sh
+

Added: trunk/freenx-redesign/server/test/include/nxserver-fuctions.inc
===================================================================
--- trunk/freenx-redesign/server/test/include/nxserver-fuctions.inc	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/include/nxserver-fuctions.inc	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1 @@
+link commercial-nx-3.0-functions
\ No newline at end of file


Property changes on: trunk/freenx-redesign/server/test/include/nxserver-fuctions.inc
___________________________________________________________________
Name: svn:special
   + *

Added: trunk/freenx-redesign/server/test/include/test-functions.inc
===================================================================
--- trunk/freenx-redesign/server/test/include/test-functions.inc	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/include/test-functions.inc	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,141 @@
+#!/bin/sh
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">diamond at google.com</A> (Stephen Shirley)
+
+EXTERN_STDIN=7
+EXTERN_STDOUT=8
+EXTERN_STDERR=9
+
+aTrue() { assertTrue &quot;$@&quot;; }
+aEquals() { assertEquals &quot;$@&quot;; }
+
+readLineX()
+{
+  lineno=&quot;$1&quot;
+  head -n &quot;$lineno&quot; | tail -1
+}
+
+toupper()
+{
+  trim &quot;$@&quot; | tr '[:lower:]' '[:upper:']
+}
+
+trim()
+{
+  echo &quot;$@&quot; | tr -d '\r\n'
+}
+
+readTrimToupper()
+{
+  local resp
+  IFS= read resp &lt;&amp;${EXTERN_READ:-$EXTERN_STDOUT}
+  resp=$(trim &quot;$resp&quot;)
+  toupper &quot;$resp&quot;
+}
+
+recvCheck()
+{
+  local comment=&quot;$1&quot;
+  local expected=&quot;$(toupper &quot;$2&quot;)&quot;
+
+  local resp=&quot;$(readTrimToupper)&quot;
+  #echo &quot;Resp: \&quot;$resp\&quot; Exp: \&quot;$expected\&quot;&quot;
+
+  aEquals &quot;$comment&quot; &quot;$expected&quot; &quot;$resp&quot;
+}
+
+recvCheckRegx()
+{
+  local comment=&quot;$1&quot;
+  local regex=&quot;$2&quot;
+
+  local resp=&quot;$(readTrimToupper)&quot;
+  #echo &quot;Resp: \&quot;$resp\&quot; Regex: \&quot;$regex\&quot;&quot;
+
+  echo &quot;$resp&quot; | egrep -ixq &quot;$regex&quot;
+  aTrue &quot;$comment didn't match \&quot;$regex\&quot; (Got \&quot;$resp\&quot;)&quot; $?
+}
+
+sendRecvCheck()
+{
+  local send=&quot;$1&quot;
+  local comment=&quot;$2&quot;
+  local expected=&quot;$3&quot;
+
+  eval &quot;echo \&quot;$send\&quot; &gt;&amp;${EXTERN_WRITE:-$EXTERN_STDIN}&quot;
+  recvCheck &quot;$comment&quot; &quot;$expected&quot;
+}
+
+sendRecvCheckRegx()
+{
+  local send=&quot;$1&quot;
+  local comment=&quot;$2&quot;
+  local regex=&quot;$3&quot;
+
+  eval &quot;echo \&quot;$send\&quot; &gt;&amp;${EXTERN_WRITE:-$EXTERN_STDIN}&quot;
+  recvCheckRegx &quot;$comment&quot; &quot;$regex&quot;
+}
+
+setupLoggingStderr()
+{
+  logger_addAppender stderr
+  appender_setType stderr FileAppender
+  appender_file_setFile stderr STDERR
+  appender_activateOptions stderr
+}
+
+setupPaths()
+{
+  TEST_DIR=&quot;$__shunit_tmpDir&quot;
+  SRC_DIR=&quot;${SRC_DIR:-$(cd .. &amp;&amp; pwd -L)}&quot;
+  PATH_ETC=&quot;${PATH_ETC:-$TEST_DIR/etc}&quot;
+  PATH_BIN=&quot;${PATH_BIN:-$TEST_DIR/bin}&quot;
+  PATH_LIB=&quot;${PATH_LIB:-$TEST_DIR/lib}&quot;
+  PATH=&quot;$PATH:$PATH_BIN&quot;
+}
+
+setupLoadConfig()
+{
+  setupPaths
+  setupTestDirs
+  cat &lt;&lt; EOF &gt; &quot;$PATH_ETC/general.conf&quot;
+LOG_LEVEL=DEBUG
+PATH_BASE=&quot;$TEST_DIR&quot;
+PATH=&quot;$PATH&quot;
+EOF
+}
+
+setupTestDirs()
+{
+  set -e
+  chmod 755 &quot;$TEST_DIR&quot;
+  rm -rf &quot;$PATH_BIN&quot;
+  mkdir -pm 755 &quot;$PATH_BIN&quot;
+  (
+    cd &quot;$PATH_BIN&quot;
+    for file in &quot;$SRC_DIR/&quot;{compatibility,utility}/*; do
+      cp &quot;$file&quot; .
+    done
+    chmod 755 *
+  )
+  cp -R &quot;$SRC_DIR/lib&quot; &quot;$TEST_DIR&quot;
+  chmod -R u=rwX,g=rX,o=X &quot;$PATH_LIB&quot;
+  mkdir -pm 755 &quot;$PATH_ETC&quot;
+  set +e
+}

Added: trunk/freenx-redesign/server/test/run-test-suite
===================================================================
--- trunk/freenx-redesign/server/test/run-test-suite	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/run-test-suite	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,28 @@
+#!/bin/sh
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">diamond at google.com</A> (Stephen Shirley)
+
+TEST_SHELL=&quot;/bin/bash&quot;
+TEST_FILES=&quot;testTest-functions testNxlog testNxserver-login testNxloadconfig testClient2server-regression-*&quot;
+
+for file in $TEST_FILES; do
+  echo &quot;============&gt; Running $file:&quot;
+  &quot;$TEST_SHELL&quot; ./&quot;$file&quot;
+  echo &quot;============&gt; Finished $file:&quot;
+done


Property changes on: trunk/freenx-redesign/server/test/run-test-suite
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/test/testClient2server-regression-1.5.0
===================================================================
--- trunk/freenx-redesign/server/test/testClient2server-regression-1.5.0	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/testClient2server-regression-1.5.0	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1 @@
+link client2server-regression.template
\ No newline at end of file


Property changes on: trunk/freenx-redesign/server/test/testClient2server-regression-1.5.0
___________________________________________________________________
Name: svn:special
   + *

Added: trunk/freenx-redesign/server/test/testClient2server-regression-2.0.0
===================================================================
--- trunk/freenx-redesign/server/test/testClient2server-regression-2.0.0	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/testClient2server-regression-2.0.0	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1 @@
+link client2server-regression.template
\ No newline at end of file


Property changes on: trunk/freenx-redesign/server/test/testClient2server-regression-2.0.0
___________________________________________________________________
Name: svn:special
   + *

Added: trunk/freenx-redesign/server/test/testClient2server-regression-2.1.0
===================================================================
--- trunk/freenx-redesign/server/test/testClient2server-regression-2.1.0	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/testClient2server-regression-2.1.0	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1 @@
+link client2server-regression.template
\ No newline at end of file


Property changes on: trunk/freenx-redesign/server/test/testClient2server-regression-2.1.0
___________________________________________________________________
Name: svn:special
   + *

Added: trunk/freenx-redesign/server/test/testClient2server-regression-3.0.0
===================================================================
--- trunk/freenx-redesign/server/test/testClient2server-regression-3.0.0	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/testClient2server-regression-3.0.0	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1 @@
+link client2server-regression.template
\ No newline at end of file


Property changes on: trunk/freenx-redesign/server/test/testClient2server-regression-3.0.0
___________________________________________________________________
Name: svn:special
   + *

Added: trunk/freenx-redesign/server/test/testNxloadconfig
===================================================================
--- trunk/freenx-redesign/server/test/testNxloadconfig	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/testNxloadconfig	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,97 @@
+#!/bin/bash
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">diamond at google.com</A> (Stephen Shirley)
+
+oneTimeSetUp() {
+  . &quot;include/test-functions.inc&quot; &amp;&amp; setupLoadConfig
+  # Uncomment for debugging unit tests:
+  #setup_extra_logging=&quot;setupLoggingStderr&quot;
+
+  cat &lt;&lt; EOF &gt; &quot;$PATH_ETC/nxlog.override&quot;
+nxlog_log() { :; }
+EOF
+
+  . &quot;$PATH_ETC/nxlog.override&quot;
+}
+
+testSource() {
+  . &quot;$PATH_BIN/nxloadconfig&quot; &amp;&amp; [ -n &quot;$PATH_BASE&quot; ]
+  assertTrue &quot;nxloadconfig fails when sourced&quot; &quot;$?&quot;
+}
+
+testDefault_if_not_set() {
+  unset CHECKVAR
+  default_if_not_set CHECKVAR &quot;val  ue1&quot;
+  assertTrue &quot;default_if_not_set incorrectly returns true when variable is not set&quot; &quot;$?&quot;
+  assertEquals &quot;default_if_not_set failed to set unset var to default value&quot; &quot;val  ue1&quot; &quot;$CHECKVAR&quot;
+
+  CHECKVAR=&quot;&quot;
+  default_if_not_set CHECKVAR value2
+  assertFalse &quot;default_if_not_set incorrectly returns true when variable is set but null&quot; &quot;$?&quot;
+  assertEquals &quot;default_if_not_set changed the value of a set variable&quot; &quot;&quot; &quot;$CHECKVAR&quot;
+
+  CHECKVAR=&quot;some  thing&quot;
+  default_if_not_set CHECKVAR value3
+  assertFalse &quot;default_if_not_set incorrectly returns true when variable is set to a non-null string&quot; &quot;$?&quot;
+  assertEquals &quot;default_if_not_set changed the value of a set variable&quot; &quot;some  thing&quot; &quot;$CHECKVAR&quot;
+
+  unset CHECKVAR
+}
+
+testCheck_dir_var() {
+  unset CHECKDIR
+  check_dir_var CHECKDIR &quot;/etc&quot;
+  assertEquals &quot;check_dir_var fails to set correct default dir when var isn't set&quot; &quot;/etc&quot; &quot;$CHECKDIR&quot;
+
+  CHECKDIR=&quot;/nonexistent dir. i hope&quot;
+  check_dir_var CHECKDIR &quot;/usr&quot;
+  assertEquals &quot;check_dir_var fails to set correct default dir when var has an invalid value&quot; &quot;/usr&quot; &quot;$CHECKDIR&quot;
+
+  CHECKDIR=&quot;/etc&quot;
+  check_dir_var CHECKDIR &quot;/usr&quot;
+  assertEquals &quot;check_dir_var incorrectly overridess valid directory value&quot; &quot;/etc&quot; &quot;$CHECKDIR&quot;
+
+  CHECKDIR=&quot;/nonexistent dir. i hope&quot;
+  ( check_dir_var CHECKDIR &quot;/also nonexistent dir. i hope&quot;; exit 0; )
+  assertFalse &quot;check_dir_var failed to detect an invalid default directory value&quot; &quot;$?&quot;
+
+  unset CHECKDIR
+}
+
+testCheck_command_var() {
+  unset CHECKCMD
+  check_command_var CHECKCMD &quot;/sbin/init&quot;
+  assertEquals &quot;check_command_var fails to set correct default path when var isn't set&quot; &quot;/sbin/init&quot; &quot;$CHECKCMD&quot;
+
+  CHECKCMD=&quot;/etc/fstab&quot;
+  check_command_var CHECKCMD &quot;/sbin/init&quot;
+  assertEquals &quot;check_command_var fails to set correct default path when var has an invalid value&quot; &quot;/sbin/init&quot; &quot;$CHECKCMD&quot;
+
+  CHECKCMD=&quot;/bin/true&quot;
+  check_command_var CHECKCMD &quot;/bin/sh&quot;
+  assertEquals &quot;check_command_var incorrectly overridess valid command value&quot; &quot;/bin/true&quot; &quot;$CHECKCMD&quot;
+
+  CHECKCMD=&quot;/nonexistent cmd. i hope&quot;
+  ( check_command_var CHECKCMD &quot;/also nonexistent cmd. i hope&quot;; exit 0; )
+  assertFalse &quot;check_command_var failed to detect an invalid default command value&quot; &quot;$?&quot;
+
+  unset CHECKCMD
+}
+
+. ../utility/shunit2


Property changes on: trunk/freenx-redesign/server/test/testNxloadconfig
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/test/testNxlog
===================================================================
--- trunk/freenx-redesign/server/test/testNxlog	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/testNxlog	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,100 @@
+#!/bin/bash
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">diamond at google.com</A> (Stephen Shirley)
+
+oneTimeSetUp()
+{
+  # This unit test may need to be run while installed.
+  . &quot;./include/test-functions.inc&quot; &amp;&amp; setupLoadConfig
+  abs_path=&quot;$(cd &quot;$PATH_BIN&quot; &amp;&amp; pwd -L)/nxlog&quot;
+  rel_path=&quot;./bin/nxlog&quot;
+  above_path=&quot;bin/nxlog&quot;
+  LOG_LEVEL=4
+}
+
+setUp()
+{
+  cd &quot;$TEST_DIR&quot;
+}
+
+sourcePrep() {
+  set -e
+}
+
+testRunAbsolute () {
+  &quot;$abs_path&quot; &quot;$LOG_LEVEL&quot; &quot;$_su_func&quot;
+  assertTrue &quot;nxlog fails to run from an absolute path&quot; &quot;$?&quot;
+}
+
+testRunRelative () {
+  &quot;$rel_path&quot; &quot;$LOG_LEVEL&quot; &quot;$_su_func&quot;
+  assertTrue &quot;nxlog fails to run from a relative path&quot; &quot;$?&quot;
+}
+
+testRunAbove () {
+  &quot;$above_path&quot; &quot;$LOG_LEVEL&quot; &quot;$_su_func&quot;
+  assertTrue &quot;nxlog fails to run from the parent dir&quot; &quot;$?&quot;
+}
+
+testSourceAbsolute () {
+  ( sourcePrep &amp;&amp; . &quot;$abs_path&quot; &amp;&amp; nxlog_log &quot;$LOG_LEVEL&quot; &quot;$_su_func&quot; )
+  assertTrue &quot;nxlog fails when sourced with an absolute path&quot; &quot;$?&quot;
+}
+
+testSourceRelative () {
+  ( sourcePrep &amp;&amp; . &quot;$rel_path&quot; &amp;&amp; nxlog_log &quot;$LOG_LEVEL&quot; &quot;$_su_func&quot; )
+  assertTrue &quot;nxlog fails when sourced with a relative path&quot; &quot;$?&quot;
+}
+
+testSetupExtraLogging () {
+  ( [ &quot;do_called&quot; =  &quot;$( sourcePrep &amp;&amp; setup_extra_logging=&quot;do_call&quot; &amp;&amp; 
+      . &quot;$rel_path&quot; &amp;&amp; nxlog_log &quot;$LOG_LEVEL&quot; &quot;$_su_func&quot; )&quot; ] )
+  assertTrue &quot;nxlog fails to honour setup_extra_logging&quot; &quot;$?&quot;
+}
+
+testNxlog_log_level_2_log4shName () {
+  FROM=&quot;EMERG&quot;
+  TO=&quot;FATAL&quot;
+  ret=&quot;$( ( sourcePrep &amp;&amp; . &quot;$rel_path&quot; &amp;&amp; _nxlog_log_level_2_log4sh &quot;$FROM&quot;; ) )&quot;
+  assertEquals &quot;_nxlog_log_level_2_log4sh fails to map $FROM to $TO&quot; &quot;$TO&quot; &quot;$ret&quot;
+}
+
+testNxlog_log_level_2_log4shNum () {
+  FROM=&quot;7&quot;
+  TO=&quot;DEBUG&quot;
+  ret=&quot;$( ( sourcePrep &amp;&amp; . &quot;$rel_path&quot; &amp;&amp; _nxlog_log_level_2_log4sh &quot;$FROM&quot;; ) )&quot;
+  assertEquals &quot;_nxlog_log_level_2_log4sh fails to map $FROM to $TO&quot; &quot;$TO&quot; &quot;$ret&quot;
+}
+
+testNxlog_log_level_2_log4shInvalidLvl () {
+  FROM=&quot;hello world&quot;
+  TO=&quot;INFO&quot;
+  ret=$( ( sourcePrep &amp;&amp; setup_extra_logging=&quot;do_call&quot; &amp;&amp; . &quot;$rel_path&quot; &amp;&amp; \
+  _nxlog_log_level_2_log4sh &quot;$FROM&quot;; ) )
+  LOGGED=$(echo &quot;$ret&quot; | head -1)
+  assertEquals &quot;_nxlog_log_level_2_log4sh didn't log error for invalid level&quot; &quot;do_called&quot; &quot;$LOGGED&quot;
+  LEVEL=$(echo &quot;$ret&quot; | tail -1)
+  assertEquals &quot;_nxlog_log_level_2_log4sh fails to map invalid level to $TO&quot; &quot;$TO&quot; &quot;$LEVEL&quot;
+}
+
+do_call () {
+  echo &quot;do_called&quot;
+}
+
+. ../utility/shunit2


Property changes on: trunk/freenx-redesign/server/test/testNxlog
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/test/testNxserver-login
===================================================================
--- trunk/freenx-redesign/server/test/testNxserver-login	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/testNxserver-login	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,211 @@
+#!/bin/bash
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">diamond at google.com</A> (Stephen Shirley)
+
+oneTimeSetUp()
+{
+  # This unit test may need to be run while installed.
+  . &quot;./include/test-functions.inc&quot; &amp;&amp; setupLoadConfig
+  echo &quot;NX_VERSION=3.0.0&quot; &gt;&gt; &quot;$PATH_ETC/general.conf&quot;
+  NX_PROMPT=&quot;NX&gt; 105 &quot;
+  NX_SERVER_BANNER_REGX='^HELLO NXSERVER - Version [^[:blank:]]+ .*$'
+  LOGIN_ERROR_REPLY=&quot;NX&gt; 404 ERROR: WRONG PASSWORD OR LOGIN.&quot;
+}
+
+setUp()
+{
+  cd &quot;$TEST_DIR&quot;
+}
+
+runPrep()
+{
+  cmd=&quot;$1&quot;
+  shift
+  rm -f .extern.*
+  mkfifo .extern.stdin
+  mkfifo .extern.stdout
+  &quot;$cmd&quot; &quot;$@&quot; &lt; .extern.stdin &amp;&gt; .extern.stdout &amp;
+  eval &quot;exec $EXTERN_STDIN&gt;.extern.stdin&quot;
+  eval &quot;exec $EXTERN_STDOUT&lt;.extern.stdout&quot;
+}
+
+runCleanup()
+{
+  eval &quot;exec $EXTERN_STDIN&gt;&amp;-&quot;
+  eval &quot;exec $EXTERN_STDOUT&lt;&amp;-&quot;
+  rm -f .extern.*
+}
+
+# Tests that check output of running nxserver script need to be in this section
+testBanner()
+{
+  runPrep nxserver-login
+  recvCheckRegx 'Banner' &quot;$NX_SERVER_BANNER_REGX&quot;
+  eval &quot;exec $EXTERN_STDIN&gt;&amp;-&quot;
+  recvCheck 'Prompt' &quot;$NX_PROMPT&quot;
+  recvCheck 'Bye' 'NX&gt; 999 Bye.'
+  runCleanup
+}
+
+# Tests that check output of running nxserver need to be BEFORE this line
+
+testSourceNxserver()
+{
+  UNITTESTING=&quot;1&quot;
+  . bin/nxserver-login
+  nxloadconfig_main
+
+  assertEquals &quot;Sourcing nxserver&quot; &quot;0&quot; &quot;$?&quot;
+}
+
+testConfig_check()
+{
+  NXSERVER_LOGIN_HOOK_LOGIN_USER=&quot;/etc/fstab&quot;
+  config_check
+  assertNull &quot;config_check doesn't nuke invalid \
+    \$NXSERVER_LOGIN_HOOK_LOGIN_USER value&quot; &quot;$NXSERVER_LOGIN_HOOK_LOGIN_USER&quot;
+
+  NXSERVER_LOGIN_HOOK_LOGIN_USER=&quot;doesn'texist&quot;
+  config_check
+  assertEquals &quot;config_check doesn't change invalid \
+    \$NXSERVER_LOGIN_AUTHENTICATION_METHOD to 'su'&quot; &quot;su&quot; \
+    &quot;$NXSERVER_LOGIN_AUTHENTICATION_METHOD&quot;
+}
+
+mainTestSetup()
+{
+  runPrep nxserver-login_main
+  recvCheckRegx 'Banner' &quot;$NX_SERVER_BANNER_REGX&quot;
+}
+
+mainTestTearDown()
+{
+  runCleanup
+}
+
+testNxserverlogin_main()
+{
+  mainTestSetup
+  eval &quot;exec $EXTERN_STDIN&gt;&amp;-&quot;
+  recvCheck 'Immediate-quit prompt' &quot;$NX_PROMPT&quot;
+  recvCheck 'Immediate-quit bye' 'NX&gt; 999 Bye.'
+
+  for i in quit exit bye; do
+    mainTestSetup
+    sendRecvCheck &quot;$i&quot; &quot;$i came back wrong&quot; &quot;${NX_PROMPT}$i&quot;
+    recvCheck &quot;$i bye&quot; 'NX&gt; 999 Bye.'
+    mainTestTearDown
+  done
+}
+
+testConfigCommands()
+{
+  local VER TYPE
+
+  mainTestSetup
+    VER=&quot;testing testing&quot;
+    SEND=&quot;hello nxclient - version $VER&quot;
+    sendRecvCheck &quot;$SEND&quot; &quot;Hello came back wrong&quot; &quot;${NX_PROMPT}$SEND&quot;
+    recvCheck &quot;Client hello reply wrong&quot; &quot;NX&gt; 134 Accepted protocol: $VER&quot;
+
+    TYPE=&quot;password&quot;
+    SEND=&quot;set auth_mode $TYPE&quot;
+    sendRecvCheck &quot;$SEND&quot; &quot;Valid auth mode came back wrong&quot; \
+      &quot;${NX_PROMPT}set auth_mode: $TYPE&quot;
+    TYPE=&quot;somethingelse&quot;
+    SEND=&quot;set auth_mode $TYPE&quot;
+    sendRecvCheck &quot;$SEND&quot; &quot;Invalid auth mode came back wrong&quot; \
+      &quot;${NX_PROMPT}set auth_mode: $TYPE&quot;
+    recvCheck &quot;Invalid auth mode accepted&quot; &quot;NX&gt; 500 ERROR: unknown auth mode ''&quot;
+  mainTestTearDown
+}
+
+testLoginWrongUsername()
+{
+  local DESC NXUSERNAME NXPASSWORD
+
+  mainTestSetup
+    sendRecvCheck &quot;login&quot; &quot;Login came back wrong&quot; &quot;${NX_PROMPT}login&quot;
+    DESC=&quot;Wrong username&quot;
+    NXUSERNAME=&quot;nxfail&quot;
+    NXPASSWORD=&quot;haha.no.&quot;
+    sendRecvCheck &quot;$NXUSERNAME&quot; &quot;$DESC - username came back wrong&quot; \
+      &quot;NX&gt; 101 user: $NXUSERNAME&quot;
+    sendRecvCheckRegx &quot;$NXPASSWORD&quot; &quot;$DESC - password came back wrong&quot; \
+      '^NX&gt; 102 password: \**$'
+    recvCheck &quot;$DESC - login succeded when it shouldn't&quot; &quot;$LOGIN_ERROR_REPLY&quot;
+    recvCheck &quot;$DESC bye&quot; 'NX&gt; 999 Bye.'
+  mainTestTearDown
+}
+
+testLoginRightUsernameWrongPassword()
+{
+  local DESC NXUSERNAME NXPASSWORD
+
+  mainTestSetup
+    sendRecvCheck &quot;login&quot; &quot;Login came back wrong&quot; &quot;${NX_PROMPT}login&quot;
+    DESC=&quot;Correct username, wrong password&quot;
+    NXUSERNAME=&quot;nxtest&quot;
+    NXPASSWORD=&quot;haha.no.&quot;
+    sendRecvCheck &quot;$NXUSERNAME&quot; &quot;$DESC - username came back wrong&quot; \
+      &quot;NX&gt; 101 user: $NXUSERNAME&quot;
+    sendRecvCheckRegx &quot;$NXPASSWORD&quot; &quot;$DESC - password came back wrong&quot; \
+      '^NX&gt; 102 password: \**$'
+    recvCheck &quot;$DESC - login succeded when it shouldn't&quot; &quot;$LOGIN_ERROR_REPLY&quot;
+    recvCheck &quot;$DESC bye&quot; 'NX&gt; 999 Bye.'
+  mainTestTearDown
+}
+
+testLoginRightUsernameRightPassword()
+{
+  local DESC NXUSERNAME NXPASSWORD
+
+  mainTestSetup
+    sendRecvCheck &quot;login&quot; &quot;Login came back wrong&quot; &quot;${NX_PROMPT}login&quot;
+    DESC=&quot;Correct username, correct password&quot;
+    NXUSERNAME=&quot;nxtest&quot;
+    NXPASSWORD=&quot;haha.yes.&quot;
+    sendRecvCheck &quot;$NXUSERNAME&quot; &quot;$DESC - username came back wrong&quot; \
+      &quot;NX&gt; 101 user: $NXUSERNAME&quot;
+    sendRecvCheckRegx &quot;$NXPASSWORD&quot; &quot;$DESC - password came back wrong&quot; \
+      &quot;NX&gt; 102 password: \**&quot;
+    recvCheck &quot;$DESC - missing mysterious blank line&quot; &quot; &quot; #FIXME - dunno where this comes from
+    recvCheck &quot;$DESC - login failed when it shouldn't&quot; \
+      &quot;NX&gt; 103 WELCOME TO: $HOSTNAME USER: $NXUSERNAME&quot;
+
+  mainTestTearDown
+}
+
+testTimeout() {
+  local before after delay
+  READ_X_TIMEOUT=4
+  before=$(date +%s)
+  mainTestSetup
+
+    recvCheck 'Immediate-quit prompt' &quot;$NX_PROMPT&quot;
+    recvCheck 'Immediate-quit bye' 'NX&gt; 999 Bye.'
+    after=$(date +%s)
+    delay=$((after - before))
+    assertTrue 'Immediate-quit timeout' '[ $delay -ge $READ_X_TIMEOUT ]'
+
+  mainTestTearDown
+  unset READ_X_TIMEOUT
+}
+
+. ../utility/shunit2


Property changes on: trunk/freenx-redesign/server/test/testNxserver-login
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/test/testTest-functions
===================================================================
--- trunk/freenx-redesign/server/test/testTest-functions	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/testTest-functions	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,157 @@
+#!/bin/sh
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">diamond at google.com</A> (Stephen Shirley)
+
+. &quot;./include/test-functions.inc&quot;
+
+aEquals() { [ &quot;$2&quot; = &quot;$3&quot; ]; }
+aTrue() { return &quot;$2&quot;; }
+
+testReadLineX()
+{
+  input=&quot;line1\nline2\nline3\nline4&quot;
+  ret=$(printf &quot;$input&quot; | readLineX 1)
+  assertEquals &quot;Correct line(1) was not returned&quot; &quot;line1&quot; &quot;$ret&quot;
+  ret=$(printf &quot;$input&quot; | readLineX 4)
+  assertEquals &quot;Correct line(4) was not returned&quot; &quot;line4&quot; &quot;$ret&quot;
+}
+
+testToUpper()
+{
+  input=&quot;AAbbVVVcccDDD4223'1#24Azz&quot;
+  expected_output=&quot;AABBVVVCCCDDD4223'1#24AZZ&quot;
+  assertEquals &quot;toUpper output isn't correct&quot; &quot;$(toupper &quot;$input&quot;)&quot; &quot;$expected_output&quot;
+}
+
+testTrim()
+{
+  input=$(printf &quot;hello world\r\n&quot;)
+  expected_output=&quot;hello world&quot;
+  assertEquals &quot;Trim didn't trim correctly&quot; &quot;$(trim &quot;$input&quot;)&quot; &quot;$expected_output&quot;
+}
+
+testReadTrimToupper()
+{
+  EXPECT=&quot;helloworld&quot;
+  assertEquals &quot;readTrimToupper fails basic check&quot; \
+  &quot;$(toupper &quot;$EXPECT&quot;)&quot; &quot;$(eval &quot;readTrimToupper $EXTERN_STDOUT&lt;&lt; EOT
+$EXPECT
+EOT
+  &quot;)&quot;
+
+  EXPECT=&quot;helloworld &quot;
+  assertEquals &quot;readTrimToupper doesn't respect trailing whitespace&quot; \
+  &quot;$(toupper &quot;$EXPECT&quot;)&quot; &quot;$(eval &quot;readTrimToupper $EXTERN_STDOUT&lt;&lt; EOT
+$EXPECT
+EOT
+  &quot;)&quot;
+
+  EXPECT=&quot;hello world&quot;
+  assertEquals &quot;readTrimToupper doesn't respect inline whitespace&quot; \
+  &quot;$(toupper &quot;$EXPECT&quot;)&quot; &quot;$(eval &quot;readTrimToupper $EXTERN_STDOUT&lt;&lt; EOT
+$EXPECT
+EOT
+  &quot;)&quot;
+
+  EXPECT=&quot; hello  world   &quot;
+  assertEquals &quot;readTrimToupper doesn't respect whitespace everywhere&quot; \
+  &quot;$(toupper &quot;$EXPECT&quot;)&quot; &quot;$(eval &quot;readTrimToupper $EXTERN_STDOUT&lt;&lt; EOT
+$EXPECT
+EOT
+  &quot;)&quot;
+}
+
+testRecvCheck()
+{
+  EXPECT=&quot;helloworld&quot;
+  eval &quot;recvCheck '' \&quot;$EXPECT\&quot; $EXTERN_STDOUT&lt;&lt; EOT
+$EXPECT
+EOT&quot;
+  assertTrue &quot;recvCheck fails to match when it should&quot; $?
+
+  EXPECT=&quot;helloworld&quot;
+  eval &quot;recvCheck '' \&quot;$EXPECT\&quot; $EXTERN_STDOUT&lt;&lt; EOT
+$EXPECT bogus
+EOT&quot;
+  assertFalse &quot;recvCheck matches when it shouldn't&quot; $?
+}
+
+testRecvCheckRegx()
+{
+  EXPECT=&quot;helloworld&quot;
+  eval &quot;recvCheckRegx '' 'hell.{3}[ra]ld' $EXTERN_STDOUT&lt;&lt; EOT
+$EXPECT
+EOT&quot;
+  assertTrue &quot;recvCheckRegx fails to match when it should&quot; $?
+
+  EXPECT=&quot;helloworld&quot;
+  eval &quot;recvCheckRegx '' 'hell.{3}[wa]ld' $EXTERN_STDOUT&lt;&lt; EOT
+$EXPECT
+EOT&quot;
+  assertFalse &quot;recvCheckRegx matches when it shouldn't&quot; $?
+}
+
+testSendRecvCheck()
+{
+  sendRecvSetup
+
+  EXPECT=&quot;hello world&quot;
+  sendRecvCheck &quot;$EXPECT&quot; &quot;&quot; &quot;$EXPECT&quot;
+  assertTrue &quot;sendRecvCheck doesn't match when it should&quot; $?
+
+  sendRecvCheck &quot;$EXPECT&quot; &quot;&quot; &quot;$EXPECT bogus&quot;
+  assertFalse &quot;sendRecvCheck matches when it shouldn't&quot; $?
+
+  sendRecvTearDown
+}
+
+testSendRecvCheckRegx()
+{
+  sendRecvSetup
+
+  EXPECT='hell.{3}[ra]ld'
+  sendRecvCheckRegx &quot;helloworld&quot; &quot;&quot; &quot;$EXPECT&quot;
+  assertTrue &quot;sendRecvCheckRegx doesn't match when it should&quot; $?
+
+  EXPECT='hell.{3}[wa]ld'
+  sendRecvCheckRegx &quot;helloworld&quot; &quot;&quot; &quot;$EXPECT&quot;
+  assertFalse &quot;sendRecvCheckRegx matches when it shouldn't&quot; $?
+
+  sendRecvTearDown
+}
+
+sendRecvSetup()
+{
+  EXTERN_TEST=4
+  rm -rf .extern.*
+  mkfifo .extern.test
+  eval &quot;exec $EXTERN_TEST&lt;&gt;.extern.test&quot;
+  EXTERN_WRITE=$EXTERN_TEST
+  EXTERN_READ=$EXTERN_TEST
+}
+
+sendRecvTearDown()
+{
+  eval &quot;exec $EXTERN_TEST&lt;&amp;-&quot;
+  rm -rf .extern.*
+  unset EXTERN_WRITE
+  unset EXTERN_READ
+}
+
+. ../utility/shunit2


Property changes on: trunk/freenx-redesign/server/test/testTest-functions
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/utility/log4sh
===================================================================
--- trunk/freenx-redesign/server/utility/log4sh	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/utility/log4sh	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,3840 @@
+# $Id: log4sh 574 2007-06-02 20:09:15Z sfsetse $
+# vim:syntax=sh:sts=2
+# vim:foldmethod=marker:foldmarker=/**,*/
+#
+#/**
+# &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+# &lt;s:shelldoc xmlns:s=&quot;<A HREF="http://www.forestent.com/2005/XSL/ShellDoc">http://www.forestent.com/2005/XSL/ShellDoc</A>&quot;&gt;
+# &lt;s:header&gt;
+# log4sh 1.4.2
+#
+# <A HREF="http://log4sh.sourceforge.net/">http://log4sh.sourceforge.net/</A>
+#
+# written by Kate Ward &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">kate.ward at forestent.com</A>&gt;
+# released under the LGPL
+#
+# this module implements something like the log4j module from the Apache group
+#
+# notes:
+# *) the default appender is a ConsoleAppender named stdout with a level
+#    of ERROR and layout of SimpleLayout
+# *) the appender levels are as follows (decreasing order of output):
+#    TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF
+# &lt;/s:header&gt;
+#*/
+
+# shell flags for log4sh:
+# u - treat unset variables as an error when performing parameter expansion
+__LOG4SH_SHELL_FLAGS='u'
+
+# save the current set of shell flags, and then set some for log4sh
+__log4sh_oldShellFlags=$-
+for _log4sh_shellFlag in `echo &quot;${__LOG4SH_SHELL_FLAGS}&quot; |sed 's/\(.\)/\1 /g'`
+do
+  set -${_log4sh_shellFlag}
+done
+
+#
+# constants
+#
+__LOG4SH_VERSION='1.4.2'
+
+__LOG4SH_TRUE=0
+__LOG4SH_FALSE=1
+__LOG4SH_ERROR=2
+__LOG4SH_NULL='~'
+
+__LOG4SH_APPENDER_FUNC_PREFIX='_log4sh_app_'
+__LOG4SH_APPENDER_INCLUDE_EXT='.inc'
+
+__LOG4SH_TYPE_CONSOLE='ConsoleAppender'
+__LOG4SH_TYPE_DAILY_ROLLING_FILE='DailyRollingFileAppender'
+__LOG4SH_TYPE_FILE='FileAppender'
+__LOG4SH_TYPE_ROLLING_FILE='RollingFileAppender'
+__LOG4SH_TYPE_ROLLING_FILE_MAX_BACKUP_INDEX=1
+__LOG4SH_TYPE_ROLLING_FILE_MAX_FILE_SIZE=10485760
+__LOG4SH_TYPE_SMTP='SMTPAppender'
+__LOG4SH_TYPE_SYSLOG='SyslogAppender'
+__LOG4SH_TYPE_SYSLOG_FACILITY_NAMES=' kern user mail daemon auth security syslog lpr news uucp cron authpriv ftp local0 local1 local2 local3 local4 local5 local6 local7 '
+__LOG4SH_TYPE_SYSLOG_FACILITY='user'
+
+__LOG4SH_LAYOUT_HTML='HTMLLayout'
+__LOG4SH_LAYOUT_SIMPLE='SimpleLayout'
+__LOG4SH_LAYOUT_PATTERN='PatternLayout'
+
+__LOG4SH_LEVEL_TRACE=0
+__LOG4SH_LEVEL_TRACE_STR='TRACE'
+__LOG4SH_LEVEL_DEBUG=1
+__LOG4SH_LEVEL_DEBUG_STR='DEBUG'
+__LOG4SH_LEVEL_INFO=2
+__LOG4SH_LEVEL_INFO_STR='INFO'
+__LOG4SH_LEVEL_WARN=3
+__LOG4SH_LEVEL_WARN_STR='WARN'
+__LOG4SH_LEVEL_ERROR=4
+__LOG4SH_LEVEL_ERROR_STR='ERROR'
+__LOG4SH_LEVEL_FATAL=5
+__LOG4SH_LEVEL_FATAL_STR='FATAL'
+__LOG4SH_LEVEL_OFF=6
+__LOG4SH_LEVEL_OFF_STR='OFF'
+__LOG4SH_LEVEL_CLOSED=255
+__LOG4SH_LEVEL_CLOSED_STR='CLOSED'
+
+__LOG4SH_PATTERN_DEFAULT='%d %p - %m%n'
+__LOG4SH_THREAD_DEFAULT='main'
+
+__LOG4SH_CONFIGURATION=&quot;${LOG4SH_CONFIGURATION:-log4sh.properties}&quot;
+__LOG4SH_CONFIG_PREFIX=&quot;${LOG4SH_CONFIG_PREFIX:-log4sh}&quot;
+__LOG4SH_CONFIG_LOG4J_CP='org.apache.log4j'
+
+# the following IFS is *supposed* to be on two lines!!
+__LOG4SH_IFS_ARRAY=&quot;
+&quot;
+__LOG4SH_IFS_DEFAULT=' '
+
+__LOG4SH_SECONDS=`eval &quot;expr \`date '+%H \* 3600 + %M \* 60 + %S'\`&quot;`
+
+# configure log4sh debugging. set the LOG4SH_INFO environment variable to any
+# non-empty value to enable info output, LOG4SH_DEBUG enable debug output, or
+# LOG4SH_TRACE to enable trace output. log4sh ERROR and above messages are
+# always printed. to send the debug output to a file, set the LOG4SH_DEBUG_FILE
+# with the filename you want debug output to be written to.
+__LOG4SH_TRACE=${LOG4SH_TRACE:+'_log4sh_trace '}
+__LOG4SH_TRACE=${__LOG4SH_TRACE:-':'}
+[ -n &quot;${LOG4SH_TRACE:-}&quot; ] &amp;&amp; LOG4SH_DEBUG=1
+__LOG4SH_DEBUG=${LOG4SH_DEBUG:+'_log4sh_debug '}
+__LOG4SH_DEBUG=${__LOG4SH_DEBUG:-':'}
+[ -n &quot;${LOG4SH_DEBUG:-}&quot; ] &amp;&amp; LOG4SH_INFO=1
+__LOG4SH_INFO=${LOG4SH_INFO:+'_log4sh_info '}
+__LOG4SH_INFO=${__LOG4SH_INFO:-':'}
+
+# set the constants to readonly
+for _log4sh_const in `set |grep &quot;^__LOG4SH_&quot; |cut -d= -f1`; do
+  readonly ${_log4sh_const}
+done
+unset _log4sh_const
+
+#
+# internal variables
+#
+
+__log4sh_filename=`basename $0`
+__log4sh_tmpDir=''
+__log4sh_trapsFile=''
+
+__log4sh_alternative_mail='mail'
+
+__log4sh_threadName=${__LOG4SH_THREAD_DEFAULT}
+__log4sh_threadStack=${__LOG4SH_THREAD_DEFAULT}
+
+__log4sh_seconds=0
+__log4sh_secondsLast=0
+__log4sh_secondsWrap=0
+
+# workarounds for various commands
+__log4sh_wa_strictBehavior=${__LOG4SH_FALSE}
+(
+  # determine if the set builtin needs to be evaluated. if the string is parsed
+  # into two separate strings (common in ksh), then set needs to be evaled.
+  str='x{1,2}'
+  set -- ${str}
+  test ! &quot;$1&quot; = 'x1' -a ! &quot;${2:-}&quot; = 'x2'
+)
+__log4sh_wa_setNeedsEval=$?
+
+
+#=============================================================================
+# Log4sh
+#
+
+#-----------------------------------------------------------------------------
+# internal debugging
+#
+
+#/**
+# &lt;s:function group=&quot;Log4sh&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_log4sh_log&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;level&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;
+#     This is an internal debugging function. It should not be called.
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;_log4sh_log&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_log4sh_log()
+{
+  _ll__level=$1
+  shift
+  if [ -z &quot;${LOG4SH_DEBUG_FILE:-}&quot; ]; then
+    echo &quot;log4sh:${_ll__level} $@&quot; &gt;&amp;2
+  else
+    echo &quot;${_ll__level} $@&quot; &gt;&gt;${LOG4SH_DEBUG_FILE}
+  fi
+  unset _ll__level
+}
+
+#/**
+# &lt;s:function group=&quot;Log4sh&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_log4sh_trace&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;level&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;
+#     This is an internal debugging function. It should not be called.
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;_log4sh_log&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_log4sh_trace()
+{
+  _log4sh_log &quot;${__LOG4SH_LEVEL_TRACE_STR}&quot; &quot;${BASH_LINENO:+(${BASH_LINENO}) }- $@&quot;;
+ }
+
+#/**
+# &lt;s:function group=&quot;Log4sh&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_log4sh_debug&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;level&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;
+#     This is an internal debugging function. It should not be called.
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;_log4sh_log&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_log4sh_debug()
+{
+  _log4sh_log &quot;${__LOG4SH_LEVEL_DEBUG_STR}&quot; &quot;${BASH_LINENO:+(${BASH_LINENO}) }- $@&quot;;
+}
+
+#/**
+# &lt;s:function group=&quot;Log4sh&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_log4sh_info&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;level&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;
+#     This is an internal debugging function. It should not be called.
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;_log4sh_log&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_log4sh_info()
+{
+  _log4sh_log &quot;${__LOG4SH_LEVEL_INFO_STR}&quot; &quot;${BASH_LINENO:+(${BASH_LINENO}) }- $@&quot;;
+}
+
+#/**
+# &lt;s:function group=&quot;Log4sh&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_log4sh_warn&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;level&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;
+#     This is an internal debugging function. It should not be called.
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;_log4sh_log&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_log4sh_warn()
+{
+  echo &quot;log4sh:${__LOG4SH_LEVEL_WARN_STR} $@&quot; &gt;&amp;2
+  [ -n &quot;${LOG4SH_DEBUG_FILE:-}&quot; ] \
+    &amp;&amp; _log4sh_log &quot;${__LOG4SH_LEVEL_WARN_STR}&quot; &quot;$@&quot;
+}
+
+#/**
+# &lt;s:function group=&quot;Log4sh&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_log4sh_error&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;level&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;
+#     This is an internal debugging function. It should not be called.
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;_log4sh_log&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_log4sh_error()
+{
+  echo &quot;log4sh:${__LOG4SH_LEVEL_ERROR_STR} $@&quot; &gt;&amp;2
+  [ -n &quot;${LOG4SH_DEBUG_FILE:-}&quot; ] \
+    &amp;&amp; _log4sh_log &quot;${__LOG4SH_LEVEL_ERROR_STR}&quot; &quot;$@&quot;
+}
+
+#/**
+# &lt;s:function group=&quot;Log4sh&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_log4sh_fatal&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;level&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;
+#     This is an internal debugging function. It should not be called.
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;_log4sh_log&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_log4sh_fatal()
+{
+  echo &quot;log4sh:${__LOG4SH_LEVEL_FATAL_STR} $@&quot; &gt;&amp;2
+  [ -n &quot;${LOG4SH_DEBUG_FILE:-}&quot; ] \
+    &amp;&amp; _log4sh_log &quot;${__LOG4SH_LEVEL_FATAL_STR}&quot; &quot;$@&quot;
+}
+
+#-----------------------------------------------------------------------------
+# miscellaneous
+#
+
+#/**
+# &lt;s:function group=&quot;Log4sh&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_log4sh_mktempDir&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;void /&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;
+#     Creates a secure temporary directory within which temporary files can be
+#     created. Honors the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable if it is
+#     set.
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;tmpDir=`_log4sh_mktempDir`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_log4sh_mktempDir()
+{
+  _lmd_tmpPrefix='log4sh'
+
+  # try the standard mktemp function
+  ( exec mktemp -dqt ${_lmd_tmpPrefix}.XXXXXX 2&gt;/dev/null ) &amp;&amp; return
+
+  # the standard mktemp didn't work. doing our own.
+  if [ -n &quot;${RANDOM:-}&quot; ]; then
+    # $RANDOM works
+    _lmd_random=${RANDOM}${RANDOM}${RANDOM}$$
+  elif [ -r '/dev/urandom' ]; then
+    _lmd_random=`od -vAn -N4 -tu4 &lt;/dev/urandom |sed 's/^[^0-9]*//'`
+  else
+    # $RANDOM doesn't work
+    _lmd_date=`date '+%Y%m%d%H%M%S'`
+    _lmd_random=`expr ${_lmd_date} / $$`
+    unset _lmd_date
+  fi
+
+  _lmd_tmpDir=&quot;${TMPDIR:-/tmp}/${_lmd_tmpPrefix}.${_lmd_random}&quot;
+  ( umask 077 &amp;&amp; mkdir &quot;${_lmd_tmpDir}&quot; ) || {
+    _log4sh_fatal 'could not create temporary directory! exiting'
+    exit 1
+  }
+
+  ${__LOG4SH_DEBUG} &quot;created temporary directory (${_lmd_tmpDir})&quot;
+  echo &quot;${_lmd_tmpDir}&quot;
+  unset _lmd_random _lmd_tmpDir _lmd_tmpPrefix
+}
+
+#/**
+# &lt;s:function group=&quot;Log4sh&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_log4sh_updateSeconds&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;void /&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;
+#     Set the &lt;code&gt;__log4sh_seconds&lt;/code&gt; variable to the number of seconds
+#     elapsed since the start of the script.
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;_log4sh_updateSeconds`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_log4sh_updateSeconds()
+{
+  if [ -n &quot;${SECONDS:-}&quot; ]; then
+    __log4sh_seconds=${SECONDS}
+  else
+    _lgs__date=`date '+%H \* 3600 + %M \* 60 + %S'`
+    _lgs__seconds=`eval &quot;expr ${_lgs__date} + ${__log4sh_secondsWrap} \* 86400&quot;`
+    if [ ${_lgs__seconds} -lt ${__log4sh_secondsLast} ]; then
+      __log4sh_secondsWrap=`expr ${__log4sh_secondsWrap} + 1`
+      _lgs__seconds=`expr ${_lgs_seconds} + 86400`
+    fi
+    __log4sh_seconds=`expr ${_lgs__seconds} - ${__LOG4SH_SECONDS}`
+    __log4sh_secondsLast=${__log4sh_seconds}
+    unset _lgs__date _lgs__seconds
+  fi
+}
+
+#/**
+# &lt;s:function group=&quot;Log4sh&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;/boolean
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;log4sh_enableStrictBehavior&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;void /&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;
+#     Enables strict log4j behavior.
+#   &lt;/para&gt;
+#   &lt;para&gt;&lt;emphasis role=&quot;strong&quot;&gt;Since:&lt;/emphasis&gt; 1.3.7&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;log4sh_enableStrictBehavior&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+log4sh_enableStrictBehavior()
+{
+  __log4sh_wa_strictBehavior=${__LOG4SH_TRUE}
+}
+
+#/**
+# &lt;s:function group=&quot;Log4sh&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;/boolean
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;log4sh_setAlternative&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;command&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;path&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;boolean &lt;parameter&gt;useRuntimePath&lt;/parameter&gt; (optional)&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;
+#     Specifies an alternative path for a command.
+#   &lt;/para&gt;
+#   &lt;para&gt;&lt;emphasis role=&quot;strong&quot;&gt;Since:&lt;/emphasis&gt; 1.3.7&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;log4sh_setAlternative nc /bin/nc&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+log4sh_setAlternative()
+{
+  if [ $# -lt 2 ]; then
+    _log4sh_error 'log4sh_setAlternative(): invalid number of parameters'
+    return ${__LOG4SH_FALSE}
+  fi
+
+  lsa_cmdName=$1
+  lsa_cmdPath=$2
+  lsa_useRuntimePath=${3:-}
+  __log4sh_return=${__LOG4SH_TRUE}
+
+  # check that the alternative command exists and is executable
+  if [ \
+    ! -x &quot;${lsa_cmdPath}&quot; \
+    -a ${lsa_useRuntimePath:-${__LOG4SH_FALSE}} -eq ${__LOG4SH_FALSE} \
+  ]; then
+    # the alternative command is not executable
+    _log4sh_error &quot;log4sh_setAlternative(): ${lsa_cmdName}: command not found&quot;
+    __log4sh_return=${__LOG4SH_ERROR}
+  fi
+
+  # check for valid alternative
+  if [ ${__log4sh_return} -eq ${__LOG4SH_TRUE} ]; then
+    case ${lsa_cmdName} in
+      mail) ;;
+      nc)
+        lsa_cmdVers=`${lsa_cmdPath} --version 2&gt;&amp;1 |head -1`
+        if echo &quot;${lsa_cmdVers}&quot; |grep '^netcat' &gt;/dev/null; then
+          # GNU Netcat
+          __log4sh_alternative_nc_opts='-c'
+        else
+          # older netcat (v1.10)
+          if nc -q 0 2&gt;&amp;1 |grep '^no destination$' &gt;/dev/null 2&gt;&amp;1; then
+            # supports -q option
+            __log4sh_alternative_nc_opts='-q 0'
+          else
+            # doesn't support the -q option
+            __log4sh_alternative_nc_opts=''
+          fi
+        fi
+        unset lsa_cmdVers
+        ;;
+      *)
+        # the alternative is not valid
+        _log4sh_error &quot;unrecognized command alternative '${lsa_cmdName}'&quot;
+        __log4sh_return=${__LOG4SH_FALSE}
+        ;;
+    esac
+  fi
+
+  # set the alternative
+  if [ ${__log4sh_return} -eq ${__LOG4SH_TRUE} ]; then
+    eval __log4sh_alternative_${lsa_cmdName}=&quot;\${lsa_cmdPath}&quot;
+    ${__LOG4SH_DEBUG} &quot;alternative '${lsa_cmdName}' command set to '${lsa_cmdPath}'&quot;
+  fi
+
+  unset lsa_cmdName lsa_cmdPath
+  return ${__log4sh_return}
+}
+
+#-----------------------------------------------------------------------------
+# array handling
+#
+# note: arrays are '1' based
+#
+
+#/**
+# &lt;s:function group=&quot;Log4sh&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;integer&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_log4sh_findArrayElement&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string[] &lt;parameter&gt;array&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;element&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Find the position of element in an array&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;
+#       pos=`_log4sh_findArrayElement &quot;$array&quot; $element`
+#     &lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_log4sh_findArrayElement()
+{
+  __pos=`echo &quot;$1&quot; |awk '$0==e{print NR}' e=&quot;$2&quot;`
+  [ -n &quot;${__pos}&quot; ] &amp;&amp; echo &quot;${__pos}&quot; || echo 0
+  unset __pos
+}
+
+#/**
+# &lt;s:function group=&quot;Log4sh&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_log4sh_getArrayElement&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string[] &lt;parameter&gt;array&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;integer &lt;parameter&gt;position&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Retrieve the element at the given position from an array&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;element=`_log4sh_getArrayElement &quot;$array&quot; $position`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_log4sh_getArrayElement()
+{
+  [ -n &quot;${FUNCNAME:-}&quot; ] &amp;&amp; ${__LOG4SH_TRACE} &quot;${FUNCNAME}()${BASH_LINENO:+'(called from ${BASH_LINENO})'}&quot;
+  _lgae_array=$1
+  _lgae_index=$2
+  ${__LOG4SH_TRACE} &quot;_lgae_array='${_lgae_array}' _lgae_index='${_lgae_index}'&quot;
+
+  _lgae_oldIFS=${IFS} IFS=${__LOG4SH_IFS_ARRAY}
+  if [ ${__log4sh_wa_setNeedsEval} -eq 0 ]; then
+    set -- junk ${_lgae_array}
+  else
+    eval &quot;set -- junk \&quot;${_lgae_array}\&quot;&quot;
+    _lgae_arraySize=$#
+
+    if [ ${_lgae_arraySize} -le ${__log4shAppenderCount} ]; then
+      # the evaled set *didn't* work; failing back to original set command and
+      # disabling the work around. (pdksh)
+      __log4sh_wa_setNeedsEval=${__LOG4SH_FALSE}
+      set -- junk ${_lgae_array}
+    fi
+  fi
+  IFS=${_lgae_oldIFS}
+
+  shift ${_lgae_index}
+  ${__LOG4SH_TRACE} &quot;1='${1:-}' 2='${2:-}' 3='${3:-}' ...&quot;
+  echo &quot;$1&quot;
+
+  unset _lgae_array _lgae_arraySize _lgae_index _lgae_oldIFS
+  return ${__LOG4SH_TRUE}
+}
+
+#/**
+# &lt;s:function group=&quot;Log4sh&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;integer&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry align=&quot;left&quot;&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_log4sh_getArrayLength&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string[] &lt;parameter&gt;array&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Get the length of an array&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;length=`_log4sh_getArrayLength &quot;$array&quot;`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_log4sh_getArrayLength()
+{
+  _oldIFS=${IFS} IFS=${__LOG4SH_IFS_ARRAY}
+  set -- $1
+  IFS=${_oldIFS} unset _oldIFS
+  echo $#
+}
+
+#/**
+# &lt;s:function group=&quot;Log4sh&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string[]&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_log4sh_setArrayElement&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string[] &lt;parameter&gt;array&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;integer &lt;parameter&gt;position&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;element&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Place an element at a given location in an array&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;newArray=`_log4sh_setArrayElement &quot;$array&quot; $position $element`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_log4sh_setArrayElement()
+{
+  echo &quot;$1&quot; |awk '{if(NR==r){print e}else{print $0}}' r=$2 e=&quot;$3&quot;
+}
+
+#/**
+# &lt;s:function group=&quot;Log4sh&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_log4sh_peekStack&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string[] &lt;parameter&gt;array&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Return the topmost element on a stack without removing the
+#   element.&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;element=`_log4sh_peekStack &quot;$array&quot;`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_log4sh_peekStack()
+{
+  echo &quot;$@&quot; |awk '{line=$0}END{print line}'
+}
+
+#/**
+# &lt;s:function group=&quot;Log4sh&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string[]&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_log4sh_popStack&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string[] &lt;parameter&gt;array&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Remove the top-most element from a stack. This command takes a
+#   normal log4sh string array as input, but treats it as though it were a
+#   stack.&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;newArray=`_log4sh_popStack &quot;$array&quot;`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_log4sh_popStack()
+{
+  _array=$1
+  _length=`_log4sh_getArrayLength &quot;${_array}&quot;`
+  echo &quot;${_array}&quot; |awk '{if(NR&lt;r){print $0}}' r=${_length}
+  unset _array _length
+}
+
+#/**
+# &lt;s:function group=&quot;Log4sh&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_log4sh_pushStack&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string[] &lt;parameter&gt;array&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;element&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Add a new element to the top of a stack. This command takes a normal
+#   log4sh string array as input, but treats it as though it were a
+#   stack.&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;newArray=`_log4sh_pushStack &quot;$array&quot; $element`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_log4sh_pushStack()
+{
+  echo &quot;${1:+$1${__LOG4SH_IFS_ARRAY}}$2&quot;
+}
+
+#=============================================================================
+# Appender
+#
+
+#/**
+# &lt;s:function group=&quot;Appender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_activateOptions&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;
+#     Activate an appender's configuration. This should be called after
+#     reconfiguring an appender via code. It needs only to be called once
+#     before any logging statements are called. This calling of this function
+#     will be required in log4sh 1.4.x.
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;appender_activateAppender myAppender&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_activateOptions()
+{
+  _aao_appender=$1
+  ${__LOG4SH_APPENDER_FUNC_PREFIX}${_aao_appender}_activateOptions
+  unset _aao_appender
+}
+
+#/**
+# &lt;s:function group=&quot;Appender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_close&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Disable any further logging via an appender. Once closed, the
+#   appender can be reopened by setting it to any logging Level (e.g.
+#   INFO).&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;appender_close myAppender&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_close()
+{
+  appender_setLevel $1 ${__LOG4SH_LEVEL_CLOSED_STR}
+}
+
+#/**
+# &lt;s:function group=&quot;Appender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;boolean&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_exists&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Checks for the existance of a named appender&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;exists=`appender_exists myAppender`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_exists()
+{
+  _ae_index=`_log4sh_findArrayElement &quot;${__log4shAppenders}&quot; $1`
+  [ &quot;${_ae_index}&quot; -gt 0 ] \
+    &amp;&amp; _ae_return=${__LOG4SH_TRUE} \
+    || _ae_return=${__LOG4SH_FALSE}
+  unset _ae_index
+  return ${_ae_return}
+}
+
+#/**
+# &lt;s:function group=&quot;Appender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_getLayout&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Gets the Layout of an Appender&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;type=`appender_getLayout myAppender`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_getLayout()
+{
+  _agl_index=`_log4sh_findArrayElement &quot;${__log4shAppenders}&quot; $1`
+  _log4sh_getArrayElement &quot;${__log4shAppenderLayouts}&quot; ${_agl_index}
+  unset _agl_index
+}
+
+#/**
+# &lt;s:function group=&quot;Appender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_setLayout&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;layout&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Sets the Layout of an Appender (e.g. PatternLayout)&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;appender_setLayout myAppender PatternLayout&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_setLayout()
+{
+  _asl_appender=$1
+  _asl_layout=$2
+
+  case ${_asl_layout} in
+    ${__LOG4SH_LAYOUT_HTML}|\
+    ${__LOG4SH_CONFIG_LOG4J_CP}.${__LOG4SH_LAYOUT_HTML})
+      _asl_layout=${__LOG4SH_LAYOUT_HTML}
+      ;;
+
+    ${__LOG4SH_LAYOUT_SIMPLE}|\
+    ${__LOG4SH_CONFIG_LOG4J_CP}.${__LOG4SH_LAYOUT_SIMPLE})
+      _asl_layout=${__LOG4SH_LAYOUT_SIMPLE}
+      ;;
+
+    ${__LOG4SH_LAYOUT_PATTERN}|\
+    ${__LOG4SH_CONFIG_LOG4J_CP}.${__LOG4SH_LAYOUT_PATTERN})
+      _asl_layout=${__LOG4SH_LAYOUT_PATTERN}
+      ;;
+
+    *)
+      _log4sh_error &quot;unknown layout: ${_asl_layout}&quot;
+      return ${__LOG4SH_FALSE}
+      ;;
+  esac
+
+  _asl_index=`_log4sh_findArrayElement &quot;${__log4shAppenders}&quot; $1`
+  __log4shAppenderLayouts=`_log4sh_setArrayElement \
+      &quot;${__log4shAppenderLayouts}&quot; ${_asl_index} &quot;${_asl_layout}&quot;`
+
+  # resource the appender
+  _appender_cache ${_asl_appender}
+
+  unset _asl_appender _asl_index _asl_layout
+  return ${__LOG4SH_TRUE}
+}
+
+#/**
+# &lt;s:function group=&quot;Appender&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_appender_getLayoutByIndex&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;integer &lt;parameter&gt;index&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Gets the Layout of an Appender at the given array index&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;type=`_appender_getLayoutByIndex 3`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_appender_getLayoutByIndex()
+{
+  _log4sh_getArrayElement &quot;${__log4shAppenderLayouts}&quot; $1
+}
+
+#/**
+# &lt;s:function group=&quot;Appender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;/boolean
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_getLevel&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Gets the current logging Level of an Appender&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;type=`appender_getLevel myAppender`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_getLevel()
+{
+  if [ $# -ne 1 ]; then
+    _log4sh_error 'appender_getLevel(): invalid number of parameters'
+    return ${__LOG4SH_FALSE}
+  fi
+
+  agl_appender=$1
+
+  agl_index=`_log4sh_findArrayElement &quot;${__log4shAppenders}&quot; ${agl_appender}`
+  # TODO: put check for valid index here
+  agl_level=`_log4sh_getArrayElement \
+      &quot;${__log4shAppenderLevels}&quot; ${agl_index}`
+  __log4sh_return=$?
+
+  echo &quot;${agl_level}&quot;
+
+  unset agl_appender agl_index agl_level
+  return ${__log4sh_return}
+}
+
+#/**
+# &lt;s:function group=&quot;Appender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;/&lt;code&gt;boolean&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_setLevel&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;level&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Sets the Level of an Appender (e.g. INFO)&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;appender_setLevel myAppender INFO&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_setLevel()
+{
+  asl_appender=$1
+  asl_level=$2
+
+  _index=`_log4sh_findArrayElement &quot;${__log4shAppenders}&quot; ${asl_appender}`
+  __log4shAppenderLevels=`_log4sh_setArrayElement \
+    &quot;${__log4shAppenderLevels}&quot; ${_index} &quot;${asl_level}&quot;`
+
+  # resource the appender
+  _appender_cache ${asl_appender}
+
+  unset asl_appender asl_level _index
+  return ${__LOG4SH_TRUE}
+}
+
+#/**
+# &lt;s:function group=&quot;Appender&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_appender_getLevelByIndex&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;integer &lt;parameter&gt;index&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Gets the current logging Level of an Appender at the given array
+#   index&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;type=`_appender_getLevelByIndex 3`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_appender_getLevelByIndex()
+{
+  [ -n &quot;${FUNCNAME:-}&quot; ] &amp;&amp; ${__LOG4SH_TRACE} &quot;${FUNCNAME}()${BASH_LINENO:+'(called from ${BASH_LINENO})'}&quot;
+  _log4sh_getArrayElement &quot;${__log4shAppenderLevels}&quot; $1
+}
+
+#/**
+# &lt;s:function group=&quot;Appender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_getPattern&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Gets the Pattern of an Appender&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;pattern=`appender_getPattern myAppender`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_getPattern()
+{
+  _index=`_log4sh_findArrayElement &quot;$__log4shAppenders&quot; $1`
+  _log4sh_getArrayElement &quot;$__log4shAppenderPatterns&quot; $_index
+  unset _index
+}
+
+#/**
+# &lt;s:function group=&quot;Appender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;/&lt;code&gt;boolean&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_setPattern&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;pattern&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Sets the Pattern of an Appender&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;appender_setPattern myAppender '%d %p - %m%n'&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_setPattern()
+{
+  asp_appender=$1
+  asp_pattern=$2
+
+  _index=`_log4sh_findArrayElement &quot;${__log4shAppenders}&quot; ${asp_appender}`
+  __log4shAppenderPatterns=`_log4sh_setArrayElement \
+    &quot;${__log4shAppenderPatterns}&quot; ${_index} &quot;${asp_pattern}&quot;`
+
+  # resource the appender
+  _appender_cache ${asp_appender}
+
+  unset asp_appender asp_pattern _index
+  return ${__LOG4SH_TRUE}
+}
+
+#/**
+# &lt;s:function group=&quot;Appender&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_appender_getPatternByIndex&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;integer &lt;parameter&gt;index&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Gets the Pattern of an Appender at the specified array index&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;pattern=`_appender_getPatternByIndex 3`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_appender_getPatternByIndex()
+{
+  _log4sh_getArrayElement &quot;$__log4shAppenderPatterns&quot; $1
+}
+
+#/**
+# &lt;s:function group=&quot;Appender&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_appender_parsePattern&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;pattern&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;priority&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;message&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Generate a logging message given a Pattern, priority, and message.
+#   All dates will be represented as ISO 8601 dates (YYYY-MM-DD
+#   HH:MM:SS).&lt;/para&gt;
+#   &lt;para&gt;Note: the '&lt;code&gt;%r&lt;/code&gt;' character modifier does not work in the
+#   Solaris &lt;code&gt;/bin/sh&lt;/code&gt; shell&lt;/para&gt;
+#   &lt;para&gt;Example:
+#     &lt;blockquote&gt;
+#       &lt;funcsynopsis&gt;
+#         &lt;funcsynopsisinfo&gt;_appender_parsePattern '%d %p - %m%n' INFO &quot;message to log&quot;&lt;/funcsynopsisinfo&gt;
+#       &lt;/funcsynopsis&gt;
+#     &lt;/blockquote&gt;
+#   &lt;/para&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_appender_parsePattern()
+{
+  _pattern=$1
+  _priority=$2
+  _msg=$3
+
+  _date=''
+  _doEval=${__LOG4SH_FALSE}
+
+  # determine if various commands must be run
+  _oldIFS=&quot;${IFS}&quot;; IFS='%'; set -- x${_pattern}; IFS=&quot;${_oldIFS}&quot;
+  if [ $# -gt 1 ]; then
+    # run the date command??
+    IFS='d'; set -- ${_pattern}x; IFS=&quot;${_oldIFS}&quot;
+    [ $# -gt 1 ] &amp;&amp; _date=`date '+%Y-%m-%d %H:%M:%S'`
+
+    # run the eval command?
+    IFS='X'; set -- ${_pattern}x; IFS=&quot;${_oldIFS}&quot;
+    [ $# -gt 1 ] &amp;&amp; _doEval=${__LOG4SH_TRUE}
+  fi
+  unset _oldIFS
+
+  # escape any '\' and '&amp;' chars in the message
+  _msg=`echo &quot;${_msg}&quot; |sed 's/\\\\/\\\\\\\\/g;s/&amp;/\\\\&amp;/g'`
+
+  # deal with any newlines in the message
+  _msg=`echo &quot;${_msg}&quot; |tr '\n' ''`
+
+  # parse the pattern
+  _pattern=`echo &quot;${_pattern}&quot; |sed \
+    -e 's/%c/shell/g' \
+    -e 's/%d{[^}]*}/%d/g' -e &quot;s/%d/${_date}/g&quot; \
+    -e &quot;s/%F/${__log4sh_filename}/g&quot; \
+    -e 's/%L//g' \
+    -e 's/%n//g' \
+    -e &quot;s/%-*[0-9]*p/${_priority}/g&quot; \
+    -e &quot;s/%-*[0-9]*r/${__log4sh_seconds}/g&quot; \
+    -e &quot;s/%t/${__log4sh_threadName}/g&quot; \
+    -e 's/%x//g' \
+    -e 's/%X{/$\{/g' \
+    -e 's/%%m/%%%m/g' -e 's/%%/%/g' \
+    -e &quot;s%m${_msg}&quot; |tr '' '\n'`
+  if [ ${_doEval} -eq ${__LOG4SH_FALSE} ]; then
+    echo &quot;${_pattern}&quot;
+  else
+    eval &quot;echo \&quot;${_pattern}\&quot;&quot;
+  fi
+
+  unset _date _doEval _msg _pattern _tag
+}
+
+#/**
+# &lt;s:function group=&quot;Appender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_getType&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Gets the Type of an Appender&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;type=`appender_getType myAppender`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_getType()
+{
+  _index=`_log4sh_findArrayElement &quot;$__log4shAppenders&quot; $1`
+  _log4sh_getArrayElement &quot;$__log4shAppenderTypes&quot; $_index
+  unset _index
+}
+
+#/**
+# &lt;s:function group=&quot;Appender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_getAppenderType&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;integer &lt;parameter&gt;index&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;&lt;emphasis role=&quot;strong&quot;&gt;Deprecated as of 1.3.1&lt;/emphasis&gt;&lt;/para&gt;
+#   &lt;para&gt;
+#     Gets the Type of an Appender at the given array index
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;type=`appender_getAppenderType 3`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_getAppenderType()
+{
+  _appender_getTypeByIndex &quot;$@&quot;
+}
+
+#/**
+# &lt;s:function group=&quot;Appender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;/&lt;code&gt;boolean&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_setType&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;type&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Sets the Type of an Appender (e.g. FileAppender)&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;appender_setType myAppender FileAppender&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_setType()
+{
+  ast_appender=$1
+  ast_type=$2
+
+  # XXX need to verify types
+
+  _index=`_log4sh_findArrayElement &quot;${__log4shAppenders}&quot; ${ast_appender}`
+  __log4shAppenderTypes=`_log4sh_setArrayElement \
+    &quot;${__log4shAppenderTypes}&quot; ${_index} &quot;${ast_type}&quot;`
+
+  # resource the appender
+  _appender_cache ${ast_appender}
+
+  unset ast_appender ast_type _index
+  return ${__LOG4SH_TRUE}
+}
+
+#/**
+# &lt;s:function group=&quot;Appender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_setAppenderType&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;type&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;&lt;emphasis role=&quot;strong&quot;&gt;Deprecated as of 1.3.1&lt;/emphasis&gt;&lt;/para&gt;
+#   &lt;para&gt;
+#     Sets the Type of an Appender (e.g. FileAppender)
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;appender_setAppenderType myAppender FileAppender&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_setAppenderType()
+{
+  appender_setType &quot;$@&quot;
+}
+
+#/**
+# &lt;s:function group=&quot;Appender&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_appender_getTypeByIndex&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;integer &lt;parameter&gt;index&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Gets the Type of an Appender at the given array index&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;type=`_appender_getTypeByIndex 3`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_appender_getTypeByIndex()
+{
+  _log4sh_getArrayElement &quot;$__log4shAppenderTypes&quot; $1
+}
+
+#/**
+# &lt;s:function group=&quot;Appender&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_appender_cache&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Dynamically creates an appender function in memory that will fully
+#   instantiate itself when it is called.&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;_appender_cache myAppender&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_appender_cache()
+{
+  _ac__appender=$1
+
+  _ac__inc=&quot;${__log4sh_tmpDir}/${_ac__appender}${__LOG4SH_APPENDER_INCLUDE_EXT}&quot;
+
+  cat &gt;&quot;${_ac__inc}&quot; &lt;&lt;EOF
+${__LOG4SH_APPENDER_FUNC_PREFIX}${_ac__appender}_activateOptions()
+{
+  [ -n &quot;\${FUNCNAME:-}&quot; ] &amp;&amp; \${__LOG4SH_TRACE} &quot;\${FUNCNAME}()\${BASH_LINENO:+'(called from \${BASH_LINENO})'}&quot;
+  _appender_activate ${_ac__appender}
+}
+
+${__LOG4SH_APPENDER_FUNC_PREFIX}${_ac__appender}_append() { :; }
+EOF
+
+  # source the new functions
+  . &quot;${_ac__inc}&quot;
+
+  # call the activateOptions function
+  # XXX will be removed in log4sh-1.5.x
+  appender_activateOptions ${_ac__appender}
+}
+
+#/**
+# &lt;s:function group=&quot;Appender&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_appender_activate&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;
+#     Dynamically regenerates an appender function in memory that is fully
+#     instantiated for a specific logging task.
+#     &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;_appender_activate myAppender&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_appender_activate()
+{
+  [ -n &quot;${FUNCNAME:-}&quot; ] &amp;&amp; ${__LOG4SH_TRACE} &quot;${FUNCNAME}()${BASH_LINENO:+'(called from ${BASH_LINENO})'}&quot;
+  ${__LOG4SH_TRACE} &quot;_appender_activate($#)&quot;
+  _aa_appender=$1
+  ${__LOG4SH_TRACE} &quot;_aa_appender='${_aa_appender}'&quot;
+
+  _aa_index=`_log4sh_findArrayElement &quot;${__log4shAppenders}&quot; ${_aa_appender}`
+  _aa_inc=&quot;${__log4sh_tmpDir}/${_aa_appender}${__LOG4SH_APPENDER_INCLUDE_EXT}&quot;
+
+  ### generate function for inclusion
+  # TODO can we modularize this in the future?
+
+  # send STDOUT to our include file
+  exec 4&gt;&amp;1 &gt;${_aa_inc}
+
+  # header
+  cat &lt;&lt;EOF
+${__LOG4SH_APPENDER_FUNC_PREFIX}${_aa_appender}_append()
+{
+  [ -n &quot;\${FUNCNAME:-}&quot; ] &amp;&amp; \${__LOG4SH_TRACE} &quot;\${FUNCNAME}()\${BASH_LINENO:+'(called from \${BASH_LINENO})'}&quot;
+  _la_level=\$1
+  _la_message=\$2
+EOF
+
+  # determine the 'layout'
+  _aa_layout=`_appender_getLayoutByIndex ${_aa_index}`
+  ${__LOG4SH_TRACE} &quot;_aa_layout='${_aa_layout}'&quot;
+  case ${_aa_layout} in
+    ${__LOG4SH_LAYOUT_SIMPLE}|\
+    ${__LOG4SH_LAYOUT_HTML})
+      ${__LOG4SH_DEBUG} 'using simple/html layout'
+      echo &quot;  _la_layout=\&quot;\${_la_level} - \${_la_message}\&quot;&quot;
+      ;;
+
+    ${__LOG4SH_LAYOUT_PATTERN})
+      ${__LOG4SH_DEBUG} 'using pattern layout'
+      _aa_pattern=`_appender_getPatternByIndex ${_aa_index}`
+      echo &quot;  _la_layout=\`_appender_parsePattern '${_aa_pattern}' \${_la_level} \&quot;\${_la_message}\&quot;\`&quot;
+      ;;
+  esac
+
+  # what appender 'type' do we have? TODO check not missing
+  _aa_type=`_appender_getTypeByIndex ${_aa_index}`
+  ${__LOG4SH_TRACE} &quot;_aa_type='${_aa_type}'&quot;
+  case ${_aa_type} in
+    ${__LOG4SH_TYPE_CONSOLE})
+      echo &quot;  echo \&quot;\${_la_layout}\&quot;&quot;
+      ;;
+
+    ${__LOG4SH_TYPE_FILE}|\
+    ${__LOG4SH_TYPE_ROLLING_FILE}|\
+    ${__LOG4SH_TYPE_DAILY_ROLLING_FILE})
+      _aa_file=`_appender_file_getFileByIndex ${_aa_index}`
+      ${__LOG4SH_TRACE} &quot;_aa_file='${_aa_file}'&quot;
+      if [ &quot;${_aa_file}&quot; = 'STDERR' ]; then
+        echo &quot;  echo \&quot;\${_la_layout}\&quot; &gt;&amp;2&quot;
+      elif [ &quot;${_aa_file}&quot; != &quot;${__LOG4SH_NULL}&quot; ]; then
+        # do rotation
+        case ${_aa_type} in
+          ${__LOG4SH_TYPE_ROLLING_FILE})
+            # check whether the max file size has been exceeded
+            _aa_rotIndex=`appender_file_getMaxBackupIndex ${_aa_appender}`
+            _aa_rotSize=`appender_file_getMaxFileSize ${_aa_appender}`
+            cat &lt;&lt;EOF
+  _la_rotSize=${_aa_rotSize}
+  _la_size=\`wc -c '${_aa_file}' |awk '{print \$1}'\`
+  if [ \${_la_size} -ge \${_la_rotSize} ]; then
+    if [ ${_aa_rotIndex} -gt 0 ]; then
+      # rotate the appender file(s)
+      _la_rotIndex=`expr ${_aa_rotIndex} - 1`
+      _la_rotFile=&quot;${_aa_file}.\${_la_rotIndex}&quot;
+      [ -f &quot;\${_la_rotFile}&quot; ] &amp;&amp; rm -f &quot;\${_la_rotFile}&quot;
+      while [ \${_la_rotIndex} -gt 0 ]; do
+        _la_rotFileLast=&quot;\${_la_rotFile}&quot;
+        _la_rotIndex=\`expr \${_la_rotIndex} - 1\`
+        _la_rotFile=&quot;${_aa_file}.\${_la_rotIndex}&quot;
+        [ -f &quot;\${_la_rotFile}&quot; ] &amp;&amp; mv -f &quot;\${_la_rotFile}&quot; &quot;\${_la_rotFileLast}&quot;
+      done
+      mv -f '${_aa_file}' &quot;\${_la_rotFile}&quot;
+    else
+      # keep no backups; truncate the file
+      cp /dev/null &quot;${_aa_file}&quot;
+    fi
+    unset _la_rotFile _la_rotFileLast _la_rotIndex
+  fi
+  unset _la_rotSize _la_size
+EOF
+            ;;
+          ${__LOG4SH_TYPE_DAILY_ROLLING_FILE})
+            ;;
+        esac
+        echo &quot;  echo \&quot;\${_la_layout}\&quot; &gt;&gt;'${_aa_file}'&quot;
+      else
+        # the file &quot;${__LOG4SH_NULL}&quot; is closed?? Why did we get here, and why
+        # did I care when I wrote this bit of code?
+        :
+      fi
+
+      unset _aa_file
+      ;;
+
+    ${__LOG4SH_TYPE_SMTP})
+      _aa_smtpTo=`appender_smtp_getTo ${_aa_appender}`
+      _aa_smtpSubject=`appender_smtp_getSubject ${_aa_appender}`
+
+      cat &lt;&lt;EOF
+  echo &quot;\${_la_layout}&quot; |\\
+      ${__log4sh_alternative_mail} -s &quot;${_aa_smtpSubject}&quot; ${_aa_smtpTo}
+EOF
+      ;;
+
+    ${__LOG4SH_TYPE_SYSLOG})
+      cat &lt;&lt;EOF
+  case &quot;\${_la_level}&quot; in
+    ${__LOG4SH_LEVEL_TRACE_STR}) _la_tag='debug' ;;  # no 'trace' equivalent
+    ${__LOG4SH_LEVEL_DEBUG_STR}) _la_tag='debug' ;;
+    ${__LOG4SH_LEVEL_INFO_STR}) _la_tag='info' ;;
+    ${__LOG4SH_LEVEL_WARN_STR}) _la_tag='warning' ;;  # 'warn' is deprecated
+    ${__LOG4SH_LEVEL_ERROR_STR}) _la_tag='err' ;;     # 'error' is deprecated
+    ${__LOG4SH_LEVEL_FATAL_STR}) _la_tag='alert' ;;
+  esac
+EOF
+
+      _aa_facilityName=`appender_syslog_getFacility ${_aa_appender}`
+      _aa_syslogHost=`appender_syslog_getHost ${_aa_appender}`
+      _aa_hostname=`hostname |sed 's/^\([^.]*\)\..*/\1/'`
+
+      # are we logging to a remote host?
+      if [ -z &quot;${_aa_syslogHost}&quot; ]; then
+        # no -- use logger
+        cat &lt;&lt;EOF
+  ( exec logger -p &quot;${_aa_facilityName}.\${_la_tag}&quot; \
+      -t &quot;${__log4sh_filename}[$$]&quot; &quot;\${_la_layout}&quot; 2&gt;/dev/null )
+  unset _la_tag
+EOF
+      else
+        # yes -- use netcat
+        if [ -n &quot;${__log4sh_alternative_nc:-}&quot; ]; then
+          case ${_aa_facilityName} in
+            kern) _aa_facilityCode=0 ;;            # 0&lt;&lt;3
+            user) _aa_facilityCode=8 ;;            # 1&lt;&lt;3
+            mail) _aa_facilityCode=16 ;;           # 2&lt;&lt;3
+            daemon) _aa_facilityCode=24 ;;         # 3&lt;&lt;3
+            auth|security) _aa_facilityCode=32 ;;  # 4&lt;&lt;3
+            syslog) _aa_facilityCode=40 ;;         # 5&lt;&lt;3
+            lpr) _aa_facilityCode=48 ;;            # 6&lt;&lt;3
+            news) _aa_facilityCode=56 ;;           # 7&lt;&lt;3
+            uucp) _aa_facilityCode=64 ;;           # 8&lt;&lt;3
+            cron) _aa_facilityCode=72 ;;           # 9&lt;&lt;3
+            authpriv) _aa_facilityCode=80 ;;       # 10&lt;&lt;3
+            ftp) _aa_facilityCode=88 ;;            # 11&lt;&lt;3
+            local0) _aa_facilityCode=128 ;;        # 16&lt;&lt;3
+            local1) _aa_facilityCode=136 ;;        # 17&lt;&lt;3
+            local2) _aa_facilityCode=144 ;;        # 18&lt;&lt;3
+            local3) _aa_facilityCode=152 ;;        # 19&lt;&lt;3
+            local4) _aa_facilityCode=160 ;;        # 20&lt;&lt;3
+            local5) _aa_facilityCode=168 ;;        # 21&lt;&lt;3
+            local6) _aa_facilityCode=176 ;;        # 22&lt;&lt;3
+            local7) _aa_facilityCode=184 ;;        # 23&lt;&lt;3
+          esac
+
+          cat &lt;&lt;EOF
+  case \${_la_tag} in
+    alert) _la_priority=1 ;;
+    err|error) _la_priority=3 ;;
+    warning|warn) _la_priority=4 ;;
+    info) _la_priority=6 ;;
+    debug) _la_priority=7 ;;
+  esac
+  _la_priority=\`expr ${_aa_facilityCode} + \${_la_priority}\`
+  _la_date=\`date &quot;+%b %d %H:%M:%S&quot;\`
+  _la_hostname='${_aa_hostname}'
+
+  _la_syslogMsg=&quot;&lt;\${_la_priority}&gt;\${_la_date} \${_la_hostname} \${_la_layout}&quot;
+
+  # do RFC 3164 cleanups
+  _la_date=\`echo \&quot;\${_la_date}\&quot; |sed 's/ 0\([0-9]\) /  \1 /'\`
+  _la_syslogMsg=\`echo &quot;\${_la_syslogMsg}&quot; |cut -b1-1024\`
+
+  ( echo &quot;\${_la_syslogMsg}&quot; |\
+      exec ${__log4sh_alternative_nc} ${__log4sh_alternative_nc_opts} -w 1 -u \
+          ${_aa_syslogHost} 514 )
+  unset _la_tag _la_priority _la_date _la_hostname _la_syslogMsg
+EOF
+          unset _aa_facilityCode _aa_syslogHost _aa_hostname
+        else
+          # no netcat alternative set; doing nothing
+          :
+        fi
+      fi
+      unset _aa_facilityName
+      ;;
+
+    *) _log4sh_error &quot;unrecognized appender type (${_aa_type})&quot; ;;
+  esac
+
+  # footer
+  cat &lt;&lt;EOF
+  unset _la_level _la_message _la_layout
+}
+EOF
+
+  # override the activateOptions function as we don't need it anymore
+  cat &lt;&lt;EOF
+${__LOG4SH_APPENDER_FUNC_PREFIX}${_aa_appender}_activateOptions() { :; }
+EOF
+
+  # restore STDOUT
+  exec 1&gt;&amp;4 4&gt;&amp;-
+
+  # source the newly created function
+  ${__LOG4SH_TRACE} 're-sourcing the newly created function'
+  . &quot;${_aa_inc}&quot;
+
+  unset _aa_appender _aa_inc _aa_layout _aa_pattern _aa_type
+}
+
+#-----------------------------------------------------------------------------
+# FileAppender
+#
+
+#/**
+# &lt;s:function group=&quot;FileAppender&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_appender_file_getFileByIndex&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;integer &lt;parameter&gt;index&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Get the filename of a FileAppender at the given array index&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;_appender_file_getFileByIndex 3&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_appender_file_getFileByIndex()
+{
+  _log4sh_getArrayElement &quot;${__log4shAppender_file_files}&quot; $1
+}
+
+#/**
+# &lt;s:function group=&quot;FileAppender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_file_getFile&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Get the filename of a FileAppender&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;appender_file_getFile myAppender&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_file_getFile()
+{
+  _index=`_log4sh_findArrayElement &quot;$__log4shAppenders&quot; $1`
+  _log4sh_getArrayElement &quot;$__log4shAppender_file_files&quot; $_index
+  unset _index
+}
+
+#/**
+# &lt;s:function group=&quot;FileAppender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_file_setFile&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;filename&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;
+#     Set the filename for a FileAppender (e.g. &lt;filename&gt;STDERR&lt;/filename&gt; or
+#     &lt;filename&gt;/var/log/log4sh.log&lt;/filename&gt;).
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;appender_file_setFile myAppender STDERR&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_file_setFile()
+{
+  afsf_appender=$1
+  afsf_file=$2
+  ${__LOG4SH_TRACE} &quot;afsf_appender='${afsf_appender}' afsf_file='${afsf_file}'&quot;
+
+  if [ -n &quot;${afsf_appender}&quot; -a -n &quot;${afsf_file}&quot; ]; then
+    # set the file
+    _index=`_log4sh_findArrayElement &quot;${__log4shAppenders}&quot; ${afsf_appender}`
+    __log4shAppender_file_files=`_log4sh_setArrayElement \
+      &quot;${__log4shAppender_file_files}&quot; ${_index} &quot;${afsf_file}&quot;`
+    _return=$?
+
+    # create the file (if it isn't already)
+    if [ ${_return} -eq ${__LOG4SH_TRUE} \
+      -a ! &quot;${afsf_file}&quot; '=' &quot;${__LOG4SH_NULL}&quot; \
+      -a ! &quot;${afsf_file}&quot; '=' 'STDERR' \
+      -a ! -f &quot;${afsf_file}&quot; \
+    ]; then
+      touch &quot;${afsf_file}&quot; 2&gt;/dev/null
+      _result=$?
+      # determine success of touch command
+      if [ ${_result} -eq 1 ]; then
+        _log4sh_error &quot;appender_file_setFile(): could not create file (${afsf_file}); closing appender&quot;
+        appender_setLevel ${afsf_appender} ${__LOG4SH_LEVEL_CLOSED_STR}
+      fi
+      unset _result
+    fi
+  else
+    _log4sh_error 'appender_file_setFile(): missing appender and/or file'
+    _return=${__LOG4SH_FALSE}
+  fi
+
+  # resource the appender
+  _appender_cache ${afsf_appender}
+
+  unset afsf_appender afsf_file _index
+  return ${_return}
+}
+
+#/**
+# &lt;s:function group=&quot;FileAppender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_setAppenderFile&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;filename&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;&lt;emphasis role=&quot;strong&quot;&gt;Deprecated as of 1.3.2&lt;/emphasis&gt;&lt;/para&gt;
+#   &lt;para&gt;
+#     Set the filename for a FileAppender (e.g. &quot;STDERR&quot; or
+#     &quot;/var/log/log4sh.log&quot;)
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;appender_setAppenderFile myAppender STDERR&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_setAppenderFile()
+{
+  appender_file_setFile &quot;$@&quot;
+}
+
+#/**
+# &lt;s:function group=&quot;FileAppender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;integer&lt;/code&gt;/boolean
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_file_getMaxBackupIndex&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;
+#     Returns the value of the MaxBackupIndex option.
+#   &lt;/para&gt;
+#   &lt;para&gt;&lt;emphasis role=&quot;strong&quot;&gt;Since:&lt;/emphasis&gt; 1.3.7&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;appender_file_getMaxBackupIndex myAppender&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_file_getMaxBackupIndex()
+{
+  if [ $# -ne 1 ]; then
+    _log4sh_error 'appender_file_getMaxBackupIndex(): invalid number of parameters'
+    return ${__LOG4SH_FALSE}
+  fi
+
+  afgmbi_appender=$1
+
+  afgmbi_index=`_log4sh_findArrayElement \
+      &quot;${__log4shAppenders}&quot; ${afgmbi_appender}`
+  # TODO: put check for valid index here
+  _log4sh_getArrayElement \
+      &quot;${__log4shAppender_rollingFile_maxBackupIndexes}&quot; ${afgmbi_index}
+  __log4sh_return=$?
+
+  unset afgmbi_appender afgmbi_index
+  return ${__log4sh_return}
+}
+
+#/**
+# &lt;s:function group=&quot;FileAppender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_file_setMaxBackupIndex&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;integer &lt;parameter&gt;index&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Set the maximum number of backup files to keep around.&lt;/para&gt;
+#   &lt;para&gt;
+#     The &lt;emphasis role=&quot;strong&quot;&gt;MaxBackupIndex&lt;/emphasis&gt; option determines
+#     how many backup files are kept before the oldest is erased. This option
+#     takes a positive integer value. If set to zero, then there will be no
+#     backup files and the log file will be truncated when it reaches
+#     &lt;option&gt;MaxFileSize&lt;/option&gt;.
+#   &lt;/para&gt;
+#   &lt;para&gt;&lt;emphasis role=&quot;strong&quot;&gt;Since:&lt;/emphasis&gt; 1.3.7&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;appender_file_setMaxBackupIndex myAppender 3&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_file_setMaxBackupIndex()
+{
+  if [ $# -ne 2 ]; then
+    _log4sh_error &quot;appender_file_setMaxBackupIndex(): invalid number of parameters ($#)&quot;
+    return ${__LOG4SH_FALSE}
+  fi
+
+  afsmbi_appender=$1
+  afsmbi_maxIndex=$2
+
+  # TODO: put check for valid input
+
+  afsmbi_index=`_log4sh_findArrayElement \
+      &quot;${__log4shAppenders}&quot; ${afsmbi_appender}`
+  # TODO: put check for valid index here
+  __log4shAppender_rollingFile_maxBackupIndexes=`_log4sh_setArrayElement \
+      &quot;${__log4shAppender_rollingFile_maxBackupIndexes}&quot; ${afsmbi_index} \
+      &quot;${afsmbi_maxIndex}&quot;`
+  __log4sh_return=$?
+
+  # re-source the appender
+  _appender_cache ${afsmbi_appender}
+
+  unset afsmbi_appender afsmbi_maxIndex afsmbi_index
+  return ${__log4sh_return}
+}
+
+#/**
+# &lt;s:function group=&quot;FileAppender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;integer&lt;/code&gt;/boolean
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_file_getMaxFileSize&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;
+#     Get the maximum size that the output file is allowed to reach before
+#     being rolled over to backup files.
+#   &lt;/para&gt;
+#   &lt;para&gt;&lt;emphasis role=&quot;strong&quot;&gt;Since:&lt;/emphasis&gt; 1.3.7&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;maxSize=`appender_file_getMaxBackupSize myAppender`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_file_getMaxFileSize()
+{
+  if [ $# -ne 1 ]; then
+    _log4sh_error &quot;appender_file_getMaxFileSize(): invalid number of parameters ($#)&quot;
+    return ${__LOG4SH_FALSE}
+  fi
+
+  afgmfs_appender=$1
+
+  afgmfs_index=`_log4sh_findArrayElement \
+      &quot;${__log4shAppenders}&quot; ${afgmfs_appender}`
+  # TODO: put check for valid index here
+  _log4sh_getArrayElement \
+      &quot;${__log4shAppender_rollingFile_maxFileSizes}&quot; ${afgmfs_index}
+  __log4sh_return=$?
+
+  unset afgmfs_appender afgmfs_index
+  return ${__log4sh_return}
+}
+
+#/**
+# &lt;s:function group=&quot;FileAppender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;/boolean
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_file_setMaxFileSize&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;size&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;
+#     Set the maximum size that the output file is allowed to reach before
+#     being rolled over to backup files.
+#   &lt;/para&gt;
+#   &lt;para&gt;
+#     In configuration files, the &lt;option&gt;MaxFileSize&lt;/option&gt; option takes an
+#     long integer in the range 0 - 2^40. You can specify the value with the
+#     suffixes &quot;KiB&quot;, &quot;MiB&quot; or &quot;GiB&quot; so that the integer is interpreted being
+#     expressed respectively in kilobytes, megabytes or gigabytes. For example,
+#     the value &quot;10KiB&quot; will be interpreted as 10240.
+#   &lt;/para&gt;
+#   &lt;para&gt;&lt;emphasis role=&quot;strong&quot;&gt;Since:&lt;/emphasis&gt; 1.3.7&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;appender_file_setMaxBackupSize myAppender 10KiB&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_file_setMaxFileSize()
+{
+  if [ $# -ne 2 ]; then
+    _log4sh_error \
+        &quot;appender_file_setMaxFileSize(): invalid number of parameters ($#)&quot;
+    return ${__LOG4SH_ERROR}
+  fi
+
+  afsmfs_appender=$1
+  afsmfs_size=$2
+  afsmfs_return=${__LOG4SH_TRUE}
+
+  # split the file size into parts
+  afsmfs_value=`expr ${afsmfs_size} : '\([0-9]*\)'`
+  afsmfs_unit=`expr ${afsmfs_size} : '[0-9]* *\([A-Za-z]\{1,3\}\)'`
+
+  # determine multiplier
+  if [ ${__log4sh_wa_strictBehavior} -eq ${__LOG4SH_TRUE} ]; then
+    case &quot;${afsmfs_unit}&quot; in
+      KB) afsmfs_unit='KiB' ;;
+      MB) afsmfs_unit='MiB' ;;
+      GB) afsmfs_unit='GiB' ;;
+      TB) afsmfs_unit='TiB' ;;
+    esac
+  fi
+  case &quot;${afsmfs_unit}&quot; in
+    B) afsmfs_mul=1 ;;
+    KB) afsmfs_mul=1000 ;;
+    KiB) afsmfs_mul=1024 ;;
+    MB) afsmfs_mul=1000000 ;;
+    MiB) afsmfs_mul=1048576 ;;
+    GB) afsmfs_mul=1000000000 ;;
+    GiB) afsmfs_mul=1073741824 ;;
+    TB) afsmfs_mul=1000000000000 ;;
+    TiB) afsmfs_mul=1099511627776 ;;
+    '')
+      _log4sh_warn 'missing file size unit; assuming bytes'
+      afsmfs_mul=1
+      ;;
+    *)
+      _log4sh_error &quot;unrecognized file size unit '${afsmfs_unit}'&quot;
+      afsmfs_return=${__LOG4SH_ERROR}
+      ;;
+  esac
+
+  # calculate maximum file size
+  if [ ${afsmfs_return} -eq ${__LOG4SH_TRUE} ]; then
+    afsmfs_maxFileSize=`(expr ${afsmfs_value} \* ${afsmfs_mul} 2&gt;&amp;1)`
+    if [ $? -gt 0 ]; then
+      _log4sh_error &quot;problem calculating maximum file size: '${afsmfs_maxFileSize}'&quot;
+      afsmfs_return=${__LOG4SH_FALSE}
+    fi
+  fi
+
+  # store the maximum file size
+  if [ ${afsmfs_return} -eq ${__LOG4SH_TRUE} ]; then
+    afsmfs_index=`_log4sh_findArrayElement \
+        &quot;${__log4shAppenders}&quot; ${afsmfs_appender}`
+    # TODO: put check for valid index here
+    __log4shAppender_rollingFile_maxFileSizes=`_log4sh_setArrayElement \
+        &quot;${__log4shAppender_rollingFile_maxFileSizes}&quot; ${afsmfs_index} \
+        &quot;${afsmfs_maxFileSize}&quot;`
+  fi
+
+  # re-source the appender
+  [ ${afsmfs_return} -eq ${__LOG4SH_TRUE} ] \
+      &amp;&amp; _appender_cache ${afsmfs_appender}
+
+  __log4sh_return=${afsmfs_return}
+  unset afsmfs_appender afsmfs_size afsmfs_value afsmfs_unit afsmfs_mul \
+      afsmfs_maxFileSize afsmfs_index afsmfs_return
+  return ${__log4sh_return}
+}
+
+#-----------------------------------------------------------------------------
+# SMTPAppender
+#
+
+#/**
+# &lt;s:function group=&quot;SMTPAppender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;/boolean
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_smtp_getTo&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Get the to address for the given appender&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;email=`appender_smtp_getTo myAppender`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_smtp_getTo()
+{
+  if [ $# -ne 1 ]; then
+    _log4sh_error 'appender_smtp_getTo(): invalid number of parameters'
+    return ${__LOG4SH_FALSE}
+  fi
+
+  asgt_appender=$1
+
+  asgt_index=`_log4sh_findArrayElement &quot;${__log4shAppenders}&quot; ${asgt_appender}`
+  # TODO: put check for valid index here
+  asgt_to=`_log4sh_getArrayElement \
+      &quot;${__log4shAppender_smtp_tos}&quot; ${asgt_index}`
+  __log4sh_return=$?
+
+  [ &quot;${asgt_to}&quot; = &quot;${__LOG4SH_NULL}&quot; ] &amp;&amp; asgt_to=''
+  echo &quot;${asgt_to}&quot;
+
+  unset asgt_appender asgt_index asgt_to
+  return ${__log4sh_return}
+}
+
+#/**
+# &lt;s:function group=&quot;SMTPAppender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;/boolean
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_smtp_setTo&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;email&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Set the to address for the given appender&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;appender_smtp_setTo myAppender <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">user at example.com</A>&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_smtp_setTo()
+{
+  if [ $# -ne 2 ]; then
+    _log4sh_error 'appender_smtp_setTo(): invalid number of parameters'
+    return ${__LOG4SH_FALSE}
+  fi
+
+  asst_appender=$1
+  asst_email=$2
+
+  asst_index=`_log4sh_findArrayElement &quot;${__log4shAppenders}&quot; ${asst_appender}`
+  # TODO: put check for valid index here
+  __log4shAppender_smtp_tos=`_log4sh_setArrayElement \
+    &quot;${__log4shAppender_smtp_tos}&quot; ${asst_index} &quot;${asst_email}&quot;`
+
+  # resource the appender
+  _appender_cache ${asst_appender}
+
+  unset asst_appender asst_email asst_index
+}
+
+#/**
+# &lt;s:function group=&quot;SMTPAppender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_setAppenderRecipient&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;email&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;&lt;emphasis role=&quot;strong&quot;&gt;Deprecated as of 1.3.1&lt;/emphasis&gt;&lt;/para&gt;
+#   &lt;para&gt;
+#     Set the to address for the given appender
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;appender_smtp_setTo myAppender <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">user at example.com</A>&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_setAppenderRecipient()
+{
+  appender_smtp_setTo &quot;$@&quot;
+}
+
+#/**
+# &lt;s:function group=&quot;SMTPAppender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;/boolean
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_smtp_getSubject&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Get the email subject for the given appender&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;subject=`appender_smtp_getSubject myAppender`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_smtp_getSubject()
+{
+  if [ $# -ne 1 ]; then
+    _log4sh_error 'appender_smtp_getSubject(): invalid number of parameters'
+    return ${__LOG4SH_FALSE}
+  fi
+
+  asgs_appender=$1
+
+  asgs_index=`_log4sh_findArrayElement &quot;${__log4shAppenders}&quot; ${asgs_appender}`
+  # TODO: put check for valid index here
+  asgs_subject=`_log4sh_getArrayElement \
+      &quot;${__log4shAppender_smtp_subjects}&quot; ${asgs_index}`
+  __log4sh_return=$?
+
+  [ &quot;${asgs_subject}&quot; = &quot;${__LOG4SH_NULL}&quot; ] &amp;&amp; asgs_subject=''
+  echo &quot;${asgs_subject}&quot;
+
+  unset asgs_appender asgs_index asgs_subject
+  return ${__log4sh_return}
+}
+
+#/**
+# &lt;s:function group=&quot;SMTPAppender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;/boolean
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_smtp_setSubject&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;subject&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Sets the email subject for an SMTP appender&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;appender_smtp_setSubject myAppender &quot;This is a test&quot;&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_smtp_setSubject()
+{
+  if [ $# -ne 2 ]; then
+    _log4sh_error 'appender_smtp_setSubject(): invalid number of parameters'
+    return ${__LOG4SH_FALSE}
+  fi
+
+  asss_appender=$1
+  asss_subject=$2
+
+  # set the Subject
+  asss_index=`_log4sh_findArrayElement &quot;${__log4shAppenders}&quot; ${asss_appender}`
+  if [ ${asss_index} -gt 0 ]; then
+    __log4shAppender_smtp_subjects=`_log4sh_setArrayElement \
+      &quot;${__log4shAppender_smtp_subjects}&quot; ${asss_index} &quot;${asss_subject}&quot;`
+    __log4sh_return=${__LOG4SH_TRUE}
+  else
+    _log4sh_error &quot;could not set Subject for appender (${asss_appender})&quot;
+    __log4sh_return=${__LOG4SH_FALSE}
+  fi
+
+  # re-source the appender
+  _appender_cache ${asss_appender}
+
+  unset asss_appender asss_subject asss_index
+  return ${__log4sh_return}
+}
+
+#/**
+# &lt;s:function group=&quot;SMTPAppender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_setAppenderSubject&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;subject&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;&lt;emphasis role=&quot;strong&quot;&gt;Deprecated as of 1.3.1&lt;/emphasis&gt;&lt;/para&gt;
+#   &lt;para&gt;
+#     Sets the email subject for an SMTP appender
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;appender_setAppenderSubject myAppender &quot;This is a test&quot;&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_setAppenderSubject()
+{
+  appender_smtp_setSubject &quot;$@&quot;
+}
+
+#-----------------------------------------------------------------------------
+# SyslogAppender
+#
+
+#/**
+# &lt;s:function group=&quot;SyslogAppender&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;
+#         &lt;function&gt;_appender_syslog_getFacilityByIndex&lt;/function&gt;
+#       &lt;/funcdef&gt;
+#       &lt;paramdef&gt;integer &lt;parameter&gt;index&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Get the syslog facility of the specified appender by index&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;
+#       facility=`_appender_syslog_getFacilityByIndex 3`
+#     &lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_appender_syslog_getFacilityByIndex()
+{
+  _log4sh_getArrayElement &quot;$__log4shAppender_syslog_facilities&quot; $1
+}
+
+#/**
+# &lt;s:function group=&quot;SyslogAppender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_getSyslogFacility&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;integer &lt;parameter&gt;index&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;&lt;emphasis role=&quot;strong&quot;&gt;Deprecated as of 1.3.1&lt;/emphasis&gt;&lt;/para&gt;
+#   &lt;para&gt;
+#     Get the syslog facility of the specified appender by index
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;facility=`appender_getSyslogFacility 3`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_getSyslogFacility()
+{
+  _appender_syslog_getFacilityByIndex &quot;$@&quot;
+}
+
+#/**
+# &lt;s:function group=&quot;SyslogAppender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_syslog_getFacility&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;
+#     Get the syslog facility for the given appender.
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;facility=`appender_syslog_getFacility myAppender`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_syslog_getFacility()
+{
+  if [ $# -ne 1 ]; then
+    _log4sh_error 'appender_syslog_getFacility(): invalid number of parameters'
+    return ${__LOG4SH_FALSE}
+  fi
+
+  asgf_appender=$1
+
+  asgf_index=`_log4sh_findArrayElement &quot;$__log4shAppenders&quot; ${asgf_appender}`
+  _log4sh_getArrayElement &quot;${__log4shAppender_syslog_facilities}&quot; ${asgf_index}
+
+  unset asgf_appender asgf_index
+}
+
+#/**
+# &lt;s:function group=&quot;SyslogAppender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_syslog_setFacility&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;facility&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Set the syslog facility for the given appender&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;appender_syslog_setFacility myAppender local4`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_syslog_setFacility()
+{
+  if [ $# -ne 2 ]; then
+    _log4sh_error 'appender_syslog_setFacility(): invalid number of parameters'
+    return ${__LOG4SH_FALSE}
+  fi
+  assf_appender=$1
+  assf_facility=$2
+
+  # check for valid facility
+  echo &quot;${__LOG4SH_TYPE_SYSLOG_FACILITY_NAMES}&quot; |grep &quot; ${assf_facility} &quot; &gt;/dev/null
+  if [ $? -ne 0 ]; then
+    # the facility is not valid
+    _log4sh_error &quot;[${assf_facility}] is an unknown syslog facility. Defaulting to [user].&quot;
+    assf_facility='user'
+  fi
+
+  # set appender facility
+  assf_index=`_log4sh_findArrayElement &quot;${__log4shAppenders}&quot; ${assf_appender}`
+  # TODO: put check for valid index here
+  __log4shAppender_syslog_facilities=`_log4sh_setArrayElement \
+    &quot;${__log4shAppender_syslog_facilities}&quot; ${assf_index} &quot;${assf_facility}&quot;`
+
+  # re-source the appender
+  _appender_cache ${assf_appender}
+
+  unset assf_appender assf_facility assf_index
+  return ${__LOG4SH_TRUE}
+}
+
+#/**
+# &lt;s:function group=&quot;SyslogAppender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_setSyslogFacility&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;facility&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;&lt;emphasis role=&quot;strong&quot;&gt;Deprecated as of 1.3.2&lt;/emphasis&gt;&lt;/para&gt;
+#   &lt;para&gt;
+#     Set the syslog facility for the given appender
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;appender_setSyslogFacility myAppender local4`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_setSyslogFacility()
+{
+  appender_syslog_setFacility &quot;$@&quot;
+}
+
+#/**
+# &lt;s:function group=&quot;SyslogAppender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;/boolean
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_syslog_getHost&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;integer &lt;parameter&gt;index&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;
+#     Get the syslog host of the specified appender.
+#   &lt;/para&gt;
+#   &lt;para&gt;&lt;emphasis role=&quot;strong&quot;&gt;Since:&lt;/emphasis&gt; 1.3.7&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;host=`appender_syslog_getHost myAppender`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+appender_syslog_getHost()
+{
+  if [ $# -ne 1 ]; then
+    _log4sh_error 'appender_syslog_getHost(): invalid number of parameters'
+    return ${__LOG4SH_FALSE}
+  fi
+
+  asgh_appender=$1
+
+  asgh_index=`_log4sh_findArrayElement &quot;${__log4shAppenders}&quot; ${asgh_appender}`
+  # TODO: put check for valid index here
+  asgh_host=`_log4sh_getArrayElement \
+      &quot;${__log4shAppender_syslog_hosts}&quot; ${asgh_index}`
+  __log4sh_return=$?
+
+  [ &quot;${asgh_host}&quot; = &quot;${__LOG4SH_NULL}&quot; ] &amp;&amp; asgh_host=''
+  echo &quot;${asgh_host}&quot;
+
+  unset asgh_appender asgh_index asgh_host
+  return ${__log4sh_return}
+}
+
+#/**
+# &lt;s:function group=&quot;SyslogAppender&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;/boolean
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;appender_syslog_setHost&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;host&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;
+#     Set the syslog host for the given appender. Requires that the 'nc'
+#     command alternative has been previously set with the
+#     log4sh_setAlternative() function.
+#   &lt;/para&gt;
+#   &lt;para&gt;&lt;emphasis role=&quot;strong&quot;&gt;Since:&lt;/emphasis&gt; 1.3.7&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;appender_syslog_setHost myAppender localhost&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+#
+# The BSD syslog Protocol
+#   <A HREF="http://www.ietf.org/rfc/rfc3164.txt">http://www.ietf.org/rfc/rfc3164.txt</A>
+#
+appender_syslog_setHost()
+{
+  if [ $# -ne 2 ]; then
+    _log4sh_error 'appender_syslog_setHost(): invalid number of parameters'
+    return ${__LOG4SH_FALSE}
+  fi
+
+  assh_appender=$1
+  assh_host=$2
+
+  [ -z &quot;${__log4sh_alternative_nc:-}&quot; ] \
+      &amp;&amp; _log4sh_warn 'the nc (netcat) command alternative is required for remote syslog logging. see log4sh_setAlternative().'
+
+  assh_index=`_log4sh_findArrayElement &quot;${__log4shAppenders}&quot; ${assh_appender}`
+  # TODO: put check for valid index here
+  __log4shAppender_syslog_hosts=`_log4sh_setArrayElement \
+      &quot;${__log4shAppender_syslog_hosts}&quot; ${assh_index} &quot;${assh_host}&quot;`
+
+  # re-source the appender
+  _appender_cache ${assh_appender}
+
+  unset assh_appender assh_host assh_index
+  return ${__LOG4SH_TRUE}
+}
+
+#=============================================================================
+# Level
+#
+
+#/**
+# &lt;s:function group=&quot;Level&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;logger_level_toLevel&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;integer &lt;parameter&gt;val&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Converts an internally used level integer into its external level
+#   equivalent&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;level=`logger_level_toLevel 3`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+# TODO use arrays instead of case statement ??
+logger_level_toLevel()
+{
+  _ltl__val=$1
+
+  _ltl__return=${__LOG4SH_TRUE}
+  _ltl__level=''
+
+  case ${_ltl__val} in
+    ${__LOG4SH_LEVEL_TRACE}) _ltl__level=${__LOG4SH_LEVEL_TRACE_STR} ;;
+    ${__LOG4SH_LEVEL_DEBUG}) _ltl__level=${__LOG4SH_LEVEL_DEBUG_STR} ;;
+    ${__LOG4SH_LEVEL_INFO}) _ltl__level=${__LOG4SH_LEVEL_INFO_STR} ;;
+    ${__LOG4SH_LEVEL_WARN}) _ltl__level=${__LOG4SH_LEVEL_WARN_STR} ;;
+    ${__LOG4SH_LEVEL_ERROR}) _ltl__level=${__LOG4SH_LEVEL_ERROR_STR} ;;
+    ${__LOG4SH_LEVEL_FATAL}) _ltl__level=${__LOG4SH_LEVEL_FATAL_STR} ;;
+    ${__LOG4SH_LEVEL_OFF}) _ltl__level=${__LOG4SH_LEVEL_OFF_STR} ;;
+    ${__LOG4SH_LEVEL_CLOSED}) _ltl__level=${__LOG4SH_LEVEL_CLOSED_STR} ;;
+    *) _ltl__return=${__LOG4SH_FALSE} ;;
+  esac
+
+  echo ${_ltl__level}
+  unset _ltl__val _ltl__level
+  return ${_ltl__return}
+}
+
+#/**
+# &lt;s:function group=&quot;Level&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;integer&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;logger_level_toInt&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;level&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Converts an externally used level tag into its integer
+#   equivalent&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;levelInt=`logger_level_toInt WARN`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+logger_level_toInt()
+{
+  _lti__level=$1
+
+  _lti__int=0
+  _lti__return=${__LOG4SH_TRUE}
+
+  case ${_lti__level} in
+    ${__LOG4SH_LEVEL_TRACE_STR}) _lti__int=${__LOG4SH_LEVEL_TRACE} ;;
+    ${__LOG4SH_LEVEL_DEBUG_STR}) _lti__int=${__LOG4SH_LEVEL_DEBUG} ;;
+    ${__LOG4SH_LEVEL_INFO_STR}) _lti__int=${__LOG4SH_LEVEL_INFO} ;;
+    ${__LOG4SH_LEVEL_WARN_STR}) _lti__int=${__LOG4SH_LEVEL_WARN} ;;
+    ${__LOG4SH_LEVEL_ERROR_STR}) _lti__int=${__LOG4SH_LEVEL_ERROR} ;;
+    ${__LOG4SH_LEVEL_FATAL_STR}) _lti__int=${__LOG4SH_LEVEL_FATAL} ;;
+    ${__LOG4SH_LEVEL_OFF_STR}) _lti__int=${__LOG4SH_LEVEL_OFF} ;;
+    ${__LOG4SH_LEVEL_CLOSED_STR}) _lti__int=${__LOG4SH_LEVEL_CLOSED} ;;
+    *) _lti__return=${__LOG4SH_FALSE} ;;
+  esac
+
+  echo ${_lti__int}
+  unset _lti__int _lti__level
+  return ${_lti__return}
+}
+
+#=============================================================================
+# Logger
+#
+
+#/**
+# &lt;s:function group=&quot;Logger&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;/&lt;code&gt;boolean&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;logger_addAppender&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Add and initialize a new appender&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;logger_addAppender $appender&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+logger_addAppender()
+{
+  laa_appender=$1
+
+  # FAQ should we be using setter functions here?? for performance, no.
+  __log4shAppenders=`_log4sh_pushStack &quot;${__log4shAppenders}&quot; ${laa_appender}`
+  __log4shAppenderCount=`expr ${__log4shAppenderCount} + 1`
+  __log4shAppenderCounts=&quot;${__log4shAppenderCounts} ${__log4shAppenderCount}&quot;
+  __log4shAppenderLayouts=`_log4sh_pushStack \
+      &quot;$__log4shAppenderLayouts&quot; &quot;${__LOG4SH_LAYOUT_SIMPLE}&quot;`
+  __log4shAppenderLevels=`_log4sh_pushStack \
+      &quot;${__log4shAppenderLevels}&quot; &quot;${__LOG4SH_NULL}&quot;`
+  __log4shAppenderPatterns=`_log4sh_pushStack \
+      &quot;${__log4shAppenderPatterns}&quot; &quot;${__LOG4SH_PATTERN_DEFAULT}&quot;`
+  __log4shAppenderTypes=`_log4sh_pushStack \
+      &quot;${__log4shAppenderTypes}&quot; ${__LOG4SH_TYPE_CONSOLE}`
+  __log4shAppender_file_files=`_log4sh_pushStack \
+      &quot;${__log4shAppender_file_files}&quot; ${__LOG4SH_NULL}`
+  __log4shAppender_rollingFile_maxBackupIndexes=`_log4sh_pushStack \
+      &quot;${__log4shAppender_rollingFile_maxBackupIndexes}&quot; \
+      ${__LOG4SH_TYPE_ROLLING_FILE_MAX_BACKUP_INDEX}`
+  __log4shAppender_rollingFile_maxFileSizes=`_log4sh_pushStack \
+      &quot;${__log4shAppender_rollingFile_maxFileSizes}&quot; \
+      ${__LOG4SH_TYPE_ROLLING_FILE_MAX_FILE_SIZE}`
+  __log4shAppender_smtp_tos=`_log4sh_pushStack \
+      &quot;${__log4shAppender_smtp_tos}&quot; ${__LOG4SH_NULL}`
+  __log4shAppender_smtp_subjects=`_log4sh_pushStack \
+      &quot;${__log4shAppender_smtp_subjects}&quot; ${__LOG4SH_NULL}`
+  __log4shAppender_syslog_facilities=`_log4sh_pushStack \
+      &quot;${__log4shAppender_syslog_facilities}&quot; ${__LOG4SH_TYPE_SYSLOG_FACILITY}`
+  __log4shAppender_syslog_hosts=`_log4sh_pushStack \
+      &quot;${__log4shAppender_syslog_hosts}&quot; &quot;${__LOG4SH_NULL}&quot;`
+
+  _appender_cache ${laa_appender}
+
+  unset laa_appender
+  return ${__LOG4SH_TRUE}
+}
+
+#/**
+# &lt;s:function group=&quot;Logger&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;logger_addAppenderWithPattern&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;appender&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;pattern&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;&lt;emphasis role=&quot;strong&quot;&gt;Deprecated as of 1.3.6&lt;/emphasis&gt;&lt;/para&gt;
+#   &lt;para&gt;
+#     Add and initialize a new appender with a specific PatternLayout
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;logger_addAppenderWithPattern $appender '%d %p - %m%n'&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+logger_addAppenderWithPattern()
+{
+  _myAppender=$1
+  _myPattern=$2
+
+  logger_addAppender ${_myAppender}
+  appender_setLayout ${_myAppender} ${__LOG4SH_LAYOUT_PATTERN}
+  appender_setPattern ${_myAppender} &quot;${_myPattern}&quot;
+
+  unset _myAppender _myPattern
+}
+
+#/**
+# &lt;s:function group=&quot;Logger&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;logger_getFilename&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;void /&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;
+#     Get the filename that would be shown when the '%F' conversion character
+#     is used in a PatternLayout.
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;filename=`logger_getFilename`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+logger_getFilename()
+{
+  echo &quot;${__log4sh_filename}&quot;
+}
+
+#/**
+# &lt;s:function group=&quot;Logger&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;logger_setFilename&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;filename&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Set the filename to be shown when the '%F' conversion character is
+#   used in a PatternLayout.&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;logger_setFilename 'myScript.sh'&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+logger_setFilename()
+{
+  __log4sh_filename=$1
+}
+
+#/**
+# &lt;s:function group=&quot;Logger&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;logger_getLevel&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;void /&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Get the global default logging level (e.g. DEBUG).&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;level=`logger_getLevel`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+logger_getLevel()
+{
+  logger_level_toLevel ${__log4shLevel}
+}
+
+#/**
+# &lt;s:function group=&quot;Logger&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;logger_setLevel&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;level&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Sets the global default logging level (e.g. DEBUG).&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;logger_setLevel INFO&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+logger_setLevel()
+{
+  _l_level=$1
+
+  _l_int=`logger_level_toInt ${_l_level}`
+  if [ $? -eq ${__LOG4SH_TRUE} ]; then
+    __log4shLevel=${_l_int}
+  else
+    _log4sh_error &quot;attempt to set invalid log level '${_l_level}'&quot;
+  fi
+
+  unset _l_int _l_level
+}
+
+#/**
+# &lt;s:function group=&quot;Logger&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;log&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;level&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string[] &lt;parameter&gt;message(s)&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;The base logging command that logs a message to all defined
+#     appenders&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;log DEBUG 'This is a test message'&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+log()
+{
+  _l_level=$1
+  shift
+  # if no message was passed, read it from STDIN
+  [ $# -ne 0 ] &amp;&amp; _l_msg=&quot;$@&quot; || _l_msg=`cat`
+
+  __log4sh_return=${__LOG4SH_TRUE}
+  _l_levelInt=`logger_level_toInt ${_l_level}`
+  if [ $? -eq ${__LOG4SH_TRUE} ]; then
+    # update seconds elapsed
+    _log4sh_updateSeconds
+
+    _l_oldIFS=${IFS} IFS=${__LOG4SH_IFS_DEFAULT}
+    for _l_appenderIndex in ${__log4shAppenderCounts}; do
+      ${__LOG4SH_TRACE} &quot;_l_appenderIndex='${_l_appenderIndex}'&quot;
+      # determine appender level
+      _l_appenderLevel=`_appender_getLevelByIndex ${_l_appenderIndex}`
+      if [ &quot;${_l_appenderLevel}&quot; = &quot;${__LOG4SH_NULL}&quot; ]; then
+        # continue if requested is level less than general level
+        [ ! ${__log4shLevel} -le ${_l_levelInt} ] &amp;&amp; continue
+      else
+        _l_appenderLevelInt=`logger_level_toInt ${_l_appenderLevel}`
+        # continue if requested level is less than specific appender level
+        ${__LOG4SH_TRACE} &quot;_l_levelInt='${_l_levelInt}' _l_appenderLevelInt='${_l_appenderLevelInt}'&quot;
+        [ ! ${_l_appenderLevelInt} -le ${_l_levelInt} ] &amp;&amp; continue
+      fi
+
+      # execute dynamic appender function
+      _l_appenderName=`_log4sh_getArrayElement \
+        &quot;${__log4shAppenders}&quot; ${_l_appenderIndex}`
+      ${__LOG4SH_APPENDER_FUNC_PREFIX}${_l_appenderName}_append ${_l_level} &quot;${_l_msg}&quot;
+    done
+    IFS=${_l_oldIFS}
+  else
+    _log4sh_error &quot;invalid logging level requested (${_l_level})&quot;
+    __log4sh_return=${__LOG4SH_ERROR}
+  fi
+
+  unset _l_msg _l_oldIFS _l_level _l_levelInt
+  unset _l_appenderIndex _l_appenderLevel _l_appenderLevelInt _l_appenderName
+  return ${__log4sh_return}
+}
+
+#/**
+# &lt;s:function group=&quot;Logger&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;logger_trace&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string[] &lt;parameter&gt;message&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;This is a helper function for logging a message at the TRACE
+#     priority&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;logger_trace 'This is a trace message'&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+logger_trace()
+{
+  log ${__LOG4SH_LEVEL_TRACE_STR} &quot;$@&quot;
+}
+
+#/**
+# &lt;s:function group=&quot;Logger&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;logger_debug&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string[] &lt;parameter&gt;message&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;This is a helper function for logging a message at the DEBUG
+#     priority&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;logger_debug 'This is a debug message'&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+logger_debug()
+{
+  log ${__LOG4SH_LEVEL_DEBUG_STR} &quot;$@&quot;
+}
+
+#/**
+# &lt;s:function group=&quot;Logger&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;logger_info&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string[] &lt;parameter&gt;message&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;This is a helper function for logging a message at the INFO
+#     priority&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;logger_info 'This is a info message'&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+logger_info()
+{
+  log ${__LOG4SH_LEVEL_INFO_STR} &quot;$@&quot;
+}
+
+#/**
+# &lt;s:function group=&quot;Logger&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;logger_warn&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string[] &lt;parameter&gt;message&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;
+#     This is a helper function for logging a message at the WARN priority
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;logger_warn 'This is a warn message'&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+logger_warn()
+{
+  log ${__LOG4SH_LEVEL_WARN_STR} &quot;$@&quot;
+}
+
+#/**
+# &lt;s:function group=&quot;Logger&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;logger_error&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string[] &lt;parameter&gt;message&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;
+#     This is a helper function for logging a message at the ERROR priority
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;logger_error 'This is a error message'&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+logger_error()
+{
+  log ${__LOG4SH_LEVEL_ERROR_STR} &quot;$@&quot;
+}
+
+#/**
+# &lt;s:function group=&quot;Logger&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;logger_fatal&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string[] &lt;parameter&gt;message&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;This is a helper function for logging a message at the FATAL
+#     priority&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;logger_fatal 'This is a fatal message'&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+logger_fatal()
+{
+  log ${__LOG4SH_LEVEL_FATAL_STR} &quot;$@&quot;
+}
+
+#==============================================================================
+# Property
+#
+
+#/**
+# &lt;s:function group=&quot;Property&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_log4sh_getPropPrefix&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;property&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Takes a string (eg. &quot;log4sh.appender.stderr.File&quot;) and returns the
+#   prefix of it (everything before the first '.' char). Normally used in
+#   parsing the log4sh configuration file.&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;prefix=`_log4sh_getPropPrefix $property&quot;`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_log4sh_getPropPrefix()
+{
+  _oldIFS=${IFS} IFS='.'
+  set -- $1
+  IFS=${_oldIFS} unset _oldIFS
+  echo $1
+}
+
+#/**
+# &lt;s:function group=&quot;Property&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_log4sh_stripPropPrefix&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;property&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Strips the prefix off a property configuration command and returns
+#   the string. E.g. &quot;log4sh.appender.stderr.File&quot; becomes
+#   &quot;appender.stderr.File&quot;.&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;newProperty=`_log4sh_stripPropPrefix $property`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_log4sh_stripPropPrefix()
+{
+  expr &quot;$1&quot; : '[^.]*\.\(.*\)'
+}
+
+#/**
+# &lt;s:function group=&quot;Property&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_log4sh_propAlternative&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;property&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;value&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;
+#     Configures log4sh to use an alternative command.
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;_log4sh_propAlternative property value&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_log4sh_propAlternative()
+{
+  _lpa_key=$1
+  _lpa_value=$2
+
+  # strip the leading 'alternative.'
+  _lpa_alternative=`_log4sh_stripPropPrefix ${_lpa_key}`
+
+  # set the alternative
+  log4sh_setAlternative ${_lpa_alternative} &quot;${_lpa_value}&quot;
+
+  unset _lpa_key _lpa_value _lpa_alternative
+}
+
+#/**
+# &lt;s:function group=&quot;Property&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;/boolean
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_log4sh_propAppender&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;property&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;value&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Configures log4sh using an appender property configuration statement&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;_log4sh_propAppender $property $value&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_log4sh_propAppender()
+{
+  _lpa_key=$1
+  _lpa_value=$2
+
+  _lpa_appender=''
+  _lpa_rtrn=${__LOG4SH_TRUE}
+
+  # strip the leading 'appender' keyword prefix
+  _lpa_key=`_log4sh_stripPropPrefix ${_lpa_key}`
+
+  # handle appender definitions
+  if [ &quot;${_lpa_key}&quot; '=' &quot;`expr \&quot;${_lpa_key}\&quot; : '\([^.]*\)'`&quot; ]; then
+    _lpa_appender=&quot;${_lpa_key}&quot;
+  else
+    _lpa_appender=`_log4sh_getPropPrefix ${_lpa_key}`
+  fi
+
+  # does the appender exist?
+  appender_exists ${_lpa_appender}
+  if [ $? -eq ${__LOG4SH_FALSE} ]; then
+    _log4sh_error &quot;attempt to configure the non-existant appender (${_lpa_appender})&quot;
+    unset _lpa_appender _lpa_key _lpa_value
+    return ${__LOG4SH_ERROR}
+  fi
+
+  # handle the appender type
+  if [ &quot;${_lpa_appender}&quot; = &quot;${_lpa_key}&quot; ]; then
+    case ${_lpa_value} in
+      ${__LOG4SH_TYPE_CONSOLE}|\
+      ${__LOG4SH_CONFIG_LOG4J_CP}.${__LOG4SH_TYPE_CONSOLE})
+        appender_setType ${_lpa_appender} ${__LOG4SH_TYPE_CONSOLE} ;;
+      ${__LOG4SH_TYPE_FILE}|\
+      ${__LOG4SH_CONFIG_LOG4J_CP}.${__LOG4SH_TYPE_FILE})
+        appender_setType ${_lpa_appender} ${__LOG4SH_TYPE_FILE} ;;
+      $__LOG4SH_TYPE_DAILY_ROLLING_FILE|\
+      ${__LOG4SH_CONFIG_LOG4J_CP}.${__LOG4SH_TYPE_DAILY_ROLLING_FILE})
+        appender_setType ${_lpa_appender} ${__LOG4SH_TYPE_DAILY_ROLLING_FILE} ;;
+      ${__LOG4SH_TYPE_ROLLING_FILE}|\
+      ${__LOG4SH_CONFIG_LOG4J_CP}.${__LOG4SH_TYPE_ROLLING_FILE})
+        appender_setType ${_lpa_appender} ${__LOG4SH_TYPE_ROLLING_FILE} ;;
+      ${__LOG4SH_TYPE_SMTP}|\
+      ${__LOG4SH_CONFIG_LOG4J_CP}.${__LOG4SH_TYPE_SMTP})
+        appender_setType $_lpa_appender ${__LOG4SH_TYPE_SMTP} ;;
+      ${__LOG4SH_TYPE_SYSLOG}|\
+      ${__LOG4SH_CONFIG_LOG4J_CP}.${__LOG4SH_TYPE_SYSLOG})
+        appender_setType $_lpa_appender ${__LOG4SH_TYPE_SYSLOG} ;;
+      *)
+        _log4sh_error &quot;appender type (${_lpa_value}) unrecognized&quot;
+        false
+        ;;
+    esac
+    [ $? -ne ${__LOG4SH_TRUE} ] &amp;&amp; _lpa_rtrn=${__LOG4SH_ERROR}
+    __log4sh_return=${_lpa_rtrn}
+    unset _lpa_appender _lpa_key _lpa_rtrn _lpa_value
+    return ${__log4sh_return}
+  fi
+
+  # handle appender values and methods
+  _lpa_key=`_log4sh_stripPropPrefix ${_lpa_key}`
+  if [ &quot;${_lpa_key}&quot; '=' &quot;`expr \&quot;${_lpa_key}\&quot; : '\([^.]*\)'`&quot; ]; then
+    case ${_lpa_key} in
+      # General
+      Threshold) appender_setLevel ${_lpa_appender} &quot;${_lpa_value}&quot; ;;
+      layout) appender_setLayout ${_lpa_appender} &quot;${_lpa_value}&quot; ;;
+
+      # FileAppender
+      DatePattern) ;;  # unsupported
+      File)
+        _lpa_value=`eval echo &quot;${_lpa_value}&quot;`
+        appender_file_setFile ${_lpa_appender} &quot;${_lpa_value}&quot;
+        ;;
+      MaxBackupIndex)
+        appender_file_setMaxBackupIndex ${_lpa_appender} &quot;${_lpa_value}&quot; ;;
+      MaxFileSize)
+        appender_file_setMaxFileSize ${_lpa_appender} &quot;${_lpa_value}&quot; ;;
+
+      # SMTPAppender
+      To) appender_smtp_setTo ${_lpa_appender} &quot;${_lpa_value}&quot; ;;
+      Subject) appender_smtp_setSubject ${_lpa_appender} &quot;${_lpa_value}&quot; ;;
+
+      # SyslogAppender
+      SyslogHost) appender_syslog_setHost ${_lpa_appender} &quot;${_lpa_value}&quot; ;;
+      Facility) appender_syslog_setFacility ${_lpa_appender} &quot;${_lpa_value}&quot; ;;
+
+      # catch unrecognized
+      *)
+        _log4sh_error &quot;appender value/method (${_lpa_key}) unrecognized&quot;
+        false
+        ;;
+    esac
+    [ $? -ne ${__LOG4SH_TRUE} ] &amp;&amp; _lpa_rtrn=${__LOG4SH_ERROR}
+    __log4sh_return=${_lpa_rtrn}
+    unset _lpa_appender _lpa_key _lpa_rtrn _lpa_value
+    return ${__log4sh_return}
+  fi
+
+  # handle appender layout values and methods
+  _lpa_key=`_log4sh_stripPropPrefix ${_lpa_key}`
+  case ${_lpa_key} in
+    ConversionPattern) appender_setPattern ${_lpa_appender} &quot;${_lpa_value}&quot; ;;
+    *)
+      _log4sh_error &quot;layout value/method (${_lpa_key}) unrecognized&quot;
+      false
+      ;;
+  esac
+  [ $? -ne ${__LOG4SH_TRUE} ] &amp;&amp; _lpa_rtrn=${__LOG4SH_ERROR}
+  __log4sh_return=${_lpa_rtrn}
+  unset _lpa_appender _lpa_key _lpa_rtrn _lpa_value
+  return ${__log4sh_return}
+}
+
+#/**
+# &lt;s:function group=&quot;Property&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_log4sh_propLogger&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;property&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;value&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;(future) Configures log4sh with a &lt;code&gt;logger&lt;/code&gt; configuration
+#   statement. Sample output: &quot;logger: property value&quot;.&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;result=`_log4sh_propLogger $property $value`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_log4sh_propLogger()
+{
+  _prop=`_log4sh_stripPropPrefix $1`
+  echo &quot;logger: ${_prop} $2&quot;
+  unset _prop
+}
+
+#
+# configure log4sh with a rootLogger configuration statement
+#
+# @param  _key    configuration command
+# @param  _value  configuration value
+#
+#/**
+# &lt;s:function group=&quot;Property&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_log4sh_propRootLogger&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;rootLogger&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Configures log4sh with a &lt;code&gt;rootLogger&lt;/code&gt; configuration
+#   statement. It expects a comma separated string similar to the following:&lt;/para&gt;
+#   &lt;para&gt;&lt;code&gt;log4sh.rootLogger=ERROR, stderr, R&lt;/code&gt;&lt;/para&gt;
+#   &lt;para&gt;The first option is the default logging level to set for all
+#   of the following appenders that will be created, and all following options
+#   are the names of appenders to create. The appender names must be
+#   unique.&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;_log4sh_propRootLogger $value&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_log4sh_propRootLogger()
+{
+  __lprl_rootLogger=`echo &quot;$@&quot; |sed 's/ *, */,/g'`
+  __lprl_count=`echo &quot;${__lprl_rootLogger}&quot; |sed 's/,/ /g' |wc -w`
+  __lprl_index=1
+  while [ ${__lprl_index} -le ${__lprl_count} ]; do
+    __lprl_operand=`echo &quot;${__lprl_rootLogger}&quot; |cut -d, -f${__lprl_index}`
+    if [ ${__lprl_index} -eq 1 ]; then
+      logger_setLevel &quot;${__lprl_operand}&quot;
+    else
+      appender_exists &quot;${__lprl_operand}&quot;
+      if [ $? -eq ${__LOG4SH_FALSE} ]; then
+        logger_addAppender &quot;${__lprl_operand}&quot;
+      else
+        _log4sh_error &quot;attempt to add already existing appender of name (${__lprl_operand})&quot;
+      fi
+    fi
+    __lprl_index=`expr ${__lprl_index} + 1`
+  done
+
+  unset __lprl_count __lprl_index __lprl_operand __lprl_rootLogger
+}
+
+#/**
+# &lt;s:function group=&quot;Property&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;/boolean
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;log4sh_doConfigure&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;configFileName&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;
+#     Read configuration from a file. &lt;emphasis role=&quot;strong&quot;&gt;The existing
+#     configuration is not cleared or reset.&lt;/emphasis&gt; If you require a
+#     different behavior, then call the &lt;code&gt;log4sh_resetConfiguration&lt;/code&gt;
+#     before calling &lt;code&gt;log4sh_doConfigure&lt;/code&gt;.
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;log4sh_doConfigure myconfig.properties&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+log4sh_doConfigure()
+{
+  [ -n &quot;${FUNCNAME:-}&quot; ] \
+      &amp;&amp; ${__LOG4SH_TRACE} &quot;${FUNCNAME}()${BASH_LINENO:+'(called from ${BASH_LINENO})'}&quot;
+
+  # prepare the environment for configuration
+  log4sh_resetConfiguration
+
+  ldc_file=$1
+  ldc_rtrn=${__LOG4SH_TRUE}
+
+  # strip the config prefix and dump output to a temporary file
+  ldc_tmpFile=&quot;${__log4sh_tmpDir}/properties&quot;
+  ${__LOG4SH_TRACE} &quot;__LOG4SH_CONFIG_PREFIX='${__LOG4SH_CONFIG_PREFIX}'&quot;
+  grep &quot;^${__LOG4SH_CONFIG_PREFIX}\.&quot; &quot;${ldc_file}&quot; &gt;&quot;${ldc_tmpFile}&quot;
+
+  # read the file in. using a temporary file and a file descriptor here instead
+  # of piping the file into the 'while read' because the pipe causes a fork
+  # under some shells which makes it impossible to get the variables passed
+  # back to the parent script.
+  exec 3&lt;&amp;0 &lt;&quot;${ldc_tmpFile}&quot;
+  while read ldc_line; do
+    ldc_key=`expr &quot;${ldc_line}&quot; : '\([^= ]*\) *=.*'`
+    ldc_value=`expr &quot;${ldc_line}&quot; : '[^= ]* *= *\(.*\)'`
+
+    # strip the leading 'log4sh.'
+    ldc_key=`_log4sh_stripPropPrefix ${ldc_key}`
+    ldc_keyword=`_log4sh_getPropPrefix ${ldc_key}`
+    case ${ldc_keyword} in
+      alternative) _log4sh_propAlternative ${ldc_key} &quot;${ldc_value}&quot; ;;
+      appender) _log4sh_propAppender ${ldc_key} &quot;${ldc_value}&quot; ;;
+      logger) _log4sh_propLogger ${ldc_key} &quot;${ldc_value}&quot; ;;
+      rootLogger) _log4sh_propRootLogger &quot;${ldc_value}&quot; ;;
+      *)
+        _log4sh_error &quot;unrecognized properties keyword (${ldc_keyword})&quot;
+        false
+        ;;
+    esac
+    [ $? -ne ${__LOG4SH_TRUE} ] &amp;&amp; ldc_rtrn=${__LOG4SH_ERROR}
+  done
+  exec 0&lt;&amp;3 3&lt;&amp;-
+
+  # remove the temporary file
+  rm -f &quot;${ldc_tmpFile}&quot;
+
+  # activate all of the appenders
+  for ldc_appender in ${__log4shAppenders}; do
+    ${__LOG4SH_APPENDER_FUNC_PREFIX}${ldc_appender}_activateOptions
+  done
+
+  __log4sh_return=${ldc_rtrn}
+  unset ldc_appender ldc_file ldc_tmpFile ldc_line ldc_key ldc_keyword
+  unset ldc_value ldc_rtrn
+  return ${__log4sh_return}
+}
+
+#/**
+# &lt;s:function group=&quot;Property&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;log4sh_readProperties&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;configFileName&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;&lt;emphasis role=&quot;strong&quot;&gt;Deprecated as of 1.3.6&lt;/emphasis&gt;&lt;/para&gt;
+#   &lt;para&gt;
+#     See &lt;code&gt;log4sh_doConfigure&lt;/code&gt;.
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;log4sh_readProperties myconfig.properties&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+log4sh_readProperties()
+{
+  log4sh_doConfigure &quot;$@&quot;
+}
+
+#/**
+# &lt;s:function group=&quot;Property&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;log4sh_resetConfiguration&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;void /&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;
+#     This function completely resets the log4sh configuration to have no
+#     appenders with a global logging level of ERROR.
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;log4sh_resetConfiguration&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+# XXX if a configuration is *repeatedly* established via logger_addAppender and
+# reset using this command, there is a risk of running out of memory.
+log4sh_resetConfiguration()
+{
+  __log4shAppenders=''
+  __log4shAppenderCount=0
+  __log4shAppenderCounts=''
+  __log4shAppenderLayouts=''
+  __log4shAppenderLevels=''
+  __log4shAppenderPatterns=''
+  __log4shAppenderTypes=''
+  __log4shAppender_file_files=''
+  __log4shAppender_rollingFile_maxBackupIndexes=''
+  __log4shAppender_rollingFile_maxFileSizes=''
+  __log4shAppender_smtp_tos=''
+  __log4shAppender_smtp_subjects=''
+  __log4shAppender_syslog_facilities=''
+  __log4shAppender_syslog_hosts=''
+
+  logger_setLevel ERROR
+}
+
+#==============================================================================
+# Thread
+#
+
+#/**
+# &lt;s:function group=&quot;Thread&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;code&gt;string&lt;/code&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;logger_getThreadName&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;void /&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Gets the current thread name.&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;threadName=`logger_getThreadName`&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+logger_getThreadName()
+{
+  echo ${__log4sh_threadName}
+}
+
+#/**
+# &lt;s:function group=&quot;Thread&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;logger_setThreadName&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;threadName&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;
+#     Sets the thread name (e.g. the name of the script). This thread name can
+#     be used with the '%t' conversion character within a
+#     &lt;option&gt;PatternLayout&lt;/option&gt;.
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;logger_setThreadName &quot;myThread&quot;&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+logger_setThreadName()
+{
+  _thread=$1
+
+  _length=`_log4sh_getArrayLength &quot;$__log4sh_threadStack&quot;`
+  __log4sh_threadStack=`_log4sh_setArrayElement &quot;$__log4sh_threadStack&quot; $_length $_thread`
+  __log4sh_threadName=$_thread
+
+  unset _length _thread
+}
+
+#/**
+# &lt;s:function group=&quot;Thread&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;logger_pushThreadName&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;threadName&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;&lt;emphasis role=&quot;strong&quot;&gt;Deprecated as of 1.3.7&lt;/emphasis&gt;&lt;/para&gt;
+#   &lt;para&gt;
+#     Sets the thread name (eg. the name of the script) and pushes the old on
+#     to a stack for later use. This thread name can be used with the '%t'
+#     conversion character within a &lt;option&gt;PatternLayout&lt;/option&gt;.
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;logger_pushThreadName &quot;myThread&quot;&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+logger_pushThreadName()
+{
+  __log4sh_threadStack=`_log4sh_pushStack &quot;$__log4sh_threadStack&quot; $1`
+  __log4sh_threadName=$1
+}
+
+#/**
+# &lt;s:function group=&quot;Thread&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;logger_popThreadName&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;void /&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;&lt;emphasis role=&quot;strong&quot;&gt;Deprecated as of 1.3.7&lt;/emphasis&gt;&lt;/para&gt;
+#   &lt;para&gt;
+#     Removes the topmost thread name from the stack. The next thread name on
+#     the stack is then placed in the &lt;varname&gt;__log4sh_threadName&lt;/varname&gt;
+#     variable. If the stack is empty, or has only one element left, then a
+#     warning is given that no more thread names can be popped from the stack.
+#   &lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;logger_popThreadName&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+logger_popThreadName()
+{
+  _length=`_log4sh_getArrayLength &quot;$__log4sh_threadStack&quot;`
+  if [ $_length -gt 1 ]; then
+    __log4sh_threadStack=`_log4sh_popStack &quot;$__log4sh_threadStack&quot;`
+    __log4sh_threadName=`_log4sh_peekStack &quot;$__log4sh_threadStack&quot;`
+  else
+    echo 'log4sh:WARN no more thread names available on thread name stack.' &gt;&amp;2
+  fi
+}
+
+#==============================================================================
+# Trap
+#
+
+#/**
+# &lt;s:function group=&quot;Trap&quot; modifier=&quot;public&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;log4sh_cleanup&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;void /&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;This is a cleanup function to remove the temporary directory used by
+#   log4sh. It is provided for scripts who want to do log4sh cleanup work
+#   themselves rather than using the automated cleanup of log4sh that is
+#   invoked upon a normal exit of the script.&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;log4sh_cleanup&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+log4sh_cleanup()
+{
+  _log4sh_cleanup 'EXIT'
+}
+
+#/**
+# &lt;s:function group=&quot;Trap&quot; modifier=&quot;private&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;_log4sh_cleanup&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;signal&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;This is a cleanup function to remove the temporary directory used by
+#   log4sh. It should only be called by log4sh itself when it is taking
+#   control of traps.&lt;/para&gt;
+#   &lt;para&gt;If there was a previously defined trap for the given signal, log4sh
+#   will attempt to call the original trap handler as well so as not to break
+#   the parent script.&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcsynopsisinfo&gt;_log4sh_cleanup EXIT&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+_log4sh_cleanup()
+{
+  _lc__trap=$1
+  ${__LOG4SH_INFO} &quot;_log4sh_cleanup(): the ${_lc__trap} signal was caught&quot;
+
+  _lc__restoreTrap=${__LOG4SH_FALSE}
+  _lc__oldTrap=''
+
+  # match trap to signal value
+  case &quot;${_lc__trap}&quot; in
+    EXIT) _lc__signal=0 ;;
+    INT) _lc__signal=2 ;;
+    TERM) _lc__signal=15 ;;
+  esac
+
+  # do we possibly need to restore a previous trap?
+  if [ -r &quot;${__log4sh_trapsFile}&quot; -a -s &quot;${__log4sh_trapsFile}&quot; ]; then
+    # yes. figure out what we need to do
+    if [ `grep &quot;^trap -- &quot; &quot;${__log4sh_trapsFile}&quot; &gt;/dev/null; echo $?` -eq 0 ]
+    then
+      # newer trap command
+      ${__LOG4SH_DEBUG} 'newer POSIX trap command'
+      _lc__restoreTrap=${__LOG4SH_TRUE}
+      _lc__oldTrap=`egrep &quot;(${_lc__trap}|${_lc__signal})$&quot; &quot;${__log4sh_trapsFile}&quot; |\
+        sed &quot;s/^trap -- '\(.*\)' [A-Z]*$/\1/&quot;`
+    elif [ `grep &quot;[0-9]*: &quot; &quot;${__log4sh_trapsFile}&quot; &gt;/dev/null; echo $?` -eq 0 ]
+    then
+      # older trap command
+      ${__LOG4SH_DEBUG} 'older style trap command'
+      _lc__restoreTrap=${__LOG4SH_TRUE}
+      _lc__oldTrap=`grep &quot;^${_lc__signal}: &quot; &quot;${__log4sh_trapsFile}&quot; |\
+        sed 's/^[0-9]*: //'`
+    else
+      # unrecognized trap output
+      _log4sh_error 'unable to restore old traps! unrecognized trap command output'
+    fi
+  fi
+
+  # do our work
+  rm -fr &quot;${__log4sh_tmpDir}&quot;
+
+  # execute the old trap
+  if [ ${_lc__restoreTrap} -eq ${__LOG4SH_TRUE} -a -n &quot;${_lc__oldTrap}&quot; ]; then
+    ${__LOG4SH_INFO} 'restoring previous trap of same type'
+    eval &quot;${_lc__oldTrap}&quot;
+  fi
+
+  # exit for all non-EXIT signals
+  if [ &quot;${_lc__trap}&quot; != 'EXIT' ]; then
+    # disable the EXIT trap
+    trap 0
+
+    # add 127 to signal value and exit
+    _lc__signal=`expr ${_lc__signal} + 127`
+    exit ${_lc__signal}
+  fi
+
+  unset _lc__oldTrap _lc__signal _lc__restoreTrap _lc__trap
+  return
+}
+
+
+#==============================================================================
+# main
+#
+
+# create a temporary directory
+__log4sh_tmpDir=`_log4sh_mktempDir`
+
+# preserve old trap(s)
+__log4sh_trapsFile=&quot;${__log4sh_tmpDir}/traps&quot;
+trap &gt;&quot;${__log4sh_trapsFile}&quot;
+
+# configure traps
+${__LOG4SH_INFO} 'setting traps'
+trap '_log4sh_cleanup EXIT' 0
+trap '_log4sh_cleanup INT' 2
+trap '_log4sh_cleanup TERM' 15
+
+# alternative commands
+log4sh_setAlternative mail &quot;${LOG4SH_ALTERNATIVE_MAIL:-mail}&quot; ${__LOG4SH_TRUE}
+[ -n &quot;${LOG4SH_ALTERNATIVE_NC:-}&quot; ] \
+    &amp;&amp; log4sh_setAlternative nc &quot;${LOG4SH_ALTERNATIVE_NC}&quot;
+
+# load the properties file
+${__LOG4SH_TRACE} &quot;__LOG4SH_CONFIGURATION='${__LOG4SH_CONFIGURATION}'&quot;
+if [ &quot;${__LOG4SH_CONFIGURATION}&quot; != 'none' -a -r &quot;${__LOG4SH_CONFIGURATION}&quot; ]
+then
+  ${__LOG4SH_INFO} 'configuring via properties file'
+  log4sh_doConfigure &quot;${__LOG4SH_CONFIGURATION}&quot;
+else
+  if [ &quot;${__LOG4SH_CONFIGURATION}&quot; != 'none' ]; then
+    _log4sh_warn 'No appenders could be found.'
+    _log4sh_warn 'Please initalize the log4sh system properly.'
+  fi
+  ${__LOG4SH_INFO} 'configuring at runtime'
+
+  # prepare the environment for configuration
+  log4sh_resetConfiguration
+
+  # note: not using the constant variables here (e.g. for ConsoleAppender) so
+  # that those perusing the code can have a working example
+  logger_setLevel ${__LOG4SH_LEVEL_ERROR_STR}
+  logger_addAppender stdout
+  appender_setType stdout ConsoleAppender
+  appender_setLayout stdout PatternLayout
+  appender_setPattern stdout '%-4r [%t] %-5p %c %x - %m%n'
+fi
+
+# restore the previous set of shell flags
+for _log4sh_shellFlag in ${__LOG4SH_SHELL_FLAGS}; do
+  echo ${__log4sh_oldShellFlags} |grep ${_log4sh_shellFlag} &gt;/dev/null \
+    || set +${_log4sh_shellFlag}
+done
+unset _log4sh_shellFlag
+
+#/**
+# &lt;/s:shelldoc&gt;
+#*/

Added: trunk/freenx-redesign/server/utility/nxagent-helper
===================================================================
--- trunk/freenx-redesign/server/utility/nxagent-helper	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/utility/nxagent-helper	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,365 @@
+#!/usr/bin/python2.4
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">diamond at google.com</A> (Stephen Shirley)
+
+&quot;&quot;&quot;nxserver program for accepting nx connections.
+
+&quot;&quot;&quot;
+
+import os
+import re
+import signal
+import subprocess
+import sys
+import time
+import traceback
+
+sys.path.append('/usr/freenx/lib')
+import nxlog
+import nxloadconfig
+
+prog_name = &quot;nxagent-helper&quot;
+_COMMANDS = ( &quot;start&quot;, &quot;resume&quot; )
+state_lines = { 'starting': re.compile(r'^Session: Starting session at '),
+    'running': re.compile(r'^Session: Session (started|resumed) at '),
+    'suspending': re.compile(r'^Session: Suspending session at '),
+    'suspended': re.compile(r'^Session: Session suspended at '),
+    'terminating': re.compile(r'^Session: (Terminat|Abort)ing session at '),
+    'terminated': re.compile(r'^Session: Session (terminat|abort)ed at ')
+  }
+info_lines = { 'watchdog_pid':
+      re.compile(r&quot;^Info: Watchdog running with pid '(?P&lt;pid&gt;\d+)'.&quot;),
+    'kill_watchdog':
+      re.compile(r&quot;^Info: Waiting the watchdog process to complete.&quot;),
+    'agent_pid':
+      re.compile(r&quot;^Info: Agent running with pid '(?P&lt;pid&gt;\d+)'.&quot;),
+    'general_error':
+      re.compile(r&quot;^Error: (?P&lt;error&gt;.*)$&quot;)
+  }
+options = {}
+
+
+def main():
+  &quot;&quot;&quot;Do setup, then read and handle command&quot;&quot;&quot;
+
+  basic_setup()
+  handle_command(*read_command()) # Expand the list passed back into two
+                                  # seperate arguments.
+
+
+def basic_setup():
+  &quot;&quot;&quot;Setup logging, read configuration&quot;&quot;&quot;
+
+  nxlog.setup(prog_name)
+  nxlog.log(nxlog.LOG_DEBUG, &quot;started with pid %d\n&quot; % os.getpid())
+  nxloadconfig.setup(prog_name)
+  level = nxloadconfig.conf.get('LOG_LEVEL', '5') # Default to LOG_NOTICE
+  try:
+    nxlog.set_log_level(level)
+  except ValueError:
+    nxlog.log(nxlog.LOG_ERR, &quot;Invalid log level: %s\n&quot; % level)
+  nxlog.log(nxlog.LOG_INFO, &quot;config parsed\n&quot;)
+
+
+def read_command():
+  &quot;&quot;&quot;Read a single command from stdin, check that it's valid, return it.&quot;&quot;&quot;
+
+  raw_cmd = raw_input()
+  cmd = raw_cmd.split()
+  if len(cmd) &lt; 2:
+    nxlog.log(nxlog.LOG_CRIT, &quot;Command has invalid format: %s\n&quot; %
+        repr(raw_cmd))
+    sys.exit(1)
+  if cmd[0].lower() not in _COMMANDS:
+    nxlog.log(nxlog.LOG_CRIT, &quot;Unknown command given: %s\n&quot; % repr(raw_cmd))
+    sys.exit(1)
+  return cmd[0].lower(), cmd[1]
+
+
+def handle_command(cmd, sessionid):
+  &quot;&quot;&quot;Handle the commands received.&quot;&quot;&quot;
+
+  global options
+  nxlog.log(nxlog.LOG_DEBUG, &quot;command: %s %s\n&quot; % (cmd, sessionid))
+  #FIXME: should be using a better, non-hardcoded location
+  if cmd == 'start':
+    nxlog.log(nxlog.LOG_NOTICE, &quot;Starting session %s\n&quot; % sessionid)
+    session_dir = '/tmp/nx/S-%s' % sessionid
+    try:
+      args = [line[:-1] for line in
+          open('/tmp/nx/S-%s/args' % sessionid).readlines()]
+      nxlog.log(nxlog.LOG_NOTICE, &quot;Session args: %s\n&quot; % repr(args))
+
+      # Open the session log to pass to nxagent
+      nxagent_log = open(os.path.join(session_dir, 'session.log'), 'w')
+      options_path = os.path.join(session_dir, 'options')
+      opt_read(options_path)
+    except IOError, e:
+      nxlog.log(nxlog.LOG_ERR, &quot;Session file error: %s\n&quot; % e)
+      sys.exit(1)
+    options['dir'] = session_dir
+    cleanup()
+    os.environ['LD_LIBRARY_PATH'] = '/usr/NX/lib'
+    os.environ['DISPLAY'] = 'nx/nx,options=%s:%s' % \
+        (options_path, options['display_num'])
+    os.environ['X_AUTHORITY'] = os.path.join(session_dir, 'authority')
+    setup_xauth()
+    options['p'] = subprocess.Popen(['/usr/freenx/bin/nxagent'] + args,
+        close_fds=True, stdin=None, stdout=nxagent_log,
+        stderr=subprocess.STDOUT)
+    options['agent_pid'] = options['p'].pid
+    write_agent_pid()
+    nxlog.log(nxlog.LOG_NOTICE, &quot;Spawned nxagent pid %d\n&quot; % options['p'].pid)
+    # Don't want to propogate this to other children.
+    del os.environ['LD_LIBRARY_PATH']
+    os.environ['DISPLAY'] = ':%s' % options['display_num']
+    nxagent_log = open(os.path.join(session_dir, 'session.log'), 'r')
+    follow_log(nxagent_log)
+  elif cmd == 'resume':
+    nxlog.log(nxlog.LOG_NOTICE, &quot;Resuming session %s\n&quot; % sessionid)
+    nxlog.log(nxlog.LOG_CRIT, &quot;Session resumption not yet supported\n&quot;)
+    sys.exit(1)
+
+
+def follow_log(log):
+  &quot;&quot;&quot;Follow and parse the log of nxagent.
+
+  FIXME: Keeps track of the state of nxagent, performs actions on certain
+  state changes.
+  &quot;&quot;&quot;
+
+  try:
+    nxlog.log(nxlog.LOG_DEBUG, &quot;Following agent log\n&quot;)
+    while True:
+      line = log.readline()
+      if not line:
+        if options['p'].poll() is not None:
+          ret = options['p'].returncode
+          if ret &lt; 0:
+            nxlog.log(nxlog.LOG_NOTICE, &quot;Nxagent has exited, &quot;
+                &quot;killed by signal %d\n&quot; % -ret)
+          else:
+            nxlog.log(nxlog.LOG_NOTICE, &quot;Nxagent has exited: %s\n&quot; % ret)
+          break
+        time.sleep(0.5)
+        continue
+      line = line.rstrip() # Remove trailing newline
+      if match_state(line):
+        nxlog.log(nxlog.LOG_DEBUG, &quot;Matched state: %s\n&quot; % line)
+      elif match_info(line):
+        nxlog.log(nxlog.LOG_DEBUG, &quot;Matched info: %s\n&quot; % line)
+  # If any problems occur, we want to cleanup first. When we're done cleaning
+  # up, re-raise the exception.
+  except:
+    nxlog.log(nxlog.LOG_ERR, &quot;Got exception, cleaning up\n&quot;)
+    print &quot;NX&gt; 1009 Session status: terminated&quot;
+    cleanup()
+    raise
+
+  nxlog.log(nxlog.LOG_DEBUG, &quot;Finished following agent log\n&quot;)
+
+
+def match_state(line):
+  &quot;&quot;&quot;Try match the given line against a session state
+
+  Return:
+    True: the line matched
+    False: the line didn't match
+  &quot;&quot;&quot;
+
+  # Faking a static variable
+  old_state = match_state.cur_state = getattr(match_state, 'cur_state', None)
+  if not line.startswith('Session: '):
+    return False
+  for state, rx in state_lines.iteritems():
+    if rx.search(line):
+      match_state.cur_state = state
+      handle_state_change(match_state.cur_state, old_state)
+      return True
+  return False
+
+
+def match_info(line):
+  &quot;&quot;&quot;Try match the given line against an info line regex
+  
+  Return:
+    True: the line matched
+    False: the line didn't match
+  &quot;&quot;&quot;
+
+  for info, rx in info_lines.iteritems():
+    m = rx.search(line)
+    if m:
+      handle_info(info, m)
+      return True
+  return False
+
+
+def handle_state_change(cur_state, old_state):
+  &quot;&quot;&quot;Compare the current state to the previous state, and handle as 
+  appropriate
+  
+  Args:
+    cur_state: current state name
+    old_state: previous state name
+  Return:
+    None
+  &quot;&quot;&quot;
+
+  if cur_state == old_state:
+    return
+  nxlog.log(nxlog.LOG_NOTICE,&quot;Nxagent state was: %s Now: %s\n&quot; % \
+      (old_state, cur_state))
+  print &quot;NX&gt; 1009 Session status: %s&quot; % cur_state
+  sys.stdout.flush()
+  if cur_state == 'starting' and old_state is None:
+    start_app()
+  elif cur_state == 'terminated' and old_state != 'terminated':
+    nxlog.log(nxlog.LOG_NOTICE, &quot;Nxagent finished, cleaning up&quot;)
+    cleanup()
+
+
+def handle_info(info, m):
+  &quot;&quot;&quot;Execute the required response to a given info line match
+  
+  Args:
+    info: The id of the info line
+    m: The match object from the info line's regex
+  Return:
+    None
+  &quot;&quot;&quot;
+
+  if info == 'watchdog_pid':
+    options['watchdog_pid'] = int(m.group('pid'))
+    nxlog.log(nxlog.LOG_NOTICE, &quot;matched info watchdog, pid %s\n&quot; %
+        options['watchdog_pid'])
+  elif info == 'agent_pid':
+    real_agent_pid = int(m.group('pid'))
+    nxlog.log(nxlog.LOG_NOTICE, &quot;matched info agent_pid, pid %s\n&quot; %
+        real_agent_pid)
+    if options['agent_pid'] != real_agent_pid:
+      # Probably caused by nxagent being a shell script
+      nxlog.log(nxlog.LOG_WARNING, &quot;Agent pid (%s) doesn't match &quot;
+          &quot;spawned pid (%s)\n&quot; % (options['agent_pid'], real_agent_pid))
+      options['agent_pid'] = real_agent_pid
+      write_agent_pid()
+  elif info == 'kill_watchdog':
+    if 'watchdog_pid' not in options:
+      nxlog.log(nxlog.LOG_ERR, &quot;matched info kill_watchdog, &quot;
+          &quot;but no known watchdog pid\n&quot;)
+    else:
+      try:
+        os.kill(options['watchdog_pid'], signal.SIGTERM)
+      except OSError, (errno, strerror):
+        nxlog.log(nxlog.LOG_WARNING, &quot;matched info kill_watchdog, &quot;
+            &quot;got error from kill[%d]: %s\n&quot; % (errno, strerror))
+      else:
+        nxlog.log(nxlog.LOG_NOTICE, &quot;matched info kill_watchdog, sent TERM.\n&quot;)
+  elif info == 'general_error':
+    nxlog.log(nxlog.LOG_ERR, &quot;Agent error: %s&quot; % m.group('error'))
+  else:
+    # If none of the above handers match...
+    nxlog.log(nxlog.LOG_ERR, &quot;matched info %s, but failed to &quot;
+        &quot;find handler for it\n&quot; % info)
+
+
+def opt_read(opt_path):
+  &quot;&quot;&quot;Parse the nxagent options file into a dict.&quot;&quot;&quot;
+
+  global options
+  options = {}
+  #FIXME: this needs to be much more robust
+  opt_str = open(opt_path).read().rstrip()
+  opt_str, options['display_num'] = opt_str.rsplit(':', 1)
+  for pair in opt_str.split(','):
+    if pair == 'nx/nx': continue
+    name, val = pair.split('=')
+    options[name] = val
+
+
+def setup_xauth():
+  &quot;&quot;&quot;Setup Xauthority file using session cookie.&quot;&quot;&quot;
+
+  global options
+  os.system('xauth add localhost:%(display_num)s MIT-MAGIC-COOKIE-1 '
+      '%(cookie)s &amp;&gt; $X_AUTHORITY.log' % options)
+  os.system('xauth add :%(display_num)s MIT-MAGIC-COOKIE-1 %(cookie)s' % \
+      options)
+
+
+def start_app():
+  &quot;&quot;&quot;Start the session application (startkde/gnome-session/etc).&quot;&quot;&quot;
+
+  global options
+  if options['type'] in ('gnome', 'kde'):
+    app = nxloadconfig.conf['COMMAND_START_%s' % options['type'].upper()]
+  elif options['type'] == 'application':
+    app = options['application']
+  assert(app) #FIXME(diamond): handle this better
+  cmd = 'nxstart %d %s &amp;' % (options['agent_pid'], app)
+  nxlog.log(nxlog.LOG_INFO, &quot;Nxagent ready, launching app: %s&quot; % cmd)
+  log = open(os.path.join(options['dir'], 'app.log'), 'w')
+  s = subprocess.Popen(cmd, shell=True, close_fds=True,
+      stdin=None, stdout=log, stderr=subprocess.STDOUT)
+  options['app_pid'] = s.pid
+  #FIXME(diamond): check for errors here
+
+
+def cleanup():
+  &quot;&quot;&quot;Cleanup after various things (X11 locks etc).&quot;&quot;&quot;
+
+  global options
+
+  for proc in 'watchdog', 'agent', 'app':
+    pid_name = &quot;%s_pid&quot; % proc
+    if pid_name in options:
+      try:
+        os.kill(options[pid_name], signal.SIGTERM)
+      except OSError, (errno, strerror):
+        nxlog.log(nxlog.LOG_WARNING, &quot;Cleanup handler got error %d when &quot;
+            &quot;killing %s: %s\n&quot; % (errno, proc, strerror))
+      else:
+        nxlog.log(nxlog.LOG_WARNING, &quot;Cleanup handler sent TERM to %s\n&quot; % proc)
+
+  for f in ['/tmp/.X%(display_num)s-lock' % options,
+    '/tmp/.X11-unix/X%(display_num)s' % options]:
+      if os.path.exists(f):
+        os.remove(f)
+
+
+def write_agent_pid():
+  &quot;&quot;&quot;Send the agent pid to nxserver-inner&quot;&quot;&quot;
+
+  global options
+  sys.stdout.write('NX&gt; 8888 agentpid: %s\n' % options['agent_pid'])
+  sys.stdout.flush()
+
+
+if __name__ == '__main__':
+  try:
+    main()
+  except SystemExit, e:
+    sys.exit(e.code)
+  except Exception, e:
+    trace = traceback.format_exc()
+    nxlog.log(nxlog.LOG_ERR, 'Going down because exception caught '
+                             'at the top level.')
+    for line in trace.split('\n'):
+      nxlog.log(nxlog.LOG_ERR, '%s' % line)
+    sys.exit(1)


Property changes on: trunk/freenx-redesign/server/utility/nxagent-helper
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/freenx-redesign/server/utility/nxloadconfig
===================================================================
--- trunk/freenx-redesign/server/utility/nxloadconfig	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/utility/nxloadconfig	2008-03-10 22:22:58 UTC (rev 503)
@@ -1,18 +1,30 @@
 #!/bin/bash
 
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
 # nxloadconfig - Read configuration files, setup logging
 #
-# Copyright 2007 Google Inc.
-# All Rights Reserved.
 # Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">diamond at google.com</A> (Stephen Shirley)
 #
-# License: GNU GPL, version 2
-#
 # Used configuration keys:
 #
 # Used internal subfunctions:
 #
-# @sub &quot;log n&quot; log to (sys)log with loglevel n
+# @sub &quot;nxlog_log n&quot; log to (sys)log with loglevel n
 #
 # Used internal variables:
 #
@@ -33,36 +45,63 @@
 # SVN: $Id$
 #
 
+COMMAND_GETOPT=&quot;$(which getopt)&quot;
+
 # Store these for use later
-ORIG_ARGS=($@)
+ORIG_ARGS=(&quot;$@&quot;) # Initialise ORIG_ARGS as an array
 SCRIPT_NAME=$(basename $0)
 SCRIPT_DIR=$(dirname $0)
+PATH_BASE=&quot;${PATH_BASE:-/usr/freenx}&quot;
+PATH_ETC=&quot;${PATH_ETC:-$PATH_BASE/etc}&quot;
+PATH_BIN=&quot;${PATH_BIN:-$PATH_BASE/bin}&quot;
 
 
+check_command_vars() {
+	check_command_var COMMAND_START_KDE &quot;$(which startkde:-NOTFOUND)&quot;
+	check_command_var COMMAND_START_GNOME &quot;$(which gnome-session:-NOTFOUND)&quot;
+	check_command_var COMMAND_START_CDE &quot;$(which cdwm:-NOTFOUND)&quot;
+	check_command_var COMMAND_XTERM &quot;$(which xterm:-NOTFOUND)&quot;
+	check_command_var COMMAND_XAUTH &quot;$(which xauth:-NOTFOUND)&quot;
+	check_command_var COMMAND_SMBMOUNT &quot;$(which smbmount:-NOTFOUND)&quot;
+	check_command_var COMMAND_SMBUMOUNT &quot;$(which smbumount:-NOTFOUND)&quot;
+	check_command_var COMMAND_NETCAT &quot;$(which netcat:-NOTFOUND)&quot;
+	check_command_var COMMAND_SSH &quot;$(which ssh:-NOTFOUND)&quot;
+	check_command_var COMMAND_SSH_KEYGEN &quot;$(which ssh-keygen:-NOTFOUND)&quot;
+	check_command_var COMMAND_CUPSD &quot;$(which cupsd:-NOTFOUND)&quot;
+	check_command_var COMMAND_MD5SUM &quot;$(which md5sum:-NOTFOUND)&quot;
+	check_command_var NXSESSION_HOOK &quot;$(which nxsession:-NOTFOUND)&quot;
+}
+
+
+check_dir_vars() {
+	check_dir_var PATH_BASE &quot;$PATH_BASE&quot;
+	check_dir_var PATH_BIN &quot;$PATH_BASE/bin&quot;
+	check_dir_var PATH_ETC &quot;$PATH_BASE/etc&quot;
+	check_dir_var PATH_LIB &quot;$PATH_BASE/lib&quot;
+}
+
+
 parse_args() {
-	ARGS=$(/usr/bin/getopt -n &quot;$SCRIPT_NAME&quot; -o &quot;h&quot; -l &quot;config:,help&quot; -- \
-	&quot;${ORIG_ARGS[@]}&quot; 2&gt;/dev/null)
+	# Horrible hack to parse the output of getopt correctly
+	eval ARGS=(&quot;$(&quot;$COMMAND_GETOPT&quot; -n &quot;$SCRIPT_NAME&quot; -o &quot;h&quot; -l &quot;config:,help&quot; -- \
+	&quot;${ORIG_ARGS[@]:-}&quot;)&quot;)
 
-	if [ $? != 0 ]
-	then
-		# Can't grab only the error message if there's an issue, so just run it
-		# again to output the error directly.
-		/usr/bin/getopt -n &quot;$SCRIPT_NAME&quot; -o &quot;h&quot; -l &quot;config:,help&quot; -- \
-		&quot;${ORIG_ARGS[@]}&quot; &gt; /dev/null
+	if [ &quot;$?&quot; != &quot;0&quot; ]; then
+		echo &quot;Error: unable to parse arguments: \&quot;${ORIG_ARGS[@]}\&quot;&quot; &gt;&amp;2
 		exit 1
 	fi
 }
 
 
 process_args() {
-	HELP=&quot;no&quot;
+	local HELP=&quot;no&quot;
 
 	while true; do
 		case &quot;$1&quot; in
 			--config) CONF_NAME=&quot;$2&quot;; shift 2 ;;
 			-h|--help) HELP=&quot;yes&quot;; shift ;;
 			--) shift; break ;;
-			*) echo &quot;$SCRIPT_NAME: error parsing cmdline&quot; &gt;&amp;2; exit 1 ;;
+			*) echo &quot;$SCRIPT_NAME: error parsing cmdline: $@&quot; &gt;&amp;2; exit 1 ;;
 		esac
 	done
 
@@ -71,128 +110,144 @@
 
 
 usage() {
-	echo &quot;$SCRIPT_NAME - Load the FreeNX configuration variables into the environment.&quot;
-	echo &quot;Syntax: nxloadconfig -h|--help&quot;
-	echo &quot;        nxloadconfig [--config=name]&quot;
-	echo
-	echo &quot;  --config=name            Load $PATH_ETC/name.conf config file.&quot;
-	echo &quot;  -h,--help                Display this message.&quot;
+	{
+		echo &quot;$SCRIPT_NAME - Load the FreeNX configuration variables into the environment.&quot;
+		echo &quot;Syntax: nxloadconfig -h|--help&quot;
+		echo &quot;        nxloadconfig [--config=name]&quot;
+		echo
+		echo &quot;  --config=name            Load $PATH_ETC/name.conf config file.&quot;
+		echo &quot;  -h,--help                Display this message.&quot;
+	} &gt;&amp;2
 	exit 0
 }
 
 
 default_if_not_set() {
-	var=&quot;$1&quot;
-	default=&quot;$2&quot;
+	local var=&quot;$1&quot;
+	local default=&quot;$2&quot;
 
 	# Is the var set?
 	if ! declare -p &quot;$var&quot; &amp;&gt; /dev/null
 	then
 		# Var is not set, set it to the default now and return
-		declare &quot;$var&quot; &quot;$default&quot;
+		eval &quot;$var&quot;=&quot;\&quot;$default\&quot;&quot;
 		return 0
 	else
+		# Var is set, carry on
 		return 1
 	fi
 }
 
 
-check_dir_vars() {
-	check_dir_var PATH_BASE &quot;/usr/NX&quot;
-	check_dir_var PATH_BIN &quot;$PATH_BASE/bin&quot;
-	check_dir_var PATH_ETC &quot;$PATH_BASE/etc&quot;
-	check_dir_var PATH_LIB &quot;$PATH_BASE/lib&quot;
-}
-
-
 check_dir_var() {
-	var=&quot;$1&quot;
-	defdir=&quot;$2&quot;
+	local var=&quot;$1&quot;
+	local defdir=&quot;$2&quot;
 	# Gets the value of the variable named by $var
-	varval=$(eval echo \$&quot;$foo&quot;)
+	local varval=&quot;$(eval &quot;echo \&quot;\${$var:-}\&quot;&quot;)&quot;
 
-	default_if_not_set &quot;$var&quot; &quot;$defdir&quot; &amp;&amp; return
-
-	if [ ! -d &quot;$varval&quot; ]
-	then
-		log $LOG_WARNING &quot;Invalid directory variable $var: $varval&quot;
-		declare &quot;$var&quot; &quot;$defdir&quot;
+	# Only check current value if it's actually been set
+	if ! default_if_not_set &quot;$var&quot; &quot;$defdir&quot;; then
+		if [ ! -d &quot;$varval&quot; ]
+		then
+			nxlog_log $_NXLOG_LOG_WARNING &quot;Invalid directory variable $var: \&quot;$varval\&quot;&quot;
+			eval &quot;$var&quot;=&quot;\&quot;$defdir\&quot;&quot;
+		else
+			# Everything checks out.
+			return
+		fi
 	fi
 
 	if [ ! -d &quot;$defdir&quot; ]
 	then
-		log $LOG_ERR &quot;Invalid default directory variable $var: $defdir&quot;
+		nxlog_log $_NXLOG_LOG_ERR &quot;Invalid default directory variable $var: \&quot;$defdir\&quot;&quot;
 		exit 1
 	fi
 }
 
 
-check_command_vars() {
-	check_command_var COMMAND_START_KDE &quot;startkde&quot;
-	check_command_var COMMAND_START_GNOME &quot;gnome-session&quot;
-	check_command_var COMMAND_START_CDE &quot;cdwm&quot;
-	check_command_var COMMAND_XTERM &quot;xterm&quot;
-	check_command_var COMMAND_XAUTH &quot;/usr/X11R6/bin/xauth&quot;
-	check_command_var COMMAND_SMBMOUNT &quot;smbmount&quot;
-	check_command_var COMMAND_SMBUMOUNT &quot;smbumount&quot;
-	check_command_var COMMAND_NETCAT &quot;netcat&quot;
-	check_command_var COMMAND_SSH &quot;ssh&quot;
-	check_command_var COMMAND_SSH_KEYGEN &quot;ssh-keygen&quot;
-	check_command_var COMMAND_CUPSD &quot;/usr/sbin/cupsd&quot;
-	check_command_var COMMAND_MD5SUM &quot;md5sum&quot;
-}
-
-
 check_command_var() {
-	var=&quot;$1&quot;
-	defcmd=&quot;$2&quot;
+	local var=&quot;$1&quot;
+	local defcmd=&quot;$2&quot;
 	# Gets the value of the variable named by $var
-	varval=$(eval echo \$&quot;$foo&quot;)
+	local varval=$(eval echo \&quot;\${&quot;$var&quot;:-}\&quot;)
 
-	default_if_not_set &quot;$var&quot; &quot;$defcmd&quot; &amp;&amp; return
-
-	if [ ! -d &quot;$varval&quot; ]
-	then
-		log $LOG_WARNING &quot;Invalid directory variable $var: $varval&quot;
-		declare &quot;$var&quot; &quot;$defdir&quot;
+	# Only check current value if it's actually been set
+	if ! default_if_not_set &quot;$var&quot; &quot;$defcmd&quot;; then
+		if [ ! -x &quot;$varval&quot; -o ! -f &quot;$varval&quot; ]
+		then
+			nxlog_log $_NXLOG_LOG_WARNING &quot;Invalid command variable $var: \&quot;$varval\&quot;&quot;
+			eval &quot;$var&quot;=&quot;\&quot;$defcmd\&quot;&quot;
+		else
+			# Everything checks out.
+			return
+		fi
 	fi
 
-	if [ ! -d &quot;$defdir&quot; ]
-	then
-		log $LOG_ERR &quot;Invalid default directory variable $var: $defdir&quot;
-		exit 1
+	# If the default is empty, it probably means the executable couldn't be found.
+	if [ &quot;$defcmd&quot; = &quot;&quot; ]; then
+		eval &quot;$var&quot;=&quot;\&quot;NOTFOUND\&quot;&quot;
+	else
+		if [ ! -x &quot;$defcmd&quot; -o ! -f &quot;$defcmd&quot; ]
+		then
+			nxlog_log $_NXLOG_LOG_ERR &quot;Invalid default command variable $var: \&quot;$defcmd\&quot;&quot;
+			exit 1
+		fi
 	fi
 }
 
 
 load_file() {
-	file=&quot;$1&quot;
+	local file=&quot;$1&quot;
 
-	if [ -f &quot;$file&quot; ]
-	then
-		. &quot;$file&quot;
-	else
-		echo &quot;$SCRIPT_NAME: no such file or directory: \&quot;$file\&quot;&quot; &gt;&amp;2; exit 1;
+	set -- # Clear arguments before sourcing
+	# Depend on the file being in in $PATH, or a path specified
+	if ! . &quot;$file&quot;; then
+		echo &quot;$SCRIPT_NAME: error sourcing \&quot;$file\&quot;: ${err:-}&quot; &gt;&amp;2
+		echo &quot;PATH: $PATH&quot; &gt;&amp;2
+		exit 1
 	fi
 }
 
-parse_args
-eval set -- &quot;$ARGS&quot;
-process_args &quot;$@&quot;
+nxloadconfig_main() {
+	parse_args
+	process_args &quot;${ARGS[@]}&quot;
 
-# Load logging fuctionality
-LOG_LEVEL=$LOG_WARNING
-load_file &quot;$SCRIPT_DIR/nxlog&quot;
+	# Load general configuration
+	load_file &quot;$PATH_ETC/general.conf&quot;
 
-# Load general configuration
-load_file &quot;$PATH_ETC/general.conf&quot;
-# Load function-specific configuration
-[ -n &quot;$CONF_NAME&quot; ] &amp;&amp; load_file &quot;$PATH_ETC/$CONF_NAME.conf&quot;
+	# Load logging fuctionality
+	LOG_LEVEL=&quot;${LOG_LEVEL:-WARNING}&quot;
+	load_file &quot;nxlog&quot;
 
-check_dir_vars
-check_command_vars
+	# Load function-specific configuration
+	[ -n &quot;${CONF_NAME:-}&quot; -a -e &quot;$PATH_ETC/${CONF_NAME:-}.conf&quot; ] &amp;&amp; \
+		load_file &quot;$PATH_ETC/$CONF_NAME.conf&quot;
 
-log $LOG_DEBUG &quot;called with cmdline: ${ORIG_ARGS[@]}&quot;
+	# In case the function-specific config updates $LOG_LEVEL
+	_nxlog_set_log_level
 
+	check_dir_vars
+	check_command_vars
+	default_if_not_set &quot;NX_VERSION&quot; &quot;3.0.0&quot;
+	default_if_not_set &quot;NX_LICENSE&quot; &quot;GPL&quot;
 
+	nxlog_log $_NXLOG_LOG_DEBUG &quot;called with cmdline: ${ORIG_ARGS[@]:-}&quot;
+
+	if [ -z &quot;${UNITTESTING:-}&quot; ]; then
+		# Unset functions that aren't useful outside of nxloadconfig
+		unset check_command_vars
+		unset check_dir_vars
+		unset parse_args
+		unset process_args
+		unset usage
+		unset nxloadconfig_main
+	fi
+}
+
+if [ -z &quot;${UNITTESTING:-}&quot; ]; then
+	nxloadconfig_main
+fi
+
+true # So sourcing the file will return 0 if everything is ok.
+
 # vim: ts=8 noexpandtab sw=8 softtabstop=0

Added: trunk/freenx-redesign/server/utility/nxloadconfig-helper.sh
===================================================================
--- trunk/freenx-redesign/server/utility/nxloadconfig-helper.sh	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/utility/nxloadconfig-helper.sh	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">diamond at google.com</A> (Stephen Shirley)
+
+for i in $(env | cut -f1 -d=); do
+  declare +x &quot;$i&quot; # Unexport all variables
+done
+set -a
+. &quot;$1&quot;
+set +a
+env | grep -v &quot;^_=&quot;


Property changes on: trunk/freenx-redesign/server/utility/nxloadconfig-helper.sh
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/freenx-redesign/server/utility/nxlog
===================================================================
--- trunk/freenx-redesign/server/utility/nxlog	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/utility/nxlog	2008-03-10 22:22:58 UTC (rev 503)
@@ -1,13 +1,25 @@
 #!/bin/bash
 
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
 # nxlog - Provides functions for logging to syslog
 #
-# Copyright 2007 Google Inc.
-# All Rights Reserved.
-# Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">diamond at google.com</A> (Stephen Shirley)
+# Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">alriddoch at google.com</A> (Alistair Riddoch)
 #
-# License: GNU GPL, version 2
-#
 # Used configuration keys:
 #
 # Used internal subfunctions:
@@ -20,7 +32,8 @@
 #
 # Used external programs:
 #
-# @ext logger - a shell command interface to the syslog(3) system log module
+# @ext log4sh - a shell logging library interface with support for the
+#               syslog(3) system log module
 #
 # Accepted protocol requests from client:
 #
@@ -31,81 +44,119 @@
 # SVN: $Id$
 #
 
-LOG_EMERG=0
-LOG_ALERT=1
-LOG_CRIT=2
-LOG_ERR=3
-LOG_WARNING=4
-LOG_NOTICE=5
-LOG_INFO=6
-LOG_DEBUG=7
+_NXLOG_LOG_EMERG=0
+_NXLOG_LOG_ALERT=1
+_NXLOG_LOG_CRIT=2
+_NXLOG_LOG_ERR=3
+_NXLOG_LOG_WARNING=4
+_NXLOG_LOG_NOTICE=5
+_NXLOG_LOG_INFO=6
+_NXLOG_LOG_DEBUG=7
 
-
-log()
+_nxlog_log_level_2_log4sh()
 {
-	PRIORITY=&quot;$1&quot;
-	if [ &quot;$LOG_LEVEL&quot; -ge &quot;$PRIORITY&quot; ]
-	then
-		shift
-		[ &quot;$1&quot; = &quot;-n&quot; ] &amp;&amp; shift
-		ARGS=&quot;$@&quot;
-		[ -n &quot;$ARGS&quot; ] || ARGS=&quot;No arguments supplied to log()&quot;
-		logger -p &quot;syslog.$PRIORITY&quot; -t &quot;$SCRIPT_NAME&quot; -- &quot;$ARGS&quot;
-	fi
+	local def_lev=&quot;INFO&quot;
+	case &quot;$1&quot; in
+		$_NXLOG_LOG_EMERG|EMERG) echo FATAL ;;
+		$_NXLOG_LOG_ALERT|ALERT) echo FATAL ;;
+		$_NXLOG_LOG_CRIT|CRIT) echo ERROR ;;
+		$_NXLOG_LOG_ERR|ERR) echo ERROR ;;
+		$_NXLOG_LOG_WARNING|WARNING) echo WARN ;;
+		$_NXLOG_LOG_NOTICE|NOTICE) echo INFO ;;
+		$_NXLOG_LOG_INFO|INFO) echo INFO ;;
+		$_NXLOG_LOG_DEBUG|DEBUG) echo DEBUG ;;
+		*)
+			nxlog_log ERR &quot;_nxlog_log_level_2_log4sh: Invalid log level \&quot;$1\&quot;, defaulting to \&quot;$def_lev\&quot;&quot;
+			echo &quot;$def_lev&quot;
+		;;
+	esac
 }
 
-
-log_tee()
+_nxlog_set_log_level()
 {
-	PRIORITY=&quot;$1&quot;
-	while read -r; do
-		[ -n &quot;$REPLY&quot; ] &amp;&amp; log &quot;$PRIORITY&quot; &quot;$REPLY&quot;
-		echo &quot;$REPLY&quot;
-	done
+	logger_setLevel `_nxlog_log_level_2_log4sh $LOG_LEVEL`
 }
 
+_nxlog_import_log4sh()
+{
+	# If the library is already imported, return.
+	[ -n &quot;${__LOG4SH_VERSION:-}&quot; ] &amp;&amp; return
 
-echo_x()
-{
-	echo &quot;$@&quot;
-	case &quot;$NX_LOG_PROG&quot; in
-		&quot;nxserver&quot;) prefix=&quot;(s&gt;c)&quot; ;;
-		&quot;nxnode&quot;) prefix=&quot;(n&gt;s)&quot; ;;
-		*) prefix=&quot;(?&gt;?)&quot; ;;
-	esac
-        log $LOG_INFO &quot;$prefix $@&quot;
+	# Look for the library in our current location
+	_NXLOG_LOG4SH=&quot;$(cd $(dirname $1) &amp;&amp; pwd -L)/log4sh&quot;
+
+	# If it is not there, look for it on the PATH
+	[ -f &quot;$_NXLOG_LOG4SH&quot; ] || _NXLOG_LOG4SH='log4sh'
+
+	# Source the library with no configuration
+	LOG4SH_CONFIGURATION='none' . $_NXLOG_LOG4SH
 }
 
+_nxlog_setup_log4sh()
+{
+	# Import the log4sh library if necessary
+	_nxlog_import_log4sh &quot;$1&quot;
+	# Reset the configuration
+	log4sh_resetConfiguration
 
-read_x()
-{
-	read -t 10 &quot;$@&quot;
-	case &quot;$NX_LOG_PROG&quot; in
-		&quot;nxserver&quot;) prefix=&quot;(s&lt;c)&quot; ;;
-		&quot;nxnode&quot;) prefix=&quot;(n&lt;s)&quot; ;;
-		*) prefix=&quot;(?&lt;?)&quot; ;;
-	esac
-        log $LOG_INFO &quot;$prefix $REPLY&quot;
+	# Set the level up for INFO by default
+	[ -n &quot;${LOG_LEVEL:-}&quot; ] || LOG_LEVEL=$_NXLOG_LOG_INFO
+
+	# Set the log level
+	_nxlog_set_log_level
+
+	# Set up the syslog as the only appender
+	logger_addAppender syslog
+	logger_setFilename &quot;$SCRIPT_NAME&quot;
+	appender_setType syslog SyslogAppender
+	appender_syslog_setFacility syslog daemon
+
+  # Allow tests etc to setup extra logging
+  if declare -f &quot;${setup_extra_logging:-}&quot; &amp;&gt;/dev/null; then
+    &quot;$setup_extra_logging&quot;
+  fi
 }
 
-
-read_x_prompt() 
+nxlog_log()
 {
-	echo_x -n &quot;$1&quot;
+	PRIORITY=&quot;$1&quot;
+	if [ &quot;$#&quot; -le &quot;1&quot; ]
+	then
+		return
+	fi
 	shift
-	read_x &quot;$@&quot;
+	log `_nxlog_log_level_2_log4sh $PRIORITY` &quot;$@&quot;
 }
 
-
-if [ &quot;$#&quot; = &quot;0&quot; -a &quot;$SCRIPT_NAME&quot; = &quot;nxlog&quot; ]
-then
+nxlog_log_pipe()
+{
+	PRIORITY=&quot;$1&quot;
 	while read
 	do
-		log $line # no &quot;&quot; here to have it split up in different levels
+		nxlog_log &quot;$PRIORITY&quot; ${NXLOG_LOG_PIPE_PREFIX:-} $REPLY
 	done
+}
+
+[ -n &quot;${SCRIPT_NAME:-}&quot; ] || SCRIPT_NAME=&quot;$(basename $0)&quot;
+
+_nxlog_setup_log4sh &quot;$0&quot;
+
+if [ &quot;$#&quot; -le &quot;1&quot; ]
+then
+	# If we are being run rather than sourced, read log data in from
+	# stdin.
+	if [ &quot;$SCRIPT_NAME&quot; = &quot;nxlog&quot; ]
+	then
+		if [ &quot;$#&quot; = &quot;1&quot; ]; then
+			PRIORITY=&quot;$1&quot;
+			shift
+		else
+			PRIORITY=INFO
+		fi
+
+		nxlog_log_pipe &quot;$PRIORITY&quot;
+	fi
 else
-	log &quot;$@&quot;
+	# If we are being run with arguments, log using the arguments.
+	nxlog_log &quot;$@&quot;
 fi
-
-
-# vim: ts=8 noexpandtab sw=8 softtabstop=0

Added: trunk/freenx-redesign/server/utility/nxserver-suid.c
===================================================================
--- trunk/freenx-redesign/server/utility/nxserver-suid.c	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/utility/nxserver-suid.c	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,142 @@
+/*
+ * Copyright 2007 Google Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Author: <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">alriddoch at google.com</A> (Alistair Riddoch)
+ */
+
+#include &lt;sys/types.h&gt;
+#include &lt;sys/socket.h&gt;
+
+#include &lt;unistd.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;pwd.h&gt;
+#include &lt;syslog.h&gt;
+#include &lt;string.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;libgen.h&gt;
+
+#include &lt;assert.h&gt;
+
+char * prgname = NULL;
+
+#define STRING_BUFLEN 512
+#define NXNODE_COMMAND &quot;nxnode&quot;
+#define NXSERVER_COMMAND &quot;nxserver&quot;
+
+int launch_nxnode(uid_t user, int comm_fd)
+{
+    // This program is being run setuid, so we can now drop back to
+    // the ruid which should be the original user.
+    if (seteuid(user) != 0) {
+        syslog(LOG_ERR, &quot;ERROR: Unable to drop back to calling userid: %m\n&quot;);
+        return 1;
+    }
+
+    // Disassociate from the terminal connected to the client that we were
+    // invoked from.
+    setsid();
+
+    // Close stdio, and reconnected it to a socket via which we can
+    // communicate with nxserver.
+    close(STDIN_FILENO);
+    close(STDOUT_FILENO);
+    close(STDERR_FILENO);
+
+    dup2(comm_fd, STDIN_FILENO);
+    dup2(comm_fd, STDOUT_FILENO);
+    dup2(comm_fd, STDERR_FILENO);
+
+    return execlp(NXNODE_COMMAND, NXNODE_COMMAND, NULL);
+}
+
+int launch_nxserver(const char * username, int comm_fd, int argc, char ** argv)
+{
+    size_t env_string_length;
+    char * env_string;
+    char ** new_argv;
+    int i;
+
+    env_string_length = snprintf(0, 0, &quot;%s=%s&quot;,
+                                 &quot;NX_TRUSTED_USER&quot;, username);
+    env_string = malloc(env_string_length + 1);
+    assert(env_string != NULL);
+    sprintf(env_string, &quot;%s=%s&quot;, &quot;NX_TRUSTED_USER&quot;, username);
+    putenv(env_string);
+
+    env_string_length = snprintf(0, 0, &quot;%s=%d&quot;,
+                                 &quot;NX_COMMFD&quot;, comm_fd);
+    env_string = malloc(env_string_length + 1);
+    assert(env_string != NULL);
+    sprintf(env_string, &quot;%s=%d&quot;, &quot;NX_COMMFD&quot;, comm_fd);
+    putenv(env_string);
+
+    new_argv = calloc(argc + 1, sizeof(char *));
+    new_argv[0] = NXSERVER_COMMAND;
+
+    for (i = 1; i &lt; argc; ++i) {
+        new_argv[i] = argv[i];
+    }
+
+    return execvp(NXSERVER_COMMAND, new_argv);
+}
+
+int main(int argc, char ** argv)
+{
+    prgname = basename(strdup(argv[0]));
+
+    openlog(prgname, LOG_PID, LOG_USER);
+
+    uid_t calling_uid = getuid();
+
+    if (geteuid() == calling_uid) {
+        syslog(LOG_WARNING, &quot;WARNING: Not running suid.\n&quot;);
+    }
+
+    struct passwd calling_user;
+    struct passwd * ret;
+    char user_string_buffer[STRING_BUFLEN];
+    errno = 0;
+
+    if (getpwuid_r(calling_uid, &amp;calling_user, &amp;user_string_buffer[0],
+                   STRING_BUFLEN, &amp;ret) != 0) {
+        syslog(LOG_ERR, &quot;ERROR: Unable to get passwd entry for calling user %d: %m\n&quot;, calling_uid);
+        return 1;
+    }
+
+    int sockets[2];
+
+    if (socketpair(AF_UNIX, SOCK_STREAM, 0, sockets) != 0) {
+        syslog(LOG_ERR, &quot;FATAL: Socket error: %m&quot;);
+        return 1;
+    }
+
+    pid_t child = fork();
+
+    if (child &lt; 0) {
+        syslog(LOG_ERR, &quot;FATAL: Fork error: %m&quot;);
+        return 1;
+    }
+
+    if (child == 0) {
+        close(sockets[1]);
+        return launch_nxnode(calling_uid, sockets[0]);
+    }
+
+    close(sockets[0]);
+    return launch_nxserver(calling_user.pw_name, sockets[1], argc, argv);
+}

Added: trunk/freenx-redesign/server/utility/shunit2
===================================================================
--- trunk/freenx-redesign/server/utility/shunit2	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/utility/shunit2	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,797 @@
+# $Id: shunit2 93 2007-07-12 22:44:31Z sfsetse $
+# vim:syntax=sh:sts=2
+# vim:foldmethod=marker:foldmarker=/**,*/
+#
+#/**
+# &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+# &lt;s:shelldoc xmlns:s=&quot;<A HREF="http://www.forestent.com/projects/shelldoc/xsl/2005.0">http://www.forestent.com/projects/shelldoc/xsl/2005.0</A>&quot;&gt;
+# &lt;s:header&gt;
+# shUnit 2.0.3
+# Shell Unit Test Framework
+#
+# <A HREF="http://shunit2.sourceforge.net/">http://shunit2.sourceforge.net/</A>
+#
+# written by Kate Ward &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">kate.ward at forestent.com</A>&gt;
+# released under the LGPL
+#
+# this module implements a xUnit based unit test framework similar to JUnit
+# &lt;/s:header&gt;
+#*/
+
+# shell flags for shunit:
+# u - treat unset variables as an error when performing parameter expansion
+__SHUNIT_SHELL_FLAGS='u'
+
+# save the current set of shell flags, and then set some for ourselves
+__shunit_oldShellFlags=&quot;$-&quot;
+for _shunit_shellFlag in `echo &quot;${__SHUNIT_SHELL_FLAGS}&quot; |sed 's/\(.\)/\1 /g'`
+do
+  set -${_shunit_shellFlag}
+done
+
+# constants
+
+__SHUNIT_VERSION='2.0.3'
+
+__SHUNIT_TRUE=0
+__SHUNIT_FALSE=1
+
+__SHUNIT_ASSERT_MSG_PREFIX='ASSERT:'
+
+for _su_const in `set |grep &quot;^__SHUNIT_&quot; |cut -d= -f1`; do
+  readonly ${_su_const}
+done
+unset _su_const
+
+# variables
+__shunit_suite=''
+
+__shunit_testsPassed=0
+__shunit_testsFailed=0
+__shunit_testsTotal=0
+
+#-----------------------------------------------------------------------------
+# assert functions
+#
+
+#/**
+# &lt;s:function group=&quot;asserts&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;assertEquals&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;[message]&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;expected&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;actual&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Asserts that &lt;emphasis&gt;expected&lt;/emphasis&gt; and
+#   &lt;emphasis&gt;actual&lt;/emphasis&gt; are equal to one another. The message is
+#   optional.&lt;/para&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+assertEquals()
+{
+  _su_message=''
+  if [ $# -eq 3 ]; then
+    _su_message=$1
+    shift
+  fi
+  _su_expected=${1:-}
+  _su_actual=${2:-}
+
+  shunit_return=${__SHUNIT_TRUE}
+  if [ &quot;${_su_expected}&quot; = &quot;${_su_actual}&quot; ]; then
+    _shunit_testPassed
+  else
+    failNotEquals &quot;${_su_message}&quot; &quot;${_su_expected}&quot; &quot;${_su_actual}&quot;
+    shunit_return=${__SHUNIT_FALSE}
+  fi
+
+  unset _su_message _su_expected _su_actual
+  return ${shunit_return}
+}
+
+#/**
+# &lt;s:function group=&quot;asserts&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;assertNull&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;[message]&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;value&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Asserts that &lt;emphasis&gt;value&lt;/emphasis&gt; is &lt;literal&gt;null&lt;/literal&gt;,
+#   or in shell terms a zero-length string. The message is optional.&lt;/para&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+assertNull()
+{
+  if [ $# -eq 2 ]; then
+    assertTrue &quot;$1&quot; &quot;[ -z '$2' ]&quot;
+  else
+    assertTrue &quot;[ -z '${1:-}' ]&quot;
+  fi
+}
+
+#/**
+# &lt;s:function group=&quot;asserts&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;assertNotNull&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;[message]&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;value&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Asserts that &lt;emphasis&gt;value&lt;/emphasis&gt; is &lt;emphasis
+#   role=&quot;strong&quot;&gt;not&lt;/emphasis&gt; &lt;literal&gt;null&lt;/literal&gt;, or in shell terms not
+#   a zero-length string. The message is optional.&lt;/para&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+assertNotNull()
+{
+  if [ $# -eq 2 ]; then
+    assertTrue &quot;$1&quot; &quot;[ -n '$2' ]&quot;
+  else
+    assertTrue &quot;[ -n '${1:-}' ]&quot;
+  fi
+}
+
+#/**
+# &lt;s:function group=&quot;asserts&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;assertSame&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;[message]&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;expected&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;actual&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;This function is functionally equivalent to
+#   &lt;function&gt;assertEquals&lt;/function&gt;.&lt;/para&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+assertSame()
+{
+  assertEquals &quot;${@:-}&quot;
+}
+
+#/**
+# &lt;s:function group=&quot;asserts&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;assertNotSame&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;[message]&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;unexpected&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;actual&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Asserts that &lt;emphasis&gt;unexpected&lt;/emphasis&gt; and
+#   &lt;emphasis&gt;actual&lt;/emphasis&gt; are &lt;emphasis role=&quot;strong&quot;&gt;not&lt;/emphasis&gt;
+#   equal to one another. The message is optional.&lt;/para&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+assertNotSame()
+{
+  _su_message=''
+  if [ $# -eq 3 ]; then
+    _su_message=$1
+    shift
+  fi
+  _su_unexpected=${1:-}
+  _su_actual=${2:-}
+
+  shunit_return=${__SHUNIT_TRUE}
+  if [ &quot;${_su_unexpected}&quot; != &quot;${_su_actual}&quot; ]; then
+    _shunit_testPassed
+  else
+    failSame &quot;${_su_message}&quot;
+    shunit_return=${__SHUNIT_FALSE}
+  fi
+
+  unset _su_message _su_unexpected _su_actual
+  return ${shunit_return}
+}
+
+#/**
+# &lt;s:function group=&quot;asserts&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;assertTrue&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;[message]&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;condition&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Asserts that a given shell test condition is true. The message is
+#   optional.&lt;/para&gt;
+#   &lt;para&gt;Testing whether something is true or false is easy enough by using
+#   the assertEquals/assertNotSame functions. Shell supports much more
+#   complicated tests though, and a means to support them was needed. As such,
+#   this function tests that conditions are true or false through evaluation
+#   rather than just looking for a true or false.&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     The following test will succeed: &lt;funcsynopsisinfo&gt;assertTrue &quot;[ 34 -gt 23 ]&quot;&lt;/funcsynopsisinfo&gt;
+#     The folloing test will fail with a message: &lt;funcsynopsisinfo&gt;assertTrue &quot;test failed&quot; &quot;[ -r '/non/existant/file' ]&quot;&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+assertTrue()
+{
+  _su_message=''
+  if [ $# -eq 2 ]; then
+    _su_message=$1
+    shift
+  fi
+  _su_condition=${1:-}
+
+  shunit_return=${__SHUNIT_TRUE}
+
+  # see if condition is an integer, i.e. a return value
+  _su_match=`expr &quot;${_su_condition}&quot; : '\([0-9]*\)'`
+  if [ -z &quot;${_su_condition}&quot; ]; then
+    # null condition
+    shunit_return=${__SHUNIT_FALSE}
+  elif [ &quot;${_su_condition}&quot; = &quot;${_su_match}&quot; ]; then
+    # possible return value. treating 0 as true, and non-zero as false.
+    [ ${_su_condition} -ne 0 ] &amp;&amp; shunit_return=${__SHUNIT_FALSE}
+  else
+    # (hopefully) a condition
+    ( eval ${_su_condition} ) &gt;/dev/null 2&gt;&amp;1
+    [ $? -ne 0 ] &amp;&amp; shunit_return=${__SHUNIT_FALSE}
+  fi
+
+  # record the test
+  if [ ${shunit_return} -eq ${__SHUNIT_TRUE} ]; then
+    _shunit_testPassed
+  else
+    _shunit_testFailed &quot;${_su_message}&quot;
+  fi
+
+  unset _su_message _su_condition _su_match
+  return ${shunit_return}
+}
+
+#/**
+# &lt;s:function group=&quot;asserts&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;assertFalse&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;[message]&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;condition&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Asserts that a given shell test condition is false. The message is
+#   optional.&lt;/para&gt;
+#   &lt;para&gt;Testing whether something is true or false is easy enough by using
+#   the assertEquals/assertNotSame functions. Shell supports much more
+#   complicated tests though, and a means to support them was needed. As such,
+#   this function tests that conditions are true or false through evaluation
+#   rather than just looking for a true or false.&lt;/para&gt;
+#   &lt;funcsynopsis&gt;
+#     The following test will succeed: &lt;funcsynopsisinfo&gt;assertFalse &quot;[ 'apples' = 'oranges' ]&quot;&lt;/funcsynopsisinfo&gt;
+#     The folloing test will fail with a message: &lt;funcsynopsisinfo&gt;assertFalse &quot;test failed&quot; &quot;[ 1 -eq 1 -a 2 -eq 2 ]&quot;&lt;/funcsynopsisinfo&gt;
+#   &lt;/funcsynopsis&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+assertFalse()
+{
+  _su_message=''
+  if [ $# -eq 2 ]; then
+    _su_message=$1
+    shift
+  fi
+  _su_condition=${1:-}
+
+  shunit_return=${__SHUNIT_TRUE}
+
+  # see if condition is an integer, i.e. a return value
+  _su_match=`expr &quot;${_su_condition}&quot; : '\([0-9]*\)'`
+  if [ -z &quot;${_su_condition}&quot; ]; then
+    # null condition
+    shunit_return=${__SHUNIT_FALSE}
+  elif [ &quot;${_su_condition}&quot; = &quot;${_su_match}&quot; ]; then
+    # possible return value. treating 0 as true, and non-zero as false.
+    [ ${_su_condition} -eq 0 ] &amp;&amp; shunit_return=${__SHUNIT_FALSE}
+  else
+    # (hopefully) a condition
+    ( eval ${_su_condition} ) &gt;/dev/null 2&gt;&amp;1
+    [ $? -eq 0 ] &amp;&amp; shunit_return=${__SHUNIT_FALSE}
+  fi
+
+  # record the test
+  if [ ${shunit_return} -eq ${__SHUNIT_TRUE} ]; then
+    _shunit_testPassed
+  else
+    _shunit_testFailed &quot;${_su_message}&quot;
+  fi
+
+  unset _su_message _su_condition _su_match
+  return ${shunit_return}
+}
+
+#-----------------------------------------------------------------------------
+# failure functions
+#
+
+#/**
+# &lt;s:function group=&quot;failures&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;fail&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;[message]&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Fails the test immediately, with the optional message.&lt;/para&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+fail()
+{
+  _su_message=${1:-}
+
+  _shunit_testFailed &quot;${_su_message}&quot;
+
+  unset _su_message
+}
+
+#/**
+# &lt;s:function group=&quot;failures&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;failNotEquals&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;[message]&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;unexpected&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;actual&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Fails the test if &lt;emphasis&gt;unexpected&lt;/emphasis&gt; and
+#   &lt;emphasis&gt;actual&lt;/emphasis&gt; are &lt;emphasis role=&quot;strong&quot;&gt;not&lt;/emphasis&gt;
+#   equal to one another. The message is optional.&lt;/para&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+failNotEquals()
+{
+  _su_message=''
+  if [ $# -eq 3 ]; then
+    _su_message=$1
+    shift
+  fi
+  _su_unexpected=${1:-}
+  _su_actual=${2:-}
+
+  _shunit_testFailed &quot;${_su_message:+${_su_message} }expected:&lt;${_su_unexpected}&gt; but was:&lt;${_su_actual}&gt;&quot;
+
+  unset _su_message _su_unexpected _su_actual
+}
+
+#/**
+# &lt;s:function group=&quot;failures&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;failSame&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;[message]&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Indicate test failure because arguments were not the same. The
+#   message is optional.&lt;/para&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+failSame()
+{
+  _su_message=${1:-}
+
+  _shunit_testFailed &quot;${_su_message:+${_su_message} }expected not same&quot;
+
+  unset _su_message
+}
+
+#/**
+# &lt;s:function group=&quot;failures&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;failNotSame&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;[message]&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;expected&lt;/parameter&gt;&lt;/paramdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;actual&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;Fails the test if &lt;emphasis&gt;expected&lt;/emphasis&gt; and
+#   &lt;emphasis&gt;actual&lt;/emphasis&gt; are equal to one another. The message is
+#   optional.&lt;/para&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+failNotSame()
+{
+  failNotEquals &quot;${@:-}&quot;
+}
+
+#-----------------------------------------------------------------------------
+# suite functions
+#
+
+#/**
+# &lt;s:function group=&quot;suites&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;suite&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef /&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;This function can be optionally overridden by the user in their test
+#   suite.&lt;/para&gt;
+#   &lt;para&gt;If this function exists, it will be called when
+#   &lt;command&gt;shunit2&lt;/command&gt; is sourced. If it does not exist, shUnit2 will
+#   search the parent script for all functions beginning with the word
+#   &lt;literal&gt;test&lt;/literal&gt;, and they will be added dynamically to the test
+#   suite.&lt;/para&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+# Note: see _shunit_mktempFunc() for actual implementation
+# suite() { :; }
+
+#/**
+# &lt;s:function group=&quot;suites&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;suite_addTest&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef&gt;string &lt;parameter&gt;function&lt;/parameter&gt;&lt;/paramdef&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;This function adds a function name to the list of tests scheduled for
+#   execution as part of this test suite. This function should only be called
+#   from within the &lt;function&gt;suite()&lt;/function&gt; function.&lt;/para&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+suite_addTest()
+{
+  _su_func=${1:-}
+
+  __shunit_suite=&quot;${__shunit_suite:+${__shunit_suite} }${_su_func}&quot;
+
+  unset _su_func
+}
+
+#/**
+# &lt;s:function group=&quot;suites&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;oneTimeSetUp&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef /&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;This function can be be optionally overridden by the user in their
+#   test suite.&lt;/para&gt;
+#   &lt;para&gt;If this function exists, it will be called once before any tests are
+#   run. It is useful to prepare a common environment for all tests.&lt;/para&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+# Note: see _shunit_mktempFunc() for actual implementation
+# oneTimeSetUp() { :; }
+
+#/**
+# &lt;s:function group=&quot;suites&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;oneTimeTearDown&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef /&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;This function can be be optionally overridden by the user in their
+#   test suite.&lt;/para&gt;
+#   &lt;para&gt;If this function exists, it will be called once after all tests are
+#   completed. It is useful to clean up the environment after all tests.&lt;/para&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+# Note: see _shunit_mktempFunc() for actual implementation
+# oneTimeTearDown() { :; }
+
+#/**
+# &lt;s:function group=&quot;suites&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;setUp&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef /&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;This function can be be optionally overridden by the user in their
+#   test suite.&lt;/para&gt;
+#   &lt;para&gt;If this function exists, it will be called before each test is run.
+#   It is useful to reset the environment before each test.&lt;/para&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+# Note: see _shunit_mktempFunc() for actual implementation
+# setUp() { :; }
+
+#/**
+# &lt;s:function group=&quot;suites&quot;&gt;
+# &lt;entry align=&quot;right&quot;&gt;
+#   &lt;emphasis&gt;void&lt;/emphasis&gt;
+# &lt;/entry&gt;
+# &lt;entry&gt;
+#   &lt;funcsynopsis&gt;
+#     &lt;funcprototype&gt;
+#       &lt;funcdef&gt;&lt;function&gt;tearDown&lt;/function&gt;&lt;/funcdef&gt;
+#       &lt;paramdef /&gt;
+#     &lt;/funcprototype&gt;
+#   &lt;/funcsynopsis&gt;
+#   &lt;para&gt;This function can be be optionally overridden by the user in their
+#   test suite.&lt;/para&gt;
+#   &lt;para&gt;If this function exists, it will be called after each test completes.
+#   It is useful to clean up the environment after each test.&lt;/para&gt;
+# &lt;/entry&gt;
+# &lt;/s:function&gt;
+#*/
+# Note: see _shunit_mktempFunc() for actual implementation
+# tearDown() { :; }
+
+#------------------------------------------------------------------------------
+# internal shUnit2 functions
+#
+
+_shunit_cleanup()
+{
+  name=$1
+
+  case ${name} in
+    EXIT) signal=0 ;;
+    INT) signal=2 ;;
+    TERM) signal=15 ;;
+  esac
+
+  # do our work
+  rm -fr &quot;${__shunit_tmpDir}&quot;
+
+  # exit for all non-EXIT signals
+  if [ ${name} != 'EXIT' ]; then
+    echo &quot;trapped and now handling the ${name} signal&quot; &gt;&amp;2
+    _shunit_generateReport
+    # disable EXIT trap
+    trap 0
+    # add 127 to signal and exit
+    signal=`expr ${signal} + 127`
+    exit ${signal}
+  fi
+}
+
+_shunit_execSuite()
+{
+  echo '#'
+  echo '# Performing tests'
+  echo '#'
+  for _su_func in ${__shunit_suite}; do
+    # execute the per-test setup function
+    setUp
+
+    # execute the test
+    echo &quot;${_su_func}&quot;
+    eval ${_su_func}
+
+    # execute the per-test tear-down function
+    tearDown
+  done
+
+  unset _su_func
+}
+
+_shunit_functionExists()
+{
+  _su__func=$1
+  type ${_su__func} 2&gt;/dev/null |grep &quot;is a function$&quot; &gt;/dev/null
+  _su__return=$?
+  unset _su__func
+  return ${_su__return}
+}
+
+_shunit_generateReport()
+{
+  _su__awkPercent='{printf(&quot;%0.0f%%&quot;, $1*100/$2)}'
+  if [ ${__shunit_testsTotal} -gt 0 ]; then
+    _su__success=`echo ${__shunit_testsPassed} ${__shunit_testsTotal} |\
+        awk &quot;${_su__awkPercent}&quot;`
+  else
+    _su__success=0
+  fi
+
+  cat &lt;&lt;EOF
+
+#
+# Test report
+#
+tests passed: ${__shunit_testsPassed}
+tests failed: ${__shunit_testsFailed}
+tests total:  ${__shunit_testsTotal}
+success rate: ${_su__success}
+EOF
+
+  unset _su__success
+}
+
+# this function is a cross-platform temporary directory creation tool. not all
+# OSes have the mktemp function, so one is included here.
+_shunit_mktempDir()
+{
+  # try the standard mktemp function
+  ( exec mktemp -dqt shunit.XXXXXX 2&gt;/dev/null ) &amp;&amp; return
+
+  # the standard mktemp didn't work.  doing our own.
+  if [ -r '/dev/urandom' ]; then
+    _su__random=`od -vAn -N4 -tx4 &lt;/dev/urandom |sed 's/^[^0-9a-f]*//'`
+  elif [ -n &quot;${RANDOM:-}&quot; ]; then
+    # $RANDOM works
+    _su__random=${RANDOM}${RANDOM}${RANDOM}$$
+  else
+    # $RANDOM doesn't work
+    _su__date=`date '+%Y%m%d%H%M%S'`
+    _su__random=`expr ${_su__date} / $$`
+  fi
+
+  _su__tmpDir=&quot;${TMPDIR-/tmp}/shunit.${_su__random}&quot;
+  ( umask 077 &amp;&amp; mkdir &quot;${_su__tmpDir}&quot; ) || {
+    echo 'shUnit:FATAL could not create temporary directory! exiting' &gt;&amp;2
+    exit 1
+  }
+
+  echo ${_su__tmpDir}
+  unset _su__date _su__random _su__tmpDir
+}
+
+# this function is here to work around issues in Cygwin
+_shunit_mktempFunc()
+{
+  for _su__func in oneTimeSetUp oneTimeTearDown setUp tearDown suite; do
+    _su__file=&quot;${__shunit_tmpDir}/${_su__func}&quot;
+    cat &lt;&lt;EOF &gt;&quot;${_su__file}&quot;
+#! /bin/sh
+exit 0
+EOF
+    chmod +x &quot;${_su__file}&quot;
+  done
+
+  unset _su__file
+}
+
+_shunit_testPassed()
+{
+  __shunit_testsPassed=`expr ${__shunit_testsPassed} + 1`
+  __shunit_testsTotal=`expr ${__shunit_testsTotal} + 1`
+}
+
+_shunit_testFailed()
+{
+  _su__msg=$1
+
+  __shunit_testsFailed=`expr ${__shunit_testsFailed} + 1`
+  __shunit_testsTotal=`expr ${__shunit_testsTotal} + 1`
+  echo &quot;${__SHUNIT_ASSERT_MSG_PREFIX}${_su__msg}&quot; &gt;&amp;2
+
+  unset _su__msg
+}
+
+#------------------------------------------------------------------------------
+# main
+#
+
+# create a temporary storage location
+__shunit_tmpDir=`_shunit_mktempDir`
+
+# setup traps to clean up after ourselves
+trap '_shunit_cleanup EXIT' 0
+trap '_shunit_cleanup INT' 2
+trap '_shunit_cleanup TERM' 15
+
+# create phantom functions to work around issues with Cygwin
+_shunit_mktempFunc
+PATH=&quot;${__shunit_tmpDir}:${PATH}&quot;
+
+# execute the oneTimeSetUp function (if it exists)
+#_shunit_functionExists oneTimeSetUp &amp;&amp; oneTimeSetUp
+oneTimeSetUp
+
+# deprecated: execute the suite function defined in the parent test script
+suite
+
+# if no suite function was defined, dynamically build a list of functions
+if [ -z &quot;${__shunit_suite}&quot; ]; then
+  funcs=`grep &quot;^[ \t]*test[A-Za-z0-9_]* *()&quot; $0 |sed 's/[^A-Za-z0-9_]//g'`
+  for func in ${funcs}; do
+    suite_addTest ${func}
+  done
+fi
+
+# execute the tests
+_shunit_execSuite
+
+# execute the oneTimeTearDown function (if it exists)
+oneTimeTearDown
+
+# generate report
+_shunit_generateReport
+
+# restore the previous set of shell flags
+for _shunit_shellFlag in ${__SHUNIT_SHELL_FLAGS}; do
+  echo ${__shunit_oldShellFlags} |grep ${_shunit_shellFlag} &gt;/dev/null \
+    || set +${_shunit_shellFlag}
+done
+unset _shunit_shellFlag
+
+#/**
+# &lt;/s:shelldoc&gt;
+#*/


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000628.html">[Freenx-cvs] r502 - / tags trunk
</A></li>
	<LI>Next message: <A HREF="000629.html">[Freenx-cvs] r504 - in tags: . nx-utils nxcl qtnx
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#670">[ date ]</a>
              <a href="thread.html#670">[ thread ]</a>
              <a href="subject.html#670">[ subject ]</a>
              <a href="author.html#670">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/freenx-cvs">More information about the Freenx-cvs
mailing list</a><br>
</body></html>
