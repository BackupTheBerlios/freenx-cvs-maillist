<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Freenx-cvs] r62 - / freenx-server freenx-server/CVS
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/freenx-cvs/2005-July/index.html" >
   <LINK REL="made" HREF="mailto:freenx-cvs%40lists.berlios.de?Subject=Re%3A%20%5BFreenx-cvs%5D%20r62%20-%20/%20freenx-server%20freenx-server/CVS&In-Reply-To=%3C200507031435.j63EZZWx005285%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000154.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Freenx-cvs] r62 - / freenx-server freenx-server/CVS</H1>
    <B>Fabian Franz at BerliOS</B> 
    <A HREF="mailto:freenx-cvs%40lists.berlios.de?Subject=Re%3A%20%5BFreenx-cvs%5D%20r62%20-%20/%20freenx-server%20freenx-server/CVS&In-Reply-To=%3C200507031435.j63EZZWx005285%40sheep.berlios.de%3E"
       TITLE="[Freenx-cvs] r62 - / freenx-server freenx-server/CVS">fabianx at berlios.de
       </A><BR>
    <I>Sun Jul  3 16:35:35 CEST 2005</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000154.html">[Freenx-cvs] r63 - freenx-server
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#153">[ date ]</a>
              <a href="thread.html#153">[ thread ]</a>
              <a href="subject.html#153">[ subject ]</a>
              <a href="author.html#153">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: fabianx
Date: 2005-07-03 16:35:34 +0200 (Sun, 03 Jul 2005)
New Revision: 62

Added:
   freenx-server/
   freenx-server/AUTHORS
   freenx-server/CONTRIB
   freenx-server/COPYING
   freenx-server/CVS/
   freenx-server/CVS/Entries
   freenx-server/CVS/Repository
   freenx-server/CVS/Root
   freenx-server/ChangeLog
   freenx-server/INSTALL
   freenx-server/RoadMap
   freenx-server/gentoo-nomachine.diff
   freenx-server/node.conf.sample
   freenx-server/nxclient
   freenx-server/nxkeygen
   freenx-server/nxloadconfig
   freenx-server/nxnode
   freenx-server/nxnode-login
   freenx-server/nxprint
   freenx-server/nxserver
   freenx-server/nxserver.old
   freenx-server/nxsetup
Log:
Initial import of FreeNX 0.4.1.


Added: freenx-server/AUTHORS
===================================================================
--- freenx-server/AUTHORS	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/AUTHORS	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,5 @@
+Fabian Franz &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">freenx at fabian-franz.de</A>&gt;
+Rick Stout &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">zipsonic at gmail.com</A>&gt;
+Thorsten Sandfuchs &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">fux at users.berlios.de</A>&gt;
+Kurt Pfeifle &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">pfeifle at kde.org</A>&gt;
+Jon Severinsson &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">jonno at users.berlios.de</A>&gt;

Added: freenx-server/CONTRIB
===================================================================
--- freenx-server/CONTRIB	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/CONTRIB	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,81 @@
+III. How you can help
+=====================
+
+1. Documentation
+----------------
+
+Documentation and experience reports are most important of course. So if you have something send it to us ;-). (<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">FreeNX-kNX at kde.org</A>)
+
+2. Code and Patches
+-------------------
+
+While FreeNX is a volounteer project, it of course depends on the work of 7 years kindly donated by NoMachine to the Free Software Community: 
+
+The NX open source libraries
+
+While they are mature and very good working, they need work in some very important fields. Most &quot;difficulties&quot; were provided by Gian Fillipo Pinzari main developer of NoMachine NX and CEO of NoMachine.
+
+2.1 Rootless nxagent
+
+This is the most needed feature at the moment. It will allow using single applications instead of a full featured desktop. Most code needed for that is already in the nxagent source tree; its just still a bit buggy and needs some &quot;love&quot;.
+
+Difficulty: Medium
+
+2.2 Pseudo Color / True Color support
+
+This is the second most important feature needed. With the addition of Pseudo Color / True Color, it it possible to reconnect also on different depths (which is not possible at the moment). This will also make nxagent independent of the used Visuals (as far as I've understand it).
+
+Last but not least, will this allow me to use Xvfb to keep a session running, while no display is attached to it.
+
+Difficulty: Medium
+
+2.3 XRandr support
+
+XRandr support is available since version XFree86 4.3 and also most applications already support it. XRandr support would also enable one to reconnect at different geometry sizes and you could in an ideal case also just resize the window and it would work.
+
+At reconnection stage this is really important for the fullscreen mode.
+
+Difficulty: Easy
+
+2.4 XDamage support
+
+nxagent should be also able to profit from the new XDamage extension, to allow making NX sessions again even faster. 
+
+Difficulty: Easy
+
+2.5 &quot;Lazy image encoding&quot;
+
+Currently images are sent at once and just limited by having a small control channel open to allow fast user interaction. It would be much better if the images would be &quot;streamed&quot; in a way. 
+
+Quoting GFP:
+
+&quot;&gt; What about doing this asynchronously? Not necessarily doing it immediately,
+&gt; but analyzing (in parallel, the data is still sent with normal compression
+&gt; regardless) what is seen and then biasing the type of compression over
+&gt; time based on the &quot;popularity&quot; of given image characteristics for a
+&gt; specific application or window class.
+
+This is more or less what we want to do as part of the &quot;lazy&quot;
+image encoding functionality that is going to be implemented.
+The main goal of the &quot;lazy&quot; encoding is to decouple the image
+handling from other protocol requests. The effect we want to
+achieve is similar to loading a web page, where the browser
+renders the images progressively, as they are downloaded from
+the network. Once you have images sent asynchrounously, you
+have opened the way to any form of post-processing.&quot;
+
+[TODO: This part is not yet explained enough ]
+
+2.6 Drag and Drop with automatic file transfer
+
+The idea is:
+
+Grab the X Drag And Drop requests in nxagent and advise the nxproxy on the other side to stream you the file with the filename, which you have got. The file should then be saved to a temporary location and the event given to the real application. While the file is transferred nxagent should display some kind of status bar.
+
+Difficulty: ~ Medium - Difficult
+
+2.7 Add the GLX extension
+
+Add the glx extension to nxagent and also try to remove roundtrips in GLX.
+
+Difficulty: Easy - Medium

Added: freenx-server/COPYING
===================================================================
--- freenx-server/COPYING	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/COPYING	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The &quot;Program&quot;, below,
+refers to any such program or work, and a &quot;work based on the Program&quot;
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term &quot;modification&quot;.)  Each licensee is addressed as &quot;you&quot;.
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and &quot;any
+later version&quot;, you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM &quot;AS IS&quot; WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the &quot;copyright&quot; line and a pointer to where the full notice is found.
+
+    &lt;one line to give the program's name and a brief idea of what it does.&gt;
+    Copyright (C) &lt;year&gt;  &lt;name of author&gt;
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a &quot;copyright disclaimer&quot; for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  &lt;signature of Ty Coon&gt;, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.

Added: freenx-server/CVS/Entries
===================================================================
--- freenx-server/CVS/Entries	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/CVS/Entries	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,16 @@
+/CONTRIB/1.1.1.1/Thu Jan 27 02:08:55 2005//
+/COPYING/1.1.1.1/Thu Jan 27 02:08:55 2005//
+/gentoo-nomachine.diff/1.14/Sat Mar 12 18:03:32 2005//
+/nxprint/1.1/Tue Mar 15 03:55:08 2005//
+/AUTHORS/1.4/Wed Mar 16 03:14:42 2005//
+/nxnode-login/1.12/Thu Mar 24 00:10:37 2005//
+/nxclient/1.5/Mon Apr 25 02:11:24 2005//
+/INSTALL/1.6/Sat Apr 30 14:37:01 2005//
+/node.conf.sample/1.28/Sun Jun 19 23:51:22 2005//
+/nxkeygen/1.12/Sun Jun 19 23:51:22 2005//
+/nxloadconfig/1.33/Sun Jun 19 23:51:22 2005//
+/nxsetup/1.28/Sun Jun 19 23:51:22 2005//
+/nxnode/1.60/Thu Jun 23 15:42:52 2005//
+/ChangeLog/1.58/Sat Jun 25 12:24:10 2005//
+/nxserver/1.55/Sat Jun 25 12:26:22 2005//
+D

Added: freenx-server/CVS/Repository
===================================================================
--- freenx-server/CVS/Repository	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/CVS/Repository	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1 @@
+freenx

Added: freenx-server/CVS/Root
===================================================================
--- freenx-server/CVS/Root	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/CVS/Root	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1 @@
<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">+fabianx at cvs.berlios.de</A>:/cvsroot/freenx

Added: freenx-server/ChangeLog
===================================================================
--- freenx-server/ChangeLog	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/ChangeLog	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,194 @@
+24.06.2005 FreeNX 0.4.1 &quot;LinuxTag Edition&quot;
+	* Fixed a small security problem giving access to session database.
+	* Added support for 1.5.0 OSS components. (especially rootless mode)
+	* Fixed Filesharing over the Internet. (Thanks to <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">rogierm at users.berlios.de</A>)
+	* Fixed Resume on Windows with non-fullscreen sessions.
+	* Added suspend/resume support for 1.5.0 OSS components.
+	* Fixed display of suspended sessions in nxserver --list.
+
+04.05.2005 FreeNX 0.4.0 &quot;SambaXP Edition&quot;
+	* Opened the 0.4.0 branch.
+	* Added initial support for filesharing via samba.
+	* Improvements to be more node.conf compatible.
+	* Added COMMAND_NETCAT, COMMAND_SSH &amp; COMMAND_SSH_KEYGEN directive
+	* Added support for 'nxloadconfig --check' to validate node.conf 
+	  settings
+	* Added initial support for sound (esd/artsd).
+	* Added optional support for utmp/wtmp/lastlog database.
+	* Removed support for OSS components prior version 1.4.0 in nxnode.
+	  Added -option option to nxagent/nxdesktop/nxviewer.
+	* Added forwarding to commercial server via destination port.
+	* Added more compatible getparam function
+	* Sets LD_PRELOAD for applications and LD_LIBRARY_PATH for 
+	  nxagent/nxproxy by default.
+		- SET_LD_LIBRARY_PATH replaces NX_NOMACHINE_WAY and is 
+		  enabled by default, as it is now safe to do so
+	* Implemented SSHD_CHECK_IP directive.
+	* Added the SESSION_HISTORY directive. Session history will by default 
+	  be kept for 30 days.
+	* Implemented DEFAULT_X_WM for unix-application virtual desktop mode.
+	* Implemented SESSION_LIMIT and SESSION_USER_LIMIT.
+	* Fixed nxviewer commandline for geometry and fullscreen-support
+	* Added NX_LOG_LEVEL instead of NX_LOGGING, allowing less verbose 
+	  logfile.
+	* Added SESSION_LOG_CLEAN for configurable removal of the temporary 
+	  session directory.
+	* Added &quot;--ssh2&quot; cmdline switch for commercial ssh2-server support 
+	  in nxsetup.
+	* Added ENABLE_FORCE_ENCRYPTION to enforce the usage of encryption on 
+	  the server.
+	* Added nxprint and added -printer to nxclient together with handling
+	  of drivers cache.
+	* Fixed a possible race-condition. (reported by Edward Warnicke
+	  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">eaw at cisco.com</A>&gt;)
+	* Feature Request #847 (stderror of some applications to log-file)
+	* Feature Request #900 (Detect ssh/sshd in nxsetup)
+	* Added printing support via userspace CUPSd and Samba.
+
+20.03.2005 FreeNX 0.3.1 &quot;Bugfix Edition&quot;
+	* Fixed keyboard mapping problems.
+	* Fixed unix-custom mode; now allowing parameters to be passed.
+	* Fixed password prompt detection support in nxnode-login.
+	* Fixed locking to prevent usage of the same display.
+	* Fixed resume when agent is no longer there.
+	* Fixed error message shown to user, when session startup fails.
+	* Fixed handling of /tmp/.X*-lock files.
+	* Fixed handling of not closed sessions in &quot;Terminating&quot; status.
+	* Fixed resume of multiple suspended sessions.
+
+05.03.2005 FreeNX 0.3.0 &quot;Chemnitzer LinuxTage Edition&quot;
+	* Initial CVS checkin.
+	* Added unix-default as session type - by Kalev Lember 
+	  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">kalev at smartlink.ee</A>&gt;
+	* Fixed nxclient loop - by &quot;Neil Wilson&quot; &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">neil at aldur.co.uk</A>&gt;.
+	* Several fixes by Thorsten Sandfuchs &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">fux at users.berlios.de</A>&gt;.
+	* Optional config file support (system- and user-wide)
+		- by Jon Severinsson &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">jonno at users.berlios.de</A>&gt;.
+	* Moved logfile to /var/log/nxserver.log.
+	* Moved nx homedir to /var/lib/nxserver/home
+	* Complete rewrite of authentication code
+		* passdb, su or ssh is now supported.
+		- by Jon Severinsson &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">jonno at users.berlios.de</A>&gt;.
+	* Added NODE_AUTOSTART, EXPORT_{USERIP/SESSIONID} config file
+	  directives.
+	* Added mechanism to forward connection to commercial NoMachine 
+	  nxserver (as available from www.nomachine.com).
+	* Added mechanism to forward connection to another nxserver. This
+	  allows using a &quot;chain&quot; of nxservers.
+	* Added &quot;floating window&quot; support by using rootless nxagent as
+	  it will be standard in NX 1.5.0.
+	* Added &quot;floating window&quot; support by just nxproxy/nxproxy connection
+	  and added configuration directive to enable rootless mode.
+	* Added nxsetup --uninstall and added more feature to nxsetup.
+	  Note: You need to use nxsetup --install for installation now.
+	* Added Disabling of port-forwarding, X11-forwarding, ... to ssh-key.
+
+	* Security: Fixed a security blunder. Authority file was not used 
+	            and so basically xhost +localhost was set. (ported from
+		    0.2.8)
+		    
+		    Update immediately.
+                   
+	* Security: Fixed two possible security problems (umask was not set
+                   correctly; ported from 0.2.8)
+
+20.11.2004 FreeNX 0.2.7 &quot;Skolelinux Edition&quot;
+	* Fix nxserver to work again with KNX-Client. ('\r' is evil)
+	* Fix timeout in nxnode-login to allow proper session management
+	  again.
+	* Fixed possible race condition for the wait-file.
+
+11.11.2004 FreeNX 0.2.6
+	
+	* Security: Fixed a possible exploit in ssh-usage
+	    (thanx to Sebastian Krahmer from the SuSE security team)
+	* Important: Public/Private key is no longer used for PAM auth mode.
+	
+14.10.2004 FreeNX 0.2.5
+	* Added Xdialog interface for nxclient and automatic usage
+	  of commercial nxclient when available. (Thx go to Rick Stout 
+	  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">zipsonic at gmail.com</A>&gt;)
+	* Added bugfix from the 0.3.0 branch for more flexible nxdesktop in
+	  nxnode.
+	* Added patch by Rick Stout for permission problems in nxnode.
+	* Added patch by Rick Stout for a typo in nxkeygen.
+	* Updated gentoo-nomachine.diff.
+	* Updated CONTRIB to include a description of lazy-image encoding.
+
+11.09.2004 FreeNX 0.2.4
+	* Added timeout to avoid having hanging tail processes.
+	* Added &quot;locking&quot; of the display-offset if nxagent failed to start.
+	* Fixed ssh encryption for resume on client 1.4.0-snapshot 5.
+	* Fixed mktemp, which was non-portable to FreeBSD and Red Hat 9.
+
+10.09.2004 FreeNX 0.2-3
+	* Added support for autoreconnection or autoreconnection just 
+	  for the case when an older client version is used.
+	  	* This makes it possible to use Reconnection with the 
+	  	  stable version 1.3.2-7 (enabled by default)
+	* Added instructions how to install the NoMachine sources to INSTALL
+	* Changed $NX_DIR/bin/ssh to ssh to fix gentoo-nomachine.diff
+	* Added nxkeygen by Stuart Herbert for easier change from the 
+	  NoMachine key to another key afterwards.
+	
+	* Security: Any user was able to change the status of other sessions
+	            in the session database by providing the correct uniqueid.
+
+10.09.2004 FreeNX 0.2-2
+	* Added additional support for safe session suspend, 
+	  autosuspend when network connection times out works now!
+	* AuthorizedKeysFile cannot be safely determined on Gentoo;
+	  changed it to config option now.
+	* Added config option to completely disable passdb support.
+	* Fixed bugs in nxclient dialog frontend.
+	* Removed all usage of nxssh due to security concerns from SuSE. 
+	* Fixed session management for knx client.
+	* Added detection of failed nxagent startup.
+	* Updated the gentoo-nomachine.diff to be not fuzzy.
+
+08.09.2004 FreeNX 0.2-1
+	* Fixed support for one windows client version. 
+	* Fixed setting of key with --adduser.
+	  (Thanks to Stuart Herbert &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">stuart at gentoo.org</A>&gt;)
+	* Fixed _some_ cases for AuthorizedKeysFile in sshd_config.
+	  (Thanks to Peter Holik &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">peter at holik.at</A>&gt;)
+
+	* Fixed gentoo-nomachine.diff (nxnode not in path, but nxnode-login would try that)
+	* Fixed the bug with hanging tail processes.
+
+07.09.2004 FreeNX 0.2-0
+	* Reworked the whole security model in nxsetup due to requests from SuSE and Gentoo.
+		- nxsetup does not use the NoMachine key by default. 
+		- PAM authentication is enabled by default.
+	
+	* Added nxclient for compatibility with nxclient -dialog mode.
+	
+	* Minor changes
+		* Added SSHD_AUTH_PORT to config vars in nxserver
+		* Made all programs NX_ aware
+		* Programs do now honor the setting of AuthorizedKeysFile in sshd_config
+		* Changed nxsetup check from direct reading of passwd to getent
+		  (Thanks to Tom Hibbert &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">tom at nsp.co.nz</A>&gt;)
+		* Changed overall messages in nxsetup
+	
+	* Made a overall clean upstream package.
+	* Added Gentoo / NoMachine compatibility diff
+
+06.09.2004 
+	* Added pam authentication
+	* Added user_db switch
+	* moved some su - to nxnode-login
+
+02.09.2004 
+	* Added support for snapshot 4 (43/66)
+	* Fixed compatibility issue with 1.3.0 
+	  (Used by Knoppix 3.4 and earlier)
+	* added sane logging (LOGGING is now properly used)
+
+20.06.2004 
+	* Added Protocol version 1.4.0
+	* Cleanup
+	* Added missing functions
+
+14.06.2004 
+	* Added Protocol version 1.3.2

Added: freenx-server/INSTALL
===================================================================
--- freenx-server/INSTALL	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/INSTALL	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,65 @@
+INTRODUCTION
+------------
+
+This is the FreeNX server package.
+
+DEPENDENCIES
+------------
+
+It depends on:
+
+- NX sources
+- X11 libraries
+- sshd
+- expect
+- netcat
+
+NOTE
+----
+
+This tarball is intented mainly for distributions, which want to use FreeNX as building the other OpenSource NX components is quite difficult.
+
+In the following sections it is outlined how to install FreeNX as soon as you've build all open source components. 
+
+HOWTO MANUALLY INSTALL
+----------------------
+
+You must apply the gentoo-nomachine.diff and then copy the files to /usr/NX/bin and /usr/NX/lib.
+
+You can use the following schema to do the install to /usr/NX/:
+
+NXPREFIX=/usr/NX
+mkdir -p ${NXPREFIX}/lib ${NXPREFIX}/bin
+
+# Libraries
+cp -a nx-X11/lib/X11/libX11.so* ${NXPREFIX}/lib
+cp -a nx-X11/lib/Xext/libXext.so* ${NXPREFIX}/lib
+cp -a nx-X11/lib/Xrender/libXrender.so* ${NXPREFIX}/lib
+cp -a nxcomp/libXcomp.so* ${NXPREFIX}/lib
+cp -a nxcompext/libXcompext.so* ${NXPREFIX}/lib
+
+# binaries
+cp -a nx-X11/programs/Xserver/nxagent ${NXPREFIX}/bin
+cp -a nxproxy/nxproxy ${NXPREFIX}/bin
+cp -a nxdesktop/nxdesktop ${NXPREFIX}/bin
+cp -a nxviewer/nxviewer/nxviewer ${NXPREFIX}/bin
+cp -a nxviewer/nxpasswd/nxpasswd ${NXPREFIX}/bin
+
+# windows-keymaps for nxdesktop RDP-sessions and keyboard layout != us
+cd nxdesktop
+make installkeymaps
+
+# scripts
+cp -a freenx*/nxnode ${NXPREFIX}/bin
+cp -a freenx*/nxserver ${NXPREFIX}/bin
+cp -a freenx*/nxsetup ${NXPREFIX}/bin
+cp -a freenx*/nxkeygen ${NXPREFIX}/bin
+cp -a freenx*/nxnode-login ${NXPREFIX}/bin
+cp -a freenx*/nxloadconfig ${NXPREFIX}/bin
+
+# config file
+cp -a freenx*/node.conf.sample ${NXPREFIX}/etc/
+
+You should also install the nxclient from NoMachine or also copy the nxclient program from freenx. 
+
+Then you need to run 'nxsetup --install' and follow the instructions given.

Added: freenx-server/RoadMap
===================================================================
--- freenx-server/RoadMap	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/RoadMap	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,21 @@
+0.4.0
+	- Samba File and Printer sharing
+	- Sound via SOUNDSERVER
+
+0.4.1
+	- Bugfixes
+	
+0.4.2
+	- Solaris Support
+	- Stability Support
+
+[Between]
+	- Umfrage zu NX (Ask Slashdot?)
+	- Dokumentation
+	
+0.5.0
+	- &quot;Rewrite&quot; of Session-Management
+	- Transparent Socks-Implementation
+		- Seamless printing
+		- Seamless FileSharing (fish)
+	- Transparent tunnel of devices

Added: freenx-server/gentoo-nomachine.diff
===================================================================
--- freenx-server/gentoo-nomachine.diff	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/gentoo-nomachine.diff	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,19 @@
+--- nxloadconfig.old	2005-02-14 01:08:56.482546352 +0100
++++ nxloadconfig	2005-02-14 01:09:40.109913984 +0100
+@@ -53,12 +53,12 @@
+ NX_LICENSE=&quot;OS (GPL)&quot;
+ 
+ # Where can different nx components be found
+-NX_DIR=/usr
++NX_DIR=/usr/NX
+ PATH_BIN=$NX_DIR/bin # if you change that, be sure to also change the public keys
+ PATH_LIB=$NX_DIR/lib
+-NX_ETC_DIR=/etc/nxserver
+-NX_SESS_DIR=/var/lib/nxserver/db
+-NX_HOME_DIR=/var/lib/nxserver/home
++NX_ETC_DIR=$NX_DIR/etc
++NX_SESS_DIR=$NX_DIR/var/db
++NX_HOME_DIR=$NX_DIR/home/nx
+ 
+ # the name of the authorized keys file for ssh
+ SSH_AUTHORIZED_KEYS=&quot;authorized_keys2&quot;

Added: freenx-server/node.conf.sample
===================================================================
--- freenx-server/node.conf.sample	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/node.conf.sample	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,352 @@
+# node.conf
+#
+# This file is provided by FreeNX. It should be placed either into
+# /etc/nxserver/node.conf (FreeNX style) or /usr/NX/etc/node.conf
+# (NoMachine NX style).
+#
+# It is mostly compatible with NoMachine node.conf. The most important 
+# difference is that no spaces are allowed when assigning values (eg 
+# &quot;A=value&quot; is allowed, &quot;A = value&quot; is NOT).
+#
+# This file is sourced by bash, so you can do some fancy stuff here if you
+# want to, but be aware that it is sourced 3 times per connection. If you 
+# want autostart stuff, set NODE_AUTOSTART instead!
+# 
+#
+# You surely are aware that FreeNX is based on the fantastic results that
+# the hard work by NoMachine.com has achieved. NoMachine.com released the
+# core NX libraries under the GPL. The installation of these libs are the
+# precondition for all FreeNX scripts to work. If you are installing this
+# software with the help of one of the package management tools of your
+# Linux distribution, you can assume that this dependency is taken care of
+# by the tool.
+#
+# You have questions about the inner workings of the NX technology?
+#
+# Then you are recommended to first check out the rich and very detailed
+# NoMachine documentation and their online Knowledge Base at 
+#
+#           <A HREF="http://www.nomachine.com/kb/">http://www.nomachine.com/kb/</A>
+#
+# Other sources of information are the NoMachine mailing lists 
+# (<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">nxusers at nomachine.com</A> and <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">nxdevelopers at nomachine.com</A>):
+#
+#           <A HREF="http://www.nomachine.com/mailinglists.php">http://www.nomachine.com/mailinglists.php</A>
+#
+# The FreeNX (<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">freenx-knx at kde.org</A>) list is here:
+#
+#           <A HREF="https://mail.kde.org/mailman/listinfo/freenx-knx">https://mail.kde.org/mailman/listinfo/freenx-knx</A>
+#
+# CVS: $Id: node.conf.sample,v 1.28 2005/05/05 08:17:54 jonno Exp $
+
+#########################################################################
+# General FreeNX directives
+#########################################################################
+
+# The host name which is used by NX server. It's should be used if it's
+# different than the default hostname (as returned by `hostname`)
+#SERVER_NAME=&quot;$(hostname)&quot;
+
+# The port number where local 'sshd' is listening.
+#SSHD_PORT=22
+
+
+#########################################################################
+# Authentication / Security directives
+#########################################################################
+
+# Authentication directives
+# This adds the passdb to the possible authentication methods
+#ENABLE_PASSDB_AUTHENTICATION=&quot;1&quot;
+
+# This adds SSH to the possible authentication methods. For it to work sshd
+# must be set up at localhost accepting password authentication.
+#ENABLE_SSH_AUTHENTICATION=&quot;1&quot;
+
+# This adds SU to the possible authentication methods. For it to work the 
+# &quot;nx&quot; user must be in the wheel (RedHat, Fedora) or the users group (SUSE)
+# and the user logging in must have a valid shell that accepts the -c
+# parameter.
+#ENABLE_SU_AUTHENTICATION=&quot;0&quot;
+
+# Require all users to be in the passdb, regardless of authentication method
+#ENABLE_USER_DB=&quot;0&quot;
+
+
+# If enabled forces the user to use encryption. This will bail out
+# if the user does not have encryption enabled.
+#ENABLE_FORCE_ENCRYPTION=&quot;0&quot;
+
+# Refuse the NX client connection if SSHD does not export the
+# SSH_CONNECTION and SSH_CLIENT variables in the environment
+# passed to the NX server.
+# 1: Will check the remote IP and will not accept the
+#    connection if it can't be determined.
+# 0: Will accept the connection even if the remote IP
+#    is not provided.
+#SSHD_CHECK_IP=&quot;0&quot;
+
+
+#########################################################################
+# Restriction directives
+#########################################################################
+
+# The base display number from which sessions are started.
+#DISPLAY_BASE=1000
+
+# The maximum number of contemporary sessions that can be run on FreeNX
+#SESSION_LIMIT=200
+
+# The maximum number of contemporary sessions that a single user can run
+# on FreeNX. Defaults to the value of SESSION_LIMIT.
+#SESSION_USER_LIMIT=200
+
+# The number of displays reserved for sessions, it has to be greater or equal
+# to the maximum number of contemporary sessions that a server can run.
+#DISPLAY_LIMIT=200
+
+
+# User for which sessions should be persistent. Either the keyword &quot;all&quot; or a
+# comma-separated list of usernames or groups in the @groupname syntax.
+#ENABLE_PERSISTENT_SESSION=&quot;all&quot;
+
+# Users and groups for whom persistent sessions should be disabled.
+# Especially useful if ENABLE_PERSISTENT_SESSION=&quot;all&quot;
+#DISABLE_PERSISTENT_SESSION=&quot;&quot;
+
+
+#########################################################################
+# Logging directives
+#########################################################################
+
+# This directives controls the verbosity of the server-wide log.
+# 0: No Logging
+# 1: Errors
+# 2: Warnings
+# 3: Important information
+# 4: Server - Client communication
+# 5: Information
+# 6: Debugging information
+# 7: stderror of some applications
+#NX_LOG_LEVEL=0
+
+# Before turning logging on, please make sure that NX_LOGFILE is
+# writeable for the &quot;nx&quot; user
+#NX_LOGFILE=/var/log/nxserver.log
+
+# This directive controls if the temporary session directory
+# ($HOME/.nx/C-&lt;hostname&gt;-&lt;display&gt;-&lt;session_id&gt;) should be kept after a
+# session has ended. A successfully terminated session will be saved as
+# T-C-&lt;hostname&gt;-&lt;display&gt;-&lt;session_id&gt; while a failed session will be saved
+# as F-C-&lt;hostname&gt;-&lt;display&gt;-&lt;session_id&gt;.
+#SESSION_LOG_CLEAN=0
+
+# Amount of seconds nxserver is to keep session history. The default of 2592000
+# is equivalent to 30 days. If this is 0 no session history will be kept
+# and a negative value denotes infinity.
+#SESSION_HISTORY=2592000
+
+
+#########################################################################
+# Forwarding directives
+#########################################################################
+
+# FreeNX with ENABLE_SERVER_FORWARD=&quot;1&quot; will automatically forward all
+# connections to the host specified in SERVER_FORWARD_HOST with the
+# secret key SERVER_FORWARD_KEY.
+#
+# This allows to have a &quot;chain&quot; of NX Servers. Note that you will need to
+# use &quot;SSL encryption&quot; for all connections.
+
+#ENABLE_SERVER_FORWARD=&quot;0&quot;
+#SERVER_FORWARD_HOST=&quot;&quot;
+#SERVER_FORWARD_PORT=22
+#SERVER_FORWARD_KEY=&quot;/usr/NX/share/client.id_dsa.key&quot;
+
+
+# FreeNX with ENABLE_NOMACHINE_FORWARD_USER=&quot;1&quot; will automatically forward all
+# connections to the commercial NoMachine nxserver installed on the same
+# machine. This feature is introduced to enable the usage of FreeNX and
+# NoMachine NX side by side on the same machine without conflicts.
+#
+# To make a connection to the FreeNX server, just use 'freenx.&lt;user&gt;' as 
+# username (where &lt;username&gt; is the existing Unix username. (You do not 
+# need to create a user named 'freenx.&lt;user&gt;'!)
+#
+# To make a connection to the NoMachine nxserver, use the unmodified
+# '&lt;user&gt;' username.
+
+#ENABLE_NOMACHINE_FORWARD_USER=&quot;0&quot;
+#NOMACHINE_SERVER=&quot;/usr/NX/bin/nxserver&quot;
+#NOMACHINE_NX_HOME_DIR=&quot;/usr/NX/home/nx&quot;
+
+
+# To just forward connections to the NoMachine server, which connect to a
+# certain port enable the following two directives.
+# 
+# Note: You need to let SSHD listen to several ports to make use of this
+#       directive.
+
+#ENABLE_NOMACHINE_FORWARD_PORT=&quot;0&quot;
+#NOMACHINE_FORWARD_PORT=&quot;22&quot;
+
+
+#########################################################################
+# Services directives
+#########################################################################
+
+# FreeNX with ENABLE_ESD_PRELOAD=&quot;1&quot; will automatically try to setup
+# the sound with the help of the esd media helper.
+#
+# Currently ESD will be used just by the Windows NX Client.
+#
+# Be sure that $ESD_BIN_PRELOAD is in your path, does exist and work
+# before enabling this directive.
+
+#ENABLE_ESD_PRELOAD=&quot;0&quot;
+#ESD_BIN_PRELOAD=&quot;esddsp&quot;
+
+# FreeNX with ENABLE_ARTSD_PRELOAD=&quot;1&quot; will automatically try to setup
+# the sound with the help of the artsd media helper.
+#
+# Currently ARTSD will be used just by the Linux NX Client.
+#
+# Be sure that $ARTSD_BIN_PRELOAD is in your path, does exist and work
+# before enabling this directive.
+
+#ENABLE_ARTSD_PRELOAD=&quot;0&quot;
+#ARTSD_BIN_PRELOAD=&quot;artsdsp&quot;
+
+# FreeNX with ENABLE_KDE_CUPS=&quot;1&quot; will automatically write 
+# $KDE_PRINTRC and put the current used port into it.
+# $KDE_PRINTRC is automatically calculated if its not set.
+
+#ENABLE_KDE_CUPS=&quot;0&quot;
+#KDE_PRINTRC=&quot;$KDEHOME/share/config/kdeprintrc&quot;
+#CUPS_ETC=&quot;/etc/cups&quot;
+
+#########################################################################
+# Path directives
+#########################################################################
+
+# USER_FAKE_HOME is the base directory for the .nx directory. Use this
+# parameter instead of the users home directory if $HOME is on a NFS share.
+# Note that this directory must be unique for every user! To accomplish this
+# it is recommended to include $USER in the path.
+#USER_FAKE_HOME=$HOME
+
+# Add the nx libraries to LD_LIBRARY_PATH before starting nx agents.
+# WARNING: This will NOT (and should not) affect applications. ONLY Disable
+# this if the nx libraries are in a standard system path (such as /usr/lib)!
+#SET_LD_LIBRARY_PATH=&quot;1&quot;
+
+
+# The command binary for the default window manager. If set it is run when a
+# 'unix-custom' session is requested by the NX Client and an application
+# to run is specified. It defaults to empty (ie no WM is run).
+# If KILL_DEFAULT_X_WM is set the WM is terminated after the started 
+# application finishes. Else FreeNX will wait for the WM to complete.
+#DEFAULT_X_WM=&quot;&quot;
+#KILL_DEFAULT_X_WM=&quot;1&quot;
+
+# When a 'unix-default' session is requested by the client the user's X startup
+# script will be run if pressent and executable, otherwise the default X
+# session will be run.
+# Depending on distribution USER_X_STARTUP_SCRIPT might be .Xclients, .xinitrc
+# and .Xsession
+# Depending on distribution DEFAULT_X_SESSION might be /etc/X11/xdm/Xsession,
+# /etc/X11/Sessions/Xsession or /etc/X11/xinit/xinitrc
+#USER_X_STARTUP_SCRIPT=.Xclients
+#DEFAULT_X_SESSION=/etc/X11/xdm/Xsession
+
+# The key that contains the name of the script that starts a KDE session.
+# It's run when a 'unix-kde' session is requested by the client.
+#COMMAND_START_KDE=startkde
+
+# The key that contains the name of the script that starts a gnome session.
+# It's run when a 'unix-gnome' session is requested by the client.
+#COMMAND_START_GNOME=gnome-session
+
+# The key that contains the name of the script that starts a CDE session.
+# It's run when a 'unix-cde' session is requested by the client.
+#COMMAND_START_CDE=cdwm
+
+# The key that contains the name of the complete path of command name
+# 'xterm'. It is run when a unix &quot;xterm&quot; session is requested by the
+# client.
+#COMMAND_XTERM=xterm
+
+# The key that contains the name of the complete path of command name
+# 'xauth'.
+#COMMAND_XAUTH=/usr/X11R6/bin/xauth
+
+# The key that contains the name of the complete path of command name
+# 'smbmount'.
+#COMMAND_SMBMOUNT=smbmount
+
+# The key that contains the name of the complete path of command name
+# 'smbumount'.
+#COMMAND_SMBUMOUNT=smbumount
+
+# The key that contains the name of the complete path of the 'netcat' command.
+#COMMAND_NETCAT=netcat
+
+# The key that contains the name of the complete path of the 'ssh' and
+# 'ssh-keygen' command.
+#COMMAND_SSH=ssh
+#COMMAND_SSH_KEYGEN=ssh-keygen
+
+# The key that contains the name of the complete path of the 'cupsd' command.
+#COMMAND_CUPSD=/usr/sbin/cupsd
+
+#########################################################################
+# Misc directives
+#########################################################################
+
+# When set to 1 this will automatically resume started sessions
+#ENABLE_AUTORECONNECT=&quot;0&quot;
+
+# When set to 1 this will automatically resume started sessions
+# but only if an older client version is used
+#ENABLE_AUTORECONNECT_BEFORE_140=&quot;1&quot;
+
+# When set to 1 exports NXUSERIP / NXSESSIONID in nxnode
+#EXPORT_USERIP=&quot;0&quot;
+#EXPORT_SESSIONID=&quot;0&quot;
+
+# This can be set to any executable, which is started after session startup
+# like: $NODE_AUTOSTART {start|restore}
+#NODE_AUTOSTART=&quot;&quot;
+
+# When set to 1 will start nxagent in rootless mode.
+#ENABLE_ROOTLESS_MODE=&quot;0&quot;
+
+# If enabled writes entries via the COMMAND_SESSREG program
+# into utmp/wtmp/lastlog database.
+# Note: You have to make sure that you add the nx user to the
+#       utmp or tty group or how its called on your system
+#       before this directive works.
+#ENABLE_USESSION=&quot;0&quot;
+#COMMAND_SESSREG=&quot;sessreg&quot;
+
+# Extra options sent to the different nx agents. See !M documentation
+# for examples of useful parameters.
+#AGENT_EXTRA_OPTIONS_RFB=&quot;&quot;
+#AGENT_EXTRA_OPTIONS_RDP=&quot;&quot;
+#AGENT_EXTRA_OPTIONS_X=&quot;&quot;
+
+# The font server the agent will use. If set to &quot;&quot; no font server is used.
+# For this to do any good, the client has to have the same font server set
+# in /etc/X11/XF86Config
+#AGENT_FONT_SERVER=&quot;&quot;
+
+# Disable or enable use of 'tcp nodelay' on proxy. Old versions of Linux
+# kernels have problems using this option on sockets that will cause a loss
+# of TCP connections. This option is not set by default to allow clients to
+# specify whether to enable or disable TCP nodelay. Setting this option to
+# the value of &quot;0&quot; NX proxy avoids using 'tcp nodelay' but it will cause a
+# loss of interaction in sessions.
+#PROXY_TCP_NODELAY=&quot;0&quot;
+
+# Extra options to nxproxy. See !M documentation for useful parameters.
+#PROXY_EXTRA_OPTIONS=&quot;&quot;

Added: freenx-server/nxclient
===================================================================
--- freenx-server/nxclient	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/nxclient	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,334 @@
+#!/bin/bash
+#
+# Copyright (c) 2004 by Fabian Franz &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">freenx at fabian-franz.de</A>&gt;
+#           (c) 2004 by Rick Stout &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">zipsonic at gmail.com</A>&gt;
+#
+# License: GPL, version 2
+#
+# Note: NX does not check the exit-code from nxclient,
+#       but we set it to a &quot;good value&quot; anyway in case 
+#       it does check it someday.
+#
+# CVS: $Id: nxclient,v 1.5 2005/04/25 02:11:24 fabianx Exp $
+#
+# ========================================================================
+
+# First check if the commercial nxclient is available and use it
+# but check that it isn't this script to prevent a loop!
+NXCLIENT=&quot;/usr/NX/bin/nxclient&quot;
+[ -x &quot;$NXCLIENT&quot; -a &quot;$(file -bi $NXCLIENT)&quot; != 'application/x-shellscript' ] \
+	&amp;&amp; exec ${NXCLIENT} &quot;$@&quot;
+
+TEMP=`getopt -a -o d: --long local,noautokill,dialog:,caption:,message:,display:,printer: -n $(basename $0) -- &quot;$@&quot;`
+
+if [ $? != 0 ] ; then echo &quot;Terminating...&quot; &gt;&amp;2 ; exit 1 ; fi
+
+# Note the quotes around `$TEMP': they are essential!
+eval set -- &quot;$TEMP&quot;
+
+DIALOG_TYPE=&quot;ok&quot;;
+DIALOG_CAPTION=&quot;&quot;
+DIALOG_MESSAGE=&quot;&quot;
+DIALOG_LOCAL=&quot;&quot;
+DIALOG_NOAUTOKILL=&quot;&quot;
+DIALOG_PRINTER=&quot;&quot;
+
+while true
+do
+        case &quot;$1&quot; in
+		--dialog) DIALOG_TYPE=&quot;$2&quot;; shift 2 ;;
+		--caption) DIALOG_CAPTION=&quot;$2&quot;; shift 2 ;;
+		--message) DIALOG_MESSAGE=&quot;$2&quot;; shift 2 ;;
+		--local) DIALOG_LOCAL=&quot;yes&quot;; shift ;;
+		--noautokill) DIALOG_NOAUTOKILL=&quot;yes&quot;; shift ;;
+		--display) DISPLAY=&quot;$2&quot;; shift 2 ;;
+		--printer) DIALOG_PRINTER=&quot;$2&quot;; shift 2 ; break ;;
+		--) shift ; break ;;
+                *) echo &quot;Internal error!&quot; ; exit 1; ;;
+	esac
+done
+
+export DISPLAY
+
+# if --printer is set, the dialog type is overridden
+[ -n &quot;$DIALOG_PRINTER&quot; ] &amp;&amp; DIALOG_TYPE=&quot;printer&quot;
+
+if [ -x /usr/bin/Xdialog ] 
+then
+	dialog_interface=&quot;xdialog&quot;
+	DIALOG=/usr/bin/Xdialog # just in case that we have no good path
+else
+	dialog_interface=&quot;xmessage&quot;
+	xmessage=$(which xmessage 2&gt;/dev/null)
+	[ -z &quot;$xmessage&quot; ] &amp;&amp; xmessage=&quot;/usr/X11R6/bin/xmessage&quot;
+fi
+
+#
+# utility functions for all interfaces
+#
+
+# utility_printer &quot;get|set|getlist|getvendlist|getdrvlist&quot;
+#
+#	get &lt;name&gt; - gets the current driver for name
+#	set &lt;name&gt; &lt;driver&gt; &lt;description&gt; - sets the current driver and description for name
+#	getvendlist - gets a list of vendors
+#	getdrvlist &lt;vendor&gt; - gets a list of drivers for vendor
+#	getextdrvlist &lt;vendor&gt; - gets an extended list (with driver and 
+#                                description) of drivers for vendor
+#	getdesc &lt;driver&gt; - gets the description for driver &lt;driver&gt;
+#	getlist - gets a list of drivers
+
+#
+# drivers.cache has the following format:
+#	
+#	driver|&lt;printername&gt;|&lt;ppdfile&gt;|&lt;description&gt;
+#
+
+#
+# Example: IFS='|' DEFAULT_PRINTER=( $(utility_printer get &lt;myprinter&gt;) )
+# 	  
+#	You can then select ${DEFAULT_PRINTER[1]} for &lt;printername&gt;.
+# 
+
+utility_printer()
+{
+	UTILITY_DRIVERS_CACHE=&quot;$HOME/.nx/config/drivers.cache&quot;
+	[ -n &quot;$USER_FAKE_HOME&quot; ] &amp;&amp; UTILITY_DRIVERS_CACHE=&quot;$USER_FAKE_HOME/.nx/config/drivers.cache&quot;
+	UTILITY_NXPRINT=&quot;nxprint&quot;
+	[ -n &quot;$PATH_BIN&quot; ] &amp;&amp; UTILITY_NXPRINT=&quot;$PATH_BIN/nxprint&quot;
+	case &quot;$1&quot; in 
+		get)
+			grep &quot;driver|$2|&quot; &quot;$UTILITY_DRIVERS_CACHE&quot; 2&gt;/dev/null
+		;;
+		set)
+			# FIXME: Handle possible race conditions?
+			grep -v &quot;driver|$2|&quot; &quot;$UTILITY_DRIVERS_CACHE&quot; 2&gt;/dev/null &gt; $UTILITY_DRIVERS_CACHE.tmp
+			echo &quot;driver|$2|$3|$4&quot; &gt;&gt; $UTILITY_DRIVERS_CACHE.tmp
+			mv -f $UTILITY_DRIVERS_CACHE.tmp $UTILITY_DRIVERS_CACHE
+		;;
+		getvendlist)
+			$UTILITY_NXPRINT -d | awk -F'|' '{ print $2 }' | uniq | tr '\n' '|'
+		;;
+		getdrvlist)
+			$UTILITY_NXPRINT -d | awk -F'|' '($2==&quot;'$2'&quot;) { print $4}' | tr '\n' '|'
+		;;
+		getextdrvlist)
+			$UTILITY_NXPRINT -d | awk -F'|' '($2==&quot;'$2'&quot;) { print $4 &quot;|&quot; $3 }'
+		;;
+
+		getdesc)
+			$UTILITY_NXPRINT -d | awk -F'|' '($4==&quot;'$2'&quot;) { print $3}'
+		;;
+		getlist)
+			$UTILITY_NXPRINT -d
+		;;
+	esac
+}
+
+#
+# xmessage dialog interface
+#
+
+xmessage_ok()
+{
+	$xmessage -buttons &quot;Ok:0&quot; -center &quot;$DIALOG_MESSAGE&quot;
+	return 0 # Give cancel on close ...
+}
+
+xmessage_yesno()
+{
+	$xmessage -buttons &quot;Yes:2,No:0&quot; -center &quot;$DIALOG_MESSAGE&quot;
+}
+
+xmessage_yesnosuspend()
+{
+	$xmessage -buttons &quot;Suspend:3,Terminate:2,Cancel:0&quot; -center &quot;$DIALOG_MESSAGE&quot;
+}
+
+xmessage_panic()
+{
+	$xmessage -buttons &quot;Terminate:2,Cancel:0&quot; -center &quot;$DIALOG_MESSAGE&quot;
+}
+
+xmessage_quit()
+{
+	$xmessage -buttons &quot;Quit:0&quot; -center &quot;$DIALOG_MESSAGE&quot;
+	return 0 # Give cancel on close ...
+}
+
+xmessage_printer_ask()
+{
+	$xmessage -buttons &quot;Ok:100,Configure:101,Cancel:102&quot; -center &quot;$DIALOG_MESSAGE&quot;
+	RC=$?
+	[ $RC -lt 100 ] &amp;&amp; return 2
+	let RC=$RC-100
+	return $RC
+}
+
+xmessage_printer_configure()
+{
+	IFS=','
+	$xmessage -buttons &quot;$*&quot; -center &quot;$DIALOG_MESSAGE&quot;
+	RC=$?
+	unset IFS
+	VENDOR=&quot;&quot;
+	if [ $RC -gt 100 ]
+	then
+		let NR=$RC-100
+		VENDOR=&quot;${!NR}&quot;
+	fi
+	echo &quot;$VENDOR&quot;
+}
+
+xmessage_printer_configure_vendor()
+{
+	IFS='|' VENDOR_LIST=( $(utility_printer getvendlist) )
+	xmessage_printer_configure &quot;${VENDOR_LIST[@]}&quot;
+}
+
+xmessage_printer_configure_driver()
+{
+	IFS='|' DRIVER_LIST=( $(utility_printer getdrvlist &quot;$1&quot;) )
+	xmessage_printer_configure &quot;${DRIVER_LIST[@]}&quot;
+}
+
+#
+# xdialog interface
+#
+
+xdialog_ok()
+{
+	$DIALOG --title &quot;$DIALOG_CAPTION&quot; --msgbox &quot;$DIALOG_MESSAGE&quot; 0 0
+	return 0 # Give cancel on close ...
+}
+
+xdialog_yesno()
+{
+	$DIALOG --title &quot;$DIALOG_CAPTION&quot; --yesno &quot;$DIALOG_MESSAGE&quot; 0 0
+	RC=$?
+	[ $RC -eq 0 ] &amp;&amp; return 2
+	[ $RC -eq 1 ] &amp;&amp; return 0
+}
+
+xdialog_yesnosuspend()
+{
+	$DIALOG --title &quot;$DIALOG_CAPTION&quot; --buttons-style text --ok-label &quot;Suspend&quot; --cancel-label &quot;Terminate&quot; --yesno &quot;$DIALOG_MESSAGE Close window to cancel.&quot; 400x150
+	RC=$?
+	[ $RC -eq 0 ] &amp;&amp; return 3
+	[ $RC -eq 1 ] &amp;&amp; return 2
+}
+
+xdialog_panic()
+{
+	$DIALOG --title &quot;$DIALOG_CAPTION&quot; --buttons-style text --default-no --ok-label &quot;Terminate&quot; --cancel-label &quot;Cancel&quot; --yesno &quot;$DIALOG_MESSAGE&quot; 0x0
+	RC=$?
+	[ $RC -eq 0 ] &amp;&amp; return 2
+	[ $RC -eq 1 ] &amp;&amp; return 0
+}
+
+xdialog_quit()
+{
+        $DIALOG --buttons-style text --ok-label &quot;Quit&quot; --title &quot;$DIALOG_CAPTION&quot; --msgbox &quot;$DIALOG_MESSAGE&quot; 0 0
+        return 0 # Give cancel on close ...
+}
+
+xdialog_printer_ask()
+{
+	$DIALOG --title &quot;$DIALOG_CAPTION&quot; --buttons-style text --ok-label &quot;Ok&quot; --cancel-label &quot;Configure&quot; --yesno &quot;$DIALOG_MESSAGE\n\nClose window to cancel.&quot; 400x250
+	RC=$?
+	[ $RC -eq 255 ] &amp;&amp; return 2
+	return $RC
+}
+
+xdialog_printer_configure_vendor()
+{
+	IFS='|' VENDOR_LIST=( $(utility_printer getvendlist | sed 's/|/||off|/g') )
+	$DIALOG --stdout --title &quot;$DIALOG_CAPTION&quot; --radiolist &quot;$DIALOG_MESSAGE&quot; 0 0 6 &quot;${VENDOR_LIST[@]}&quot;
+}
+
+# xdialog_printer_configure_driver vendor old_driver
+xdialog_printer_configure_driver()
+{
+	IFS='|' XDIALOG_LIST=( $(utility_printer getextdrvlist &quot;$1&quot; | sed 's/$/|off/g; /'&quot;$2&quot;'/ s/|off/|on/g' | tr '\n' '|') )
+	$DIALOG --stdout --title &quot;$DIALOG_CAPTION&quot; --radiolist &quot;$DIALOG_MESSAGE&quot; 0 0 6 &quot;${XDIALOG_LIST[@]}&quot;
+}
+
+
+#
+# helper functions
+#
+
+helper_dialog_printer()
+{
+	IFS=&quot;|&quot; PRINTER_INFORMATION=( $(utility_printer get &quot;$DIALOG_PRINTER&quot;) )
+	PRINTER_CONFIGURE=&quot;yes&quot;
+	[ -z &quot;$DIALOG_CAPTION&quot; ] &amp;&amp; DIALOG_CAPTION=&quot;NX Printer configuration for $DIALOG_PRINTER&quot;
+	
+	# Do we have old printer information present?
+	if [ -n &quot;$PRINTER_INFORMATION&quot; ]
+	then
+		DIALOG_MESSAGE=$(echo -e &quot;Found driver for printer $DIALOG_PRINTER.\n\nOld choice was: ${PRINTER_INFORMATION[3]}.\n\nIf you want to keep the settings click on 'Ok' \n- else click on 'Configure'.&quot;) ${dialog_interface}_printer_ask
+		RC=$?
+		# bail out with exit code 2 in case the user cancelled the operation
+		[ $RC -eq 2 ] &amp;&amp; echo &quot;cancel: aborted&quot; &amp;&amp; exit 2
+		[ $RC -eq 0 ] &amp;&amp; PRINTER_CONFIGURE=&quot;no&quot;
+	fi
+	
+	VENDOR=&quot;&quot;
+	OLD_DRIVER=&quot;${PRINTER_INFORMATION[2]}&quot;
+
+	if [ &quot;$PRINTER_CONFIGURE&quot; = &quot;yes&quot; ]
+	then
+		DRIVER=&quot;&quot;
+		VENDOR=$(DIALOG_MESSAGE=&quot;Choose vendor for printer $DIALOG_PRINTER.&quot; ${dialog_interface}_printer_configure_vendor)
+		[ -n &quot;$VENDOR&quot; ] &amp;&amp; DRIVER=$(DIALOG_MESSAGE=&quot;Choose driver for printer $DIALOG_PRINTER.&quot; ${dialog_interface}_printer_configure_driver &quot;$VENDOR&quot; &quot;${OLD_DRIVER:-invalid}&quot;)
+		# set the new printer driver
+		if [ -n &quot;$DRIVER&quot; ]
+		then
+			DESC=$(utility_printer getdesc &quot;$DRIVER&quot;)
+			utility_printer set &quot;$DIALOG_PRINTER&quot; &quot;$DRIVER&quot; &quot;$DESC&quot;
+		fi
+	else
+		DRIVER=&quot;$OLD_DRIVER&quot;
+	fi
+
+	# echo the choosen &lt;ppdfile&gt; to stdout
+	[ -n &quot;$DRIVER&quot; ] &amp;&amp; echo &quot;$DRIVER&quot;
+	[ -z &quot;$DRIVER&quot; ] &amp;&amp; echo &quot;cancel: aborted&quot; &amp;&amp; exit 2
+			
+	exit 0
+}
+
+#
+# main case statement
+#
+
+case $DIALOG_TYPE in 
+	ok)
+		${dialog_interface}_ok
+	;;
+	yesno)
+		${dialog_interface}_yesno
+	;;
+	yesnosuspend)
+		${dialog_interface}_yesnosuspend
+	;;
+	panic)
+		${dialog_interface}_panic
+	;;
+	quit)
+		${dialog_interface}_quit
+	;;
+	printer)
+		helper_dialog_printer
+	;;
+esac
+
+#
+# Time for exit code checks :)
+#
+
+RC=$?
+	[ $RC -eq 2 ] &amp;&amp; kill -TERM $PPID
+	[ $RC -eq 3 ] &amp;&amp; kill -HUP $PPID
+exit 0


Property changes on: freenx-server/nxclient
___________________________________________________________________
Name: svn:executable
   + 

Added: freenx-server/nxkeygen
===================================================================
--- freenx-server/nxkeygen	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/nxkeygen	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,69 @@
+#!/bin/bash
+#
+# /usr/NX/bin/nxkeygen
+#		Create a new client/server key pair
+#
+#		Originally written for Gentoo Linux
+#
+# Author	Stuart Herbert
+#		(<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">stuart at gentoo.org</A>)
+#
+# Copyright	(c) 2004 Gentoo Foundation
+#		Released under v2 of the GNU GPL
+#
+# CVS: $Id: nxkeygen,v 1.12 2005/05/05 08:04:24 jonno Exp $
+#
+# ========================================================================
+
+# Read the config file
+. $(PATH=$(cd $(dirname $0) &amp;&amp; pwd):$PATH which nxloadconfig) --
+
+NX_KEY_DIR=&quot;$NX_HOME_DIR/.ssh&quot;
+DATE=&quot;`date '+%Y%m%d-%H%M%S'`&quot;
+NX_CLIENT_KEY=&quot;${NX_KEY_DIR}/client.id_dsa.key&quot;
+NX_SERVER_KEY=&quot;${NX_KEY_DIR}/server.id_dsa.pub.key&quot;
+
+main ()
+{
+	# create a new key
+	umask 177
+	$COMMAND_SSH_KEYGEN -q -t dsa -N '' -f ${NX_KEY_DIR}/local.id_dsa
+
+	# backup the existing keys
+	
+	if [ -f &quot;${NX_SERVER_KEY}&quot; ]; then
+		echo &quot;Backing up existing server key to ${NX_SERVER_KEY}.${DATE}&quot;
+		mv -f &quot;${NX_SERVER_KEY}&quot; &quot;${NX_SERVER_KEY}.${DATE}&quot;
+	fi
+
+	if [ -f &quot;${NX_CLIENT_KEY}&quot; ]; then
+		echo &quot;Backing up existing client key to ${NX_CLIENT_KEY}.${DATE}&quot;
+		mv -f &quot;${NX_CLIENT_KEY}&quot; &quot;${NX_CLIENT_KEY}.${DATE}&quot;
+	fi
+
+	# put the new keys in place
+
+	mv -f &quot;${NX_KEY_DIR}/local.id_dsa&quot; &quot;${NX_CLIENT_KEY}&quot;
+	mv -f &quot;${NX_KEY_DIR}/local.id_dsa.pub&quot; &quot;${NX_SERVER_KEY}&quot;
+
+	for x in ${NX_CLIENT_KEY} ${NX_SERVER_KEY} ; do
+		chmod 600 $x
+		chown nx:root $x
+	done
+	
+	# copy the key to the authorized_keys2 file
+	rm -f $NX_KEY_DIR/$SSH_AUTHORIZED_KEYS
+	echo -n &quot;no-port-forwarding,no-X11-forwarding,no-agent-forwarding,command=\&quot;$PATH_BIN/nxserver\&quot; &quot; &gt;$NX_KEY_DIR/$SSH_AUTHORIZED_KEYS
+	cat ${NX_SERVER_KEY} &gt;&gt; $NX_KEY_DIR/$SSH_AUTHORIZED_KEYS
+
+	# now tell the user what to do
+
+	echo &quot;Unique key generated; your users must install&quot;
+	echo
+	echo &quot;    ${NX_CLIENT_KEY}&quot;
+	echo
+	echo &quot;on their computers.&quot;
+}
+
+main &quot;$@&quot;
+


Property changes on: freenx-server/nxkeygen
___________________________________________________________________
Name: svn:executable
   + 

Added: freenx-server/nxloadconfig
===================================================================
--- freenx-server/nxloadconfig	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/nxloadconfig	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,455 @@
+#!/bin/bash
+#
+# Copyright (c) 2005 by Fabian Franz &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">freenx at fabian-franz.de</A>&gt;
+#           (c) 2005 by Jon Severinsson &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">jonno at users.berlios.de</A>&gt;
+#
+# License: GPL, version 2
+#
+# CVS: $Id: nxloadconfig,v 1.33 2005/05/05 08:34:20 jonno Exp $
+#
+# ========================================================================
+
+#########################################################################
+# Commandline support for --help, --check and --userconf
+#########################################################################
+
+HELP=&quot;no&quot;
+CHECK=&quot;no&quot;
+USERCONF=&quot;no&quot;
+
+while [ &quot;$1&quot; ]
+do
+	case &quot;$1&quot; in
+		--help) HELP=&quot;yes&quot;; shift ;;
+		--check) CHECK=&quot;yes&quot;; shift ;;
+		--userconf) USERCONF=&quot;yes&quot; ; 
+					case &quot;$2&quot; in
+						&quot;&quot; | --*) shift ;;
+						*) USER=$2 ; shift 2 ;;
+					esac ;;
+		--) shift ; break ;;
+		*) echo &quot;Invalid flag $1&quot; ; HELP=&quot;yes&quot;; shift ; break ;;
+	esac
+done
+
+if [ &quot;$HELP&quot; = &quot;yes&quot; ]
+then
+	echo &quot;nxloadconfig - Load the FreeNX configuration variables into the environment.&quot;
+	echo &quot;Syntax: nxloadconfig --help&quot;
+	echo &quot;        nxloadconfig [--check] [--userconf [&lt;username&gt;]]&quot;
+	echo
+	echo &quot;  --check                  Write errors to standard output.&quot;
+	echo &quot;  --userconf [&lt;username&gt;]  Parse &lt;username&gt;.node.conf as well as node.conf.&quot;
+	echo &quot;                           Assume current user if no username is specified.&quot;
+	exit 0
+fi
+
+#########################################################################
+# INTERNAL STUFF
+# DO NOT TOUCH unless you REALLY know what you are doing
+#########################################################################
+
+NX_VERSION=1.4.0-04-CVS
+NX_LICENSE=&quot;OS (GPL)&quot;
+
+# Where can different nx components be found
+NX_DIR=/usr
+PATH_BIN=$NX_DIR/bin # if you change that, be sure to also change the public keys
+PATH_LIB=$NX_DIR/lib
+NX_ETC_DIR=/etc/nxserver
+NX_SESS_DIR=/var/lib/nxserver/db
+NX_HOME_DIR=/var/lib/nxserver/home
+
+# Advanced users ONLY
+AGENT_LIBRARY_PATH=&quot;&quot; #Calculated
+PROXY_LIBRARY_PATH=&quot;&quot; #Calculated
+APPLICATION_LIBRARY_PATH=&quot;&quot; #Calculated
+APPLICATION_LIBRARY_PRELOAD=&quot;&quot; #Calculated
+
+# the name of the authorized keys file for ssh
+SSH_AUTHORIZED_KEYS=&quot;authorized_keys2&quot;
+
+#########################################################################
+# Default Values
+# A user should NEVER touch this, edit $NX_ETC_DIR/node.conf instead
+#########################################################################
+
+# General FreeNX directives
+
+SERVER_NAME=&quot;$(hostname)&quot;
+SSHD_PORT=22
+
+
+# Authentication / Security directives
+
+ENABLE_PASSDB_AUTHENTICATION=&quot;1&quot;
+ENABLE_SSH_AUTHENTICATION=&quot;1&quot;
+ENABLE_SU_AUTHENTICATION=&quot;0&quot;
+ENABLE_USER_DB=&quot;0&quot;
+
+ENABLE_FORCE_ENCRYPTION=&quot;0&quot;
+SSHD_CHECK_IP=&quot;0&quot;
+
+
+# Restriction directives
+
+DISPLAY_BASE=1000
+SESSION_LIMIT=200
+SESSION_USER_LIMIT=&quot;&quot; #Calculated
+DISPLAY_LIMIT=200
+
+ENABLE_PERSISTENT_SESSION=&quot;all&quot;
+DISABLE_PERSISTENT_SESSION=&quot;&quot;
+
+
+# Logging directives
+
+NX_LOG_LEVEL=0
+NX_LOGFILE=/var/log/nxserver.log
+SESSION_LOG_CLEAN=1
+SESSION_HISTORY=2592000
+
+
+# Forwarding directives
+
+ENABLE_SERVER_FORWARD=&quot;0&quot;
+SERVER_FORWARD_HOST=&quot;&quot;
+SERVER_FORWARD_PORT=22
+SERVER_FORWARD_KEY=&quot;/usr/NX/share/client.id_dsa.key&quot;
+
+ENABLE_NOMACHINE_FORWARD_USER=&quot;0&quot;
+NOMACHINE_SERVER=&quot;/usr/NX/bin/nxserver&quot;
+NOMACHINE_NX_HOME_DIR=&quot;/usr/NX/home/nx&quot;
+
+ENABLE_NOMACHINE_FORWARD_PORT=&quot;0&quot;
+NOMACHINE_FORWARD_PORT=&quot;22&quot;
+
+
+# Services directives
+
+ENABLE_ESD_PRELOAD=&quot;0&quot;
+ESD_BIN_PRELOAD=&quot;esddsp&quot;
+ENABLE_ARTSD_PRELOAD=&quot;0&quot;
+ARTSD_BIN_PRELOAD=&quot;artsdsp&quot;
+
+ENABLE_KDE_CUPS=&quot;0&quot;
+KDE_PRINTRC=&quot;&quot; # Calculated
+CUPS_ETC=&quot;/etc/cups/&quot;
+
+# Path directives
+
+USER_FAKE_HOME=&quot;&quot; #Calculated
+SET_LD_LIBRARY_PATH=&quot;1&quot;
+
+DEFAULT_X_WM=&quot;&quot;
+KILL_DEFAULT_X_WM=&quot;1&quot;
+USER_X_STARTUP_SCRIPT=.Xclients
+DEFAULT_X_SESSION=/etc/X11/xdm/Xsession
+COMMAND_START_KDE=startkde
+COMMAND_START_GNOME=gnome-session
+COMMAND_START_CDE=cdwm
+COMMAND_XTERM=xterm
+COMMAND_XAUTH=/usr/X11R6/bin/xauth
+COMMAND_SMBMOUNT=smbmount
+COMMAND_SMBUMOUNT=smbumount
+COMMAND_NETCAT=netcat
+COMMAND_SSH=ssh
+COMMAND_SSH_KEYGEN=ssh-keygen
+COMMAND_CUPSD=/usr/sbin/cupsd
+
+
+# Misc directives
+
+ENABLE_AUTORECONNECT=&quot;0&quot;
+ENABLE_AUTORECONNECT_BEFORE_140=&quot;1&quot;
+EXPORT_USERIP=&quot;0&quot;
+EXPORT_SESSIONID=&quot;0&quot;
+NODE_AUTOSTART=&quot;&quot;
+ENABLE_ROOTLESS_MODE=&quot;0&quot;
+ENABLE_USESSION=&quot;0&quot;
+COMMAND_SESSREG=&quot;sessreg&quot;
+AGENT_EXTRA_OPTIONS_RFB=&quot;&quot;
+AGENT_EXTRA_OPTIONS_RDP=&quot;&quot;
+AGENT_EXTRA_OPTIONS_X=&quot;&quot;
+AGENT_FONT_SERVER=&quot;&quot;
+PROXY_TCP_NODELAY=&quot;0&quot;
+PROXY_EXTRA_OPTIONS=&quot;&quot;
+
+
+#########################################################################
+# node.conf file evaluation
+#########################################################################
+
+[ -e $NX_ETC_DIR/node.conf ] &amp;&amp; . $NX_ETC_DIR/node.conf
+[ &quot;$USERCONF&quot; = &quot;yes&quot; -a -e $NX_ETC_DIR/$USER.node.conf ] &amp;&amp; . $NX_ETC_DIR/$USER.node.conf
+
+
+#########################################################################
+# Calculated values
+#########################################################################
+
+[ -z &quot;$SESSION_USER_LIMIT&quot; ] &amp;&amp; SESSION_USER_LIMIT=$SESSION_LIMIT
+[ -z &quot;$USER_FAKE_HOME&quot; ] &amp;&amp; USER_FAKE_HOME=$HOME
+
+[ -z &quot;$AGENT_LIBRARY_PATH&quot; ] &amp;&amp; AGENT_LIBRARY_PATH=$PATH_LIB
+[ -z &quot;$PROXY_LIBRARY_PATH&quot; ] &amp;&amp; PROXY_LIBRARY_PATH=$PATH_LIB
+[ -z &quot;$APPLICATION_LIBRARY_PATH&quot; ] &amp;&amp; APPLICATION_LIBRARY_PATH=$PATH_LIB
+[ -z &quot;$APPLICATION_LIBRARY_PRELOAD&quot; ] &amp;&amp; APPLICATION_LIBRARY_PRELOAD=&quot;$APPLICATION_LIBRARY_PATH/libX11.so.6.2:$APPLICATION_LIBRARY_PATH/libXext.so.6.4:$APPLICATION_LIBRARY_PATH/libXcomp.so.1:$APPLICATION_LIBRARY_PATH/libXcompext.so.1:$APPLICATION_LIBRARY_PATH/libXrender.so.1.2&quot;
+
+[ -z &quot;$KDE_PRINTRC&quot; -a -n &quot;$KDEHOME&quot; ] &amp;&amp; KDE_PRINTRC=&quot;$KDEHOME/share/config/kdeprintrc&quot;
+[ -z &quot;$KDE_PRINTRC&quot; -a -z &quot;$KDEHOME&quot; ] &amp;&amp; KDE_PRINTRC=&quot;$HOME/.kde/share/config/kdeprintrc&quot;
+
+#########################################################################
+# Support for --check
+#########################################################################
+
+if [ &quot;$CHECK&quot; = &quot;yes&quot; ]
+then
+	ERROR=&quot;no&quot;
+	WARNING=&quot;no&quot;
+	
+	# Internal Stuff
+	
+	[ ! -d &quot;$PATH_BIN&quot; ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;PATH_BIN=$PATH_BIN\&quot;&quot;
+	[ ! -d &quot;$PATH_LIB&quot; ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;PATH_LIB=$PATH_LIB\&quot;&quot;
+	[ ! -d &quot;$NX_ETC_DIR&quot; ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;NX_ETC_DIR=$NX_ETC_DIR\&quot;&quot;
+	[ ! -d &quot;$NX_SESS_DIR&quot; ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;NX_SESS_DIR=$NX_SESS_DIR\&quot;&quot;
+	[ ! -d &quot;$NX_HOME_DIR&quot; ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;NX_HOME_DIR=$NX_HOME_DIR\&quot;&quot;
+
+	[ ! -d &quot;$AGENT_LIBRARY_PATH&quot; ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;AGENT_LIBRARY_PATH=$AGENT_LIBRARY_PATH\&quot;&quot;
+	[ ! -d &quot;$PROXY_LIBRARY_PATH&quot; ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;PROXY_LIBRARY_PATH=$PROXY_LIBRARY_PATH\&quot;&quot;
+	[ ! -d &quot;$APPLICATION_LIBRARY_PATH&quot; ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;APPLICATION_LIBRARY_PATH=$APPLICATION_LIBRARY_PATH\&quot;&quot;
+	
+	OLD_IFS=$IFS
+	IFS=&quot;:&quot;
+	for LIBRARY in $APPLICATION_LIBRARY_PRELOAD; do
+		[ ! -e $LIBRARY ] &amp;&amp; \
+			ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;APPLICATION_LIBRARY_PRELOAD=$APPLICATION_LIBRARY_PRELOAD\&quot;&quot; &amp;&amp; break ;
+	done
+	IFS=$OLD_IFS
+	
+	[ -z &quot;$SSH_AUTHORIZED_KEYS&quot; ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;SSH_AUTHORIZED_KEYS=$SSH_AUTHORIZED_KEYS\&quot;&quot;
+	
+	
+	# General FreeNX directives
+	
+	[ -z &quot;$SERVER_NAME&quot; ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;SERVER_NAME=$SERVER_NAME\&quot;&quot;
+	[ -z $(echo &quot;$SSHD_PORT&quot; | egrep &quot;^[1-9][0-9]{0,4}$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;SSHD_PORT=$SSHD_PORT\&quot;&quot;
+	
+	
+	# Authentication / Security directives
+	
+	[ -z $(echo &quot;$ENABLE_PASSDB_AUTHENTICATION&quot; | egrep &quot;^[0|1]$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;ENABLE_PASSDB_AUTHENTICATION=$ENABLE_PASSDB_AUTHENTICATION\&quot;&quot;
+	[ -z $(echo &quot;$ENABLE_SSH_AUTHENTICATION&quot; | egrep &quot;^[0|1]$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;ENABLE_SSH_AUTHENTICATION=$ENABLE_SSH_AUTHENTICATION:\&quot;&quot;
+	[ -z $(echo &quot;$ENABLE_SU_AUTHENTICATION&quot; | egrep &quot;^[0|1]$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;ENABLE_SU_AUTHENTICATION=$NENABLE_SU_AUTHENTICATION\&quot;&quot;
+	[ -z $(echo &quot;$ENABLE_USER_DB&quot; | egrep &quot;^[0|1]$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;ENABLE_USER_DB=$ENABLE_USER_DB\&quot;&quot;
+	
+	[ -z $(echo &quot;$ENABLE_FORCE_ENCRYPTION&quot; | egrep &quot;^[0|1]$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;ENABLE_FORCE_ENCRYPTION=$ENABLE_FORCE_ENCRYPTION\&quot;&quot;
+	[ -z $(echo &quot;$SSHD_CHECK_IP&quot; | egrep &quot;^[0|1]$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;SSHD_CHECK_IP=$SSHD_CHECK_IP\&quot;&quot;
+	
+	
+	# Restriction directives
+	
+	[ -z $(echo &quot;$DISPLAY_BASE&quot; | egrep &quot;^[1-9][0-9]{0,4}$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;DISPLAY_BASE=$DISPLAY_BASE\&quot;&quot;
+	[ -z $(echo &quot;$SESSION_LIMIT&quot; | egrep &quot;^[1-9][0-9]{0,4}$&quot;) ] &amp;&amp;  \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;SESSION_LIMIT=$SESSION_LIMIT\&quot;&quot;
+	[ -z $(echo &quot;$SESSION_USER_LIMIT&quot; | egrep &quot;^[1-9][0-9]{0,4}$&quot;) -o $SESSION_USER_LIMIT -gt $SESSION_LIMIT ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;SESSION_USER_LIMIT=$SESSION_USER_LIMIT\&quot;&quot;
+	[ -z $(echo &quot;$DISPLAY_LIMIT&quot; | egrep &quot;^[1-9][0-9]{0,4}$&quot;) -o $DISPLAY_LIMIT -lt $SESSION_LIMIT ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;DISPLAY_LIMIT=$DISPLAY_LIMIT\&quot;&quot;
+	
+	OLD_IFS=$IFS
+	IFS=&quot;,&quot;
+	if [ &quot;$ENABLE_PERSISTENT_SESSION&quot; != &quot;all&quot; ]
+	then
+		for USERNAME in $ENABLE_PERSISTENT_SESSION; do
+			[ &quot;${USERNAME:0:1}&quot; != &quot;@&quot; ] &amp;&amp; [ -z $(getent passwd | egrep &quot;^$USERNAME:&quot;) ] &amp;&amp; \
+				ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;ENABLE_PERSISTENT_SESSION=$ENABLE_PERSISTENT_SESSION\&quot;&quot; &amp;&amp; break ;
+			[ &quot;${USERNAME:0:1}&quot; = &quot;@&quot; ] &amp;&amp; [ -z $(getent group | egrep &quot;^${USERNAME:1}:&quot;) ] &amp;&amp; \
+				ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;ENABLE_PERSISTENT_SESSION=$ENABLE_PERSISTENT_SESSION\&quot;&quot; &amp;&amp; break ;
+		done
+	fi
+	for USERNAME in $DISABLE_PERSISTENT_SESSION; do
+		[ &quot;${USERNAME:0:1}&quot; != &quot;@&quot; ] &amp;&amp; [ -z $(getent passwd | egrep &quot;^$USERNAME:&quot;) ] &amp;&amp; \
+			ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;DISABLE_PERSISTENT_SESSION=$DISABLE_PERSISTENT_SESSION\&quot;&quot; &amp;&amp; break ;
+		[ &quot;${USERNAME:0:1}&quot; = &quot;@&quot; ] &amp;&amp; [ -z $(getent group | egrep &quot;^${USERNAME:1}:&quot;) ] &amp;&amp; \
+			ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;DISABLE_PERSISTENT_SESSION=$DISABLE_PERSISTENT_SESSION\&quot;&quot; &amp;&amp; break ;
+	done
+	IFS=$OLD_IFS
+	
+	
+	# Logging directives
+	
+	[ -z $(echo &quot;$NX_LOG_LEVEL&quot; | egrep &quot;^[0-7]$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;NX_LOG_LEVEL=$NX_LOG_LEVEL\&quot;&quot;
+	[ &quot;$NX_LOG_LEVEL&quot; != &quot;0&quot; -a ! -e &quot;$NX_LOGFILE&quot; ] &amp;&amp; \
+		WARNING=&quot;yes&quot; &amp;&amp; echo &quot;Warning: Invalid value \&quot;NX_LOGFILE=$NX_LOGFILE\&quot;&quot; \
+					  &amp;&amp; echo &quot;         No loggfile will be kept.&quot;
+		# How do I check if another user might write to a file? ( -w checks only current user)
+	[ -z $(echo &quot;$SESSION_LOG_CLEAN&quot; | egrep &quot;^[0|1]$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;SESSION_LOG_CLEAN=$SESSION_LOG_CLEAN\&quot;&quot;
+	[ -z $(echo &quot;$SESSION_HISTORY&quot; | egrep &quot;^-?[0-9]+$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;SESSION_HISTORY=$SESSION_HISTORY\&quot;&quot;
+	
+	
+	# Forwarding directives
+	
+	[ -z $(echo &quot;$ENABLE_SERVER_FORWARD&quot; | egrep &quot;^[0|1]$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;ENABLE_SERVER_FORWARD=$ENABLE_SERVER_FORWARD\&quot;&quot;
+	[ &quot;$ENABLE_SERVER_FORWARD&quot; = &quot;1&quot; -a -z &quot;$SERVER_FORWARD_HOST&quot; ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;SERVER_FORWARD_HOST=$SERVER_FORWARD_HOST\&quot;&quot; 
+		# Any ideas on how I can check for a VALID host is velcome!
+		# In my private scripts I use 'resolveip -q' and check if output conforms to [0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}, 
+		# but resolveip is part of mysql, and I don't think I should add that dependancy...
+	[ &quot;$ENABLE_SERVER_FORWARD&quot; = &quot;1&quot; -a -z $(echo &quot;$SERVER_FORWARD_PORT&quot; | egrep &quot;^[1-9][0-9]{0,4}$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;SERVER_FORWARD_PORT=$SERVER_FORWARD_PORT\&quot;&quot;
+	[ &quot;$ENABLE_SERVER_FORWARD&quot; = &quot;1&quot; -a ! -e &quot;$SERVER_FORWARD_KEY&quot; ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;SERVER_FORWARD_KEY=$SERVER_FORWARD_KEY\&quot;&quot;
+	
+	[ -z $(echo &quot;$ENABLE_NOMACHINE_FORWARD_USER&quot; | egrep &quot;^[0|1]$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;ENABLE_NOMACHINE_FORWARD_USER=$ENABLE_NOMACHINE_FORWARD_USER\&quot;&quot;
+	[ -z $(echo &quot;$ENABLE_NOMACHINE_FORWARD_PORT&quot; | egrep &quot;^[0|1]$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;ENABLE_NOMACHINE_FORWARD_PORT=$ENABLE_NOMACHINE_FORWARD_PORT\&quot;&quot;
+	[ &quot;$ENABLE_NOMACHINE_FORWARD_USER&quot; = &quot;1&quot; -o &quot;$ENABLE_NOMACHINE_FORWARD_PORT&quot; = &quot;1&quot; ] &amp;&amp; ! which &quot;$NOMACHINE_SERVER&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;NOMACHINE_SERVER=$NOMACHINE_SERVER\&quot;&quot;
+	[ &quot;$ENABLE_NOMACHINE_FORWARD_USER&quot; = &quot;1&quot; -a ! -d &quot;$NOMACHINE_NX_HOME_DIR&quot; ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;NOMACHINE_NX_HOME_DIR=$NOMACHINE_NX_HOME_DIR\&quot;&quot;
+	[ &quot;$ENABLE_NOMACHINE_FORWARD_PORT&quot; = &quot;1&quot; -a -z $(echo &quot;$NOMACHINE_FORWARD_PORT&quot; | egrep &quot;^[1-9][0-9]{0,4}$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;NOMACHINE_FORWARD_PORT=$NOMACHINE_FORWARD_PORT\&quot;&quot;
+	
+	
+	# Services directives
+	
+	[ -z $(echo &quot;$ENABLE_ESD_PRELOAD&quot; | egrep &quot;^[0|1]$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;ENABLE_ESD_PRELOAD=$ENABLE_ESD_PRELOAD\&quot;&quot;
+	[ &quot;$ENABLE_ESD_PRELOAD&quot; = &quot;1&quot; ] &amp;&amp; ! which &quot;$ESD_BIN_PRELOAD&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; \
+		WARNING=&quot;yes&quot; &amp;&amp; echo &quot;Warning: Invalid value \&quot;ESD_BIN_PRELOAD=$ESD_BIN_PRELOAD\&quot;&quot; \
+					  &amp;&amp; echo &quot;         No esd preload will be performed.&quot;
+	
+	[ -z $(echo &quot;$ENABLE_ARTSD_PRELOAD&quot; | egrep &quot;^[0|1]$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;ENABLE_ARTSD_PRELOAD=$ENABLE_ARTSD_PRELOAD\&quot;&quot;
+	[ &quot;$ARTSD_BIN_PRELOAD&quot; = &quot;1&quot; ] &amp;&amp; ! which &quot;$ARTSD_BIN_PRELOAD&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; \
+		WARNING=&quot;yes&quot; &amp;&amp; echo &quot;Warning: Invalid value \&quot;ARTSD_BIN_PRELOAD=$ARTSD_BIN_PRELOAD\&quot;&quot; \
+					  &amp;&amp; echo &quot;         No arts preload will be performed.&quot;
+	
+	[ -z $(echo &quot;$ENABLE_KDE_CUPS&quot; | egrep &quot;^[0|1]$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;ENABLE_KDE_CUPS=$ENABLE_KDE_CUPS\&quot;&quot;
+	[ &quot;$ENABLE_KDE_CUPS&quot; = &quot;1&quot; -a ! -e &quot;$KDE_PRINTRC&quot; ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;KDE_PRINTRC=$KDE_PRINTRC\&quot;&quot;
+	[ ! -e &quot;$CUPS_ETC/mime.types&quot; -o ! -e &quot;$CUPS_ETC/mime.convs&quot; ] &amp;&amp; \
+		WARNING=&quot;yes&quot; &amp;&amp; echo &quot;Warning: Invalid value \&quot;CUPS_ETC=$CUPS_ETC\&quot;&quot; \
+					  &amp;&amp; echo &quot;         Users will not be able to enable printing.&quot;
+	
+	# Path directives
+	
+	[ ! -d &quot;$USER_FAKE_HOME&quot; ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;USER_FAKE_HOME=$USER_FAKE_HOME\&quot;&quot;
+	[ -z $(echo &quot;$SET_LD_LIBRARY_PATH&quot; | egrep &quot;^[0|1]$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;SET_LD_LIBRARY_PATH=$SET_LD_LIBRARY_PATH\&quot;&quot;
+	
+	[ &quot;$DEFAULT_X_WM&quot; != &quot;&quot; ] &amp;&amp; ! which &quot;$DEFAULT_X_WM&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;DEFAULT_X_WM=$DEFAULT_X_WM\&quot;&quot;
+	[ &quot;$DEFAULT_X_WM&quot; != &quot;&quot; -a  -z $(echo &quot;$KILL_DEFAULT_X_WM&quot; | egrep &quot;^[0|1]$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;KILL_DEFAULT_X_WM=$KILL_DEFAULT_X_WM\&quot;&quot;
+	[ -z &quot;$USER_X_STARTUP_SCRIPT&quot; ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;USER_X_STARTUP_SCRIPT=$USER_X_STARTUP_SCRIPT\&quot;&quot;
+	! which &quot;$DEFAULT_X_SESSION&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; \
+		WARNING=&quot;yes&quot; &amp;&amp; echo &quot;Warning: Invalid value \&quot;DEFAULT_X_SESSION=$DEFAULT_X_SESSION\&quot;&quot; \
+					  &amp;&amp; echo &quot;         Users might not be able to request a default X session.&quot;
+	! which &quot;$COMMAND_START_KDE&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; \
+		WARNING=&quot;yes&quot; &amp;&amp; echo &quot;Warning: Invalid value \&quot;COMMAND_START_KDE=$COMMAND_START_KDE\&quot;&quot; \
+					  &amp;&amp; echo &quot;         Users will not be able to request a KDE session.&quot;
+	! which &quot;$COMMAND_START_GNOME&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; \
+		WARNING=&quot;yes&quot; &amp;&amp; echo &quot;Warning: Invalid value \&quot;COMMAND_START_GNOME=$COMMAND_START_GNOME\&quot;&quot; \
+					  &amp;&amp; echo &quot;         Users will not be able to request a Gnome session.&quot;
+	! which &quot;$COMMAND_START_CDE&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; \
+		WARNING=&quot;yes&quot; &amp;&amp; echo &quot;Warning: Invalid value \&quot;COMMAND_START_CDE=$COMMAND_START_CDE\&quot;&quot; \
+					  &amp;&amp; echo &quot;         Users will not be able to request a CDE session.&quot;
+	! which &quot;$COMMAND_XTERM&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; \
+		WARNING=&quot;yes&quot; &amp;&amp; echo &quot;Warning: Invalid value \&quot;COMMAND_XTERM=$COMMAND_XTERM\&quot;&quot; \
+					  &amp;&amp; echo &quot;         Users will not be able to request an xterm session.&quot;
+	! which &quot;$COMMAND_XAUTH&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;COMMAND_XAUTH=$COMMAND_XAUTH\&quot;&quot;
+	! which &quot;$COMMAND_SMBMOUNT&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;COMMAND_SMBMOUNT=$COMMAND_SMBMOUNT\&quot;&quot;
+	! which &quot;$COMMAND_SMBUMOUNT&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;COMMAND_SMBUMOUNT=$COMMAND_SMBUMOUNT\&quot;&quot;
+	! which &quot;$COMMAND_NETCAT&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;COMMAND_NETCAT=$COMMAND_NETCAT\&quot;&quot;
+	! which &quot;$COMMAND_SSH&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;COMMAND_SSH=$COMMAND_SSH\&quot;&quot;
+	! which &quot;$COMMAND_SSH_KEYGEN&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;COMMAND_SSH_KEYGEN=$COMMAND_SSH_KEYGEN\&quot;&quot;
+	! which &quot;$COMMAND_CUPSD&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; \
+		WARNING=&quot;yes&quot; &amp;&amp; echo &quot;Warning: Invalid value \&quot;COMMAND_CUPSD=$COMMAND_CUPSD\&quot;&quot; \
+					  &amp;&amp; echo &quot;         Users will not be able to enable printing.&quot;
+
+	# Misc directives
+	
+	[ -z $(echo &quot;$ENABLE_AUTORECONNECT&quot; | egrep &quot;^[0|1]$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;ENABLE_AUTORECONNECT=$ENABLE_AUTORECONNECT\&quot;&quot;
+	[ -z $(echo &quot;$ENABLE_AUTORECONNECT_BEFORE_140&quot; | egrep &quot;^[0|1]$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;ENABLE_AUTORECONNECT_BEFORE_140=$ENABLE_AUTORECONNECT_BEFORE_140\&quot;&quot;
+	
+	[ -z $(echo &quot;$EXPORT_USERIP&quot; | egrep &quot;^[0|1]$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;EXPORT_USERIP=$EXPORT_USERIP\&quot;&quot;
+	[ -z $(echo &quot;$EXPORT_SESSIONID&quot; | egrep &quot;^[0|1]$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;EXPORT_SESSIONID=$EXPORT_SESSIONID\&quot;&quot;
+	[ -n &quot;$NODE_AUTOSTART&quot; ] &amp;&amp; ! which &quot;$NODE_AUTOSTART&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; \
+		WARNING=&quot;yes&quot; &amp;&amp; echo &quot;Warning: Invalid value \&quot;NODE_AUTOSTART=$NODE_AUTOSTART\&quot;&quot; \
+					  &amp;&amp; echo &quot;         No autostart will be performed.&quot;
+
+	[ -z $(echo &quot;$ENABLE_ROOTLESS_MODE&quot; | egrep &quot;^[0|1]$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;ENABLE_ROOTLESS_MODE=$ENABLE_ROOTLESS_MODE\&quot;&quot;
+
+	[ -z $(echo &quot;$ENABLE_USESSION&quot; | egrep &quot;^[0|1]$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;ENABLE_USESSION=$ENABLE_USESSION\&quot;&quot;
+	[ &quot;$ENABLE_USESSION&quot; = &quot;1&quot; ] &amp;&amp; ! which &quot;$COMMAND_SESSREG&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; \
+		WARNING=&quot;yes&quot; &amp;&amp; echo &quot;Warning: Invalid value \&quot;COMMAND_SESSREG=$COMMAND_SESSREG\&quot;&quot; \
+					  &amp;&amp; echo &quot;         Logged in users will not be registered with sessreg.&quot;
+	
+	#AGENT_EXTRA_OPTIONS_RFB=&quot;&quot;
+	#AGENT_EXTRA_OPTIONS_RDP=&quot;&quot;
+	#AGENT_EXTRA_OPTIONS_X=&quot;&quot;
+	#PROXY_EXTRA_OPTIONS=&quot;&quot;
+		#Can these be checked???
+	
+	#AGENT_FONT_SERVER=&quot;&quot;
+		#Any ideas on how I can check for a VALID host is velcome!
+	
+	[ -z $(echo &quot;$PROXY_TCP_NODELAY&quot; | egrep &quot;^[0|1]$&quot;) ] &amp;&amp; \
+		ERROR=&quot;yes&quot; &amp;&amp; echo &quot;Error: Invalid value \&quot;PROXY_TCP_NODELAY=$PROXY_TCP_NODELAY\&quot;&quot;
+	
+	
+	if [ &quot;$ERROR&quot; = &quot;yes&quot; ]
+	then
+		echo
+		echo &quot;  Errors occured during config check.&quot;
+		echo &quot;  Please correct the configuration file.&quot;
+		echo
+	elif [ &quot;$WARNING&quot; = &quot;yes&quot; ]
+	then
+		echo
+		echo &quot;  Warnings occured during config check.&quot;
+		echo &quot;  To enable these features please correct the configuration file.&quot;
+		echo
+	fi
+fi


Property changes on: freenx-server/nxloadconfig
___________________________________________________________________
Name: svn:executable
   + 

Added: freenx-server/nxnode
===================================================================
--- freenx-server/nxnode	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/nxnode	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,818 @@
+#!/bin/bash
+
+# Free implementation of nxserver components
+#
+# nxnode does accept (for now):
+# 
+#	--startsession
+#	--terminate
+#	--smbmount 
+#		(smbmount is not implemented yet)
+#
+# Copyright (c) 2004 by Fabian Franz.
+#
+# License: GNU GPL, version 2
+#
+# CVS: $Id: nxnode,v 1.60 2005/06/23 15:42:52 fabianx Exp $
+#
+# 21.06.2004: - Full reconnection support
+
+# Read the config file
+. $(PATH=$(cd $(dirname $0) &amp;&amp; pwd):$PATH which nxloadconfig) --userconf
+
+echo &quot;NX&gt; 1000 NXNODE - Version $NX_VERSION $NX_LICENSE&quot;
+
+if [ &quot;$1&quot; != &quot;--check&quot; -a &quot;$1&quot; != &quot;--setkey&quot; ]
+then 
+	read CMDLINE
+
+	CMDLINE=&quot;a=b&amp;$CMDLINE&quot;
+fi
+
+# --------
+
+# following two functions are Copyright by Klaus Knopper
+
+# same for strings
+stringinstring(){
+case &quot;$2&quot; in *$1*) return 0;; esac
+return 1
+}
+
+# Reread boot command line; echo last parameter's argument or return false.
+getparam(){
+stringinstring &quot;&amp;$1=&quot; &quot;$CMDLINE&quot; || return 1
+echo &quot;$CMDLINE&quot; | awk &quot;/^$1=/&quot;' { VAL=$2 } END { print VAL }' FS=&quot;=&quot; RS=&quot;(&amp;|\n)&quot;
+return 0
+}
+
+find_app()
+{
+	set -- $*
+	which $1 2&gt;/dev/null
+}
+
+getparam_user()
+{
+	[ $UID -eq 0 ] &amp;&amp; echo $(getparam user)
+	[ $UID -eq 0 ] || $(whoami)
+}
+
+node_abort()
+{
+	echo &quot;$@&quot; 1&gt;&amp;2
+	exit 1
+}
+
+getparam_sessionid()
+{
+	sessionid=$(getparam sessionid)
+	
+	[ -n &quot;$sessionid&quot; ] || sessionid=$(getparam session_id)
+	[ -n &quot;$sessionid&quot; ] || node_abort &quot;NX&gt; 500 Error: missing parameter session id&quot;
+	echo $sessionid
+}
+
+
+node_terminate_agent()
+{
+	AGENT_PID=$(cat $USER_FAKE_HOME/.nx/C-$1/pids/agent 2&gt;/dev/null)
+	[ -n &quot;$AGENT_PID&quot; ] &amp;&amp; kill $AGENT_PID 2&gt;/dev/null
+}
+
+node_terminate_session()
+{
+	[ -d &quot;$USER_FAKE_HOME/.nx/C-$1/&quot; ] || return
+	AGENT_PID=$(cat $USER_FAKE_HOME/.nx/C-$1/pids/agent 2&gt;/dev/null)
+	if [ -n &quot;$AGENT_PID&quot; ]
+	then 
+		kill $AGENT_PID 2&gt;/dev/null
+		if ! [ &quot;$virtualdesktop&quot; = &quot;0&quot; -a &quot;$ENABLE_ROOTLESS_MODE&quot; != &quot;1&quot; ]
+		then
+			sleep 1
+			kill -9 $AGENT_PID 2&gt;/dev/null
+		fi
+	fi
+	# remove possible leftover display ...
+	display=$(echo $1 | cut -d&quot;-&quot; -f2)
+	rm -f /tmp/.X$display-lock
+	rm -f /tmp/.X11-unix/X$display
+	
+	# remove cookie
+	$COMMAND_XAUTH -v source $USER_FAKE_HOME/.nx/C-$sess_id/scripts/authority &gt;/dev/null 2&gt;&amp;1
+	# FIXME: What to do on errors ... ?
+	[ &quot;$SESSION_LOG_CLEAN&quot; = &quot;1&quot; ] &amp;&amp; rm -rf $USER_FAKE_HOME/.nx/C-$1/
+	[ &quot;$SESSION_LOG_CLEAN&quot; = &quot;0&quot; -a &quot;$2&quot; = &quot;failed&quot; ] &amp;&amp; mv $USER_FAKE_HOME/.nx/C-$1/ $USER_FAKE_HOME/.nx/F-C-$1/
+	[ &quot;$SESSION_LOG_CLEAN&quot; = &quot;0&quot; -a &quot;$2&quot; != &quot;failed&quot; ] &amp;&amp; mv $USER_FAKE_HOME/.nx/C-$1/ $USER_FAKE_HOME/.nx/T-C-$1/
+}
+
+node_fail_restore_session()
+{
+	echo &quot;NX&gt; 1004 Error: Could not resume session. nxagent process could not be found.&quot;
+	node_terminate_session &quot;$sess_id&quot; &quot;failed&quot;
+	exit 1
+}
+
+node_suspend_session()
+{
+	AGENT_PID=$(cat $USER_FAKE_HOME/.nx/C-$1/pids/agent 2&gt;/dev/null)
+	if [ -n &quot;$AGENT_PID&quot; ]
+	then 
+		kill -0 $AGENT_PID || return 1
+		kill -HUP $AGENT_PID &amp;&amp; return 0
+	fi
+	return 1
+}
+
+# ---------
+#stringinstring &quot;$CMD&quot;
+
+node_start_applications()
+{
+	# close input and output file descriptors
+	exec 0&lt;&amp;-
+	exec 1&gt;&amp;-
+	exec 2&gt;&amp;-
+	
+	. /etc/profile
+	[ -f ~/.bash_profile ] &amp;&amp; . ~/.bash_profile
+
+	mkdir -p $USER_FAKE_HOME/.nx/C-$sess_id/pids/
+
+	STARTX=&quot;&quot;
+	case $type in
+		unix-kde)
+			STARTX=$COMMAND_START_KDE
+		;;
+		unix-gnome)
+			STARTX=$COMMAND_START_GNOME
+		;;
+		unix-cde)
+			STARTX=$COMMAND_START_CDE
+		;;
+		unix-application)
+			[ &quot;$application&quot; = &quot;xterm&quot; ] &amp;&amp; application=&quot;$COMMAND_XTERM&quot;
+			STARTX=$application
+		;;
+		unix-default)
+			if [ -x &quot;$HOME/$USER_X_STARTUP_SCRIPT&quot; ]; then
+				STARTX=&quot;$HOME/$USER_X_STARTUP_SCRIPT&quot;
+			elif which &quot;$DEFAULT_X_SESSION&quot; &gt;/dev/null 2&gt;&amp;1 ; then
+				STARTX=&quot;$DEFAULT_X_SESSION&quot;
+			fi
+		;;
+	esac
+	[ -n &quot;$STARTX&quot; ] || return
+
+	if [ &quot;$mediahelper&quot; = &quot;esd&quot; ]
+	then
+		# Set Espeaker variable
+		let ESPEAKER=$display+7000
+		export ESPEAKER=&quot;127.0.0.1:$ESPEAKER&quot;
+		
+		# Check for config file directive
+		if [ &quot;$ENABLE_ESD_PRELOAD&quot; = &quot;1&quot; -a -x &quot;$(find_app $ESD_BIN_PRELOAD)&quot; ]
+		then
+			STARTX=&quot;$ESD_BIN_PRELOAD $STARTX&quot;
+			
+			# Do not spawn new ESD daemons
+			export ESD_NO_SPAWN=&quot;yes&quot;
+			
+			echo &quot;Info: NXNODE - Using $ESD_BIN_PRELOAD wrapper script.&quot; &gt;&gt; $USER_FAKE_HOME/.nx/C-$sess_id/session
+		fi
+	elif [ &quot;$mediahelper&quot; = &quot;artsd&quot; ]
+	then
+		# Overwrite users mcoprc
+		echo -n &quot;GlobalComm=Arts::X11GlobalComm&quot; &gt; $HOME/.mcoprc
+		if [ &quot;$ENABLE_ARTSD_PRELOAD&quot; = &quot;1&quot; -a -x &quot;$(find_app $ARTSD_BIN_PRELOAD)&quot; ]
+		then
+			STARTX=&quot;$ARTSD_BIN_PRELOAD $STARTX&quot;
+			echo &quot;Info: NXNODE - Using $ARTSD_BIN_PRELOAD wrapper script.&quot; &gt;&gt; $USER_FAKE_HOME/.nx/C-$sess_id/session
+		fi
+	fi
+
+	[ &quot;$virtualdesktop&quot; = &quot;0&quot; -a &quot;$ENABLE_ROOTLESS_MODE&quot; != &quot;1&quot; ] &amp;&amp; export LD_PRELOAD=&quot;$APPLICATION_LIBRARY_PRELOAD:$LD_PRELOAD&quot;
+	if [ &quot;$virtualdesktop&quot; = &quot;1&quot; -a &quot;$type&quot; = &quot;unix-application&quot; -a &quot;$DEFAULT_X_WM&quot; != &quot;&quot; -a -x &quot;$(find_app $DEFAULT_X_WM)&quot; ]
+	then
+		DISPLAY=unix:$display $DEFAULT_X_WM 2&gt;&gt;$USER_FAKE_HOME/.nx/C-$sess_id/session &amp;
+		WM_PID=$!
+	fi
+	DISPLAY=unix:$display $STARTX 2&gt;&gt;$USER_FAKE_HOME/.nx/C-$sess_id/session &amp;
+	APP_PID=$!
+	mkdir -p $USER_FAKE_HOME/.nx/C-$sess_id/pids/
+	echo &quot;$APP_PID&quot; &gt; $USER_FAKE_HOME/.nx/C-$sess_id/pids/applications
+	wait $APP_PID
+	if [ -n &quot;$WM_PID&quot; ]
+	then
+		# kill the WM after application is finished?
+		[ &quot;$KILL_DEFAULT_X_WM&quot; = &quot;1&quot; ] &amp;&amp; kill $WM_PID 2&gt;/dev/null
+		# or just wait until it finishes?
+		[ &quot;$KILL_DEFAULT_X_WM&quot; = &quot;1&quot; ] || wait $WM_PID
+	fi
+	rm -f $USER_FAKE_HOME/.nx/C-$sess_id/pids/applications
+	node_terminate_agent $sess_id
+}
+
+node_start_agent()
+{
+	# close input and output file descriptors
+	exec 0&lt;&amp;-
+	exec 1&gt;&amp;-
+	exec 2&gt;&amp;-
+	
+	export DISPLAY=&quot;nx/nx,options=$USER_FAKE_HOME/.nx/C-$sess_id/options:$display&quot;
+	export XAUTHORITY=&quot;$USER_FAKE_HOME/.nx/C-$sess_id/authority&quot;
+	export HOME=&quot;$USER_FAKE_HOME&quot;
+	
+	# backwards compatibility
+	K=&quot;&quot;
+	[ -n &quot;$keyboard&quot; ] &amp;&amp; K=&quot;-keyboard $keyboard&quot;
+	[ -n &quot;$kbtype&quot; ] &amp;&amp; K=&quot;-kbtype $kbtype&quot;
+	B=&quot;&quot;
+	[ -n &quot;$backingstore&quot; ] &amp;&amp; B=&quot;-bs $backingstore&quot;
+	G=&quot;&quot;
+	[ -n &quot;$geometry&quot; ] &amp;&amp; G=&quot;-geometry $geometry&quot;
+	R=&quot;&quot;
+	[ &quot;$virtualdesktop&quot; = &quot;0&quot; ] &amp;&amp; R=&quot;-R&quot;
+	vncfullscreen=&quot;&quot;
+	[ &quot;$geometry&quot; = &quot;fullscreen&quot; -a &quot;$type&quot; = &quot;vnc&quot; ] &amp;&amp; vncfullscreen=&quot;-fullscreen&quot; &amp;&amp; G=&quot;&quot;
+
+	if [ &quot;$type&quot; = &quot;windows&quot; ]
+	then
+		# nxdesktop session (Windows RDP)
+		[ &quot;$SET_LD_LIBRARY_PATH&quot; = &quot;1&quot; ] &amp;&amp; export LD_LIBRARY_PATH=&quot;$AGENT_LIBRARY_PATH:$LD_LIBRARY_PATH&quot;
+		U=&quot;&quot;
+		P=&quot;&quot;
+		[ -n &quot;$agent_user&quot; ] &amp;&amp; U=&quot;-u $agent_user&quot;
+		[ -n &quot;$agent_password&quot; ] &amp;&amp; P=&quot;-p -&quot;
+		echo &quot;$agent_password&quot; | $PATH_BIN/nxdesktop -name &quot;NX - $user@$SERVER_NAME:$display - $session (GPL Edition)&quot; -option &quot;$USER_FAKE_HOME/.nx/C-$sess_id/options&quot; $K $G $U $P $agent_server $AGENT_EXTRA_OPTIONS_RDP 2&gt;&gt;$USER_FAKE_HOME/.nx/C-$sess_id/session &amp;
+	elif [ &quot;$type&quot; = &quot;vnc&quot; ]
+	then
+		# nxviewer session (VNC RFP)
+		[ &quot;$SET_LD_LIBRARY_PATH&quot; = &quot;1&quot; ] &amp;&amp; export LD_LIBRARY_PATH=&quot;$AGENT_LIBRARY_PATH:$LD_LIBRARY_PATH&quot;
+		mkdir -p $USER_FAKE_HOME/.nx/C-$sess_id/scripts/
+		echo &quot;$agent_password&quot; | $PATH_BIN/nxpasswd $USER_FAKE_HOME/.nx/C-$sess_id/scripts/.passwd doit
+		$PATH_BIN/nxviewer -encodings tight hextile copyrect raw -passwd $USER_FAKE_HOME/.nx/C-$sess_id/scripts/.passwd -name &quot;NX - $user@$SERVER_NAME:$display - $session (GPL Edition)&quot; -option &quot;$USER_FAKE_HOME/.nx/C-$sess_id/options&quot; $vncfullscreen $G $K $agent_server $AGENT_EXTRA_OPTIONS_RFB 2&gt;&gt;$USER_FAKE_HOME/.nx/C-$sess_id/session &amp;
+	elif [ -n &quot;$R&quot; -a &quot;$ENABLE_ROOTLESS_MODE&quot; != &quot;1&quot; ]
+	then
+		# nxproxy single application mode session
+		[ &quot;$SET_LD_LIBRARY_PATH&quot; = &quot;1&quot; ] &amp;&amp; export LD_LIBRARY_PATH=&quot;$PROXY_LIBRARY_PATH:$LD_LIBRARY_PATH&quot;
+		$PATH_BIN/nxproxy -C :$display $PROXY_EXTRA_OPTIONS 2&gt;&gt;$USER_FAKE_HOME/.nx/C-$sess_id/session &amp;
+	else
+		# nxagent session (X11)
+		[ &quot;$SET_LD_LIBRARY_PATH&quot; = &quot;1&quot; ] &amp;&amp; export LD_LIBRARY_PATH=&quot;$AGENT_LIBRARY_PATH:$LD_LIBRARY_PATH&quot;
+		P=&quot;-nopersistent&quot;
+		OLD_IFS=$IFS
+		IFS=&quot;,&quot;
+		[ &quot;$ENABLE_PERSISTENT_SESSION&quot; = &quot;all&quot; ] &amp;&amp; P=&quot;-persistent&quot;
+		[ &quot;$ENABLE_PERSISTENT_SESSION&quot; = &quot;all&quot; ] || for USERNAME in $ENABLE_PERSISTENT_SESSION; do
+			[ &quot;${USERNAME:0:1}&quot; != &quot;@&quot; ] &amp;&amp; [ &quot;$USER&quot; = &quot;$USERNAME&quot; ] &amp;&amp; P=&quot;-persistent&quot; &amp;&amp; break ;
+			[ &quot;${USERNAME:0:1}&quot; = &quot;@&quot; ] &amp;&amp; [ -z $(groups &quot;$USER&quot; | egrep &quot;^${USERNAME:1}:&quot;) ] &amp;&amp; P=&quot;-persistent&quot; &amp;&amp; break ;
+		done
+		for USERNAME in $DISABLE_PERSISTENT_SESSION; do
+			[ &quot;${USERNAME:0:1}&quot; != &quot;@&quot; ] &amp;&amp; [ &quot;$USER&quot; = &quot;$USERNAME&quot; ] &amp;&amp; P=&quot;-nopersistent&quot; &amp;&amp; break ;
+			[ &quot;${USERNAME:0:1}&quot; = &quot;@&quot; ] &amp;&amp; [ -z $(groups &quot;$USER&quot; | egrep &quot;^${USERNAME:1}:&quot;) ] &amp;&amp; P=&quot;-nopersistent&quot; &amp;&amp; break ;
+		done
+		IFS=$OLD_IFS
+		FP=&quot;&quot;
+		[ -n &quot;$AGENT_FONT_SERVER&quot; ] &amp;&amp; FP=&quot;-fp $AGENT_FONT_SERVER&quot;
+		$PATH_BIN/nxagent $P $R -name &quot;NX - $user@$SERVER_NAME:$display - $session (GPL Edition)&quot; -option &quot;$USER_FAKE_HOME/.nx/C-$sess_id/options&quot; $K $G $B $FP :$display $AGENT_EXTRA_OPTIONS_X 2&gt;&gt;$USER_FAKE_HOME/.nx/C-$sess_id/session &amp;
+	fi
+	PID=$!
+	mkdir -p $USER_FAKE_HOME/.nx/C-$sess_id/pids/
+	echo &quot;$PID&quot; &gt; $USER_FAKE_HOME/.nx/C-$sess_id/pids/agent
+	wait $PID
+	rm -f $USER_FAKE_HOME/.nx/C-$sess_id/pids/agent
+	[ &quot;$type&quot; = &quot;windows&quot; -o &quot;$type&quot; = &quot;vnc&quot; ] &amp;&amp; node_terminate_session &quot;$sess_id&quot;
+}
+
+node_kill_proxy()
+{
+	# Info: Proxy running in server mode with pid '5279'.
+	PROXY_PID=$(grep &quot;Info: Proxy running in server mode with pid&quot; $USER_FAKE_HOME/.nx/C-$1/session | cut -d&quot;'&quot; -f2)
+	sleep 2
+	[ -n &quot;$PROXY_PID&quot; ] &amp;&amp; kill $PROXY_PID 2&gt;/dev/null
+}
+
+node_cupsd_stop()
+{
+	[ -e &quot;$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd&quot; ] || return
+	NODE_CUPSD_PID=$(cat &quot;$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd&quot;)
+	# Check for a running userspace cupsd, look if its still active 
+	# and kill it if so
+	( [ -n &quot;$NODE_CUPSD_PID&quot; ] &amp;&amp; kill -0 $NODE_CUPSD_PID &amp;&amp; kill $NODE_CUPSD_PID &amp;&amp; sleep 2 &amp;&amp; kill -0 $NODE_CUPSD_PID &amp;&amp; kill -9 $NODE_CUPSD_PID ) 2&gt;/dev/null
+	# delete pid file
+	rm -f &quot;$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd&quot;
+	# remove all printers
+	echo &gt;&quot;$USER_FAKE_HOME/.nx/C-$sess_id/cups/printers.conf&quot;
+}
+
+node_cupsd_setup()
+{
+	let NODE_CUPSD_PORT=$display+9000 # offset 9000 for userspace cupsd's
+	export NODE_CUPSD_PORT
+	mkdir -p &quot;$USER_FAKE_HOME/.nx/C-$sess_id/pids/&quot;
+	[ -e &quot;$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd&quot; ] &amp;&amp; return
+	touch &quot;$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd&quot;
+	
+	mkdir -p $USER_FAKE_HOME/.nx/C-$sess_id/cups/spool/tmp $USER_FAKE_HOME/.nx/C-$sess_id/cups/spool/certs $USER_FAKE_HOME/.nx/C-$sess_id/cups/ppd
+	ln -sf spool/certs $USER_FAKE_HOME/.nx/C-$sess_id/cups/certs
+cat &lt;&lt;EOF &gt; $USER_FAKE_HOME/.nx/C-$sess_id/cups/cupsd.conf
+AccessLog /dev/null
+ErrorLog error_log
+PageLog page_log
+LogLevel info
+TempDir $USER_FAKE_HOME/.nx/C-$sess_id/cups/spool/tmp
+RequestRoot $USER_FAKE_HOME/.nx/C-$sess_id/cups/spool
+ServerRoot $USER_FAKE_HOME/.nx/C-$sess_id/cups/
+Port $NODE_CUPSD_PORT
+Browsing Off
+ServerName localhost
+
+&lt;Location /&gt;
+Order Deny,Allow
+Deny From All
+Allow from 127.0.0.1
+&lt;/Location&gt;
+EOF
+	touch $USER_FAKE_HOME/.nx/C-$sess_id/cups/printers.conf $USER_FAKE_HOME/.nx/C-$sess_id/cups/classes.conf
+
+	# copy mime.* files
+	cp &quot;$CUPS_ETC&quot;/mime.* &quot;$USER_FAKE_HOME/.nx/C-$sess_id/cups/&quot;
+
+	# start cupsd
+	$COMMAND_CUPSD -f -c &quot;$USER_FAKE_HOME/.nx/C-$sess_id/cups/cupsd.conf&quot; &amp;&gt;/dev/null &lt;/dev/null &amp;
+	CUPSD_PID=$!
+	sleep 3
+	echo $CUPSD_PID &gt;&quot;$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd&quot;
+	# setup KDE
+	if [ &quot;$ENABLE_KDE_CUPS&quot; = &quot;1&quot; -a -e &quot;$KDE_PRINTRC&quot; ]
+	then
+		if egrep -q &quot;^Port=&quot; &quot;$KDE_PRINTRC&quot;
+		then
+			perl -pi -e 's/^Port=.*/Port='&quot;$NODE_CUPSD_PORT&quot;'/g' &quot;$KDE_PRINTRC&quot;
+		else
+			echo &quot;[CUPS]&quot; &gt;&gt; &quot;$KDE_PRINTRC&quot;
+			echo &quot;Port=$NODE_CUPSD_PORT&quot; &gt;&gt; &quot;$KDE_PRINTRC&quot;
+		fi
+	fi
+}
+
+node_cupsd_reload()
+{
+	[ -e &quot;$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd&quot; ] || return
+	NODE_CUPSD_PID=$(cat &quot;$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd&quot;)
+	[ -n &quot;$NODE_CUPSD_PID&quot; ] &amp;&amp; kill -0 $NODE_CUPSD_PID &amp;&amp; kill -HUP $NODE_CUPSD_PID
+}
+
+node_cupsd_get_port()
+{
+	node_cupsd_setup
+	echo $NODE_CUPSD_PORT
+}
+
+node_umount_smb()
+{
+	[ -e &quot;$USER_FAKE_HOME/.nx/C-$sess_id/scripts/mpoint&quot; ] || return
+	cat &quot;$USER_FAKE_HOME/.nx/C-$sess_id/scripts/mpoint&quot; | while read mpoint
+	do
+		$COMMAND_SMBUMOUNT &quot;$mpoint&quot; &gt;/dev/null 2&gt;/dev/null
+	done
+}
+
+node_stop_services()
+{
+	node_umount_smb
+	node_cupsd_stop
+}
+
+
+#
+# Monitoring the nxagent: Its also kind of a &quot;state-machine&quot; 
+#                         as it has to keep track of different 
+#                         connection states and react differently.
+#
+
+node_start_monitor()
+{
+	RUNNING=0
+	RECONNECT=0
+	TAIL_PID=&quot;&quot;
+	TIMEOUT_PID=&quot;&quot;
+	
+	sh -c 'echo &quot;Info: tail -f running with pid '\'\$$\''.&quot;; exec tail -n1 -f '$USER_FAKE_HOME'/.nx/C-'$sess_id'/session' | while read line 
+	do
+		#
+		# Catch tail pid
+		#
+		if stringinstring &quot;Info: tail -f running with pid&quot; &quot;$line&quot;
+		then
+			TAIL_PID=$(echo $line | cut -d&quot;'&quot; -f2)
+			# now set a timeout of 10 seconds ...
+			( 
+                          sleep 10
+			  if [ -d &quot;$HOME/.nx/C-$sess_id/&quot; ]
+			  then
+		          	echo &quot;NX&gt; 1004 Error: nxagent failed to start. Session timed out.&quot;
+			  	echo &quot;                Blocking $display again ...&quot;
+				touch /tmp/.X$display-lock
+			  	mv $HOME/.nx/C-$sess_id/ $HOME/.nx/F-C-$sess_id/ 2&gt;/dev/null
+			  fi
+			  kill $TAIL_PID 2&gt;/dev/null
+			) &amp;
+			TIMEOUT_PID=$!
+			disown $TIMEOUT_PID
+		fi
+
+		#
+		# Detect nxagent syntax errors
+		#
+		
+		if stringinstring &quot;Unrecognized option:&quot; &quot;$line&quot;
+		then
+			kill $TAIL_PID 2&gt;/dev/null
+			echo &quot;NX&gt; 1004 Error: nxagent failed to start with: $line&quot;
+			break
+		fi
+
+		#
+		# Suspending possibilities
+		#
+		
+		if stringinstring &quot;Info: Suspending session on user request.&quot; &quot;$line&quot;
+		then
+			kill $TAIL_PID 2&gt;/dev/null
+			echo &quot;NX&gt; 1005 Session status: suspended&quot;
+			kill -HUP $PROXY_PID 2&gt;/dev/null
+			sleep 2
+			break
+		fi
+		
+		#if stringinstring &quot;Info: Disconnected from user display.&quot;
+		if stringinstring &quot;Info: Going to sleep waiting for reconnection.&quot; &quot;$line&quot;
+		then
+			kill $TAIL_PID 2&gt;/dev/null
+			
+			echo &quot;NX&gt; 1005 Session status: suspended&quot;
+			# umount shares &amp; stop printers
+			node_stop_services
+			break
+		fi
+
+		if stringinstring &quot;Error: Connection with remote peer broken.&quot; &quot;$line&quot;
+		then
+			kill $TAIL_PID 2&gt;/dev/null
+			echo &quot;NX&gt; 1005 Session status: suspended&quot;
+			kill -HUP $PROXY_PID 2&gt;/dev/null
+			sleep 2
+			# time out faster for suspend
+			break
+		fi
+
+		#
+		# Session end
+		#
+		
+		if stringinstring &quot;Info: End of session requested by &quot; &quot;$line&quot; &amp;&amp; [ &quot;$RECONNECT&quot; = &quot;0&quot; ]
+		then
+			echo &quot;NX&gt; 1009 Session status: terminating&quot;
+			kill $PROXY_PID 2&gt;/dev/null
+		fi
+		
+		if stringinstring &quot;Info: Waiting for a further signal to complete.&quot; &quot;$line&quot; &amp;&amp; [ &quot;$RECONNECT&quot; = &quot;0&quot; ]
+		then
+			kill $TAIL_PID 2&gt;/dev/null
+			echo &quot;NX&gt; 1006 Session status: closed&quot;
+			# TODO: Need a way to remove session infos ...
+			# especially for windows/vnc mode
+			kill $PROXY_PID 2&gt;/dev/null
+			sleep 2
+			kill -9 $PROXY_PID 2&gt;/dev/null
+
+			# umount shares &amp; stop printers
+			node_stop_services
+
+			# kill the session
+			node_terminate_session &quot;$sess_id&quot;
+			
+			break
+		fi
+
+		#
+		# Session was suspended before, do not _close_ it, until
+		# it is fully resumed.
+		#
+
+		if stringinstring &quot;Info: Going to reconnect to a new display.&quot; &quot;$line&quot;
+		then
+			RECONNECT=1
+		fi
+
+		#
+		# Session is running
+		#
+		
+		if stringinstring &quot;Info: Waiting for connection from&quot; &quot;$line&quot;
+		then
+			echo &quot;NX&gt; 710 Session status: running&quot;
+			echo &quot;NX&gt; 1002 Commit&quot;
+			echo &quot;NX&gt; 1006 Session status: running&quot;
+			[ -n &quot;$TIMEOUT_PID&quot; ] &amp;&amp; kill $TIMEOUT_PID 2&gt;/dev/null
+		fi
+
+		#
+		# Status = Running - Do _not_ fail anymore.
+		#
+
+		if stringinstring &quot;Info: Connection with remote proxy established.&quot; &quot;$line&quot;
+		then
+			RUNNING=1
+		fi
+	
+		#
+		# Catch proxy pid
+		#
+		
+		if stringinstring &quot;Info: Proxy running in server mode with pid&quot; &quot;$line&quot;
+		then
+			PROXY_PID=$(echo $line | cut -d&quot;'&quot; -f2)
+			#echo &quot;Got $PROXY_PID ... &quot; &gt;&gt; /tmp/nxnode.log
+		fi
+		
+		#
+		# Reconnection success!
+		#
+		
+		if stringinstring &quot;Info: Reconnection succeded.&quot; &quot;$line&quot;
+		then
+			echo &quot;NX&gt; 718 Session restore succeded&quot;
+			RECONNECT=0 # Do no longer block &quot;Connection Close&quot;
+		fi
+
+		#
+		# Error handling.
+		#
+
+		if stringinstring &quot;Error: Connection with remote host&quot; &quot;$line&quot; &amp;&amp; [ &quot;$RUNNING&quot; = &quot;0&quot; ] 
+		then
+			kill $TAIL_PID 2&gt;/dev/null
+			echo &quot;NX&gt; 1004 Error:&quot;
+			echo &quot;Session '$sess_id' has failed after reaching usable state.&quot;
+			[ &quot;$SESSION_LOG_CLEAN&quot; = &quot;1&quot; ] &amp;&amp; rm -rf $USER_FAKE_HOME/.nx/C-$sess_id/
+			[ &quot;$SESSION_LOG_CLEAN&quot; = &quot;1&quot; ] || mv $USER_FAKE_HOME/.nx/C-$sess_id/ $USER_FAKE_HOME/.nx/F-C-$sess_id/
+			break
+		fi
+	done 
+	node_stop_services
+	# close all open file descriptors
+	exec 0&lt;&amp;-
+	exec 1&gt;&amp;-
+	exec 2&gt;&amp;-
+	exit 0
+}
+
+node_startsession()
+{
+
+	# user=knoppix&amp;userip=192.168.1.66&amp;uniqueid=6A8269CC467264EAEF6349D062689755&amp;display=1000&amp;session=lappi%5ffull&amp;type=unix%2dkde&amp;cache=8M&amp;images=32M&amp;cookie=84765070afee043cf83f85d21130145f&amp;link=lan&amp;render=1&amp;backingstore=when_requested&amp;imagecompressionmethod=0&amp;geometry=fullscreen&amp;keyboard=fr&amp;media=0&amp;samba=1&amp;agent_server=&amp;agent_user=&amp;agent_password=
+
+	user=$(getparam user)
+	userip=$(getparam userip)
+	uniqueid=$(getparam uniqueid)
+	display=$(getparam display)
+	session=$(getparam session)
+	type=$(getparam type | sed 's/%2d/-/g')
+	application=$(getparam application)
+	cache=$(getparam cache)
+	images=$(getparam images)
+	cookie=$(getparam cookie)
+	link=$(getparam link)
+	virtualdesktop=$(getparam virtualdesktop)
+	render=$(getparam render)
+	backingstore=$(getparam backingstore)
+	imagecompressionmethod=$(getparam imagecompressionmethod)
+	geometry=$(getparam geometry)
+	keyboard=$(getparam keyboard)
+	kbtype=$(getparam kbtype)
+	media=$(getparam media)
+	mediahelper=$(getparam mediahelper)
+	sync=$(getparam sync)
+	samba=$(getparam samba)
+	agent_server=$(getparam agent_server)
+	agent_user=$(getparam agent_user)
+	agent_password=$(getparam agent_password)
+
+	[ &quot;$EXPORT_USERIP&quot; = &quot;1&quot; ] &amp;&amp; export NXUSERIP=&quot;$userip&quot;
+
+	ssl_tunnel=$(getparam encryption)
+	[ -z &quot;$ssl_tunnel&quot; ] &amp;&amp; ssl_tunnel=0
+	
+	[ &quot;$ssl_tunnel&quot; = &quot;1&quot; ] &amp;&amp; userip=&quot;127.0.0.1&quot;
+	
+	# ok, lets make the session dir first:
+	
+	sess_id=&quot;$SERVER_NAME-$display-$uniqueid&quot;
+	[ &quot;$EXPORT_SESSIONID&quot; = &quot;1&quot; ] &amp;&amp; export NXSESSIONID=&quot;$sess_id&quot;
+	
+	mkdir -p $USER_FAKE_HOME/.nx/C-$sess_id
+	
+	# cache=8M,images=32M,pack=nopack,link=lan,type=unix-kde,cleanup=0,accept=192.168.1.66,cookie=E38A94A77F975443AF04EC911881B120,id=Knoppix-1000-6A8269CC467264EAEF6349D062689755,samba=1,render=1:1000
+	
+	# TODO: imagecompressionmethod ...
+	[ &quot;$imagecompressionmethod&quot; = &quot;0&quot; ] &amp;&amp; PACK=&quot;pack=nopack,&quot;
+	
+	proxy_cookie=$(echo $[$RANDOM*$RANDOM] | md5sum | cut -d&quot; &quot; -f1)
+
+	# write options file
+	[ -z &quot;$samba&quot; ] &amp;&amp; samba=0
+	[ -z &quot;$media&quot; ] &amp;&amp; media=0
+
+	CACHE=&quot;cache=$cache,&quot;
+	[ -z &quot;$cache&quot; ] &amp;&amp; CACHE=&quot;&quot;
+	IMAGES=&quot;images=$images,&quot;
+	[ -z &quot;$images&quot; ] &amp;&amp; IMAGES=&quot;&quot;
+
+	ACCEPT=&quot;accept=$userip,&quot;
+	[ &quot;$userip&quot; = &quot;*&quot; ] &amp;&amp; ACCEPT=&quot;&quot;
+
+	OLD_UMASK=$(umask)
+	umask 0077
+
+cat &lt;&lt; EOF &gt; $USER_FAKE_HOME/.nx/C-$sess_id/options
+${kbtype:+kbtype=$kbtype,}${CACHE}${IMAGES}${PACK}link=$link,type=$type,cleanup=0,${ACCEPT}cookie=$proxy_cookie,id=$sess_id,samba=$samba,media=$media${sync:+,sync=$sync}${cups:+,cups=$cups}:$display
+EOF
+	umask $OLD_UMASK
+#samba=$samba,
+	#cache=$cache,images=$images,pack=nopack,link=$link,type=$type,cleanup=0,accept=$userip,cookie=$proxy_cookie,id=$sess_id
+#samba=$samba,media=$media,render=$render:$display
+
+	# write xauth script file
+
+$COMMAND_XAUTH &gt;/dev/null 2&gt;&amp;1 &lt;&lt;EOF
+add localhost:$display MIT-MAGIC-COOKIE-1 $cookie
+add unix:$display MIT-MAGIC-COOKIE-1 $cookie
+exit
+EOF
+
+$COMMAND_XAUTH -f &quot;$USER_FAKE_HOME/.nx/C-$sess_id/authority&quot; &gt;/dev/null 2&gt;&amp;1 &lt;&lt;EOF
+add localhost:$display MIT-MAGIC-COOKIE-1 $cookie
+add unix:$display MIT-MAGIC-COOKIE-1 $cookie
+exit
+EOF
+
+	mkdir -m700 $USER_FAKE_HOME/.nx/C-$sess_id/scripts/ 2&gt;/dev/null || chmod 700 $USER_FAKE_HOME/.nx/C-$sess_id/scripts/
+
+cat &lt;&lt; EOF &gt;$USER_FAKE_HOME/.nx/C-$sess_id/scripts/authority
+remove localhost:$display
+remove unix:$display
+exit
+EOF
+
+echo &gt; $USER_FAKE_HOME/.nx/C-$sess_id/session
+node_start_monitor &amp;
+SPID=$!
+mkdir -p $USER_FAKE_HOME/.nx/C-$sess_id/pids/
+echo &quot;$SPID&quot; &gt; $USER_FAKE_HOME/.nx/C-$sess_id/pids/monitor
+
+if [ &quot;$1&quot; = &quot;restore&quot; ]
+then
+	node_suspend_session $sess_id || node_fail_restore_session
+else
+	node_start_agent &amp;
+	node_start_applications &amp;
+fi
+
+which &quot;$NODE_AUTOSTART&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; &quot;$NODE_AUTOSTART&quot; &quot;$1&quot;
+	
+cat &lt;&lt; EOF
+NX&gt; 700 Session id: $sess_id
+NX&gt; 705 Session display: $display
+NX&gt; 703 Session type: $type
+NX&gt; 701 Proxy cookie: $proxy_cookie
+NX&gt; 702 Proxy IP: $userip
+NX&gt; 706 Agent cookie: $cookie
+NX&gt; 704 Session cache: $type
+NX&gt; 707 SSL tunneling: $ssl_tunnel
+EOF
+
+# collection ...
+
+# NX&gt; 1004 Error:
+#Session 'Knoppix-1000-40EFB9F64FA55C64C41C72CA39EBD720' has failed after reaching usable state. Session directory '/home/knoppix/.nx/F-C-Knoppix-1000-40EFB9F64FA55C64C41C72CA39EBD720' will be not deleted to allow for further investigation.
+
+wait $SPID
+rm -f $USER_FAKE_HOME/.nx/C-$sess_id/pids/monitor
+}
+
+cmd_node_terminate()
+{
+	sessionid=$(getparam_sessionid)
+	echo &quot;NX&gt; 716 Terminating session $sessionid on user request.&quot;
+	display=$(cd $USER_FAKE_HOME/.nx/; echo C-$SERVER_NAME-*-$sessionid | cut -d&quot;-&quot; -f3)
+	node_terminate_session &quot;$SERVER_NAME-$display-$sessionid&quot;
+}
+
+cmd_node_suspend()
+{
+	sessionid=$(getparam_sessionid)
+	echo &quot;NX&gt; 716 Suspending session $sessionid on user request.&quot;
+	display=$(cd $USER_FAKE_HOME/.nx/; echo C-$SERVER_NAME-*-$sessionid | cut -d&quot;-&quot; -f3)
+	node_suspend_session &quot;$SERVER_NAME-$display-$sessionid&quot;
+}
+
+cmd_node_smbmount()
+{
+	sessionid=$(getparam_sessionid)
+	port=$(getparam port)
+	username=$(getparam username)
+	password=$(getparam password)
+	share=$(getparam share)
+	computername=$(getparam computername)
+	dir=$(getparam dir | sed 's|$(SHARES)|MyShares|g')
+	rdir=$(getparam dir | sed 's|$(SHARES)/||g')
+	display=$(cd $USER_FAKE_HOME/.nx/; echo C-$SERVER_NAME-*-$sessionid | cut -d&quot;-&quot; -f3)
+	mkdir -p &quot;$HOME/$dir&quot;
+	ERROR=$(PASSWD=&quot;$password&quot; &quot;$COMMAND_SMBMOUNT&quot; &quot;//$computername/$rdir&quot; &quot;$HOME/$dir&quot; -o username=&quot;$username,ip=127.0.0.1,port=$port&quot; 2&gt;&amp;1)
+	if [ $? -eq 0 ]
+	then
+		$PATH_BIN/nxclient -dialog ok -caption &quot;NXServer Message&quot; -message &quot;Info: Share: '//$computername/$rdir' mounted on: '$HOME/$dir'&quot; -noautokill -display :$display &amp;
+		echo &quot;$HOME/$dir&quot; &gt;&gt; &quot;$USER_FAKE_HOME/.nx/C-$SERVER_NAME-$display-$sessionid/scripts/mpoint&quot;
+	else
+		$PATH_BIN/nxclient -dialog ok -caption &quot;NXServer Message&quot; -message &quot;Info: Share: '//$computername/$rdir' failed to mount: $ERROR&quot; -noautokill -display :$display &amp;
+	fi
+}
+
+cmd_node_addprinter()
+{
+	sessionid=$(getparam_sessionid)
+	type=$(getparam type)
+	port=$(getparam port)
+	username=$(getparam username)
+	password=$(getparam password)
+	share=$(getparam share)
+	printer=$(getparam printer)
+	computername=$(getparam computername)
+	public=$(getparam public)
+	model=$(getparam model)
+	defaultPrinter=$(getparam defaultPrinter)
+	display=$(cd $USER_FAKE_HOME/.nx/; echo C-$SERVER_NAME-*-$sessionid | cut -d&quot;-&quot; -f3)
+	sess_id=&quot;$SERVER_NAME-$display-$sessionid&quot;
+	# this will also setup the userspace cupsd
+	IPP_PORT=$(node_cupsd_get_port)
+	export IPP_PORT
+	if [ &quot;$type&quot; = &quot;smb&quot; ]
+	then
+		DEVICE_URI=&quot;<A HREF="smb://$username:$password@localhost:$port/$share">smb://$username:$password@localhost:$port/$share</A>&quot;
+		NAME=&quot;$share&quot;
+	else
+		DEVICE_URI=&quot;<A HREF="ipp://localhost:$port/printers/$printer">ipp://localhost:$port/printers/$printer</A>&quot;
+		NAME=&quot;$printer&quot;
+	fi
+	MODEL=$($PATH_BIN/nxclient -printer &quot;$NAME&quot; -noautokill -display :$display)
+	[ -z &quot;$MODEL&quot; -o &quot;$MODEL&quot; = &quot;cancel: aborted&quot; ] &amp;&amp; return
+	
+	PUBLIC=&quot;-u allow:$USER&quot;
+	[ &quot;$public&quot; == &quot;1&quot; ] &amp;&amp; PUBLIC=&quot;&quot;
+	lpadmin -p &quot;$NAME&quot; -E -v &quot;$DEVICE_URI&quot; -m &quot;$MODEL&quot; $PUBLIC
+	[ &quot;$defaultPrinter&quot; = &quot;1&quot; ] &amp;&amp; lpadmin -d &quot;$NAME&quot;
+}
+
+
+case &quot;$1&quot; in 
+	--startsession)
+		node_startsession
+	;;
+	--resumesession)
+		node_startsession &quot;restore&quot;
+	;;
+	--terminate)
+		cmd_node_terminate
+	;;
+	--suspend)
+		cmd_node_suspend
+	;;
+	--smbmount)
+		cmd_node_smbmount &amp;&gt;/dev/null &lt;/dev/null &amp;
+	;;
+	--addprinter)
+		cmd_node_addprinter &amp;&gt;/dev/null &lt;/dev/null &amp;
+	;;
+	--check)
+		echo &quot;NX&gt; 716 finished&quot;
+	;;
+	--setkey)
+		mkdir -m 700 -p $HOME/.ssh
+		if ! grep -q &quot;$(cat $NX_ETC_DIR/users.id_dsa.pub)&quot; $HOME/.ssh/$SSH_AUTHORIZED_KEYS 2&gt;/dev/null
+		then
+			cat $NX_ETC_DIR/users.id_dsa.pub &gt;&gt; $HOME/.ssh/$SSH_AUTHORIZED_KEYS
+			chmod 600 $HOME/.ssh/$SSH_AUTHORIZED_KEYS
+			echo &quot;NX&gt; 716 Public key added to: $HOME/.ssh/$SSH_AUTHORIZED_KEYS&quot;
+		else
+			echo &quot;NX&gt; 716 Public key is already present in: $HOME/.ssh/$SSH_AUTHORIZED_KEYS&quot;
+		fi
+	;;
+	*)
+		echo &quot;NX&gt; 500 Error: Command not found&quot;
+	;;
+esac
+echo &quot;NX&gt; 1001 Bye.&quot;


Property changes on: freenx-server/nxnode
___________________________________________________________________
Name: svn:executable
   + 

Added: freenx-server/nxnode-login
===================================================================
--- freenx-server/nxnode-login	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/nxnode-login	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,65 @@
+#!/usr/bin/expect
+# nxnode-login: spawns and controls ssh 
+# Copyright (c) 2004 by Fabian Franz.
+# License: GPL, version 2
+#
+# CVS: $Id: nxnode-login,v 1.12 2005/03/21 13:00:21 jonno Exp $
+#
+
+# Syntax: nxnode-login {ssh|su} user ssh-port executable command tosend
+
+set auth_method [lindex $argv 0]
+set user [lindex $argv 1]
+set port [lindex $argv 2]
+set executable [lindex $argv 3]
+set command [lindex $argv 4]
+set tosend [lindex $argv 5]
+set command_ssh &quot;ssh&quot;
+catch {set command_ssh $env(COMMAND_SSH)}
+
+expect_user -re &quot;(.*)\n&quot; 
+set password $expect_out(1,string)
+
+set stty_init &quot;raw icrnl&quot;
+
+if { &quot;$auth_method&quot;==&quot;ssh&quot; } { 
+	set pid [spawn -noecho $command_ssh -2 -x -l &quot;$user&quot; &quot;127.0.0.1&quot; -o &quot;NumberOfPasswordPrompts 1&quot; -p &quot;$port&quot; &quot;$executable $command&quot; ]
+} elseif { &quot;$auth_method&quot;==&quot;su&quot; } {
+	set pid [spawn -noecho su - &quot;$user&quot; -c &quot;$executable $command&quot; ]
+} else {
+	exit 1
+}
+
+while {1} {
+	expect {
+		&quot;Are you sure you want to continue connecting (yes/no)?&quot; { send &quot;yes\r&quot; }
+		&quot;assword*:&quot;  { sleep 0.3; send &quot;$password\r&quot; }
+		&quot;Permission denied*&quot; { exit 1 }
+		&quot;su: Authentication failure&quot; { exit 1 }
+		&quot;NX&gt; 1000 NXNODE - Version&quot; { 
+			break
+		}
+	} 
+}
+
+if { &quot;$tosend&quot;!=&quot;&quot; } { 
+	send &quot;$tosend\r&quot;
+}
+
+expect {
+	&quot;NX&gt; 716 finished&quot; { }
+	&quot;NX&gt; 700&quot; { 
+			set timeout -1
+			expect {
+				&quot;NX&gt; 1001 Bye.&quot; { exit 0 }
+				&quot;NX&gt; *&quot; { exp_continue }
+			}
+			exit 0
+		  }
+	&quot;NX&gt; 716 Public key is already present in:&quot; { }
+	&quot;NX&gt; 716 Public key added to:&quot; { }
+	&quot;NX&gt; 716 Terminating session * on user request.&quot; { }
+	&quot;NX&gt; 716 Suspending session * on user request.&quot; { }
+	&quot;NX&gt; 500 Error: &quot; { exit 1}
+}
+expect &quot;NX&gt; 1001 Bye.&quot;


Property changes on: freenx-server/nxnode-login
___________________________________________________________________
Name: svn:executable
   + 

Added: freenx-server/nxprint
===================================================================
--- freenx-server/nxprint	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/nxprint	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,67 @@
+#!/bin/bash
+#
+# nxprint - Prints a list of available drivers or printers
+# 
+# Copyright (c) 2005 by Fabian Franz &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">freenx at fabian-franz.de</A>&gt;
+#
+# License: GPL, version 2
+#
+#
+
+# disable foomatic by default
+FOOMATIC=&quot;no&quot;
+
+HELP=&quot;no&quot;
+DRIVERS=&quot;no&quot;
+PRINTERS=&quot;no&quot;
+
+while [ &quot;$1&quot; ]
+do
+        case &quot;$1&quot; in
+                --help) HELP=&quot;yes&quot;; shift ;;
+                --drivers|-d) DRIVERS=&quot;yes&quot;; shift ;;
+                --printers|-l) PRINTERS=&quot;yes&quot;; shift ;;
+                --) shift ; break ;;
+                *) echo &quot;Invalid flag $1&quot; ; HELP=&quot;yes&quot;; shift ; break ;;
+        esac
+done
+
+[ &quot;$DRIVERS&quot; = &quot;no&quot; -a &quot;$PRINTERS&quot; = &quot;no&quot; ] &amp;&amp; HELP=&quot;yes&quot;
+
+if [ &quot;$HELP&quot; = &quot;yes&quot; ]
+then
+        echo &quot;nxprint - Prints a list of available drivers or printers&quot;
+	echo &quot;&quot;
+        echo &quot;Syntax: nxprint --help&quot;
+        echo &quot;        nxprint --drivers&quot;
+        echo &quot;        nxprint --printes&quot;
+        echo
+        echo &quot;  --drivers                prints a list of available CUPS drivers&quot;
+        echo &quot;  --printers               prints a list of available CUPS printers&quot;
+        exit 0
+fi
+
+if [ &quot;$DRIVERS&quot; = &quot;yes&quot; ]
+then
+	echo &quot;driver|Raw|Raw Queue|raw&quot;
+	{ 
+        cd /usr/share/cups/model
+        awk -F '&quot;' '/*Manufacturer:/ { a[FILENAME]=$2 }
+                    /*NickName:/ { b[FILENAME]=$2 } 
+                    END { 
+                       for (i in a) 
+                          print &quot;driver|&quot; (a[i]==&quot;ESP&quot;?substr(b[i],0,index(b[i],&quot; &quot;)-1):a[i]) &quot;|&quot;b[i]&quot;|&quot;i
+                    }' *.ppd
+        } | sort
+
+	if [ $FOOMATIC=&quot;yes&quot; ]
+	then
+		# TODO: Add support for foomatic-style ppds
+		:
+	fi
+fi
+
+if [ &quot;$PRINTERS&quot; = &quot;yes&quot; ]
+then
+	lpstat -p | awk '{ print $1 &quot;|&quot; $2 }'
+fi


Property changes on: freenx-server/nxprint
___________________________________________________________________
Name: svn:executable
   + 

Added: freenx-server/nxserver
===================================================================
--- freenx-server/nxserver	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/nxserver	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,1379 @@
+#!/bin/bash
+
+# Free implementation of nxserver components
+#
+# To use nxserver add the user &quot;nx&quot; 
+# and use nxserver as default shell.
+#
+# Also make sure that hostkey based authentification works.
+# 
+# Copyright (c) 2004 by Fabian Franz &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">FreeNX at fabian-franz.de</A>&gt;.
+#
+# License: GNU GPL, version 2
+#
+# CVS: $Id: nxserver,v 1.55 2005/06/25 12:26:22 fabianx Exp $
+#
+
+# Read the config file
+. $(PATH=$(cd $(dirname $0) &amp;&amp; pwd):$PATH which nxloadconfig) --
+
+# following two functions are Copyright by Klaus Knopper
+
+stringinstring(){
+case &quot;$2&quot; in *$1*) return 0;; esac
+return 1
+}
+
+# Reread boot command line; echo last parameter's argument or return false.
+getparam(){
+stringinstring &quot;&amp;$1=&quot; &quot;$CMDLINE&quot; || return 1
+echo &quot;$CMDLINE&quot; | awk &quot;/^$1=/&quot;' { VAL=$2 } END { print VAL }' FS=&quot;=&quot; RS=&quot;(&amp;|\n)&quot;
+return 0
+}
+
+
+############### PACKAGE passdb.bm #######################
+#
+# Library of passdb functions (outsource)
+#
+
+# Policy: Variable and function names _must_ start with passdb_ / PASSDB_
+
+# Needed global vars: $NX_ETC_DIR, $PATH_BIN
+
+# Needed nonstd functions: md5sum
+
+
+passdb_get_crypt_pass()
+{
+	echo &quot;$@&quot; | md5sum | cut -d&quot; &quot; -f1
+}
+
+passdb_get_pass()
+{
+	PASSDB_CHUSER=&quot;$1&quot;
+	PASSDB_PASS=$(egrep &quot;^$PASSDB_CHUSER:&quot; $NX_ETC_DIR/passwords 2&gt;/dev/null | cut -d&quot;:&quot; -f2)
+	if [ &quot;$ENABLE_PASSDB_AUTHENTICATION&quot; = &quot;1&quot; ]
+	then
+		egrep -q &quot;^$PASSDB_CHUSER:&quot; $NX_ETC_DIR/passwords 2&gt;/dev/null &amp;&amp; echo $PASSDB_PASS
+		egrep -q &quot;^$PASSDB_CHUSER:&quot; $NX_ETC_DIR/passwords 2&gt;/dev/null || echo &quot;NOT_VALID&quot;
+	else
+		echo &quot;NOT_VALID&quot;
+	fi
+}
+
+passdb_chpass()
+{
+	PASSDB_CHUSER=&quot;$1&quot;
+	PASSDB_ENC_PASS=&quot;$2&quot;
+	cp -f $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
+	perl -pi -e &quot;s/$PASSDB_CHUSER:.*/$PASSDB_CHUSER:$PASSDB_ENC_PASS/g&quot; $NX_ETC_DIR/passwords
+}
+
+passdb_user_exists()
+{
+	PASSDB_CHUSER=&quot;$1&quot;
+	egrep -q &quot;^$PASSDB_CHUSER:&quot; $NX_ETC_DIR/passwords 2&gt;/dev/null
+}
+
+
+passdb_remove_user()
+{
+	PASSDB_CHUSER=&quot;$1&quot;
+	cp -f $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
+	perl -pi -e &quot;s/$PASSDB_CHUSER:.*\n//g&quot; $NX_ETC_DIR/passwords
+}
+
+passdb_add_user()
+{
+	PASSDB_CHUSER=&quot;$1&quot;
+	cp -f $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
+	echo &quot;$PASSDB_CHUSER:*&quot; &gt;&gt; $NX_ETC_DIR/passwords
+	# deactivated to avoid problems with comm-server
+	su - $PASSDB_CHUSER -c &quot;$PATH_BIN/nxnode --setkey&quot;
+}
+
+passdb_list_user()
+{
+	cat $NX_ETC_DIR/passwords | cut -d&quot;:&quot; -f1
+}
+
+#
+# End of passdb Library
+#
+
+############### PACKAGE session.bm #######################
+#
+# Library of session management functions
+#
+
+# Needed global vars: $NX_SESS_DIR
+
+session_list()
+{
+	cat $NX_SESS_DIR/running/sessionId&quot;{$1}&quot;
+}
+
+# Find all running session-filenames 
+
+session_find_all()
+{
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		echo $i
+	done
+}
+
+# Find all running sessions of a id
+session_find_id()
+{
+	[ -f $NX_SESS_DIR/running/sessionId&quot;{$1}&quot; ] &amp;&amp; echo $NX_SESS_DIR/running/sessionId&quot;{$1}&quot;
+}
+
+# finds out if a session belongs to a user
+
+session_find_id_user()
+{
+	[ -f $NX_SESS_DIR/running/sessionId&quot;{$1}&quot; ] &amp;&amp; egrep -q &quot;^userName=$2$&quot; $NX_SESS_DIR/running/sessionId&quot;{$1}&quot; &amp;&amp; return 0
+	return 1
+}
+
+# Find all running sessions of a user
+session_find_user()
+{
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		egrep -q &quot;^userName=$1$&quot; $i &amp;&amp; echo $i
+	done
+}
+
+# Find all running sessions of a display
+session_find_display()
+{	
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		egrep -q &quot;^display=$1$&quot; $i &amp;&amp; echo $i
+	done
+}
+
+# session_get_cmdline &lt;session filename&gt;
+
+session_get_cmdline()
+{
+	echo &quot;a=b&quot; | cat - $1 | tr '\n' '&amp;'
+}
+
+# session_get &lt;uniqueid&gt;
+
+session_get()
+{
+	session_get_cmdline $NX_SESS_DIR/running/sessionId&quot;{$1}&quot;
+}
+
+
+# Get the first session, which can be resumed
+
+session_get_user_suspended()
+{
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		if egrep -q &quot;^userName=$1$&quot; $i &amp;&amp; egrep -q &quot;^status=$2$&quot; $i
+		then
+			CMDLINE=$(session_get_cmdline $i)
+			echo &quot;$(getparam sessionId)&quot;
+			break
+		fi
+	done
+}
+
+# Count all sessions of a user
+# and save it in SESSION_COUNT and SESSION_COUNT_USER
+
+session_count_user()
+{
+	SESSION_COUNT=0
+	SESSION_COUNT_USER=0
+
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		let SESSION_COUNT=$SESSION_COUNT+1
+		egrep -q &quot;^userName=$1$&quot; $i &amp;&amp; let SESSION_COUNT_USER=$SESSION_COUNT_USER+1
+	done
+}
+
+# List all sessions of a user
+
+session_list_user_suspended()
+{
+	SESSION_COUNT=0
+	SESSION_COUNT_USER=0
+
+	TMPFILE=$(mktemp /tmp/nxserver_tmp.XXXXXXXXX)
+	echo &quot;NX&gt; 127 Sessions list of user '$1' for reconnect:&quot; &gt; $TMPFILE
+	echo &gt;&gt; $TMPFILE
+	if [ -z &quot;$4&quot; ]
+	then
+		
+		echo &quot;Display Type             Session ID                       Options  Depth Screensize     Available Session Name&quot; &gt;&gt; $TMPFILE
+		echo &quot;------- ---------------- -------------------------------- -------- ----- -------------- --------- ----------------------&quot; &gt;&gt; $TMPFILE
+	else
+		echo &quot;Display Type             Session ID                       Options  Depth Screen         Status      Session Name&quot; &gt;&gt; $TMPFILE
+		echo &quot; ------- ---------------- -------------------------------- -------- ----- -------------- ----------- ------------------------------&quot; &gt;&gt; $TMPFILE
+	fi
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		let SESSION_COUNT=$SESSION_COUNT+1
+		if egrep -q &quot;^userName=$1$&quot; $i &amp;&amp; egrep -q &quot;^status=$2$&quot; $i #&amp;&amp; grep -q &quot;screeninfo=$3&quot; $i
+		then
+			CMDLINE=$(session_get_cmdline $i)
+			depth=$(getparam screeninfo | cut -d &quot;x&quot; -f3 | cut -d &quot;+&quot; -f1 )
+			geom=$(getparam screeninfo | cut -d &quot;x&quot; -f1,2) 
+			render=$(getparam screeninfo | cut -d &quot;+&quot; -f2 )
+			available=&quot;N/A&quot;
+			udepth=$(echo $3 | cut -d &quot;x&quot; -f3 | cut -d &quot;+&quot; -f1 )
+			urender=$(echo $3 | cut -d &quot;+&quot; -f2 )
+			options=&quot;-&quot;
+			stringinstring &quot;fullscreen&quot; &quot;$3&quot; &amp;&amp; options=&quot;F&quot;
+			[ &quot;$(getparam geometry)&quot; = &quot;fullscreen&quot; ] || options=&quot;-&quot;
+			[ &quot;$urender&quot; = &quot;render&quot; ] &amp;&amp; options=&quot;${options}R---PSA&quot;
+			[ &quot;$urender&quot; = &quot;render&quot; ] || options=&quot;${options}----PSA&quot;
+			[ &quot;$udepth&quot; = &quot;$depth&quot; -a &quot;$urender&quot; = &quot;$render&quot; ] &amp;&amp; available=$(getparam status)
+			# FIXME: HACK !!! to keep compatibility with old snapshot version (Knoppix 3.6 based for example)
+			if [ -z &quot;$4&quot; -a &quot;$available&quot; != &quot;N/A&quot; ] 
+			then
+				available=&quot;Yes&quot;
+			fi
+			echo -e &quot;$(getparam display)\t$(getparam type)\t$(getparam sessionId)\t$options\t$depth\t$geom\t$available\t$(getparam sessionName)&quot; &gt;&gt; $TMPFILE
+		fi
+		egrep -q &quot;^userName=$1$&quot; $i &amp;&amp; let SESSION_COUNT_USER=$SESSION_COUNT_USER+1
+	done
+	echo &quot;&quot; &gt;&gt; $TMPFILE
+	echo &quot;&quot; &gt;&gt; $TMPFILE
+	cat $TMPFILE
+	rm -f $TMPFILE
+	if [ &quot;$SESSION_COUNT&quot; -ge &quot;$SESSION_LIMIT&quot; -o &quot;$SESSION_COUNT_USER&quot; -ge &quot;$SESSION_USER_LIMIT&quot; ]
+	then
+		echo &quot;NX&gt; 147 Server capacity: reached for user: $1&quot;
+	else
+		echo &quot;NX&gt; 148 Server capacity: not reached for user: $1&quot;
+	fi
+}
+
+session_list_user()
+{
+	echo &quot;NX&gt; 127 Sessions list of user '$1'&quot;
+	echo
+	echo &quot;Display Username        Remote IP       Session ID&quot;
+	echo &quot;------- --------------- --------------- --------------------------------&quot;
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		if egrep -q &quot;^userName=$1$&quot; $i
+		then
+			CMDLINE=$(session_get_cmdline $i)
+			echo -e &quot;$(getparam display)\t$(getparam userName)\t$(getparam foreignAddress)\t$(getparam sessionId)&quot;
+		fi
+	done
+}
+
+session_history()
+{
+	userName=$1
+	sessionId=$2
+	echo &quot;NX&gt; 127 Session list:&quot;
+	echo
+	echo &quot;Display Username        Remote IP       Session ID                       Date                Status&quot;
+	echo &quot;------- --------------- --------------- -------------------------------- ------------------- -----------&quot;
+	for j in $(ls --time-style +%s -la &quot;$NX_SESS_DIR&quot;/{closed,failed,running} | awk '/sessionId/ { print $6 &quot; &quot; $7 }' | sort -n | cut -d&quot; &quot; -f2)
+	do
+		if [ -n &quot;$sessionId&quot; ]
+		then
+			[ &quot;$j&quot; = &quot;sessionId{$sessionId}&quot; ] || continue
+		fi
+		i=&quot;$NX_SESS_DIR&quot;/*/&quot;$j&quot;
+		[ -f $i ] || break
+		CMDLINE=$(session_get_cmdline $i)
+		if [ -n &quot;$userName&quot; ]
+		then
+			[ &quot;$userName&quot; = &quot;$(getparam userName)&quot; ] || continue
+		fi
+		echo -e &quot;$(getparam display)\t$(getparam userName)\t$(getparam foreignAddress)\t$(getparam sessionId)\t$(ls --time-style=&quot;+%F %X&quot; -l $i | awk '/sessionId/ { print $6 &quot; &quot; $7 }')\t$(getparam status)&quot;
+	done
+}
+
+# remove all sessions older than $SESSION_HISTORY seconds in failed/closed.
+
+session_cleanup()
+{
+	[ &quot;$SESSION_HISTORY&quot; -gt &quot;-1&quot; ] || return
+	let SESSION_HISTORY_MINUTES=$SESSION_HISTORY/60
+	find $NX_SESS_DIR/closed/ $NX_SESS_DIR/failed/ -type f -mmin +&quot;$SESSION_HISTORY_MINUTES&quot; -exec rm -f '{}' ';'
+}
+
+session_list_all()
+{
+	echo &quot;NX&gt; 127 Sessions list:&quot;
+	echo
+	echo &quot;Display Username        Remote IP       Session ID&quot;
+	echo &quot;------- --------------- --------------- --------------------------------&quot;
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		CMDLINE=$(session_get_cmdline $i)
+		echo -e &quot;$(getparam display)\t$(getparam userName)\t$(getparam foreignAddress)\t$(getparam sessionId)&quot;
+	done
+}
+
+
+# session_add &lt;session_id&gt; &lt;options&gt;
+
+session_add()
+{
+	id=$1
+	shift
+	echo &quot;$@&quot; | tr '&amp;' '\n' &gt; $NX_SESS_DIR/running/sessionId'{'$id'}'
+}
+
+# session_change &lt;session_id&gt; &lt;parameter&gt; &lt;new_value&gt;
+
+session_change()
+{
+	[ -f $NX_SESS_DIR/running/sessionId'{'$1'}' ] &amp;&amp; perl -pi -e &quot;s/$2=.*/$2=$3/&quot; $NX_SESS_DIR/running/sessionId'{'$1'}'
+}
+
+# session_id &lt;new status&gt;
+
+session_status()
+{
+	session_change &quot;$1&quot; &quot;status&quot; &quot;$2&quot;
+}
+
+# session_close &lt;session_id&gt; &lt;end-time&gt;
+
+session_close()
+{
+	perl -pi -e &quot;s/startTime=\(.*\)/startTime=\1\nendTime=$(date +%s)/&quot; $NX_SESS_DIR/running/sessionId'{'$1'}'
+	session_status $1 &quot;Finished&quot;
+	[ &quot;$SESSION_HISTORY&quot; = &quot;0&quot; ] &amp;&amp; rm -f $NX_SESS_DIR/running/sessionId'{'$1'}'
+	[ &quot;$SESSION_HISTORY&quot; = &quot;0&quot; ] || mv -f $NX_SESS_DIR/running/sessionId'{'$1'}' $NX_SESS_DIR/closed/sessionId'{'$1'}'
+}
+
+session_fail()
+{
+	perl -pi -e &quot;s/startTime=\(.*\)/startTime=\1\nendTime=$(date +%s)/&quot; $NX_SESS_DIR/running/sessionId'{'$1'}'
+	session_status $1 &quot;Failed&quot;
+	[ &quot;$SESSION_HISTORY&quot; = &quot;0&quot; ] &amp;&amp; rm -f $NX_SESS_DIR/running/sessionId'{'$1'}'
+	[ &quot;$SESSION_HISTORY&quot; = &quot;0&quot; ] || mv -f $NX_SESS_DIR/running/sessionId'{'$1'}' $NX_SESS_DIR/failed/sessionId'{'$1'}'
+}
+
+session_suspend()
+{
+	session_status $1 &quot;Suspended&quot;
+	session_change $1 foreignAddress &quot;-&quot;
+}
+
+#
+# end of library
+#
+
+
+#
+# Main nxserver &lt;-&gt; nxclient communication module
+#
+
+if [ $USER = &quot;nxfree&quot; -o &quot;$USER&quot; = &quot;nx&quot; ]
+then
+
+# Loglevels:
+# 1: Errors
+# 2: Warnings
+# 3: Important information
+# 4: Server - Client communication
+# 5: Information
+# 6: Debugging information
+# 7: stderror-channel of some applications
+
+log()
+{
+	[ &quot;$NX_LOG_LEVEL&quot; -ge &quot;$1&quot; -a -w &quot;$NX_LOGFILE&quot; ] &amp;&amp; shift &amp;&amp; echo &quot;$@&quot; &gt;&gt; &quot;$NX_LOGFILE&quot;
+}
+
+log_tee()
+{
+	[ &quot;$NX_LOG_LEVEL&quot; -ge &quot;4&quot; -a -w &quot;$NX_LOGFILE&quot; ] &amp;&amp; exec tee -a &quot;$NX_LOGFILE&quot;
+	[ &quot;$NX_LOG_LEVEL&quot; -ge &quot;4&quot; -a -w &quot;$NX_LOGFILE&quot; ] || exec cat -
+}
+
+log_error()
+{
+	[ &quot;$NX_LOG_LEVEL&quot; -ge &quot;7&quot; -a -w &quot;$NX_LOGFILE&quot; ] &amp;&amp; exec tee -a &quot;$NX_LOGFILE&quot;
+	[ &quot;$NX_LOG_LEVEL&quot; -ge &quot;7&quot; -a -w &quot;$NX_LOGFILE&quot; ] || exec cat - 
+}
+
+echo_x()
+{
+	log &quot;4&quot; &quot;$@&quot;
+	echo &quot;$@&quot;
+}
+
+# Forward the connection to the commercial NoMachine server
+server_forward_nomachine()
+{
+	set -- &quot;${RECORD_CMD[@]}&quot;
+	
+	# setup the FIFOs
+	SERVER_IN=~/server.in.$$
+	SERVER_OUT=~/server.out.$$
+	rm -f $SERVER_IN $SERVER_OUT
+	mkfifo $SERVER_IN $SERVER_OUT
+	exec 3&lt;&gt;$SERVER_IN
+	exec 4&lt;&gt;$SERVER_OUT
+	
+	$NOMACHINE_SERVER &lt;&amp;3 &gt;&amp;4 &amp;
+	NX_PID=$!
+	
+	while true
+	do
+		read -n7 opcode &lt;&amp;4
+		line=&quot;&quot;
+		case &quot;$opcode&quot; in
+			&quot;NX&gt; 105&quot;)
+				echo $1 &gt;&amp;3
+				shift
+			;;
+			&quot;NX&gt; 101&quot;)
+				echo $USER &gt;&amp;3
+				read line &lt;&amp;4
+				break
+			;;
+			*)
+				read line &lt;&amp;4
+			;;
+		esac
+	done
+	log 5 &quot;Info: Forwarding connection to NoMachine server done.&quot;
+	cat &lt;&amp;4 &amp;
+	CAT_PID=$!
+	cat - &gt;&amp;3
+	rm -f $SERVER_IN $SERVER_OUT
+	kill $CAT_PID
+	kill $NX_PID
+	exit 0
+}
+
+# Start!
+log 3 &quot;-- NX SERVER START: $@&quot;
+
+if [ &quot;$ENABLE_SERVER_FORWARD&quot; = &quot;1&quot; -a -n &quot;$SERVER_FORWARD_HOST&quot; ]
+then
+	log 3 &quot;Info: Forwarding connection to $SERVER_FORWARD_HOST with secret key $SERVER_FORWARD_KEY.&quot;
+	$COMMAND_SSH -i &quot;$SERVER_FORWARD_KEY&quot; &quot;nx@$SERVER_FORWARD_HOST:$SERVER_FORWARD_PORT&quot;
+	exit 0
+fi
+
+# forward the connection to commercial NoMachine server?
+if [ &quot;$ENABLE_NOMACHINE_FORWARD_PORT&quot; = &quot;1&quot; -a &quot;$NOMACHINE_FORWARD_PORT&quot; = &quot;$(echo $SSH_CLIENT | cut -d' ' -f3)&quot; -a -n &quot;$NOMACHINE_SERVER&quot; ]
+then
+	log 3 &quot;Info: Detected SSH destination port $NOMACHINE_FORWARD_PORT. Forwarding connection to commercial NoMachine server.&quot;
+	exec $NOMACHINE_SERVER
+	log 1 &quot;Error: Forwarding to NoMachine Server $NOMACHINE_SERVER failed. Using FreeNX server instead.&quot;
+fi
+
+echo_x &quot;HELLO NXSERVER - Version $NX_VERSION $NX_LICENSE&quot;
+
+[ &quot;$ENABLE_NOMACHINE_FORWARD_USER&quot; = &quot;1&quot; ] &amp;&amp; RECORD_CMD=()
+
+# Login stage
+while true
+do
+	echo_x -n &quot;NX&gt; 105 &quot;
+	read CMD
+	# FIXME?
+	[ &quot;$CMD&quot; = &quot;&quot; ] &amp;&amp; CMD=&quot;quit&quot;
+	echo_x &quot;$CMD&quot;
+	
+	# record $CMD in RECORD_CMD array
+	[ &quot;$ENABLE_NOMACHINE_FORWARD_USER&quot; = &quot;1&quot; ] &amp;&amp; RECORD_CMD=( &quot;${RECORD_CMD[@]}&quot; &quot;$CMD&quot; )
+	
+	case &quot;$CMD&quot; in 
+		quit|QUIT)
+			echo_x &quot;Quit&quot;
+			echo_x &quot;NX&gt; 999 Bye&quot;
+			exit 0
+		;;
+		exit|EXIT)
+			echo_x &quot;Exit&quot;
+			echo_x &quot;NX&gt; 999 Bye&quot;
+			exit 0
+		;;
+		bye|BYE)
+			echo_x &quot;Bye&quot;
+			echo_x &quot;NX&gt; 999 Bye&quot;
+			exit 0
+		;;
+		hello*|HELLO*)
+			PROTO=$(echo $CMD | sed 's/.*Version \(.*\)/\1/g')
+			echo_x &quot;NX&gt; 134 Accepted protocol: $PROTO&quot;
+			if [ &quot;$PROTO&quot; = &quot;1.3.0&quot; -o &quot;$PROTO&quot; = &quot;1.3.2&quot; ]
+			then
+				[ &quot;$ENABLE_AUTORECONNECT_BEFORE_140&quot; = &quot;1&quot; ] &amp;&amp; ENABLE_AUTORECONNECT=&quot;1&quot;
+			fi
+		;;
+		&quot;set auth_mode*&quot;|&quot;SET AUTH_MODE*&quot;)
+			if [ &quot;$CMD&quot; = &quot;set auth_mode password&quot; -o &quot;$CMD&quot; = &quot;SET AUTH_MODE PASSWORD&quot; ]
+			then
+				echo_x &quot;Set auth_mode: password&quot;
+			else
+				echo_x &quot;NX&gt; 500 ERROR: unknown auth mode ''&quot;
+			fi
+		;;
+		login|LOGIN)
+			LOGIN_SUCCESS=&quot;0&quot;
+			
+			echo_x -n &quot;NX&gt; 101 User: &quot;
+			read USER
+			echo_x $USER
+			
+			# forward the connection to commercial NoMachine server?
+			if [ &quot;$ENABLE_NOMACHINE_FORWARD_USER&quot; = &quot;1&quot; -a -n &quot;$NOMACHINE_SERVER&quot; ]
+			then
+				case &quot;$USER&quot; in
+					freenx.*)
+						log 3 &quot;Info: Not forwarding connection. FreeNX user found.&quot;
+						USER=${USER##freenx.}
+					;;
+					*)
+						log 3 &quot;Info: Forwarding connection to NoMachine server&quot;
+						server_forward_nomachine
+						log 1 &quot;Error: Forwarding connection to NoMachine server failed.&quot;
+					;;
+				esac
+			fi
+			
+			echo_x -n &quot;NX&gt; 102 Password: &quot;
+			read -s PASS
+			echo_x &quot;&quot;
+			log 6 -n &quot;Info: Auth method: &quot;
+			
+			# PASSDB based auth
+			if [ &quot;$ENABLE_PASSDB_AUTHENTICATION&quot; = &quot;1&quot; -a &quot;$LOGIN_SUCCESS&quot; = &quot;0&quot; ]
+			then
+				log 6 -n &quot;passdb &quot;
+				if [ $(passdb_get_crypt_pass &quot;$PASS&quot;) = $(passdb_get_pass &quot;$USER&quot;) ]
+				then
+					LOGIN_SUCCESS=&quot;1&quot;
+					LOGIN_METHOD=&quot;PASSDB&quot;
+				fi
+			fi
+
+			# SSH based auth
+			if [ &quot;$ENABLE_SSH_AUTHENTICATION&quot; = &quot;1&quot; -a &quot;$LOGIN_SUCCESS&quot; = &quot;0&quot; ]
+			then
+				log 6 -n &quot;ssh &quot;
+				export COMMAND_SSH			
+				echo &quot;$PASS&quot; | $PATH_BIN/nxnode-login -- ssh &quot;$USER&quot; &quot;$SSHD_PORT&quot; &quot;$PATH_BIN/nxnode&quot; --check 2&gt;&amp;1 &gt;/dev/null
+				if [ $? -eq 0 ]
+				then
+					LOGIN_SUCCESS=&quot;1&quot;
+					LOGIN_METHOD=&quot;SSH&quot;
+				fi
+			fi
+			
+			# SU based auth
+			if [ &quot;$ENABLE_SU_AUTHENTICATION&quot; = &quot;1&quot; -a &quot;$LOGIN_SUCCESS&quot; = &quot;0&quot; ]
+			then
+				log 6 -n &quot;su &quot;
+				echo &quot;$PASS&quot; | $PATH_BIN/nxnode-login -- su &quot;$USER&quot; &quot;&quot; &quot;$PATH_BIN/nxnode&quot; --check 2&gt;&amp;1 &gt;/dev/null
+				if [ $? -eq 0 ]
+				then
+					LOGIN_SUCCESS=&quot;1&quot;
+					LOGIN_METHOD=&quot;SU&quot;
+				fi
+			fi
+			
+			# Check if user in passdb
+			if [ &quot;$ENABLE_USER_DB&quot; = &quot;1&quot; ]
+			then
+				log 6 &quot;userdb check&quot;
+				passdb_user_exists &quot;$USER&quot; || LOGIN_SUCCESS=&quot;0&quot;
+			fi
+			log 6 &quot;&quot;
+
+			if [ &quot;$LOGIN_SUCCESS&quot; = &quot;1&quot; ]
+			then
+				# Reread the config files (so that $USER.node.conf get sourced)
+				. $(PATH=$(cd $(dirname $0) &amp;&amp; pwd):$PATH which nxloadconfig) --userconf
+				echo_x &quot;NX&gt; 103 Welcome to: $SERVER_NAME user: $USER&quot;
+				break
+			else
+				echo_x &quot;NX&gt; 404 ERROR: wrong password or login&quot;
+				echo_x &quot;NX&gt; 999 Bye&quot;
+				exit 1
+			fi
+		;;
+	esac
+done
+
+# remove old session infos from history
+session_cleanup
+
+#
+# call it with: server_get_params $CMD # no &quot;&quot;!
+#
+
+server_get_params()
+{
+	SERVER_PARAMS=$(echo &quot;$@&quot; | sed &quot;s/^$1/\&quot;/g; s/\&quot; --/\&amp;/g; s/\&quot;//g&quot;)
+	if [ &quot;$SERVER_PARAMS&quot; = &quot;&quot; ]
+	then
+		echo_x -n &quot;NX&gt; 106 Parameters: &quot;
+		read SERVER_PARAMS2
+		SERVER_PARAMS=$(echo $SERVER_PARAMS2 | sed 's/%2B/+/g')
+		echo_x
+	fi
+}
+
+nxnode_start()
+{
+	:
+	#CMD=&quot;$1&quot;
+	#shift
+	#echo &quot;$@&quot; | $PATH_BIN/nxnode &quot;$CMD&quot;
+}
+
+#NX&gt; 1002 Commit
+#NX&gt; 1006 Session status: running
+
+server_nxnode_start()
+{
+	CMD=&quot;$1&quot;
+	USER=&quot;$2&quot;
+	shift
+	shift
+	# Use nxnode-login?
+	if [ &quot;$LOGIN_METHOD&quot; = &quot;SSH&quot; ]
+	then
+	    export COMMAND_SSH
+	    echo &quot;$PASS&quot; | $PATH_BIN/nxnode-login -- ssh &quot;$USER&quot; &quot;$SSHD_PORT&quot; &quot;$PATH_BIN/nxnode&quot; &quot;$CMD&quot; &quot;$@&quot; 2&gt;&amp;1 | log_tee
+	elif [ &quot;$LOGIN_METHOD&quot; = &quot;SU&quot; ]
+	then
+	    echo &quot;$PASS&quot; | $PATH_BIN/nxnode-login -- su &quot;$USER&quot; &quot;&quot; &quot;$PATH_BIN/nxnode&quot; &quot;$CMD&quot; &quot;$@&quot; 2&gt;&amp;1 | log_tee
+	else 
+	    echo &quot;$@&quot; | $COMMAND_SSH -l &quot;$USER&quot; 127.0.0.1 -p $SSHD_PORT -x -2 -i $NX_ETC_DIR/users.id_dsa -o 'PubkeyAuthentication yes' -o 'RSAAuthentication yes' -o 'RhostsAuthentication no' -o 'PasswordAuthentication no' -o 'RhostsRSAAuthentication no' -o 'StrictHostKeyChecking no' $PATH_BIN/nxnode &quot;$CMD&quot; | log_tee
+	fi
+}
+
+server_add_usession()
+{
+	[ &quot;$ENABLE_USESSION&quot; = &quot;1&quot; ] || return
+	
+	$COMMAND_SESSREG -l &quot;:$SESS_DISPLAY&quot; -h &quot;$USERIP&quot; -a $USER 2&gt;&amp;1 | log_error
+}
+
+server_remove_usession()
+{
+	[ &quot;$ENABLE_USESSION&quot; = &quot;1&quot; ] || return
+	$COMMAND_SESSREG -l &quot;:$SESS_DISPLAY&quot; -h &quot;$USERIP&quot; -d $USER 2&gt;&amp;1 | log_error
+}
+
+server_nxnode_start_wait()
+{
+	server_add_usession
+	
+	STOP_SEND=&quot;&quot;
+	server_nxnode_start &quot;$@&quot; | while read CMD
+	do
+		case &quot;$CMD&quot; in 
+			&quot;NX&gt; 1006&quot;*|&quot;NX&gt; 1005&quot;*|&quot;NX&gt; 1009&quot;*)
+				case &quot;$CMD&quot; in 
+					*running*)
+						rm -f $WAIT
+						session_status $uniqueid &quot;Running&quot;
+					;;
+					*closed*)
+						session_close $uniqueid
+					;;
+					*suspended*)
+						session_suspend $uniqueid
+					;;
+					*terminating*)
+						session_status $uniqueid &quot;Terminating&quot;
+						# we need to stop sending to client as it will have already
+						# closed his side of the channel and this will lead to not 
+						# closed sessions.
+						STOP_SEND=&quot;1&quot;
+				esac
+			;;
+			&quot;NX&gt; 1004&quot;*)
+				session_fail $uniqueid
+				# FIXME: Need correct error code.
+				echo_x &quot;NX&gt; 504 Session startup failed.&quot;
+			;;
+		esac
+
+		case $CMD in
+			&quot;NX&gt; 718&quot;*)
+				[ -z &quot;$STOP_SEND&quot; ] &amp;&amp; echo $CMD &gt;&amp;2
+				#echo &quot;NX&gt; 1006 Session status: running&quot; 1&gt;&amp;2
+				#echo &quot;NX&gt; 1001 Bye.&quot; 1&gt;&amp;2
+
+			;;
+			&quot;NX&gt; &quot;*)
+				[ -z &quot;$STOP_SEND&quot; ] &amp;&amp; echo $CMD
+			;;
+		esac
+	done
+	
+	server_remove_usession
+
+	# remove lock file
+	[ -e &quot;/tmp/.nX$SESS_DISPLAY-lock&quot; ] &amp;&amp; rm -f /tmp/.nX$SESS_DISPLAY-lock
+}
+
+server_check_session_count()
+{
+	session_count_user &quot;$USER&quot;
+	
+	if [ &quot;$SESSION_COUNT&quot; -ge &quot;$SESSION_LIMIT&quot; ]
+	then
+		echo_x &quot;NX&gt; 599 Reached the maximum number of concurrent sessions on this server.&quot;
+		echo_x &quot;NX&gt; 500 ERROR: Last operation failed.&quot;
+		return 1
+	fi
+	
+	if [ &quot;$SESSION_COUNT_USER&quot; -ge &quot;$SESSION_USER_LIMIT&quot; ]
+	then
+		echo_x &quot;NX&gt; 599 Server capacity: reached for user: $USER&quot;
+		echo_x &quot;NX&gt; 500 ERROR: Last operation failed.&quot;
+		return 1
+	fi
+
+	return 0
+}
+
+server_startrestore_session()
+{
+	ACTION=&quot;$1&quot;
+	
+	server_get_params $CMD
+	PARAMS=$SERVER_PARAMS
+	CMDLINE=$PARAMS
+	echo_x
+	
+	# If we can't get the userip and SSHD_CHECK_IP is set to 1
+	# we bail out.
+	if [ -z &quot;$SSH_CLIENT&quot; ]
+	then 
+		if [ &quot;$SSHD_CHECK_IP&quot; = &quot;1&quot; ]
+		then
+			echo_x &quot;NX&gt; 504 Session startup failed. (Missing SSH_CLIENT environment variable)&quot;
+			return 1
+		else
+			log 2 &quot;Warning: Failed to determine the client IP.&quot;
+			log 2 &quot;Warning: The SSH_CLIENT variable was not provided by SSHD.&quot;
+			log 2 &quot;Warning: Please set SSHD_CHECK_IP=1 if you want to refuse the connection.&quot;
+		fi
+	fi
+	
+	export ENCRYPTION=$(getparam encryption)
+	
+	if [ &quot;$ENABLE_FORCE_ENCRYPTION&quot; = &quot;1&quot; -a &quot;$ENCRYPTION&quot; != &quot;1&quot; ]
+	then
+			echo_x &quot;NX&gt; 504 Unencrypted sessions are not allowed.&quot;
+			return 1
+	fi
+
+	# check if there is a suspended session, which we could resume
+	if [ &quot;$ENABLE_AUTORECONNECT&quot; = &quot;1&quot; -a &quot;$ACTION&quot; = &quot;start&quot; ]
+	then
+		restore=$(session_get_user_suspended &quot;$USER&quot; &quot;Suspended&quot;)
+		if [ -n &quot;$restore&quot; ]
+		then
+			PARAMS=&quot;$PARAMS&amp;restore=$restore&quot;
+			CMDLINE=$PARAMS
+			ACTION=&quot;resume&quot;
+		fi
+	fi
+
+	USERIP=$(echo $SSH_CLIENT | cut -d&quot; &quot; -f1 | sed 's/::<A HREF="ffff://g">ffff://g</A>')
+	[ -z &quot;$USERIP&quot; ] &amp;&amp; USERIP=&quot;*&quot;
+	if [ &quot;$ACTION&quot; = &quot;start&quot; ]
+	then
+		server_check_session_count || return 1
+		
+		# start nxnode
+		SESS_DISPLAY=$DISPLAY_BASE
+		let SESS_DISPLAY_LIMIT=$DISPLAY_BASE+$DISPLAY_LIMIT
+	
+		# stupid but working algo ...
+			
+		# TODO: need to check for _all_ offset and ports :-/
+			
+		while true
+		do
+			while [ -e /tmp/.X$SESS_DISPLAY-lock -o -e &quot;/tmp/.nX$SESS_DISPLAY-lock&quot; ]
+			do
+				let SESS_DISPLAY=$SESS_DISPLAY+1
+			done
+
+			SESS_LOCKFILE=$(mktemp &quot;/tmp/.nX$SESS_DISPLAY-lock.XXXXXXXXX&quot;)
+			# ln is an atomic operation
+			ln &quot;$SESS_LOCKFILE&quot; &quot;/tmp/.nX$SESS_DISPLAY-lock&quot; 2&gt;/dev/null &amp;&amp; break
+		done
+		
+		if [ &quot;$SESS_DISPLAY&quot; -gt &quot;$SESS_DISPLAY_LIMIT&quot; ]
+		then
+			# fixme we need the correct error code
+			echo_x &quot;NX&gt; 504 Error: Display limit exceeded. Please remove some files from /tmp/.X*-lock.&quot;
+			return
+		fi
+
+		rm -f &quot;$SESS_LOCKFILE&quot;
+	
+		uniqueid=$(echo $[$RANDOM*$RANDOM] | md5sum | cut -d&quot; &quot; -f1 | tr &quot;[a-z]&quot; &quot;[A-Z]&quot;)
+		FULL_PARAMS=&quot;user=$USER&amp;userip=$USERIP&amp;uniqueid=$uniqueid&amp;display=$SESS_DISPLAY&amp;$PARAMS&quot;
+		log 6 &quot;$FULL_PARAMS&quot;
+
+		# now update the session listing
+		CMDLINE=&quot;a=b&amp;$FULL_PARAMS&quot;
+		session_add $uniqueid &quot;sessionName=$(getparam session)&amp;display=$(getparam display)&amp;status=Running&amp;startTime=$(date +%s)&amp;foreignAddress=$(getparam userip)&amp;type=$(getparam type)&amp;sessionId=$uniqueid&amp;creationTime=$(date +%s)&amp;userName=$USER&amp;serverPid=$SERVER_PID&amp;screeninfo=$(getparam screeninfo)&amp;geometry=$(getparam geometry)&quot;
+	else
+		uniqueid=$(getparam restore)
+		[ -z &quot;$uniqueid&quot; ] &amp;&amp; uniqueid=$(getparam id) # 1.4.0-5 compatibility
+		session_change &quot;$uniqueid&quot; &quot;foreignAddress&quot; &quot;$USERIP&quot;
+
+		CMDLINE=$(session_get &quot;$uniqueid&quot;)
+		FULL_PARAMS=&quot;user=$USER&amp;userip=$(getparam foreignAddress)&amp;uniqueid=$uniqueid&amp;display=$(getparam display)$PARAMS&quot;
+		SESS_DISPLAY=$(getparam display)
+	fi
+
+	# now start the node
+	export WAIT=$(mktemp /tmp/nxserver_wait.XXXXXXXXX)
+	touch $WAIT
+	(sleep 10; rm -f $WAIT) &amp;
+	server_nxnode_start_wait --&quot;$ACTION&quot;session $USER &quot;$FULL_PARAMS&quot; &amp;
+	SERVER_PID=$!
+	disown $SERVER_PID
+	while [ -f &quot;$WAIT&quot; ]
+	do
+		sleep 1
+	done
+}
+
+# Session stage
+while true
+do
+	echo_x -n &quot;NX&gt; 105 &quot;
+	unset CMD
+	read CMD 2&gt;/dev/null
+	# FIXME?
+	[ &quot;$CMD&quot; = &quot;&quot; ] &amp;&amp; CMD=&quot;quit&quot;
+	echo_x &quot;$CMD&quot;
+	case &quot;$CMD&quot; in 
+		quit|QUIT)
+			echo_x &quot;Quit&quot;
+			echo_x &quot;NX&gt; 999 Bye&quot;
+			exit 0
+		;;
+		exit|EXIT)
+			echo_x &quot;Exit&quot;
+			echo_x &quot;NX&gt; 999 Bye&quot;
+			exit 0
+		;;
+		bye|BYE)
+			echo_x &quot;Bye&quot; 1&gt;&amp;2
+			echo_x &quot;NX&gt; 999 Bye&quot; 1&gt;&amp;2
+			if [ &quot;$ENCRYPTION&quot; = &quot;1&quot; ] 
+			then 
+				let PROXY_DISPLAY=$SESS_DISPLAY+4000
+				$COMMAND_NETCAT 127.0.0.1 $PROXY_DISPLAY
+				exit 0
+			else
+				echo_x &quot;NX&gt; 1001 Bye.&quot;
+			fi
+		;;
+		startsession*)
+			server_startrestore_session &quot;start&quot;
+		;;
+		list*)
+			server_get_params $CMD
+			PARAMS=$SERVER_PARAMS
+			CMDLINE=$PARAMS
+			
+			# FIXME: To NX-Node!
+
+			status=$(getparam status)
+
+			if [ &quot;$status&quot; = &quot;Suspended&quot; -a -n &quot;$(getparam screeninfo)&quot; ]
+			then
+				session_list_user_suspended &quot;$USER&quot; &quot;Suspended&quot; &quot;$(getparam screeninfo)&quot; &quot;$(getparam type)&quot; | log_tee
+			elif [ &quot;$status&quot; = &quot;Suspended,Running&quot; -o &quot;$status&quot; = &quot;Suspended&quot; ] # since 1.4.0-5
+			then
+				# disabled due to problems with 1.4.0-5 client
+				#session_list_user_suspended &quot;$USER&quot; 'Suspended$|^status=Running$' &quot;$(getparam geometry)&quot; &quot;$(getparam type)&quot; | log_tee
+				session_list_user_suspended &quot;$USER&quot; 'Suspended' &quot;$(getparam geometry)&quot; &quot;$(getparam type)&quot; | log_tee
+			else
+				session_list_user &quot;$USER&quot; | log_tee
+			fi
+		;;
+		suspend*)
+			server_get_params $CMD
+			PARAMS=$SERVER_PARAMS
+			CMDLINE=$PARAMS
+			if session_find_id_user &quot;$(getparam sessionid)&quot; &quot;$USER&quot;
+			then
+				# FIXME: Check for success/error
+				server_nxnode_start --suspend &quot;$USER&quot; &quot;$PARAMS&quot;
+				session_suspend $(getparam sessionid)
+			fi
+		;;
+		terminate*)
+			server_get_params $CMD
+			PARAMS=$SERVER_PARAMS
+			CMDLINE=$PARAMS
+			if session_find_id_user &quot;$(getparam sessionid)&quot; &quot;$USER&quot;
+			then
+				# FIXME: Check for success/error
+				server_nxnode_start --terminate &quot;$USER&quot; &quot;$PARAMS&quot;
+				session_close $(getparam sessionid)
+			fi
+		;;
+		restoresession*)
+			server_startrestore_session &quot;resume&quot;
+		;;
+		passwd)
+			echo_x &quot;NX&gt; 113 Changing password of user '$USER'&quot;
+			echo_x -n &quot;NX&gt; 102 Current password:&quot;
+			read -s PASS
+			ENC_PASS=$(passdb_get_crypt_pass &quot;$PASS&quot;)
+			REAL_PASS=$(passdb_get_pass &quot;$USER&quot;)
+			echo_x
+			if [ &quot;$ENC_PASS&quot; = &quot;$REAL_PASS&quot; ]
+			then
+				echo_x -n &quot;NX&gt; 102 Password:&quot;
+				read -s NEW_PASS1
+				
+				if [ ${#NEW_PASS1} -lt 5 ]
+				then
+					echo_x &quot;NX&gt; 500 ERROR: incorrect password format, password must be long at least five characters&quot;
+					continue
+				fi
+
+				echo_x
+				echo_x -n &quot;NX&gt; 102 Confirm password:&quot;
+				read -s NEW_PASS1
+				echo_x
+				if [ &quot;$NEW_PASS1&quot; = &quot;$NEW_PASS2&quot; ]
+				then
+					ENC_PASS=$(passdb_get_crypt_pass &quot;$NEW_PASS1&quot;)
+					passdb_chpass &quot;$USER&quot; &quot;$ENC_PASS&quot;
+					echo_x &quot;NX&gt; 114 Password of user '$USER' changed&quot;
+				else
+					echo_x &quot;NX&gt; 537 ERROR: passwords do not match&quot;
+				fi
+			else
+				echo_x &quot;NX&gt; 500 ERROR: current password doesn't match&quot;
+			fi
+		;;
+		addmount*)
+			server_get_params $CMD
+			PARAMS=$SERVER_PARAMS
+			server_nxnode_start --smbmount &quot;$USER&quot; &quot;$PARAMS&quot; 2&gt;&amp;1 | log_error &gt;/dev/null
+			echo_x &quot;NX&gt; 719 SMB filesystem: running&quot;
+		;;
+		addprinter*)
+			server_get_params $CMD
+			PARAMS=$SERVER_PARAMS
+			server_nxnode_start --addprinter &quot;$USER&quot; &quot;$PARAMS&quot; 2&gt;&amp;1 | log_error &gt;/dev/null
+		;;
+		*)
+			# disabled for 1.4.0-5 snapshot client
+			#echo_x &quot;NX&gt; 503 Error: undefined command: '$CMD'&quot;
+		;;
+	esac
+done
+
+fi
+
+#
+# End of Main nxserver &lt;--&gt; nxclient communication module
+#
+
+################### PACKAGE cmd.bm ############################
+
+#
+# library functions for nxserver-commandline cmds
+#
+
+# Policy: All functions and variables need to start with CMD_ / cmd_
+
+# Needed global vars: $NX_VERSION, $NX_LICENSE, $NX_ETC_DIR, $PATH_BIN, $NX_HOME_DIR, $SSH_AUTHORIZED_KEYS
+
+# Needed package: passdb
+
+cmd_usage()
+{
+	echo &quot;NXSERVER - Version $NX_VERSION $NX_LICENSE&quot;
+	echo &quot;Usage: nxserver &lt;option&gt;&quot; 1&gt;&amp;2
+
+	if [ &quot;$1&quot; = &quot;root&quot; ]
+	then
+		echo &quot;--adduser &lt;user&gt;: Add a new user&quot; 1&gt;&amp;2
+		echo &quot;--passwd &lt;user&gt;: Change password of &lt;user&gt;&quot; 1&gt;&amp;2
+		echo &quot;--deluser &lt;user&gt;: Remove a user from nx&quot; 1&gt;&amp;2
+		echo &quot;--listuser: List enabled users&quot; 1&gt;&amp;2
+		echo &quot;&quot; 1&gt;&amp;2
+		echo &quot;--start: Start the nx server&quot; 1&gt;&amp;2
+		echo &quot;--stop: Stop the nx server&quot; 1&gt;&amp;2
+		echo &quot;--status: Show status of nx server&quot; 1&gt;&amp;2
+		echo &quot;--restart: Restart the nx server and terminate all running sessions&quot; 1&gt;&amp;2
+		echo &quot;&quot; 1&gt;&amp;2
+		echo &quot;--list [ user | sessionid ]: List running sessions of user or sessionid &quot; 1&gt;&amp;2
+		echo &quot;--history [ user | sessionid | clear ]: Show history [ of user | sessionid ] or clear the history&quot; 1&gt;&amp;2
+		echo &quot;--terminate &lt;user | :display | sessionid&gt;: Terminate the session pointed to by&quot; 1&gt;&amp;2
+		echo &quot;       sessionid or display, or all sessions of the specified user.&quot; 1&gt;&amp;2
+		echo &quot;--suspend &lt;user | :display | sessionid&gt;: Suspend the session pointed to by&quot; 1&gt;&amp;2
+		echo &quot;       sessionid or display, or all sessions of the specified user.&quot; 1&gt;&amp;2
+		echo &quot;&quot; 1&gt;&amp;2
+		echo &quot;--broadcast &lt;message&gt;: Send a message to all users&quot; 1&gt;&amp;2
+		echo &quot;--send &lt;user | :display | sessionid&gt; &lt;message&gt;: Send a message to the specified user or sessionid&quot; 1&gt;&amp;2
+	else
+		echo &quot;--passwd: Change password&quot; 1&gt;&amp;2
+	fi
+	exit 1
+}
+
+
+cmd_abort()
+{
+	echo &quot;NX&gt; 500&quot; &quot;$@&quot; 1&gt;&amp;2
+	echo &quot;NX&gt; 999 Bye&quot; 1&gt;&amp;2
+	exit 1
+}
+
+cmd_user_passwd()
+{
+	echo &quot;NX&gt; 100 NXSERVER - Version $NX_VERSION $NX_LICENSE&quot;
+	echo &quot;Sorry: Password changing for user is _not_ implemented, yet.&quot;
+	echo &quot;Please login to NX-Server to change password&quot;
+	echo &quot;or ask your local system administrator.&quot;
+	#echo &quot;NX&gt; 113 Changing password of user '$USER'&quot;
+	#echo &quot;Old password:&quot;
+	#read -s OLDPASS
+	#echo &quot;New password:&quot;
+	#read -s NEWPASS1
+	#echo &quot;Repeat:&quot;
+	#read -s NEWPASS2
+
+}
+
+cmd_passwd()
+{
+	CMD_CHUSER=$2
+	egrep -q &quot;^$CMD_CHUSER:&quot; $NX_ETC_DIR/passwords || cmd_abort &quot;Error: User $CMD_CHUSER not found in database.&quot;
+	echo -n &quot;New password: &quot;
+	read -s CMD_NEWPASS
+	echo
+	CMD_ENC_PASS=$(passdb_get_crypt_pass &quot;$CMD_NEWPASS&quot;)
+	passdb_chpass &quot;$CMD_CHUSER&quot; &quot;$CMD_ENC_PASS&quot;
+	echo &quot;Password changed.&quot;
+}
+
+cmd_adduser()
+{
+	CMD_CHUSER=$2
+	
+	[ ${#CMD_CHUSER} -ge 32 ] &amp;&amp; cmd_abort &quot;Error: User $CMD_CHUSER must be shorter than 32 characters.&quot;
+	egrep -q &quot;^$CMD_CHUSER:&quot; $NX_ETC_DIR/passwords &amp;&amp; cmd_abort &quot;Error: User $CMD_CHUSER already in database.&quot;
+	getent passwd | egrep -q &quot;^$CMD_CHUSER:&quot; || cmd_abort &quot;Error: User $CMD_CHUSER not existing on local system. Can't add.&quot;
+	passdb_add_user &quot;$CMD_CHUSER&quot;
+}
+
+cmd_deluser()
+{
+	CMD_CHUSER=$2
+	egrep -q &quot;^$CMD_CHUSER:&quot; $NX_ETC_DIR/passwords || cmd_abort &quot;Error: User $CMD_CHUSER not found in database.&quot;
+	passdb_remove_user &quot;$CMD_CHUSER&quot;
+}
+
+cmd_listuser()
+{
+	echo &quot;NX&gt; 146 NX users list&quot;
+	echo
+	echo &quot;Username&quot;
+	echo &quot;---------------&quot;
+	echo
+	passdb_list_user
+	echo
+}
+
+cmd_start()
+{
+	
+	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] &amp;&amp; cmd_abort &quot;ERROR: Service already running&quot;
+	mv $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS.disabled $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS
+	echo &quot;NX&gt; 122 Service started&quot;
+}
+
+cmd_stop()
+{
+	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] || cmd_abort &quot;Service was already stopped&quot;
+	mv $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS.disabled
+	# TODO: Stop all running sessions
+	echo &quot;NX&gt; 123 Service stopped&quot;
+}
+
+cmd_status()
+{
+	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] &amp;&amp; echo &quot;NX&gt; 110 NX Server is running&quot;
+	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] || echo &quot;NX&gt; 110 NX Server is stopped&quot;
+}
+
+cmd_restart()
+{
+	cmd_stop
+	cmd_start
+}
+
+cmd_parse_2_params()
+{
+	if [ ${#1} -eq 32 ]
+	then
+		CMD_APARAMS=&quot;sessionid=sessionId{$1}&quot;
+	else
+	if [ &quot;$1&quot; != &quot;&quot; ]
+	then
+		#egrep -q &quot;^$1:&quot; $NX_ETC_DIR/passwords || cmd_abort &quot;Error: User $1 not found in database.&quot;
+		CMD_APARAMS=&quot;user=$1&quot;
+	fi
+	fi
+	echo $CMD_APARAMS
+
+}
+
+cmd_parse_3_params()
+{
+	if [ ${#1} -eq 32 ]
+	then
+		CMD_APARAMS=$(session_find_id $1)
+		[ -n &quot;$CMD_APARAMS&quot; ] || cmd_abort &quot;Error: Session $1 could not be found.&quot;
+	else
+	if [ &quot;${1:0:1}&quot; = &quot;:&quot; ]
+	then
+		CMD_APARAMS=$(session_find_display &quot;${1:1}&quot;)
+		[ -n &quot;$CMD_APARAMS&quot; ] || cmd_abort &quot;Error: No running sessions found for display $1.&quot;
+	else
+	if [ &quot;$1&quot; != &quot;&quot; ]
+	then
+		#egrep -q &quot;^$1:&quot; $NX_ETC_DIR/passwords || cmd_abort &quot;Error: User $1 not found in database.&quot;
+		CMD_APARAMS=$(session_find_user &quot;$1&quot;)
+		[ -n &quot;$CMD_APARAMS&quot; ] || cmd_abort &quot;Error: No running sessions found for user $1.&quot;
+	else
+		cmd_abort &quot;Error: Not enough parameters.&quot;
+	fi
+	fi
+	fi
+	echo $CMD_APARAMS
+}
+
+cmd_list_suspended()
+{
+	CMD_PARAMS=$(cmd_parse_2_params &quot;$2&quot;)
+	[ -n &quot;$2&quot; -a -z &quot;$CMD_PARAMS&quot; ] &amp;&amp; exit 1
+	case $CMD_PARAMS in
+		user=*)
+			session_list_user_suspended $2 &quot;Suspended&quot;
+		;;
+	esac
+}
+cmd_list()
+{
+	CMD_PARAMS=$(cmd_parse_2_params &quot;$2&quot;)
+	[ -n &quot;$2&quot; -a -z &quot;$CMD_PARAMS&quot; ] &amp;&amp; exit 1
+	case $CMD_PARAMS in
+		user=*)
+			session_list_user $2
+		;;
+		sessionid=*)
+			session_list $2
+		;;
+		*)
+			session_list_all
+		;;
+	esac
+}
+
+cmd_history_clear()
+{
+	rm -f $NX_SESS_DIR/closed/*
+	rm -f $NX_SESS_DIR/failed/*
+}
+
+cmd_history()
+{
+	if [ &quot;$2&quot; = &quot;clear&quot; ]
+	then
+		cmd_history_clear
+	fi
+	
+	CMD_PARAMS=$(cmd_parse_2_params &quot;$2&quot;)
+	user=&quot;&quot;
+	sessid=&quot;&quot;
+	case $CMD_PARAMS in
+		user=*)
+			user=&quot;$2&quot;
+		;;
+		sessionid=*)
+			sessid=&quot;$2&quot;
+		;;
+	esac
+
+	session_history &quot;$user&quot; &quot;$sessid&quot;
+}
+
+cmd_terminate()
+{
+	CMD_PARAMS=$(cmd_parse_3_params &quot;$2&quot;)
+	[ -z &quot;$CMD_PARAMS&quot; ] &amp;&amp; exit 1
+	for i in $CMD_PARAMS;
+	do
+			CMDLINE=$(session_get_cmdline $i)
+			cmd_sessionid=$(getparam sessionId)
+			cmd_user=$(getparam userName)
+			cmd_type=$(getparam type)
+			cmd_status=$(getparam status)
+
+			# is it a &quot;good&quot; session?
+			case &quot;$1&quot; in 
+			--suspend)
+				if [ &quot;$cmd_status&quot; = &quot;Running&quot; ] &amp;&amp; stringinstring &quot;unix-&quot; &quot;$cmd_type&quot;
+				then
+					echo &quot;sessionid=$cmd_sessionid&quot; | su - &quot;$cmd_user&quot; -c &quot;$PATH_BIN/nxnode --suspend&quot;
+					session_suspend $cmd_sessionid
+				fi
+				;;
+			--terminate)
+			#if stringinstring &quot;unix-&quot; &quot;$cmd_type&quot;
+			#	then
+					echo &quot;sessionid=$cmd_sessionid&quot; | su - &quot;$cmd_user&quot; -c &quot;$PATH_BIN/nxnode --terminate&quot;
+					session_close $cmd_sessionid
+			#	fi
+
+			;;
+			esac
+	done
+
+}
+
+cmd_send()
+{
+	if [ &quot;$1&quot; = &quot;--broadcast&quot; ]
+	then
+	  CMD_PARAMS=$(session_find_all)
+	  [ -z &quot;$CMD_PARAMS&quot; ] &amp;&amp; cmd_abort &quot;Error: No running session could be found.&quot;
+	else
+	  CMD_PARAMS=$(cmd_parse_3_params &quot;$2&quot;)
+	  [ -z &quot;$CMD_PARAMS&quot; ] &amp;&amp; exit 1
+	fi
+	shift
+	shift
+	for i in $CMD_PARAMS;
+	do
+			CMDLINE=$(session_get_cmdline $i)
+			cmd_display=$(getparam display)
+			cmd_user=$(getparam userName)
+			cmd_type=$(getparam type)
+			cmd_status=$(getparam status)
+
+			# is it a &quot;good&quot; session?
+			if [ &quot;$cmd_status&quot; = &quot;Running&quot; ] &amp;&amp; stringinstring &quot;unix-&quot; &quot;$cmd_type&quot;
+			then
+				su - &quot;$cmd_user&quot; -c &quot;$PATH_BIN/nxclient --dialog ok --caption \&quot;NX Administrator Message\&quot; --message \&quot;$@\&quot; --noautokill 
+-display \&quot;:$cmd_display\&quot;&quot; &amp;
+				disown $!
+			fi
+	done
+	#nxnode_start --send &quot;$CMD_PARAMS&quot;
+}
+
+#
+# user mode available functions
+#
+
+if [ $UID -ne 0 ]
+then
+	[ &quot;$1&quot; != &quot;--passwd&quot; ] &amp;&amp; cmd_usage
+	cmd_user_passwd
+	exit 0
+fi
+
+#
+# root mode available functions
+#
+
+[ $# -lt 1 ] &amp;&amp; cmd_usage &quot;root&quot;
+[ &quot;$1&quot; = &quot;--help&quot; ] &amp;&amp; cmd_usage &quot;root&quot;
+
+if [ &quot;$1&quot; = &quot;--version&quot; ]
+then
+  echo &quot;NXSERVER - Version $NX_VERSION $NX_LICENSE&quot;
+  exit 0
+fi
+
+CMD=$1
+
+echo &quot;NX&gt; 100 NXSERVER - Version $NX_VERSION $NX_LICENSE&quot;
+
+case $CMD in
+	# 
+	# User functions ...
+	# 
+	--passwd)
+		cmd_passwd &quot;$@&quot;
+	;;
+	--adduser|--useradd)
+		cmd_adduser &quot;$@&quot;
+	;;
+	--deluser|--userdel)
+		cmd_deluser &quot;$@&quot;
+	;;
+	--listuser|--userlist)
+		cmd_listuser
+	;;
+	--start)
+		cmd_start
+	;;
+	--stop)
+		cmd_stop
+	;;
+	--status)
+		cmd_status
+	;;
+	--restart)
+		cmd_restart
+	;;
+	--list)
+		cmd_list &quot;$@&quot;
+	;;
+	--list-suspended)
+		cmd_list_suspended &quot;$@&quot;
+	;;
+	--history)
+		cmd_history &quot;$@&quot;
+	;;
+	--terminate|--suspend)
+		cmd_terminate &quot;$@&quot;
+	;;
+	--send|--broadcast)
+		cmd_send &quot;$@&quot;
+	;;
+	*)
+		cmd_abort &quot;Error: Function $CMD not implemented yet.&quot;
+esac
+echo &quot;NX&gt; 999 Bye&quot;


Property changes on: freenx-server/nxserver
___________________________________________________________________
Name: svn:executable
   + 

Added: freenx-server/nxserver.old
===================================================================
--- freenx-server/nxserver.old	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/nxserver.old	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,1381 @@
+#!/bin/bash
+
+# Free implementation of nxserver components
+#
+# To use nxserver add the user &quot;nx&quot; 
+# and use nxserver as default shell.
+#
+# Also make sure that hostkey based authentification works.
+# 
+# Copyright (c) 2004 by Fabian Franz &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">FreeNX at fabian-franz.de</A>&gt;.
+#
+# License: GNU GPL, version 2
+#
+# CVS: $Id: nxserver,v 1.42 2005/03/14 00:51:21 fabianx Exp $
+#
+
+# Read the config file
+. $(PATH=$(cd $(dirname $0) &amp;&amp; pwd):$PATH which nxloadconfig) --
+
+if [ &quot;$USER&quot; = &quot;nxuser&quot; ]
+then
+	export NX_SESS_DIR=&quot;$HOME/.nx/db/&quot;
+	export NX_LOGFILE=&quot;$HOME/.nx/temp/nxserver.log&quot;
+	mkdir -p $NX_SESS_DIR/{closed,running,failed}
+	ENABLE_FAKE_AUTHENTICATION=&quot;1&quot;
+fi
+
+# following two functions are Copyright by Klaus Knopper
+
+stringinstring(){
+case &quot;$2&quot; in *$1*) return 0;; esac
+return 1
+}
+
+# Reread boot command line; echo last parameter's argument or return false.
+getparam(){
+stringinstring &quot;&amp;$1=&quot; &quot;$CMDLINE&quot; || return 1
+echo &quot;$CMDLINE&quot; | awk &quot;/^$1=/&quot;' { VAL=$2 } END { print VAL }' FS=&quot;=&quot; RS=&quot;(&amp;|\n)&quot;
+return 0
+}
+
+
+############### PACKAGE passdb.bm #######################
+#
+# Library of passdb functions (outsource)
+#
+
+# Policy: Variable and function names _must_ start with passdb_ / PASSDB_
+
+# Needed global vars: $NX_ETC_DIR, $PATH_BIN
+
+# Needed nonstd functions: md5sum
+
+
+passdb_get_crypt_pass()
+{
+	echo &quot;$@&quot; | md5sum | cut -d&quot; &quot; -f1
+}
+
+passdb_get_pass()
+{
+	PASSDB_CHUSER=&quot;$1&quot;
+	PASSDB_PASS=$(egrep &quot;^$PASSDB_CHUSER:&quot; $NX_ETC_DIR/passwords 2&gt;/dev/null | cut -d&quot;:&quot; -f2)
+	if [ &quot;$ENABLE_PASSDB_AUTHENTICATION&quot; = &quot;1&quot; ]
+	then
+		egrep -q &quot;^$PASSDB_CHUSER:&quot; $NX_ETC_DIR/passwords 2&gt;/dev/null &amp;&amp; echo $PASSDB_PASS
+		egrep -q &quot;^$PASSDB_CHUSER:&quot; $NX_ETC_DIR/passwords 2&gt;/dev/null || echo &quot;NOT_VALID&quot;
+	else
+		echo &quot;NOT_VALID&quot;
+	fi
+}
+
+passdb_chpass()
+{
+	PASSDB_CHUSER=&quot;$1&quot;
+	PASSDB_ENC_PASS=&quot;$2&quot;
+	cp -f $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
+	perl -pi -e &quot;s/$PASSDB_CHUSER:.*/$PASSDB_CHUSER:$PASSDB_ENC_PASS/g&quot; $NX_ETC_DIR/passwords
+}
+
+passdb_user_exists()
+{
+	PASSDB_CHUSER=&quot;$1&quot;
+	egrep -q &quot;^$PASSDB_CHUSER:&quot; $NX_ETC_DIR/passwords 2&gt;/dev/null
+}
+
+
+passdb_remove_user()
+{
+	PASSDB_CHUSER=&quot;$1&quot;
+	cp -f $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
+	perl -pi -e &quot;s/$PASSDB_CHUSER:.*\n//g&quot; $NX_ETC_DIR/passwords
+}
+
+passdb_add_user()
+{
+	PASSDB_CHUSER=&quot;$1&quot;
+	cp -f $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
+	echo &quot;$PASSDB_CHUSER:*&quot; &gt;&gt; $NX_ETC_DIR/passwords
+	# deactivated to avoid problems with comm-server
+	su - $PASSDB_CHUSER -c &quot;$PATH_BIN/nxnode --setkey&quot;
+}
+
+passdb_list_user()
+{
+	cat $NX_ETC_DIR/passwords | cut -d&quot;:&quot; -f1
+}
+
+#
+# End of passdb Library
+#
+
+############### PACKAGE session.bm #######################
+#
+# Library of session management functions
+#
+
+# Needed global vars: $NX_SESS_DIR
+
+session_list()
+{
+	cat $NX_SESS_DIR/running/sessionId&quot;{$1}&quot;
+}
+
+# Find all running session-filenames 
+
+session_find_all()
+{
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		echo $i
+	done
+}
+
+# Find all running sessions of a id
+session_find_id()
+{
+	[ -f $NX_SESS_DIR/running/sessionId&quot;{$1}&quot; ] &amp;&amp; echo $NX_SESS_DIR/running/sessionId&quot;{$1}&quot;
+}
+
+# finds out if a session belongs to a user
+
+session_find_id_user()
+{
+	[ -f $NX_SESS_DIR/running/sessionId&quot;{$1}&quot; ] &amp;&amp; egrep -q &quot;^userName=$2$&quot; $NX_SESS_DIR/running/sessionId&quot;{$1}&quot; &amp;&amp; return 0
+	return 1
+}
+
+# Find all running sessions of a user
+session_find_user()
+{
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		egrep -q &quot;^userName=$1$&quot; $i &amp;&amp; echo $i
+	done
+}
+
+# Find all running sessions of a display
+session_find_display()
+{	
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		egrep -q &quot;^display=$1$&quot; $i &amp;&amp; echo $i
+	done
+}
+
+# session_get_cmdline &lt;session filename&gt;
+
+session_get_cmdline()
+{
+	echo &quot;a=b&quot; | cat - $1 | tr '\n' '&amp;'
+}
+
+# session_get &lt;uniqueid&gt;
+
+session_get()
+{
+	session_get_cmdline $NX_SESS_DIR/running/sessionId&quot;{$1}&quot;
+}
+
+
+# Get the first session, which can be resumed
+
+session_get_user_suspended()
+{
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		if egrep -q &quot;^userName=$1$&quot; $i &amp;&amp; egrep -q &quot;^status=$2$&quot; $i
+		then
+			CMDLINE=$(session_get_cmdline $i)
+			echo &quot;$(getparam sessionId)&quot;
+			break
+		fi
+	done
+}
+
+# Count all sessions of a user
+# and save it in SESSION_COUNT and SESSION_COUNT_USER
+
+session_count_user()
+{
+	SESSION_COUNT=0
+	SESSION_COUNT_USER=0
+
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		let SESSION_COUNT=$SESSION_COUNT+1
+		egrep -q &quot;^userName=$1$&quot; $i &amp;&amp; let SESSION_COUNT_USER=$SESSION_COUNT_USER+1
+	done
+}
+
+# List all sessions of a user
+
+session_list_user_suspended()
+{
+	SESSION_COUNT=0
+	SESSION_COUNT_USER=0
+
+	TMPFILE=$(mktemp /tmp/nxserver_tmp.XXXXXXXXX)
+	echo &quot;NX&gt; 127 Sessions list of user '$1' for reconnect:&quot; &gt; $TMPFILE
+	echo &gt;&gt; $TMPFILE
+	if [ -z &quot;$4&quot; ]
+	then
+		
+		echo &quot;Display Type             Session ID                       Options  Depth Screensize     Available Session Name&quot; &gt;&gt; $TMPFILE
+		echo &quot;------- ---------------- -------------------------------- -------- ----- -------------- --------- ----------------------&quot; &gt;&gt; $TMPFILE
+	else
+		echo &quot;Display Type             Session ID                       Options  Depth Screen         Status      Session Name&quot; &gt;&gt; $TMPFILE
+		echo &quot; ------- ---------------- -------------------------------- -------- ----- -------------- ----------- ------------------------------&quot; &gt;&gt; $TMPFILE
+	fi
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		let SESSION_COUNT=$SESSION_COUNT+1
+		if egrep -q &quot;^userName=$1$&quot; $i &amp;&amp; egrep -q &quot;^status=$2$&quot; $i #&amp;&amp; grep -q &quot;screeninfo=$3&quot; $i
+		then
+			CMDLINE=$(session_get_cmdline $i)
+			depth=$(getparam screeninfo | cut -d &quot;x&quot; -f3 | cut -d &quot;+&quot; -f1 )
+			geom=$(getparam screeninfo | cut -d &quot;x&quot; -f1,2) 
+			render=$(getparam screeninfo | cut -d &quot;+&quot; -f2 )
+			available=&quot;N/A&quot;
+			udepth=$(echo $3 | cut -d &quot;x&quot; -f3 | cut -d &quot;+&quot; -f1 )
+			urender=$(echo $3 | cut -d &quot;+&quot; -f2 )
+			[ &quot;$(getparam geometry)&quot; = &quot;fullscreen&quot; ] &amp;&amp; options=&quot;F&quot;
+			[ &quot;$(getparam geometry)&quot; = &quot;fullscreen&quot; ] || options=&quot;-&quot;
+			[ &quot;$urender&quot; = &quot;render&quot; ] &amp;&amp; options=&quot;${options}R---PSA&quot;
+			[ &quot;$urender&quot; = &quot;render&quot; ] || options=&quot;${options}----PSA&quot;
+			[ &quot;$udepth&quot; = &quot;$depth&quot; -a &quot;$urender&quot; = &quot;$render&quot; ] &amp;&amp; available=$(getparam status)
+			# FIXME: HACK !!! to keep compatibility with old snapshot version (Knoppix 3.6 based for example)
+			if [ -z &quot;$4&quot; -a &quot;$available&quot; != &quot;N/A&quot; ] 
+			then
+				available=&quot;Yes&quot;
+			fi
+			echo -e &quot;$(getparam display)\t$(getparam type)\t$(getparam sessionId)\t$options\t$depth\t$geom\t$available\t$(getparam sessionName)&quot; &gt;&gt; $TMPFILE
+		fi
+		egrep -q &quot;^userName=$1$&quot; $i &amp;&amp; let SESSION_COUNT_USER=$SESSION_COUNT_USER+1
+	done
+	echo &quot;&quot; &gt;&gt; $TMPFILE
+	echo &quot;&quot; &gt;&gt; $TMPFILE
+	cat $TMPFILE
+	rm -f $TMPFILE
+	if [ &quot;$SESSION_COUNT&quot; -ge &quot;$SESSION_LIMIT&quot; -o &quot;$SESSION_COUNT_USER&quot; -ge &quot;$SESSION_USER_LIMIT&quot; ]
+	then
+		echo &quot;NX&gt; 147 Server capacity: reached for user: $1&quot;
+	else
+		echo &quot;NX&gt; 148 Server capacity: not reached for user: $1&quot;
+	fi
+}
+
+session_list_user()
+{
+	echo &quot;NX&gt; 127 Sessions list of user '$1'&quot;
+	echo
+	echo &quot;Display Username        Remote IP       Session ID&quot;
+	echo &quot;------- --------------- --------------- --------------------------------&quot;
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		if egrep -q &quot;^userName=$1$&quot; $i
+		then
+			CMDLINE=$(session_get_cmdline $i)
+			echo -e &quot;$(getparam display)\t$(getparam userName)\t$(getparam foreignAddress)\t$(getparam sessionId)&quot;
+		fi
+	done
+}
+
+session_history()
+{
+	userName=$1
+	sessionId=$2
+	echo &quot;NX&gt; 127 Session list:&quot;
+	echo
+	echo &quot;Display Username        Remote IP       Session ID                       Date                Status&quot;
+	echo &quot;------- --------------- --------------- -------------------------------- ------------------- -----------&quot;
+	for j in $(ls --time-style +%s -la &quot;$NX_SESS_DIR&quot;/{closed,failed,running} | awk '/sessionId/ { print $6 &quot; &quot; $7 }' | sort -n | cut -d&quot; &quot; -f2)
+	do
+		if [ -n &quot;$sessionId&quot; ]
+		then
+			[ &quot;$j&quot; = &quot;sessionId{$sessionId}&quot; ] || continue
+		fi
+		i=&quot;$NX_SESS_DIR&quot;/*/&quot;$j&quot;
+		[ -f $i ] || break
+		CMDLINE=$(session_get_cmdline $i)
+		if [ -n &quot;$userName&quot; ]
+		then
+			[ &quot;$userName&quot; = &quot;$(getparam userName)&quot; ] || continue
+		fi
+		echo -e &quot;$(getparam display)\t$(getparam userName)\t$(getparam foreignAddress)\t$(getparam sessionId)\t$(ls --time-style=&quot;+%F %X&quot; -l $i | awk '/sessionId/ { print $6 &quot; &quot; $7 }')\t$(getparam status)&quot;
+	done
+}
+
+# remove all sessions older than $SESSION_HISTORY seconds in failed/closed.
+
+session_cleanup()
+{
+	[ &quot;$SESSION_HISTORY&quot; -gt &quot;-1&quot; ] || return
+	let SESSION_HISTORY_MINUTES=$SESSION_HISTORY/60
+	find $NX_SESS_DIR/closed/ $NX_SESS_DIR/failed/ -type f -mmin +&quot;$SESSION_HISTORY_MINUTES&quot; -exec rm -f '{}' ';'
+}
+
+session_list_all()
+{
+	echo &quot;NX&gt; 127 Sessions list:&quot;
+	echo
+	echo &quot;Display Username        Remote IP       Session ID&quot;
+	echo &quot;------- --------------- --------------- --------------------------------&quot;
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		CMDLINE=$(session_get_cmdline $i)
+		echo -e &quot;$(getparam display)\t$(getparam userName)\t$(getparam foreignAddress)\t$(getparam sessionId)&quot;
+	done
+}
+
+
+# session_add &lt;session_id&gt; &lt;options&gt;
+
+session_add()
+{
+	id=$1
+	shift
+	echo &quot;$@&quot; | tr '&amp;' '\n' &gt; $NX_SESS_DIR/running/sessionId'{'$id'}'
+}
+
+# session_change &lt;session_id&gt; &lt;parameter&gt; &lt;new_value&gt;
+
+session_change()
+{
+	[ -f $NX_SESS_DIR/running/sessionId'{'$1'}' ] &amp;&amp; perl -pi -e &quot;s/$2=.*/$2=$3/&quot; $NX_SESS_DIR/running/sessionId'{'$1'}'
+}
+
+# session_id &lt;new status&gt;
+
+session_status()
+{
+	session_change &quot;$1&quot; &quot;status&quot; &quot;$2&quot;
+}
+
+# session_close &lt;session_id&gt; &lt;end-time&gt;
+
+session_close()
+{
+	perl -pi -e &quot;s/startTime=\(.*\)/startTime=\1\nendTime=$(date +%s)/&quot; $NX_SESS_DIR/running/sessionId'{'$1'}'
+	session_status $1 &quot;Finished&quot;
+	[ &quot;$SESSION_HISTORY&quot; = &quot;0&quot; ] &amp;&amp; rm -f $NX_SESS_DIR/running/sessionId'{'$1'}'
+	[ &quot;$SESSION_HISTORY&quot; = &quot;0&quot; ] || mv -f $NX_SESS_DIR/running/sessionId'{'$1'}' $NX_SESS_DIR/closed/sessionId'{'$1'}'
+}
+
+session_fail()
+{
+	perl -pi -e &quot;s/startTime=\(.*\)/startTime=\1\nendTime=$(date +%s)/&quot; $NX_SESS_DIR/running/sessionId'{'$1'}'
+	session_status $1 &quot;Failed&quot;
+	[ &quot;$SESSION_HISTORY&quot; = &quot;0&quot; ] &amp;&amp; rm -f $NX_SESS_DIR/running/sessionId'{'$1'}'
+	[ &quot;$SESSION_HISTORY&quot; = &quot;0&quot; ] || mv -f $NX_SESS_DIR/running/sessionId'{'$1'}' $NX_SESS_DIR/failed/sessionId'{'$1'}'
+}
+
+session_suspend()
+{
+	session_status $1 &quot;Suspended&quot;
+}
+
+#
+# end of library
+#
+
+
+#
+# Main nxserver &lt;-&gt; nxclient communication module
+#
+
+if [ $USER = &quot;nxuser&quot; -o &quot;$USER&quot; = &quot;nx&quot; ]
+then
+	
+log()
+{
+	[ &quot;$NX_LOGGING&quot; = &quot;1&quot; -a -w &quot;$NX_LOGFILE&quot; ] &amp;&amp; echo &quot;$@&quot; &gt;&gt; &quot;$NX_LOGFILE&quot;
+}
+
+log_tee()
+{
+	[ &quot;$NX_LOGGING&quot; = &quot;1&quot; -a -w &quot;$NX_LOGFILE&quot; ] &amp;&amp; exec tee -a &quot;$NX_LOGFILE&quot;
+	[ &quot;$NX_LOGGING&quot; = &quot;1&quot; -a -w &quot;$NX_LOGFILE&quot; ] || exec cat -
+}
+
+echo_x()
+{
+	log &quot;$@&quot;
+	echo &quot;$@&quot;
+}
+
+# Forward the connection to the commercial NoMachine server
+server_forward_nomachine()
+{
+	set -- &quot;${RECORD_CMD[@]}&quot;
+	
+	# setup the FIFOs
+	SERVER_IN=~/server.in.$$
+	SERVER_OUT=~/server.out.$$
+	rm -f $SERVER_IN $SERVER_OUT
+	mkfifo $SERVER_IN $SERVER_OUT
+	exec 3&lt;&gt;$SERVER_IN
+	exec 4&lt;&gt;$SERVER_OUT
+	
+	$NOMACHINE_SERVER &lt;&amp;3 &gt;&amp;4 &amp;
+	NX_PID=$!
+	
+	while true
+	do
+		read -n7 opcode &lt;&amp;4
+		line=&quot;&quot;
+		case &quot;$opcode&quot; in
+			&quot;NX&gt; 105&quot;)
+				echo $1 &gt;&amp;3
+				shift
+			;;
+			&quot;NX&gt; 101&quot;)
+				echo $USER &gt;&amp;3
+				read line &lt;&amp;4
+				break
+			;;
+			*)
+				read line &lt;&amp;4
+			;;
+		esac
+	done
+	log &quot;done.&quot;
+	cat &lt;&amp;4 &amp;
+	CAT_PID=$!
+	cat - &gt;&amp;3
+	rm -f $SERVER_IN $SERVER_OUT
+	kill $CAT_PID
+	kill $NX_PID
+	exit 0
+}
+
+# Start!
+log &quot;-- NX SERVER START: $@&quot;
+
+if [ &quot;$ENABLE_SERVER_FORWARD&quot; = &quot;1&quot; -a -n &quot;$SERVER_FORWARD_HOST&quot; ]
+then
+	log &quot;Forwarding connection to $SERVER_FORWARD_HOST with secret key $SERVER_FORWARD_KEY.&quot;
+	ssh -i &quot;$SERVER_FORWARD_KEY&quot; &quot;nx@$SERVER_FORWARD_HOST:$SERVER_FORWARD_PORT&quot;
+	exit 0
+fi
+
+# forward the connection to commercial NoMachine server?
+if [ &quot;$ENABLE_NOMACHINE_FORWARD_PORT&quot; = &quot;1&quot; -a &quot;$NOMACHINE_FORWARD_PORT&quot; = &quot;$(echo $SSH_CLIENT | cut -d' ' -f3)&quot; -a -n &quot;$NOMACHINE_SERVER&quot; ]
+then
+	log &quot;Info: Detected SSH destination port $NOMACHINE_FORWARD_PORT. Forwarding connection to commercial NoMachine server.&quot;
+	exec $NOMACHINE_SERVER
+	log &quot;Error: Forwarding to NoMachine Server $NOMACHINE_SERVER failed. Using FreeNX server instead.&quot;
+fi
+
+echo_x &quot;HELLO NXSERVER - Version $NX_VERSION $NX_LICENSE&quot;
+
+[ &quot;$ENABLE_NOMACHINE_FORWARD_USER&quot; = &quot;1&quot; ] &amp;&amp; RECORD_CMD=()
+
+# Login stage
+while true
+do
+	echo_x -n &quot;NX&gt; 105 &quot;
+	read CMD
+	# FIXME?
+	[ &quot;$CMD&quot; = &quot;&quot; ] &amp;&amp; CMD=&quot;quit&quot;
+	echo_x &quot;$CMD&quot;
+	
+	# record $CMD in RECORD_CMD array
+	[ &quot;$ENABLE_NOMACHINE_FORWARD_USER&quot; = &quot;1&quot; ] &amp;&amp; RECORD_CMD=( &quot;${RECORD_CMD[@]}&quot; &quot;$CMD&quot; )
+	
+	case &quot;$CMD&quot; in 
+		quit|QUIT)
+			echo_x &quot;Quit&quot;
+			echo_x &quot;NX&gt; 999 Bye&quot;
+			exit 0
+		;;
+		exit|EXIT)
+			echo_x &quot;Exit&quot;
+			echo_x &quot;NX&gt; 999 Bye&quot;
+			exit 0
+		;;
+		bye|BYE)
+			echo_x &quot;Bye&quot;
+			echo_x &quot;NX&gt; 999 Bye&quot;
+			exit 0
+		;;
+		hello*|HELLO*)
+			PROTO=$(echo $CMD | sed 's/.*Version \(.*\)/\1/g')
+			echo_x &quot;NX&gt; 134 Accepted protocol: $PROTO&quot;
+			if [ &quot;$PROTO&quot; = &quot;1.3.0&quot; -o &quot;$PROTO&quot; = &quot;1.3.2&quot; ]
+			then
+				[ &quot;$ENABLE_AUTORECONNECT_BEFORE_140&quot; = &quot;1&quot; ] &amp;&amp; ENABLE_AUTORECONNECT=&quot;1&quot;
+			fi
+		;;
+		set*|SET)
+			if [ &quot;$CMD&quot; = &quot;set auth_mode password&quot; -o &quot;$CMD&quot; = &quot;SET AUTH_MODE PASSWORD&quot; ]
+			then
+				echo_x &quot;Set auth_mode: password&quot;
+			else
+				echo_x &quot;NX&gt; 500 ERROR: unknown auth mode ''&quot;
+			fi
+		;;
+		login|LOGIN)
+			LOGIN_SUCCESS=&quot;0&quot;
+			
+			echo_x -n &quot;NX&gt; 101 User: &quot;
+			read USER
+			echo_x $USER
+			
+			# forward the connection to commercial NoMachine server?
+			if [ &quot;$ENABLE_NOMACHINE_FORWARD_USER&quot; = &quot;1&quot; -a -n &quot;$NOMACHINE_SERVER&quot; ]
+			then
+				case &quot;$USER&quot; in
+					freenx.*)
+						log &quot;Not forwarding connection. FreeNX user found.&quot;
+						USER=${USER##freenx.}
+					;;
+					*)
+						log -n &quot;Forwarding connection to NoMachine server...&quot;
+						server_forward_nomachine
+						log &quot;failed.&quot;
+					;;
+				esac
+			fi
+			
+			echo_x -n &quot;NX&gt; 102 Password: &quot;
+			read -s PASS
+			echo_x &quot;&quot;
+			log -n &quot;Auth method: &quot;
+
+			if [ &quot;$ENABLE_FAKE_AUTHENTICATION&quot; = &quot;1&quot; ]
+			then
+				LOGIN_SUCCESS=&quot;1&quot;
+				LOGIN_METHOD=&quot;FAKE&quot;
+			fi
+			
+			# PASSDB based auth
+			if [ &quot;$ENABLE_PASSDB_AUTHENTICATION&quot; = &quot;1&quot; -a &quot;$LOGIN_SUCCESS&quot; = &quot;0&quot; ]
+			then
+				log -n &quot;passdb &quot;
+				if [ $(passdb_get_crypt_pass &quot;$PASS&quot;) = $(passdb_get_pass &quot;$USER&quot;) ]
+				then
+					LOGIN_SUCCESS=&quot;1&quot;
+					LOGIN_METHOD=&quot;PASSDB&quot;
+				fi
+			fi
+			
+			# SSH based auth
+			if [ &quot;$ENABLE_SSH_AUTHENTICATION&quot; = &quot;1&quot; -a &quot;$LOGIN_SUCCESS&quot; = &quot;0&quot; ]
+			then
+				log -n &quot;ssh &quot;
+				echo &quot;$PASS&quot; | $PATH_BIN/nxnode-login -- ssh &quot;$USER&quot; &quot;$SSHD_PORT&quot; &quot;$PATH_BIN/nxnode&quot; --check &gt; /dev/null 2&gt;/dev/null
+				if [ $? -eq 0 ]
+				then
+					LOGIN_SUCCESS=&quot;1&quot;
+					LOGIN_METHOD=&quot;SSH&quot;
+				fi
+			fi
+			
+			# SU based auth
+			if [ &quot;$ENABLE_SU_AUTHENTICATION&quot; = &quot;1&quot; -a &quot;$LOGIN_SUCCESS&quot; = &quot;0&quot; ]
+			then
+				log -n &quot;su &quot;
+				echo &quot;$PASS&quot; | $PATH_BIN/nxnode-login -- su &quot;$USER&quot; &quot;&quot; &quot;$PATH_BIN/nxnode&quot; --check &gt; /dev/null 2&gt;/dev/null
+				if [ $? -eq 0 ]
+				then
+					LOGIN_SUCCESS=&quot;1&quot;
+					LOGIN_METHOD=&quot;SU&quot;
+				fi
+			fi
+			log &quot;&quot;
+			
+			# Check if user in passdb
+			if [ &quot;$ENABLE_USER_DB&quot; = &quot;1&quot; ]
+			then
+				log &quot;userdb check&quot;
+				passdb_user_exists &quot;$USER&quot; || LOGIN_SUCCESS=&quot;0&quot;
+			fi
+
+			if [ &quot;$LOGIN_SUCCESS&quot; = &quot;1&quot; ]
+			then
+				# Reread the config files (so that $USER.node.conf get sourced)
+				. $(PATH=$(cd $(dirname $0) &amp;&amp; pwd):$PATH which nxloadconfig) --userconf
+
+if [ &quot;$USER&quot; = &quot;nxuser&quot; ]
+then
+	export NX_SESS_DIR=&quot;$HOME/.nx/db/&quot;
+	export NX_LOGFILE=&quot;$HOME/.nx/temp/nxserver.log&quot;
+	mkdir -p $NX_SESS_DIR/{closed,running,failed}
+	ENABLE_FAKE_AUTHENTICATION=&quot;1&quot;
+fi
+
+
+				echo_x &quot;NX&gt; 103 Welcome to: $SERVER_NAME user: $USER&quot;
+				break
+			else
+				echo_x &quot;NX&gt; 404 ERROR: wrong password or login&quot;
+				echo_x &quot;NX&gt; 999 Bye&quot;
+				exit 1
+			fi
+		;;
+	esac
+done
+
+# remove old session infos from history
+session_cleanup
+
+#
+# call it with: server_get_params $CMD # no &quot;&quot;!
+#
+
+server_get_params()
+{
+	SERVER_PARAMS=$(echo &quot;$@&quot; | sed &quot;s/^$1/\&quot;/g; s/\&quot; --/\&amp;/g; s/\&quot;//g&quot;)
+	if [ &quot;$SERVER_PARAMS&quot; = &quot;&quot; ]
+	then
+		echo_x -n &quot;NX&gt; 106 Parameters: &quot;
+		read SERVER_PARAMS2
+		SERVER_PARAMS=$(echo $SERVER_PARAMS2 | sed 's/%2B/+/g')
+		echo_x
+	fi
+}
+
+nxnode_start()
+{
+	:
+	#CMD=&quot;$1&quot;
+	#shift
+	#echo &quot;$@&quot; | $PATH_BIN/nxnode &quot;$CMD&quot;
+}
+
+#NX&gt; 1002 Commit
+#NX&gt; 1006 Session status: running
+
+server_nxnode_start()
+{
+	CMD=&quot;$1&quot;
+	USER=&quot;$2&quot;
+	shift
+	shift
+	# Use nxnode-login?
+	if [ &quot;$LOGIN_METHOD&quot; = &quot;SSH&quot; ]
+	then
+	    echo &quot;$PASS&quot; | $PATH_BIN/nxnode-login -- ssh &quot;$USER&quot; &quot;$SSHD_PORT&quot; &quot;$PATH_BIN/nxnode&quot; &quot;$CMD&quot; &quot;$@&quot; 2&gt;&amp;1 | log_tee
+	elif [ &quot;$LOGIN_METHOD&quot; = &quot;SU&quot; ]
+	then
+	    echo &quot;$PASS&quot; | $PATH_BIN/nxnode-login -- su &quot;$USER&quot; &quot;&quot; &quot;$PATH_BIN/nxnode&quot; &quot;$CMD&quot; &quot;$@&quot; 2&gt;&amp;1 | log_tee
+	elif [ &quot;$LOGIN_METHOD&quot; = &quot;FAKE&quot; ]
+	then
+	    echo &quot;$@&quot; | $PATH_BIN/nxnode &quot;$CMD&quot; 2&gt;&amp;1 | log_tee
+	else 
+	    echo &quot;$@&quot; | ssh -l &quot;$USER&quot; 127.0.0.1 -p $SSHD_PORT -x -2 -i $NX_ETC_DIR/users.id_dsa -o 'PubkeyAuthentication yes' -o 'RSAAuthentication yes' -o 'RhostsAuthentication no' -o 'PasswordAuthentication no' -o 'RhostsRSAAuthentication no' -o 'StrictHostKeyChecking no' $PATH_BIN/nxnode &quot;$CMD&quot; | log_tee
+	fi
+}
+
+server_add_usession()
+{
+	[ &quot;$ENABLE_USESSION&quot; = &quot;1&quot; ] || return
+	
+	$COMMAND_SESSREG -l &quot;:$SESS_DISPLAY&quot; -h &quot;$USERIP&quot; -a $USER 2&gt;/dev/null
+}
+
+server_remove_usession()
+{
+	[ &quot;$ENABLE_USESSION&quot; = &quot;1&quot; ] || return
+	$COMMAND_SESSREG -l &quot;:$SESS_DISPLAY&quot; -h &quot;$USERIP&quot; -d $USER 2&gt;/dev/null
+}
+
+server_nxnode_start_wait()
+{
+	server_add_usession
+	
+	STOP_SEND=&quot;&quot;
+	server_nxnode_start &quot;$@&quot; | while read CMD
+	do
+		case &quot;$CMD&quot; in 
+			&quot;NX&gt; 1006&quot;*|&quot;NX&gt; 1005&quot;*|&quot;NX&gt; 1009&quot;*)
+				case &quot;$CMD&quot; in 
+					*running*)
+						rm -f $WAIT
+						session_status $uniqueid &quot;Running&quot;
+					;;
+					*closed*)
+						session_close $uniqueid
+					;;
+					*suspended*)
+						session_suspend $uniqueid
+					;;
+					*terminating*)
+						session_status $uniqueid &quot;Terminating&quot;
+						# we need to stop sending to client as it will have already
+						# closed his side of the channel and this will lead to not 
+						# closed sessions.
+						STOP_SEND=&quot;1&quot;
+				esac
+			;;
+			&quot;NX&gt; 1004&quot;*)
+				session_fail $uniqueid
+				# FIXME: Need correct error code.
+				echo_x &quot;NX&gt; 504 Session startup failed.&quot;
+			;;
+		esac
+
+		case $CMD in
+			&quot;NX&gt; 718&quot;*)
+				[ -z &quot;$STOP_SEND&quot; ] &amp;&amp; echo $CMD &gt;&amp;2
+				#echo &quot;NX&gt; 1006 Session status: running&quot; 1&gt;&amp;2
+				#echo &quot;NX&gt; 1001 Bye.&quot; 1&gt;&amp;2
+
+			;;
+			&quot;NX&gt; &quot;*)
+				[ -z &quot;$STOP_SEND&quot; ] &amp;&amp; echo $CMD
+			;;
+		esac
+	done
+	
+	server_remove_usession
+
+	# remove lock file
+	[ -e &quot;/tmp/.nX$SESS_DISPLAY-lock&quot; ] &amp;&amp; rm -f /tmp/.nX$SESS_DISPLAY-lock
+}
+
+server_check_session_count()
+{
+	session_count_user &quot;$USER&quot;
+	
+	if [ &quot;$SESSION_COUNT&quot; -ge &quot;$SESSION_LIMIT&quot; ]
+	then
+		echo_x &quot;NX&gt; 599 Reached the maximum number of concurrent sessions on this server.&quot;
+		echo_x &quot;NX&gt; 500 ERROR: Last operation failed.&quot;
+		return 1
+	fi
+	
+	if [ &quot;$SESSION_COUNT_USER&quot; -ge &quot;$SESSION_USER_LIMIT&quot; ]
+	then
+		echo_x &quot;NX&gt; 599 Server capacity: reached for user: $USER&quot;
+		echo_x &quot;NX&gt; 500 ERROR: Last operation failed.&quot;
+		return 1
+	fi
+
+	return 0
+}
+
+server_startrestore_session()
+{
+	ACTION=&quot;$1&quot;
+	
+	server_get_params $CMD
+	PARAMS=$SERVER_PARAMS
+	CMDLINE=$PARAMS
+	echo_x
+	
+	# If we can't get the userip and SSHD_CHECK_IP is set to 1
+	# we bail out.
+	if [ -z &quot;$SSH_CLIENT&quot; ]
+	then 
+		if [ &quot;$SSHD_CHECK_IP&quot; = &quot;1&quot; ]
+		then
+			echo &quot;NX&gt; 504 Session startup failed. (Missing SSH_CLIENT environment variable)&quot;
+			return 1
+		else
+			log &quot;WARNING: Failed to determine the client IP.&quot;
+			log &quot;WARNING: The SSH_CLIENT variable was not provided by SSHD.&quot;
+			log &quot;WARNING: Please set SSHD_CHECK_IP=1 if you want to refuse the connection.&quot;
+		fi
+	fi
+
+	# check if there is a suspended session, which we could resume
+	if [ &quot;$ENABLE_AUTORECONNECT&quot; = &quot;1&quot; -a &quot;$ACTION&quot; = &quot;start&quot; ]
+	then
+		restore=$(session_get_user_suspended &quot;$USER&quot; &quot;Suspended&quot;)
+		if [ -n &quot;$restore&quot; ]
+		then
+			PARAMS=&quot;$PARAMS&amp;restore=$restore&quot;
+			CMDLINE=$PARAMS
+			ACTION=&quot;resume&quot;
+		fi
+	fi
+
+	USERIP=$(echo $SSH_CLIENT | cut -d&quot; &quot; -f1 | sed 's/::<A HREF="ffff://g">ffff://g</A>')
+	[ -z &quot;$USERIP&quot; ] &amp;&amp; USERIP=&quot;*&quot;
+	if [ &quot;$ACTION&quot; = &quot;start&quot; ]
+	then
+		server_check_session_count || return 1
+		
+		# start nxnode
+		SESS_DISPLAY=$DISPLAY_BASE
+		let SESS_DISPLAY_LIMIT=$DISPLAY_BASE+$DISPLAY_LIMIT
+	
+		# stupid but working algo ...
+			
+		# TODO: need to check for _all_ offset and ports :-/
+			
+		while true
+		do
+			while [ -e /tmp/.X$SESS_DISPLAY-lock -o -e &quot;/tmp/.nX$SESS_DISPLAY-lock&quot; ]
+			do
+				let SESS_DISPLAY=$SESS_DISPLAY+1
+			done
+
+			SESS_LOCKFILE=$(mktemp &quot;/tmp/.nX$SESS_DISPLAY-lock.XXXXXXXXX&quot;)
+			# ln is an atomic operation
+			ln &quot;$SESS_LOCKFILE&quot; &quot;/tmp/.nX$SESS_DISPLAY-lock&quot; 2&gt;/dev/null &amp;&amp; break
+		done
+		
+		if [ &quot;$SESS_DISPLAY&quot; -gt &quot;$SESS_DISPLAY_LIMIT&quot; ]
+		then
+			# fixme we need the correct error code
+			echo_x &quot;NX&gt; 504 Error: Display limit exceeded. Please remove some files from /tmp/.X*-lock.&quot;
+			return
+		fi
+
+		rm -f &quot;$SESS_LOCKFILE&quot;
+	
+		uniqueid=$(echo $[$RANDOM*$RANDOM] | md5sum | cut -d&quot; &quot; -f1 | tr &quot;[a-z]&quot; &quot;[A-Z]&quot;)
+		FULL_PARAMS=&quot;user=$USER&amp;userip=$USERIP&amp;uniqueid=$uniqueid&amp;display=$SESS_DISPLAY&amp;$PARAMS&quot;
+		log &quot;$FULL_PARAMS&quot;
+
+		# now update the session listing
+		CMDLINE=&quot;a=b&amp;$FULL_PARAMS&quot;
+		session_add $uniqueid &quot;sessionName=$(getparam session)&amp;display=$(getparam display)&amp;status=Running&amp;startTime=$(date +%s)&amp;foreignAddress=$(getparam userip)&amp;type=$(getparam type)&amp;sessionId=$uniqueid&amp;creationTime=$(date +%s)&amp;userName=$USER&amp;serverPid=$SERVER_PID&amp;screeninfo=$(getparam screeninfo)&amp;geometry=$(getparam geometry)&quot;
+		export ENCRYPTION=$(getparam encryption)
+	else
+		uniqueid=$(getparam restore)
+		[ -z &quot;$uniqueid&quot; ] &amp;&amp; uniqueid=$(getparam id) # 1.4.0-5 compatibility
+		export ENCRYPTION=$(getparam encryption)
+		session_change &quot;$uniqueid&quot; &quot;foreignAddress&quot; &quot;$USERIP&quot;
+
+		CMDLINE=$(session_get &quot;$uniqueid&quot;)
+		FULL_PARAMS=&quot;user=$USER&amp;userip=$(getparam foreignAddress)&amp;uniqueid=$uniqueid&amp;display=$(getparam display)$PARAMS&quot;
+		SESS_DISPLAY=$(getparam display)
+	fi
+
+	# now start the node
+	export WAIT=$(mktemp /tmp/nxserver_wait.XXXXXXXXX)
+	touch $WAIT
+	(sleep 10; rm -f $WAIT) &amp;
+	server_nxnode_start_wait --&quot;$ACTION&quot;session $USER &quot;$FULL_PARAMS&quot; &amp;
+	SERVER_PID=$!
+	disown $SERVER_PID
+	while [ -f &quot;$WAIT&quot; ]
+	do
+		sleep 1
+	done
+}
+
+# Session stage
+while true
+do
+	echo_x -n &quot;NX&gt; 105 &quot;
+	unset CMD
+	read CMD 2&gt;/dev/null
+	# FIXME?
+	[ &quot;$CMD&quot; = &quot;&quot; ] &amp;&amp; CMD=&quot;quit&quot;
+	echo_x &quot;$CMD&quot;
+	case &quot;$CMD&quot; in 
+		quit|QUIT)
+			echo_x &quot;Quit&quot;
+			echo_x &quot;NX&gt; 999 Bye&quot;
+			exit 0
+		;;
+		exit|EXIT)
+			echo_x &quot;Exit&quot;
+			echo_x &quot;NX&gt; 999 Bye&quot;
+			exit 0
+		;;
+		bye|BYE)
+			echo_x &quot;Bye&quot;
+			echo_x &quot;NX&gt; 999 Bye&quot;
+			if [ &quot;$ENCRYPTION&quot; = &quot;1&quot; ] 
+			then 
+				let PROXY_DISPLAY=$SESS_DISPLAY+4000
+				$COMMAND_NETCAT 127.0.0.1 $PROXY_DISPLAY
+				exit 0
+			else
+				echo_x &quot;NX&gt; 1001 Bye.&quot;
+			fi
+		;;
+		startsession*)
+			server_startrestore_session &quot;start&quot;
+		;;
+		list*)
+			server_get_params $CMD
+			PARAMS=$SERVER_PARAMS
+			CMDLINE=$PARAMS
+			
+			# FIXME: To NX-Node!
+
+			status=$(getparam status)
+
+			if [ &quot;$status&quot; = &quot;Suspended&quot; ]
+			then
+				session_list_user_suspended &quot;$USER&quot; &quot;Suspended&quot; &quot;$(getparam screeninfo)&quot; &quot;$(getparam type)&quot; | log_tee
+			elif [ &quot;$status&quot; = &quot;Suspended,Running&quot; ] # since 1.4.0-5
+			then
+				# disabled due to problems with 1.4.0-5 client
+				session_list_user_suspended &quot;$USER&quot; 'Suspended$|^status=Running$' &quot;$(getparam geometry)&quot; &quot;$(getparam type)&quot; | log_tee
+				#session_list_user_suspended &quot;$USER&quot; 'Suspended' &quot;$(getparam geometry)&quot; &quot;$(getparam type)&quot; | log_tee
+			else
+				session_list_user &quot;$USER&quot; | log_tee
+			fi
+		;;
+		suspend*)
+			server_get_params $CMD
+			PARAMS=$SERVER_PARAMS
+			CMDLINE=$PARAMS
+			if session_find_id_user &quot;$(getparam sessionid)&quot; &quot;$USER&quot;
+			then
+				# FIXME: Check for success/error
+				server_nxnode_start --suspend &quot;$USER&quot; &quot;$PARAMS&quot;
+				session_suspend $(getparam sessionid)
+			fi
+		;;
+		terminate*)
+			server_get_params $CMD
+			PARAMS=$SERVER_PARAMS
+			CMDLINE=$PARAMS
+			if session_find_id_user &quot;$(getparam sessionid)&quot; &quot;$USER&quot;
+			then
+				# FIXME: Check for success/error
+				server_nxnode_start --terminate &quot;$USER&quot; &quot;$PARAMS&quot;
+				session_close $(getparam sessionid)
+			fi
+		;;
+		restoresession*)
+			server_startrestore_session &quot;resume&quot;
+		;;
+		passwd)
+			echo &quot;NX&gt; 113 Changing password of user '$USER'&quot;
+			echo -n &quot;NX&gt; 102 Current password:&quot;
+			read -s PASS
+			ENC_PASS=$(passdb_get_crypt_pass &quot;$PASS&quot;)
+			REAL_PASS=$(passdb_get_pass &quot;$USER&quot;)
+			echo_x
+			if [ &quot;$ENC_PASS&quot; = &quot;$REAL_PASS&quot; ]
+			then
+				echo_x -n &quot;NX&gt; 102 Password:&quot;
+				read -s NEW_PASS1
+				
+				if [ ${#NEW_PASS1} -lt 5 ]
+				then
+					echo_x &quot;NX&gt; 500 ERROR: incorrect password format, password must be long at least five characters&quot;
+					continue
+				fi
+
+				echo_x
+				echo_x -n &quot;NX&gt; 102 Confirm password:&quot;
+				read -s NEW_PASS1
+				echo_x
+				if [ &quot;$NEW_PASS1&quot; = &quot;$NEW_PASS2&quot; ]
+				then
+					ENC_PASS=$(passdb_get_crypt_pass &quot;$NEW_PASS1&quot;)
+					passdb_chpass &quot;$USER&quot; &quot;$ENC_PASS&quot;
+					echo_x &quot;NX&gt; 114 Password of user '$USER' changed&quot;
+				else
+					echo_x &quot;NX&gt; 537 ERROR: passwords do not match&quot;
+				fi
+			else
+				echo_x &quot;NX&gt; 500 ERROR: current password doesn't match&quot;
+			fi
+		;;
+		addmount*)
+			server_get_params $CMD
+			PARAMS=$SERVER_PARAMS
+			server_nxnode_start --smbmount &quot;$USER&quot; &quot;$PARAMS&quot; &gt;/dev/null 2&gt;&amp;1
+			echo_x &quot;NX&gt; 719 SMB filesystem: running&quot;
+		;;
+		addprintercups*)
+			server_get_params $CMD
+			PARAMS=$SERVER_PARAMS
+			server_nxnode_start --addprintercups &quot;$USER&quot; &quot;$PARAMS&quot; &gt;/dev/null 2&gt;&amp;1
+		;;
+		*)
+			# disabled for 1.4.0-5 snapshot client
+			#echo_x &quot;NX&gt; 503 Error: undefined command: '$CMD'&quot;
+		;;
+	esac
+done
+
+fi
+
+#
+# End of Main nxserver &lt;--&gt; nxclient communication module
+#
+
+################### PACKAGE cmd.bm ############################
+
+#
+# library functions for nxserver-commandline cmds
+#
+
+# Policy: All functions and variables need to start with CMD_ / cmd_
+
+# Needed global vars: $NX_VERSION, $NX_LICENSE, $NX_ETC_DIR, $PATH_BIN, $NX_HOME_DIR, $SSH_AUTHORIZED_KEYS
+
+# Needed package: passdb
+
+cmd_usage()
+{
+	echo &quot;NXSERVER - Version $NX_VERSION $NX_LICENSE&quot;
+	echo &quot;Usage: nxserver &lt;option&gt;&quot; 1&gt;&amp;2
+
+	if [ &quot;$1&quot; = &quot;root&quot; ]
+	then
+		echo &quot;--adduser &lt;user&gt;: Add a new user&quot; 1&gt;&amp;2
+		echo &quot;--passwd &lt;user&gt;: Change password of &lt;user&gt;&quot; 1&gt;&amp;2
+		echo &quot;--deluser &lt;user&gt;: Remove a user from nx&quot; 1&gt;&amp;2
+		echo &quot;--listuser: List enabled users&quot; 1&gt;&amp;2
+		echo &quot;&quot; 1&gt;&amp;2
+		echo &quot;--start: Start the nx server&quot; 1&gt;&amp;2
+		echo &quot;--stop: Stop the nx server&quot; 1&gt;&amp;2
+		echo &quot;--status: Show status of nx server&quot; 1&gt;&amp;2
+		echo &quot;--restart: Restart the nx server and terminate all running sessions&quot; 1&gt;&amp;2
+		echo &quot;&quot; 1&gt;&amp;2
+		echo &quot;--list [ user | sessionid ]: List running sessions of user or sessionid &quot; 1&gt;&amp;2
+		echo &quot;--history [ user | sessionid | clear ]: Show history [ of user | sessionid ] or clear the history&quot; 1&gt;&amp;2
+		echo &quot;--terminate &lt;user | :display | sessionid&gt;: Terminate the session pointed to by&quot; 1&gt;&amp;2
+		echo &quot;       sessionid or display, or all sessions of the specified user.&quot; 1&gt;&amp;2
+		echo &quot;--suspend &lt;user | :display | sessionid&gt;: Suspend the session pointed to by&quot; 1&gt;&amp;2
+		echo &quot;       sessionid or display, or all sessions of the specified user.&quot; 1&gt;&amp;2
+		echo &quot;&quot; 1&gt;&amp;2
+		echo &quot;--broadcast &lt;message&gt;: Send a message to all users&quot; 1&gt;&amp;2
+		echo &quot;--send &lt;user | :display | sessionid&gt; &lt;message&gt;: Send a message to the specified user or sessionid&quot; 1&gt;&amp;2
+	else
+		echo &quot;--passwd: Change password&quot; 1&gt;&amp;2
+	fi
+	exit 1
+}
+
+
+cmd_abort()
+{
+	echo &quot;NX&gt; 500&quot; &quot;$@&quot; 1&gt;&amp;2
+	echo &quot;NX&gt; 999 Bye&quot; 1&gt;&amp;2
+	exit 1
+}
+
+cmd_user_passwd()
+{
+	echo &quot;NX&gt; 100 NXSERVER - Version $NX_VERSION $NX_LICENSE&quot;
+	echo &quot;Sorry: Password changing for user is _not_ implemented, yet.&quot;
+	echo &quot;Please login to NX-Server to change password&quot;
+	echo &quot;or ask your local system administrator.&quot;
+	#echo &quot;NX&gt; 113 Changing password of user '$USER'&quot;
+	#echo &quot;Old password:&quot;
+	#read -s OLDPASS
+	#echo &quot;New password:&quot;
+	#read -s NEWPASS1
+	#echo &quot;Repeat:&quot;
+	#read -s NEWPASS2
+
+}
+
+cmd_passwd()
+{
+	CMD_CHUSER=$2
+	egrep -q &quot;^$CMD_CHUSER:&quot; $NX_ETC_DIR/passwords || cmd_abort &quot;Error: User $CMD_CHUSER not found in database.&quot;
+	echo -n &quot;New password: &quot;
+	read -s CMD_NEWPASS
+	echo
+	CMD_ENC_PASS=$(passdb_get_crypt_pass &quot;$CMD_NEWPASS&quot;)
+	passdb_chpass &quot;$CMD_CHUSER&quot; &quot;$CMD_ENC_PASS&quot;
+	echo &quot;Password changed.&quot;
+}
+
+cmd_adduser()
+{
+	CMD_CHUSER=$2
+	
+	[ ${#CMD_CHUSER} -ge 32 ] &amp;&amp; cmd_abort &quot;Error: User $CMD_CHUSER must be shorter than 32 characters.&quot;
+	egrep -q &quot;^$CMD_CHUSER:&quot; $NX_ETC_DIR/passwords &amp;&amp; cmd_abort &quot;Error: User $CMD_CHUSER already in database.&quot;
+	getent passwd | egrep -q &quot;^$CMD_CHUSER:&quot; || cmd_abort &quot;Error: User $CMD_CHUSER not existing on local system. Can't add.&quot;
+	passdb_add_user &quot;$CMD_CHUSER&quot;
+}
+
+cmd_deluser()
+{
+	CMD_CHUSER=$2
+	egrep -q &quot;^$CMD_CHUSER:&quot; $NX_ETC_DIR/passwords || cmd_abort &quot;Error: User $CMD_CHUSER not found in database.&quot;
+	passdb_remove_user &quot;$CMD_CHUSER&quot;
+}
+
+cmd_listuser()
+{
+	echo &quot;NX&gt; 146 NX users list&quot;
+	echo
+	echo &quot;Username&quot;
+	echo &quot;---------------&quot;
+	echo
+	passdb_list_user
+	echo
+}
+
+cmd_start()
+{
+	
+	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] &amp;&amp; cmd_abort &quot;ERROR: Service already running&quot;
+	mv $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS.disabled $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS
+	echo &quot;NX&gt; 122 Service started&quot;
+}
+
+cmd_stop()
+{
+	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] || cmd_abort &quot;Service was already stopped&quot;
+	mv $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS.disabled
+	# TODO: Stop all running sessions
+	echo &quot;NX&gt; 123 Service stopped&quot;
+}
+
+cmd_status()
+{
+	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] &amp;&amp; echo &quot;NX&gt; 110 NX Server is running&quot;
+	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] || echo &quot;NX&gt; 110 NX Server is stopped&quot;
+}
+
+cmd_restart()
+{
+	cmd_stop
+	cmd_start
+}
+
+cmd_parse_2_params()
+{
+	if [ ${#1} -eq 32 ]
+	then
+		CMD_APARAMS=&quot;sessionid=sessionId{$1}&quot;
+	else
+	if [ &quot;$1&quot; != &quot;&quot; ]
+	then
+		#egrep -q &quot;^$1:&quot; $NX_ETC_DIR/passwords || cmd_abort &quot;Error: User $1 not found in database.&quot;
+		CMD_APARAMS=&quot;user=$1&quot;
+	fi
+	fi
+	echo $CMD_APARAMS
+
+}
+
+cmd_parse_3_params()
+{
+	if [ ${#1} -eq 32 ]
+	then
+		CMD_APARAMS=$(session_find_id $1)
+		[ -n &quot;$CMD_APARAMS&quot; ] || cmd_abort &quot;Error: Session $1 could not be found.&quot;
+	else
+	if [ &quot;${1:0:1}&quot; = &quot;:&quot; ]
+	then
+		CMD_APARAMS=$(session_find_display &quot;${1:1}&quot;)
+		[ -n &quot;$CMD_APARAMS&quot; ] || cmd_abort &quot;Error: No running sessions found for display $1.&quot;
+	else
+	if [ &quot;$1&quot; != &quot;&quot; ]
+	then
+		#egrep -q &quot;^$1:&quot; $NX_ETC_DIR/passwords || cmd_abort &quot;Error: User $1 not found in database.&quot;
+		CMD_APARAMS=$(session_find_user &quot;$1&quot;)
+		[ -n &quot;$CMD_APARAMS&quot; ] || cmd_abort &quot;Error: No running sessions found for user $1.&quot;
+	else
+		cmd_abort &quot;Error: Not enough parameters.&quot;
+	fi
+	fi
+	fi
+	echo $CMD_APARAMS
+}
+
+cmd_list_suspended()
+{
+	CMD_PARAMS=$(cmd_parse_2_params &quot;$2&quot;)
+	[ -n &quot;$2&quot; -a -z &quot;$CMD_PARAMS&quot; ] &amp;&amp; exit 1
+	case $CMD_PARAMS in
+		user=*)
+			session_list_user_suspended $2 &quot;Suspended&quot;
+		;;
+	esac
+}
+cmd_list()
+{
+	CMD_PARAMS=$(cmd_parse_2_params &quot;$2&quot;)
+	[ -n &quot;$2&quot; -a -z &quot;$CMD_PARAMS&quot; ] &amp;&amp; exit 1
+	case $CMD_PARAMS in
+		user=*)
+			session_list_user $2
+		;;
+		sessionid=*)
+			session_list $2
+		;;
+		*)
+			session_list_all
+		;;
+	esac
+}
+
+cmd_history_clear()
+{
+	rm -f $NX_SESS_DIR/closed/*
+	rm -f $NX_SESS_DIR/failed/*
+}
+
+cmd_history()
+{
+	if [ &quot;$2&quot; = &quot;clear&quot; ]
+	then
+		cmd_history_clear
+	fi
+	
+	CMD_PARAMS=$(cmd_parse_2_params &quot;$2&quot;)
+	user=&quot;&quot;
+	sessid=&quot;&quot;
+	case $CMD_PARAMS in
+		user=*)
+			user=&quot;$2&quot;
+		;;
+		sessionid=*)
+			sessid=&quot;$2&quot;
+		;;
+	esac
+
+	session_history &quot;$user&quot; &quot;$sessid&quot;
+}
+
+cmd_terminate()
+{
+	CMD_PARAMS=$(cmd_parse_3_params &quot;$2&quot;)
+	[ -z &quot;$CMD_PARAMS&quot; ] &amp;&amp; exit 1
+	for i in $CMD_PARAMS;
+	do
+			CMDLINE=$(session_get_cmdline $i)
+			cmd_sessionid=$(getparam sessionId)
+			cmd_user=$(getparam userName)
+			cmd_type=$(getparam type)
+			cmd_status=$(getparam status)
+
+			# is it a &quot;good&quot; session?
+			case &quot;$1&quot; in 
+			--suspend)
+				if [ &quot;$cmd_status&quot; = &quot;Running&quot; ] &amp;&amp; stringinstring &quot;unix-&quot; &quot;$cmd_type&quot;
+				then
+					echo &quot;sessionid=$cmd_sessionid&quot; | su - &quot;$cmd_user&quot; -c &quot;$PATH_BIN/nxnode --suspend&quot;
+					session_suspend $cmd_sessionid
+				fi
+				;;
+			--terminate)
+			#if stringinstring &quot;unix-&quot; &quot;$cmd_type&quot;
+			#	then
+					echo &quot;sessionid=$cmd_sessionid&quot; | su - &quot;$cmd_user&quot; -c &quot;$PATH_BIN/nxnode --terminate&quot;
+					session_close $cmd_sessionid
+			#	fi
+
+			;;
+			esac
+	done
+
+}
+
+cmd_send()
+{
+	if [ &quot;$1&quot; = &quot;--broadcast&quot; ]
+	then
+	  CMD_PARAMS=$(session_find_all)
+	  [ -z &quot;$CMD_PARAMS&quot; ] &amp;&amp; cmd_abort &quot;Error: No running session could be found.&quot;
+	else
+	  CMD_PARAMS=$(cmd_parse_3_params &quot;$2&quot;)
+	  [ -z &quot;$CMD_PARAMS&quot; ] &amp;&amp; exit 1
+	fi
+	shift
+	shift
+	for i in $CMD_PARAMS;
+	do
+			CMDLINE=$(session_get_cmdline $i)
+			cmd_display=$(getparam display)
+			cmd_user=$(getparam userName)
+			cmd_type=$(getparam type)
+			cmd_status=$(getparam status)
+
+			# is it a &quot;good&quot; session?
+			if [ &quot;$cmd_status&quot; = &quot;Running&quot; ] &amp;&amp; stringinstring &quot;unix-&quot; &quot;$cmd_type&quot;
+			then
+				su - &quot;$cmd_user&quot; -c &quot;$PATH_BIN/nxclient --dialog ok --caption \&quot;NX Administrator Message\&quot; --message \&quot;$@\&quot; --noautokill 
+-display \&quot;:$cmd_display\&quot;&quot; &amp;
+				disown $!
+			fi
+	done
+	#nxnode_start --send &quot;$CMD_PARAMS&quot;
+}
+
+#
+# user mode available functions
+#
+
+if [ $UID -ne 0 ]
+then
+	[ &quot;$1&quot; != &quot;--passwd&quot; ] &amp;&amp; cmd_usage
+	cmd_user_passwd
+	exit 0
+fi
+
+#
+# root mode available functions
+#
+
+[ $# -lt 1 ] &amp;&amp; cmd_usage &quot;root&quot;
+[ &quot;$1&quot; = &quot;--help&quot; ] &amp;&amp; cmd_usage &quot;root&quot;
+
+if [ &quot;$1&quot; = &quot;--version&quot; ]
+then
+  echo &quot;NXSERVER - Version $NX_VERSION $NX_LICENSE&quot;
+  exit 0
+fi
+
+CMD=$1
+
+echo &quot;NX&gt; 100 NXSERVER - Version $NX_VERSION $NX_LICENSE&quot;
+
+case $CMD in
+	# 
+	# User functions ...
+	# 
+	--passwd)
+		cmd_passwd &quot;$@&quot;
+	;;
+	--adduser|--useradd)
+		cmd_adduser &quot;$@&quot;
+	;;
+	--deluser|--userdel)
+		cmd_deluser &quot;$@&quot;
+	;;
+	--listuser|--userlist)
+		cmd_listuser
+	;;
+	--start)
+		cmd_start
+	;;
+	--stop)
+		cmd_stop
+	;;
+	--status)
+		cmd_status
+	;;
+	--restart)
+		cmd_restart
+	;;
+	--list)
+		cmd_list &quot;$@&quot;
+	;;
+	--list-suspended)
+		cmd_list_suspended &quot;$@&quot;
+	;;
+	--history)
+		cmd_history &quot;$@&quot;
+	;;
+	--terminate|--suspend)
+		cmd_terminate &quot;$@&quot;
+	;;
+	--send|--broadcast)
+		cmd_send &quot;$@&quot;
+	;;
+	*)
+		cmd_abort &quot;Error: Function $CMD not implemented yet.&quot;
+esac
+echo &quot;NX&gt; 999 Bye&quot;


Property changes on: freenx-server/nxserver.old
___________________________________________________________________
Name: svn:executable
   + 

Added: freenx-server/nxsetup
===================================================================
--- freenx-server/nxsetup	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/nxsetup	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,349 @@
+#!/bin/bash
+
+# Coypright (c) 2004-2005 by Fabian Franz &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">freenx at fabian-franz.de</A>&gt;.
+#                    2005 by Jon Severinsson &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">jonno at users.berlios.de</A>&gt;.
+#
+# License: GNU GPL, version 2
+#
+# CVS: $Id: nxsetup,v 1.28 2005/05/05 08:04:24 jonno Exp $ 
+#
+
+HELP=&quot;no&quot;
+INSTALL=&quot;no&quot;
+SETUP_NOMACHINE_KEY=&quot;no&quot;
+SETUP_UID=&quot;&quot;
+CLEAN=&quot;no&quot;
+UNINSTALL=&quot;no&quot;
+PURGE=&quot;no&quot;
+SETUP_SSH2_KEY=&quot;no&quot;
+BUILD_KNOWN_HOSTS=&quot;yes&quot;
+
+while [ &quot;$1&quot; ]
+do
+	case &quot;$1&quot; in
+		--help) HELP=&quot;yes&quot;; shift ;;
+		--install) INSTALL=&quot;yes&quot;; shift ;;
+		--setup-nomachine-key) SETUP_NOMACHINE_KEY=&quot;yes&quot;; shift ;;
+		--ssh2) SETUP_SSH2_KEY=&quot;yes&quot;; shift;;
+		--dont-build-known-hosts) BUILD_KNOWN_HOSTS=&quot;no&quot;; shift;;
+		--uid) SETUP_UID=$2; shift 2 ;;
+		--clean) CLEAN=&quot;yes&quot;; shift ;;
+		--uninstall) UNINSTALL=&quot;yes&quot;; shift ;;
+		--purge) PURGE=&quot;yes&quot;; shift ;;
+		--) shift ; break ;;
+		*) echo &quot;Invalid flag $1&quot; ; HELP=&quot;yes&quot;; shift ; break ;;
+	esac
+done
+
+#Check for invalid combinations:
+[ &quot;$INSTALL&quot; = &quot;yes&quot; -a &quot;$UNINSTALL&quot; = &quot;yes&quot; ] &amp;&amp; HELP=&quot;yes&quot;
+[ &quot;$INSTALL&quot; = &quot;no&quot; -a &quot;$UNINSTALL&quot; = &quot;no&quot; ] &amp;&amp; HELP=&quot;yes&quot;
+[ &quot;$INSTALL&quot; = &quot;yes&quot; -a &quot;$CLEAN&quot; = &quot;no&quot; -a &quot;$PURGE&quot; = &quot;yes&quot; ] &amp;&amp; HELP=&quot;yes&quot;
+[ &quot;$UNINSTALL&quot; = &quot;yes&quot; ] &amp;&amp; [ &quot;$SETUP_NOMACHINE_KEY&quot; = &quot;yes&quot; -o -n &quot;$SETUP_UID&quot; -o &quot;$CLEAN&quot; = &quot;yes&quot; ] &amp;&amp; HELP=&quot;yes&quot;
+[ &quot;$UNINSTALL&quot; = &quot;yes&quot; -a &quot;$CLEAN&quot; = &quot;yes&quot; ] &amp;&amp; HELP=&quot;yes&quot;
+[ &quot;$SETUP_SSH2_KEY&quot; = &quot;yes&quot; -a &quot;$SETUP_NOMACHINE_KEY&quot; = &quot;no&quot; ] &amp;&amp; HELP=&quot;yes&quot;
+
+if [ &quot;$HELP&quot; = &quot;yes&quot; ]
+then
+	echo &quot;nxsetup - Setup the FreeNX server.&quot;
+	echo &quot;Syntax: nxsetup --help&quot;
+	echo &quot;        nxsetup --install [--setup-nomachine-key] [--uid &lt;nummber&gt;] [--clean [--purge]]&quot;
+	echo &quot;        nxsetup --uninstall [--purge]&quot;
+	echo
+	echo &quot;  --help                 Displays this help message&quot;
+	echo &quot;  --install              Install nessesary files and add the nx user&quot;
+	echo &quot;  --setup-nomachine-key  Allow login with the key shipped with the NoMachine&quot;
+	echo &quot;                         client. This is not as secure, but it simplifies the &quot;
+	echo &quot;                         configuration of clients.&quot;
+	echo &quot;                         Use this option at your own risk.&quot;
+	echo &quot;  --ssh2		       Additionally create commercial pubkey-support, beware&quot;
+	echo &quot;			       own _commercial_ ssh2-key is not supported!.&quot;
+	echo &quot;  --uid &lt;number&gt;         The nx user will be given the uid &lt;number&gt;.&quot;
+	echo &quot;  --clean                Performs an uninstall prior to the installation&quot;
+	echo &quot;  --uninstall            Remove log and session files, as well as the nx user&quot;
+	echo &quot;  --purge                Uninstall will remove extra configuration files and ssh&quot;
+	echo &quot;                         keys as well. Note that node.conf will always be saved.&quot;
+	exit 0
+fi
+#Undocumented
+#
+#    --dont-build-known-hosts		For system without /etc/ssh/ssh_host_key.rsa.pub and anyway
+#					expect should handle nx-users known-hosts keys so why borther
+#					in nxsetup?
+
+if [ $UID -ne 0 ]
+then
+	echo &quot;You need to be root to use this program.&quot; 
+	exit 1
+fi
+
+# Read the config file
+. $(PATH=$(cd $(dirname $0) &amp;&amp; pwd):$PATH which nxloadconfig) --
+
+# Tries to add a system user
+useradd_nx()
+{
+	# In any case create the basedir of the HOME directory before, 
+	# because useradd will fail to make more than one directory
+	mkdir -p $(dirname &quot;$NX_HOME_DIR&quot;)
+	
+	# Are uid specified
+	if [ -n &quot;$SETUP_UID&quot; ]
+	then
+		useradd -u $SETUP_UID -d $NX_HOME_DIR -s $PATH_BIN/nxserver nx
+	# Is it a debian?
+	elif [ -f /etc/debian_version ]
+	then
+		adduser --system --home $NX_HOME_DIR --shell $PATH_BIN/nxserver nx
+	# or is it a SuSE?
+	elif [ -f /etc/SuSE-release ]
+	then
+		useradd -r -d $NX_HOME_DIR -s $PATH_BIN/nxserver nx
+	# we don't know the system, fallback
+	else
+		useradd -d $NX_HOME_DIR -s $PATH_BIN/nxserver nx
+	fi
+}
+
+install_nx()
+{
+	set -e
+	
+	if [ &quot;$(pidof sshd)&quot; = &quot;&quot; ]
+	then 
+		echo -n &quot;Starting ssh service ...&quot;
+		# Generate Host keys if they are not available, yet
+		[ -e /etc/ssh/ssh_host_rsa_key ] || $COMMAND_SSH_KEYGEN -q -t rsa -f /etc/ssh/ssh_host_rsa_key -C '' -N ''
+		[ -e /etc/ssh/ssh_host_dsa_key ] || $COMMAND_SSH_KEYGEN -q -t dsa -f /etc/ssh/ssh_host_dsa_key -C '' -N ''
+		[ -x /etc/init.d/sshd ] &amp;&amp; /etc/init.d/sshd start
+		[ -x /etc/init.d/ssh ] &amp;&amp; /etc/init.d/ssh start
+		echo &quot;done&quot;
+	fi
+	
+	echo -n &quot;Setting up $NX_ETC_DIR ...&quot;
+	mkdir -p $NX_ETC_DIR
+	touch $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
+	chmod 600 $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
+	echo &quot;done&quot;
+	
+	if [ ! -f $NX_ETC_DIR/users.id_dsa ]
+	then
+		$COMMAND_SSH_KEYGEN -f $NX_ETC_DIR/users.id_dsa -t dsa -N &quot;&quot;
+	fi
+	
+	echo -n &quot;Setting up $NX_SESS_DIR ...&quot;
+	mkdir -p $NX_SESS_DIR/closed $NX_SESS_DIR/running $NX_SESS_DIR/failed
+	chmod 700 $NX_SESS_DIR/*
+	echo &quot;done&quot;
+	
+	echo -n &quot;Setting up $NX_LOGFILE ...&quot;
+	mkdir -p $(dirname &quot;$NX_LOGFILE&quot;)
+	touch &quot;$NX_LOGFILE&quot;
+	chmod 600 &quot;$NX_LOGFILE&quot;
+	echo &quot;done&quot;
+	
+	if ! { getent passwd | egrep -q &quot;^nx:&quot;; }
+	then
+		echo -n &quot;Setting up user nx ...&quot;
+		useradd_nx
+		echo &quot;done&quot;
+	fi
+	
+	if [ &quot;$ENABLE_NOMACHINE_FORWARD&quot; = &quot;1&quot; -a -x &quot;$NOMACHINE_SERVER&quot; ]
+	then
+		echo -n &quot;Setting up NoMachine forwarding ...&quot;
+		usermod -s &quot;$PATH_BIN/nxserver&quot; -d &quot;$NOMACHINE_NX_HOME_DIR&quot; nx
+		echo &quot;done&quot;
+	fi
+	
+	echo -n &quot;Setting up known_hosts and $SSH_AUTHORIZED_KEYS ...&quot;
+	
+	SETUP_NX_KEY=&quot;no&quot;
+	
+	mkdir -p $NX_HOME_DIR/.ssh
+	chmod 700 $NX_HOME_DIR/ $NX_HOME_DIR/.ssh
+	
+	if [ ! -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ]
+	then
+		SETUP_NX_KEY=&quot;yes&quot;
+		if [ &quot;$SETUP_NOMACHINE_KEY&quot; = &quot;yes&quot; ]
+		then
+			cat &lt;&lt; EOF &gt;$NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS
+no-port-forwarding,no-X11-forwarding,no-agent-forwarding,command=&quot;$PATH_BIN/nxserver&quot; ssh-dss AAAAB3NzaC1kc3MAAACBAJe/0DNBePG9dYLWq7cJ0SqyRf1iiZN/IbzrmBvgPTZnBa5FT/0Lcj39sRYt1paAlhchwUmwwIiSZaON5JnJOZ6jKkjWIuJ9MdTGfdvtY1aLwDMpxUVoGwEaKWOyin02IPWYSkDQb6cceuG9NfPulS9iuytdx0zIzqvGqfvudtufAAAAFQCwosRXR2QA8OSgFWSO6+kGrRJKiwAAAIEAjgvVNAYWSrnFD+cghyJbyx60AAjKtxZ0r/Pn9k94Qt2rvQoMnGgt/zU0v/y4hzg+g3JNEmO1PdHh/wDPVOxlZ6Hb5F4IQnENaAZ9uTZiFGqhBO1c8Wwjiq/MFZy3jZaidarLJvVs8EeT4mZcWxwm7nIVD4lRU2wQ2lj4aTPcepMAAACANlgcCuA4wrC+3Cic9CFkqiwO/Rn1vk8dvGuEQqFJ6f6LVfPfRTfaQU7TGVLk2CzY4dasrwxJ1f6FsT8DHTNGnxELPKRuLstGrFY/PR7KeafeFZDf+fJ3mbX5nxrld3wi5titTnX+8s4IKv29HJguPvOK/SI7cjzA+SqNfD7qEo8= <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">root at nettuno</A>
+EOF
+			chmod 600 $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS
+		else
+			# generate a new key, backup the old and copy it to $SSH_AUTHORIZED_KEYS
+			$PATH_BIN/nxkeygen
+		fi
+	fi
+
+	# commercial ssh2-server uses other authentification-files
+	# as they are more or less static, I don't integrated these variable
+	# in node.conf, you have to change them here, if you like
+	SSH2_AUTHORIZATION=&quot;authorization&quot;
+	SSH2_PUBKEY=&quot;nx_user.id.pub&quot;
+	SSH2_HOME_DIR=&quot;$NX_HOME_DIR/.ssh2&quot;
+	if [ ! -f &quot;${SSH2_HOME_DIR}/$SSH2_PUBKEY&quot; -a &quot;$SETUP_SSH2_KEY&quot; = &quot;yes&quot; -a &quot;$SETUP_NOMACHINE_KEY&quot; = &quot;yes&quot; ]
+	then
+		mkdir -p $SSH2_HOME_DIR
+		chmod 700 $SSH2_HOME_DIR
+		
+		cat &gt;  ${SSH2_HOME_DIR}/$SSH2_PUBKEY &lt;&lt;EOF
+---- BEGIN SSH2 PUBLIC KEY ----
+Comment: &quot;1024-bit DSA, converted from OpenSSH by <A HREF="https://lists.berlios.de/mailman/listinfo/freenx-cvs">root at localhost</A>&quot;
+AAAAB3NzaC1kc3MAAACBAJe/0DNBePG9dYLWq7cJ0SqyRf1iiZN/IbzrmBvgPTZnBa5FT/
+0Lcj39sRYt1paAlhchwUmwwIiSZaON5JnJOZ6jKkjWIuJ9MdTGfdvtY1aLwDMpxUVoGwEa
+KWOyin02IPWYSkDQb6cceuG9NfPulS9iuytdx0zIzqvGqfvudtufAAAAFQCwosRXR2QA8O
+SgFWSO6+kGrRJKiwAAAIEAjgvVNAYWSrnFD+cghyJbyx60AAjKtxZ0r/Pn9k94Qt2rvQoM
+nGgt/zU0v/y4hzg+g3JNEmO1PdHh/wDPVOxlZ6Hb5F4IQnENaAZ9uTZiFGqhBO1c8Wwjiq
+/MFZy3jZaidarLJvVs8EeT4mZcWxwm7nIVD4lRU2wQ2lj4aTPcepMAAACANlgcCuA4wrC+
+3Cic9CFkqiwO/Rn1vk8dvGuEQqFJ6f6LVfPfRTfaQU7TGVLk2CzY4dasrwxJ1f6FsT8DHT
+NGnxELPKRuLstGrFY/PR7KeafeFZDf+fJ3mbX5nxrld3wi5titTnX+8s4IKv29HJguPvOK
+/SI7cjzA+SqNfD7qEo8=
+---- END SSH2 PUBLIC KEY ----
+EOF
+		echo &quot;Key $SSH2_PUBKEY&quot; &gt;&gt; ${SSH2_HOME_DIR}/$SSH2_AUTHORIZATION
+		echo &quot;Options no-port-forwarding,no-x11-forwarding,no-agent-forwarding,command=\&quot;$PATH_BIN/nxserver\&quot;&quot; &gt;&gt; ${SSH2_HOME_DIR}/$SSH2_AUTHORIZATION
+		chmod 600 ${SSH2_HOME_DIR}/$SSH2_AUTHORIZATION ${SSH2_HOME_DIR}/$SSH2_PUBKEY
+	fi
+	
+	if [ ! -f $NX_HOME_DIR/.ssh/known_hosts -a &quot;$BUILD_KNOWN_HOSTS&quot; = &quot;yes&quot; ]
+	then
+		echo -n &quot;127.0.0.1 &quot; &gt; $NX_HOME_DIR/.ssh/known_hosts
+		cat /etc/ssh/ssh_host_rsa_key.pub &gt;&gt; $NX_HOME_DIR/.ssh/known_hosts
+	fi
+	
+	echo &quot;done&quot;
+	
+	echo -n &quot;Setting up permissions ...&quot;
+	chown -R nx:root $NX_SESS_DIR
+	chown -R nx:root $NX_ETC_DIR
+	chown -R nx:root $NX_HOME_DIR
+	chown nx:root &quot;$NX_LOGFILE&quot;
+	echo &quot;done&quot;
+}
+
+uninstall_nx() 
+{
+	if { getent passwd | egrep -q &quot;^nx:&quot;; }
+	then
+		echo -n &quot;Removing user nx ...&quot;
+		userdel nx
+		echo &quot;done&quot;
+	fi
+	
+	if [ -e &quot;$NX_SESS_DIR&quot; ]
+	then
+		echo -n &quot;Removing session database ...&quot;
+		rm -f -r $NX_SESS_DIR/closed $NX_SESS_DIR/running $NX_SESS_DIR/failed 2&gt;/dev/null
+		rmdir -p $NX_SESS_DIR 2&gt;/dev/null
+		echo &quot;done&quot;
+	fi
+	
+	if [ -e &quot;$NX_LOGFILE&quot; ] 
+	then
+		echo -n &quot;Removing logfile ...&quot;
+		rm -f &quot;$NX_LOGFILE&quot; 2&gt;/dev/null
+		rmdir -p $(dirname &quot;$NX_LOGFILE&quot;) 2&gt;/dev/null
+		echo &quot;done&quot;
+	fi
+	
+	if [ &quot;$PURGE&quot; = &quot;yes&quot; -a -e &quot;$NX_HOME_DIR&quot; ]
+	then
+		echo -n &quot;Removing nx home directory ...&quot;
+		rm -f -r &quot;$NX_HOME_DIR&quot; 2&gt;/dev/null
+		rmdir -p $(dirname &quot;$NX_HOME_DIR&quot;) 2&gt;/dev/null
+		echo &quot;done&quot;
+	fi
+	
+	if [ &quot;$PURGE&quot; = &quot;yes&quot; -a -e &quot;$NX_ETC_DIR&quot; ]
+	then
+		echo -n &quot;Removing configuration files ...&quot;
+		rm -f &quot;$NX_ETC_DIR/passwords&quot; &quot;$NX_ETC_DIR/passwords.orig&quot; &quot;$NX_ETC_DIR/users.id_dsa&quot; &quot;$NX_ETC_DIR/users.id_dsa.pub&quot; 2&gt;/dev/null
+		for i in `ls $NX_ETC_DIR/*.node.conf 2&gt;/dev/null` ;
+		do
+			rm -f &quot;$i&quot; 2&gt;/dev/null;
+		done
+		echo &quot;done&quot;
+	fi
+}
+
+if [ &quot;$INSTALL&quot; = &quot;yes&quot; ]
+then
+	#Perform cleanup?
+	[ &quot;$CLEAN&quot; = &quot;yes&quot; ] &amp;&amp; uninstall_nx
+	
+	install_nx
+	
+	echo &quot;Ok, nxserver is ready.&quot;
+	echo 
+	if [ &quot;$ENABLE_SSH_AUTHENTICATION&quot; = &quot;1&quot; -o &quot;$ENABLE_SU_AUTHENTICATION&quot; = &quot;1&quot; ]
+	then
+		echo &quot;PAM authentication enabled:&quot;
+		if [ &quot;$ENABLE_USER_DB&quot; = &quot;1&quot; ]
+		then
+			echo &quot;  Users will be able to login with their normal passwords,&quot;
+			echo &quot;  but they have to be registered in the nx database to do so.&quot;
+			echo &quot;  To add new users to the nx database do:&quot;
+			echo &quot;    nxserver --adduser &lt;username&gt;&quot;
+		else
+			echo &quot;  All users will be able to login with their normal passwords.&quot;
+		fi
+		echo
+		if [ &quot;$ENABLE_SSH_AUTHENTICATION&quot; = &quot;1&quot; -a &quot;$ENABLE_SU_AUTHENTICATION&quot; = &quot;1&quot; ]
+		then
+			echo &quot;  Both SSH and SU authentication is enabled.&quot;
+			echo &quot;  This does work, but is redundant.&quot;
+			echo &quot;  Please check if this is really what you intended.&quot;
+		elif [ &quot;$ENABLE_SSH_AUTHENTICATION&quot; = &quot;1&quot; ]
+		then
+			echo &quot;  PAM authentication will be done through SSH.&quot;
+			echo &quot;  Please ensure that SSHD on localhost accepts password authentication.&quot;
+		else
+			echo &quot;  PAM authentication will be done through SU.&quot;
+			echo &quot;  Please ensure that the user &quot;nx&quot; is a member of the wheel group.&quot;
+		fi
+	else
+		echo &quot;PAM authentication disabled.&quot;
+		echo &quot;  Only users in the nx database will be able to log in.&quot;
+		echo
+		echo &quot;  To add new users to the nx database do:&quot;
+		echo &quot;    nxserver --adduser &lt;username&gt;&quot;
+		echo &quot;  Afterwards change the password with:&quot;
+		echo &quot;    nxserver --passwd &lt;username&gt;&quot;
+	fi
+	echo
+	echo &quot;  You can change this behaviour in the $NX_ETC_DIR/node.conf file.&quot;
+	
+	if [ &quot;$SETUP_NOMACHINE_KEY&quot; = &quot;no&quot; -a &quot;$SETUP_NX_KEY&quot; = &quot;yes&quot; ]
+	then
+		echo
+		echo &quot;Warning: Clients will not be able to login to this server with the standard key.&quot;
+		echo &quot;         Please replace /usr/NX/share/client.id_dsa.key on all clients you want&quot;
+		echo &quot;         to use with $NX_HOME_DIR/.ssh/client.id_dsa.key&quot;
+		echo &quot;         and protect it accordingly.&quot;
+		echo
+		echo &quot;         If you really want to use the NoMachine key please remove&quot;
+		echo &quot;         '$NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS'&quot;
+		echo &quot;         and then run this script with the --setup-nomachine-key parameter.&quot;
+	fi
+	
+	echo &quot;Have Fun!&quot;
+elif [ &quot;$UNINSTALL&quot; = &quot;yes&quot; ]
+then
+	uninstall_nx
+	
+	echo &quot;Ok, nxserver is uninstalled&quot;
+	echo 
+	if [ &quot;$PURGE&quot; = &quot;yes&quot; ]
+	then
+		echo &quot;To complete the uninstallation process, remove the nx scripts in $PATH_BIN&quot;
+		echo &quot;and the $NX_ETC_DIR/node.conf configuration file.&quot;
+	else
+		echo &quot;To complete the uninstallation process, remove the nx scripts in $PATH_BIN&quot;
+		echo
+		echo &quot;Configuration files and ssh keys are saved in case you would like to reinstall&quot;
+		echo &quot;freenx at a later time. To remove them, please run 'nxsetup --uninstall --purge'&quot;
+	fi
+fi


Property changes on: freenx-server/nxsetup
___________________________________________________________________
Name: svn:executable
   + 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000154.html">[Freenx-cvs] r63 - freenx-server
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#153">[ date ]</a>
              <a href="thread.html#153">[ thread ]</a>
              <a href="subject.html#153">[ subject ]</a>
              <a href="author.html#153">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/freenx-cvs">More information about the Freenx-cvs
mailing list</a><br>
</body></html>
