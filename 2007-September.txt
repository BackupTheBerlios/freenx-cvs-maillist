From sebjames at mail.berlios.de  Tue Sep 11 16:59:13 2007
From: sebjames at mail.berlios.de (sebjames at BerliOS)
Date: Tue, 11 Sep 2007 16:59:13 +0200
Subject: [Freenx-cvs] r375 - in nxcl: lib nxcl test
Message-ID: <200709111459.l8BExDrg026061@sheep.berlios.de>

Author: sebjames
Date: 2007-09-11 16:59:12 +0200 (Tue, 11 Sep 2007)
New Revision: 375

Modified:
   nxcl/lib/notQt.cpp
   nxcl/lib/notQt.h
   nxcl/lib/nxclientlib.cpp
   nxcl/lib/nxclientlib.h
   nxcl/nxcl/main.cpp
   nxcl/nxcl/nxcl.cpp
   nxcl/nxcl/nxcl.h
   nxcl/test/libtest.cpp
   nxcl/test/notQttest.cpp
   nxcl/test/nxcmd.cpp
Log:
1) Unified copyright notices to all look the same.
2) Added a remove method to the notQTemporaryFile class - how temporary is a file that can't be removed?
3) Took the hardcoded certificate out of NXClientLib. I placed a hardcoded certificate into nxcmd.cpp instead - the certificate has to be passed in to nxcl somehow. In nxlaunch, I'll put the default certificate in a file and use that.



Modified: nxcl/lib/notQt.cpp
===================================================================
--- nxcl/lib/notQt.cpp	2007-09-11 13:14:39 UTC (rev 374)
+++ nxcl/lib/notQt.cpp	2007-09-11 14:59:12 UTC (rev 375)
@@ -1,13 +1,22 @@
-/*!
- * A set of QT like functionality, especially related to the starting
- * of processes.
- *
- * Author: Sebastian James <seb at esfnet.co.uk>
- * This code is copyright (C) Embedded Software Foundry Ltd. 2007
- *
- * It is released under the terms of the GNU GPL version 2.
- */
+/***************************************************************************
+        notQt.cpp: A set of Qt like functionality, especially related
+                       to the starting of processes.
+                             -------------------
+    begin                : June 2007
+    copyright            : (C) 2007 Embedded Software Foundry Ltd. (U.K.)
+                         :     Author: Sebastian James
+    email                : seb at esfnet.co.uk
+ ***************************************************************************/
 
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
 #include <iostream>
 #include <sstream>
 extern "C" {
@@ -317,6 +326,7 @@
 // Destructor
 notQTemporaryFile::~notQTemporaryFile ()
 {
+	this->close();
 }
 
 void
@@ -331,13 +341,15 @@
 void
 notQTemporaryFile::write (string input)
 {
-	f << input;
+	this->f << input;
 }
 
 void
 notQTemporaryFile::close (void)
 {
-	this->f.close();
+	if (this->f.is_open()) {
+		this->f.close();
+	}
 }
 
 // getter for fileName
@@ -347,6 +359,12 @@
 	return this->theFileName;
 }
 
+void
+notQTemporaryFile::remove (void)
+{
+	this->close();
+	unlink (this->theFileName.c_str());
+}
 //@}
 
 

Modified: nxcl/lib/notQt.h
===================================================================
--- nxcl/lib/notQt.h	2007-09-11 13:14:39 UTC (rev 374)
+++ nxcl/lib/notQt.h	2007-09-11 14:59:12 UTC (rev 375)
@@ -1,13 +1,28 @@
 /* -*-c++-*- */
-/*
- * Simple re-implementations of some QT-like functionality.  In
- * particular, there's a QProcess-like (though much simplified) class,
- * a QTemporaryFile like class and a couple of the methods that you
- * get with QString.
- *
- * (C) 2007 Sebastian James, Embedded Software Foundry Ltd (U.K.).
- *
- * Released under the terms of the GNU General Public Licence Version 2. 
+/***************************************************************************
+           notQt.h: A set of Qt like functionality, especially related
+                       to the starting of processes.
+                             -------------------
+    begin                : June 2007
+    copyright            : (C) 2007 Embedded Software Foundry Ltd. (U.K.)
+                         :     Author: Sebastian James
+    email                : seb at esfnet.co.uk
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+/*!
+ * \file notQt.h Simple re-implementations of some Qt-like
+ * functionality.  In particular, there's a QProcess-like (though much
+ * simplified) class, a QTemporaryFile like class and a couple of the
+ * methods that you get with QString.
  */
 
 #ifndef _NOTQT_H_
@@ -67,7 +82,7 @@
 	};
 
 	/*!
-	 * notQProcess is a simple replacement for the QT class QProcess.
+	 * notQProcess is a simple replacement for the Qt class QProcess.
 	 */
 	class notQProcess
 	{
@@ -170,7 +185,7 @@
 	};
 
 	/*!
-	 * A simple replacement for the QT Class QTemporaryFile.
+	 * A simple replacement for the Qt Class QTemporaryFile.
 	 */
 	class notQTemporaryFile
 	{
@@ -195,6 +210,10 @@
 		 * A getter for the file name of the temporary file
 		 */
 		string fileName (void);
+		/*!
+		 * Remove the temporary file
+		 */
+		void remove (void);
 
 	private:
 		/*!
@@ -216,7 +235,7 @@
 		notQtUtilities();
 		~notQtUtilities();
 
-		/*! The same (more or less) as QT QString::simplified */
+		/*! The same (more or less) as Qt QString::simplified */
 		static string simplify (string& input);
 		/*!
 		 * Split a string 'line' based on token, placing the portions in the vector rtn

Modified: nxcl/lib/nxclientlib.cpp
===================================================================
--- nxcl/lib/nxclientlib.cpp	2007-09-11 13:14:39 UTC (rev 374)
+++ nxcl/lib/nxclientlib.cpp	2007-09-11 14:59:12 UTC (rev 375)
@@ -38,9 +38,6 @@
 using namespace std;
 using namespace nxcl;
 
-// Default NoMachine certificate for FALLBACK
-string cert("-----BEGIN DSA PRIVATE KEY-----\nMIIBuwIBAAKBgQCXv9AzQXjxvXWC1qu3CdEqskX9YomTfyG865gb4D02ZwWuRU/9\nC3I9/bEWLdaWgJYXIcFJsMCIkmWjjeSZyTmeoypI1iLifTHUxn3b7WNWi8AzKcVF\naBsBGiljsop9NiD1mEpA0G+nHHrhvTXz7pUvYrsrXcdMyM6rxqn77nbbnwIVALCi\nxFdHZADw5KAVZI7r6QatEkqLAoGBAI4L1TQGFkq5xQ/nIIciW8setAAIyrcWdK/z\n5/ZPeELdq70KDJxoLf81NL/8uIc4PoNyTRJjtT3R4f8Az1TsZWeh2+ReCEJxDWgG\nfbk2YhRqoQTtXPFsI4qvzBWct42WonWqyyb1bPBHk+JmXFscJu5yFQ+JUVNsENpY\n+Gkz3HqTAoGANlgcCuA4wrC+3Cic9CFkqiwO/Rn1vk8dvGuEQqFJ6f6LVfPfRTfa\nQU7TGVLk2CzY4dasrwxJ1f6FsT8DHTNGnxELPKRuLstGrFY/PR7KeafeFZDf+fJ3\nmbX5nxrld3wi5titTnX+8s4IKv29HJguPvOK/SI7cjzA+SqNfD7qEo8CFDIm1xRf\n8xAPsSKs6yZ6j1FNklfu\n-----END DSA PRIVATE KEY-----");
-
 /*!
  * Implementation of the NXClientLibCallbacks class
  */
@@ -167,7 +164,7 @@
 	nxsshProcess.terminate();
 }
 
-void NXClientLib::invokeNXSSH(string publicKey, string serverHost, bool encryption, string key, int port)
+void NXClientLib::invokeNXSSH (string publicKey, string serverHost, bool encryption, string key, int port)
 {
 	list<string> arguments;
 	stringstream argtmp;
@@ -180,48 +177,38 @@
 
 	// Start to build the arguments for the nxssh command.
 	// notQProcess requires that argv[0] contains the program name
+	// FIXME: Here, I place the PACKAGE_BIN_DIR path in front of
+	// nxssh, but nxssh may be installed in a different prefix...
 	arguments.push_back (PACKAGE_BIN_DIR"/nxssh");
 	
-	if (publicKey == "default") {
-		usingHardcodedKey = true;
-	}
-
 	argtmp << "-nx";
 	arguments.push_back (argtmp.str());
 
 	argtmp.str("");
 	argtmp << "-p" << port;
-	arguments.push_back(argtmp.str());
+	arguments.push_back (argtmp.str());
 
-	if (publicKey == "default" || publicKey == "supplied") {
-		if (publicKey == "default") {
-			this->externalCallbacks->stderrSignal (_("WARNING: Using hardcoded NoMachine public key for "
-					"outer/first stage SSH encryption."));
-		}
+	if (publicKey == "supplied") {
 		
-		keyFile = new notQTemporaryFile;
-		keyFile->open();
+		this->keyFile = new notQTemporaryFile;
+		this->keyFile->open();
 		
 		argtmp.str("");
-		argtmp << "-i" << keyFile->fileName();
+		argtmp << "-i" << this->keyFile->fileName();
 		arguments.push_back (argtmp.str());
 
-		if (publicKey == "default") {
-			keyFile->write(cert);
-		} else {
-			keyFile->write(key);
-		}
-			
-		keyFile->close();
+		this->keyFile->write (key);			
+		this->keyFile->close();
+
 	} else {
 		argtmp.str("");
 		argtmp << "-i" << publicKey;
-		arguments.push_back(argtmp.str());
+		arguments.push_back (argtmp.str());
 	}
 	
 	argtmp.str("");
 	argtmp << "nx@" << serverHost;
-	arguments.push_back(argtmp.str());
+	arguments.push_back (argtmp.str());
 
 	// These options copied from the way Nomachine's client
 	// specifies the nxssh command - they make good sense.
@@ -440,9 +427,11 @@
 
 void NXClientLib::doneAuth()
 {
-	// FIXME: Don't think this is correctly removing the keyfile data.
-	if (usingHardcodedKey)
-		delete keyFile;
+	if (this->keyFile != NULL) {
+		this->keyFile->remove();
+		delete this->keyFile;
+	}
+	return;
 }
 
 void NXClientLib::allowSSHConnect (bool auth)

Modified: nxcl/lib/nxclientlib.h
===================================================================
--- nxcl/lib/nxclientlib.h	2007-09-11 13:14:39 UTC (rev 374)
+++ nxcl/lib/nxclientlib.h	2007-09-11 14:59:12 UTC (rev 375)
@@ -3,7 +3,7 @@
                                 nxclientlib.h
                              -------------------
     begin                : Sat 22nd July 2006
-    remove QT dependency : Started June 2007
+    remove Qt dependency : Started June 2007
     modifications        : June-July 2007
     copyright            : (C) 2006 by George Wright
     modifications        : (C) 2007 Embedded Software Foundry Ltd. (U.K.)
@@ -149,29 +149,35 @@
 		/*!
 		 * Set up data and then call this->nxsshProcess.start().
 		 * 
-		 * \arg publicKey is the path to the ssh public key
-		 * file to authenticate with.  Pass "default" to use
-		 * the default NoMachine key.
+		 * \param publicKey is the path to the ssh public key
+		 * file to authenticate with.  Pass "supplied" to use
+		 * a new key, which you should then supply as the
+		 * parameter key.
 		 *
-		 * \arg serverHost is the hostname of the NX server to
+		 * \param serverHost is the hostname of the NX server to
 		 * connect to
 		 *
-		 * \arg encryption is whether to use an encrypted NX
+		 * \param encryption is whether to use an encrypted NX
 		 * session
+		 *
+		 * \param key ssh key to use for authentication of the
+		 * nx user if publicKey is "supplied".
+		 *
+		 * \param port TCP port to use for the ssh connection.
 		 */
-		void invokeNXSSH (string publicKey = "default", string serverHost = "",
+		void invokeNXSSH (string publicKey = "supplied", string serverHost = "",
 				  bool encryption = true, string key = "", int port = 22);
 
 		/*!
 		 * Overloaded to give callback data on write.
 		 * 
-		 * Writes \arg data to this->nxsshProcess stdin and also
+		 * Writes data to this->nxsshProcess stdin and also
 		 * out to the user via stdoutCallback
 		 */
 		void write (string data);
 
 		/*!
-		 * Passes \arg auth to this->session.setContinue()
+		 * Passes auth to this->session.setContinue()
 		 */
 		void allowSSHConnect (bool auth);
 
@@ -265,11 +271,6 @@
 
 	private:
 		/*!
-		 * true if we're using the hardcoded SSL key (the
-		 * default NoMachine one). To be removed.
-		 */
-		bool usingHardcodedKey;
-		/*!
 		 * Set true when the program is ready to end, e.g if
 		 * authentication failed, nxssh failed to start amoung
 		 * other reasons.

Modified: nxcl/nxcl/main.cpp
===================================================================
--- nxcl/nxcl/main.cpp	2007-09-11 13:14:39 UTC (rev 374)
+++ nxcl/nxcl/main.cpp	2007-09-11 14:59:12 UTC (rev 375)
@@ -1,23 +1,33 @@
-/*
- * nxcld: The NXCL dbus daemon.
+/***************************************************************************
+                        nxcl: The NXCL dbus daemon.
+                             -------------------
+    begin                : June 2007
+    copyright            : (C) 2007 Embedded Software Foundry Ltd. (U.K.)
+                         :     Author: Sebastian James
+    email                : seb at esfnet.co.uk
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+/*!
+ * This program should be launched by a client - that might be
+ * nxlaunch (already written) or (not yet written) qtnxc, fltknxc,
+ * tknxc, emacsnxc.... etc etc you get the picture.
  *
- * This program should be launched by a client - that might be gnxc,
- * qtnxc, fltknxc, tknxc, emacsnxc.... etc etc you get the picture.
- *
- * This graphical launcher program is the place where the user can
+ * The graphical launcher program is the place where the user can
  * select the connection type, and enter his username and password. It
- * launches nxcld via a dbus call (or some other way?), then transmits
- * the settings to nxcld via dbus. nxcld then negotiates the NX
- * connection - launching nxssh and nxproxy. nxcld will send back a
- * list of sessions to the launching NX client (if there are
- * multiple available sessions) and a signal to say if the connection
- * has been launched or if an error occurred.
- *
- * (C) 2007 Embedded Software Foundry Ltd. (U.K.)
- * Author: Sebastian James
- * Email:  seb at esfnet.co.uk
- *
- * Released under the terms of the GNU GPL version 2.
+ * launches nxcl, then transmits the settings to nxcl via dbus. nxcl
+ * then negotiates the NX connection - launching nxssh and
+ * nxproxy. nxcl will send back a list of sessions to the launching
+ * NX client (if there are multiple available sessions) and a signal
+ * to say if the connection has been launched or if an error occurred.
  */
 
 #include "../config.h"

Modified: nxcl/nxcl/nxcl.cpp
===================================================================
--- nxcl/nxcl/nxcl.cpp	2007-09-11 13:14:39 UTC (rev 374)
+++ nxcl/nxcl/nxcl.cpp	2007-09-11 14:59:12 UTC (rev 375)
@@ -1,19 +1,23 @@
-/*
- * nxcl: The NXCL dbus daemon.
- *
- * See main.cpp for general notes.
- *
- * This file contains the implementation of the Nxcl class used by
- * the nxcl program.
- *
- * (C) 2007 Embedded Software Foundry Ltd. (U.K.)
- * Author: Sebastian James
- * Email:  seb at esfnet.co.uk
- *
- * Released under the terms of the GNU GPL version 2.
- */
+/***************************************************************************
+                        nxcl: The NXCL dbus daemon.
+                             -------------------
+    begin                : June 2007
+    copyright            : (C) 2007 Embedded Software Foundry Ltd. (U.K.)
+                         :     Author: Sebastian James
+    email                : seb at esfnet.co.uk
+ ***************************************************************************/
 
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
 #include "../config.h"
+#include "nxclientlib_i18n.h"
 #include "nxclientlib.h"
 #include <fstream>
 
@@ -444,17 +448,13 @@
 
 	/* If we have session info, start up the connection */
 	if (this->sessionData.key.size() == 0) { // Shouldn't need this->sessionData.encryption here.
-		this->nxclientlib.invokeNXSSH("default",
-					      this->nxserver,
-					      this->sessionData.encryption, 
-					      "", this->nxport);
+		this->callbacks.write (_("No key supplied! Please fix your client to send a key via dbus!"));
 	} else {
 		this->nxclientlib.invokeNXSSH("supplied",
 					      this->nxserver,
 					      this->sessionData.encryption,
 					      this->sessionData.key, this->nxport);
-	} // Is there another case here, other than "default" or "supplied"?
-
+	}
 }
 
 void
@@ -498,7 +498,7 @@
 						   this->dbusSendInterface.c_str(),
 						   "AvailableSession");
 
-		// We have to create a const char* pointer or each
+		// We have to create a const char* pointer for each
 		// string variable in the NXResumeSessions struct.
 		const char* sessionType = (*it).sessionType.c_str();
 		const char* sessionID = (*it).sessionID.c_str();

Modified: nxcl/nxcl/nxcl.h
===================================================================
--- nxcl/nxcl/nxcl.h	2007-09-11 13:14:39 UTC (rev 374)
+++ nxcl/nxcl/nxcl.h	2007-09-11 14:59:12 UTC (rev 375)
@@ -1,17 +1,27 @@
 /* -*-c++-*- */
-/*
- * nxcl: The NXCL dbus daemon.
+/***************************************************************************
+                        nxcl: The NXCL dbus daemon.
+                             -------------------
+    begin                : June 2007
+    copyright            : (C) 2007 Embedded Software Foundry Ltd. (U.K.)
+                         :     Author: Sebastian James
+    email                : seb at esfnet.co.uk
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+/*!
+ * \file nxcl.h This file contains the definition of the Nxcl class
+ * used by the nxcl program.
  *
  * See main.cpp for general notes.
- *
- * This file contains the definition of the Nxcl class used by the
- * nxcl program.
- *
- * (C) 2007 Embedded Software Foundry Ltd. (U.K.)
- * Author: Sebastian James
- * Email:  seb at esfnet.co.uk
- *
- * Released under the terms of the GNU GPL version 2.
  */
 
 #ifndef _NXCL_H_

Modified: nxcl/test/libtest.cpp
===================================================================
--- nxcl/test/libtest.cpp	2007-09-11 13:14:39 UTC (rev 374)
+++ nxcl/test/libtest.cpp	2007-09-11 14:59:12 UTC (rev 375)
@@ -1,3 +1,27 @@
+/***************************************************************************
+         libtest: A VERY simple command line test for the NXCL library
+                             -------------------
+    begin                : June 2007
+    copyright            : (C) 2007 Embedded Software Foundry Ltd. (U.K.)
+                         :     Author: Sebastian James
+    email                : seb at esfnet.co.uk
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+/*
+ * NB NB! This probably doesn't work. It shouldn't be hard to fix
+ * though. It will be broken because I changed the signal handler
+ * scheme. Seb.
+ */
+
 #include "nxclientlib.h"
 #include <fstream>
 

Modified: nxcl/test/notQttest.cpp
===================================================================
--- nxcl/test/notQttest.cpp	2007-09-11 13:14:39 UTC (rev 374)
+++ nxcl/test/notQttest.cpp	2007-09-11 14:59:12 UTC (rev 375)
@@ -1,14 +1,20 @@
-/*
- * notQttest.cpp - A test of some of the features in ../lib/notQt.cpp
- *
+/***************************************************************************
+   notQttest.cpp - A test of some of the features in ../lib/notQt.cpp
+                             -------------------
+    begin                : June 2007
+    copyright            : (C) 2007 Embedded Software Foundry Ltd. (U.K.)
+                         :     Author: Sebastian James
+    email                : seb at esfnet.co.uk
+ ***************************************************************************/
 
- *
- * (C) 2007 Embedded Software Foundry Ltd. (U.K.)
- * Author: Sebastian James
- * Email:  seb at esfnet.co.uk
- *
- * Released under the terms of the GNU GPL version 2.
- */
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
 
 #include <iostream>
 #include <string>

Modified: nxcl/test/nxcmd.cpp
===================================================================
--- nxcl/test/nxcmd.cpp	2007-09-11 13:14:39 UTC (rev 374)
+++ nxcl/test/nxcmd.cpp	2007-09-11 14:59:12 UTC (rev 375)
@@ -1,6 +1,22 @@
-/*
- * nxcmd: A simple command line test for the NXCL dbus daemon.
- *
+/***************************************************************************
+         nxcmd: A simple command line test for the NXCL dbus daemon.
+                             -------------------
+    begin                : June 2007
+    copyright            : (C) 2007 Embedded Software Foundry Ltd. (U.K.)
+                         :     Author: Sebastian James
+    email                : seb at esfnet.co.uk
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+/*!
  * See ../nxcl/main.cpp for general notes on the nxcl program.
  *
  * This program will fork a process and run nxcl, then it will send
@@ -10,12 +26,6 @@
  * This is a very hacked together program, part C, part C++, but it
  * serves its purpose of demonstrating the techniques you'll need to
  * write a simple client to nxcl.
- *
- * (C) 2007 Embedded Software Foundry Ltd. (U.K.)
- * Author: Sebastian James
- * Email:  seb at esfnet.co.uk
- *
- * Released under the terms of the GNU GPL version 2.
  */
 
 #include <iostream>
@@ -40,6 +50,12 @@
 
 using namespace std;
 
+// Default NoMachine certificate for FALLBACK. Don't do it this way in
+// your code. Instead, ship a default key in a file and reference
+// that.
+string cert("-----BEGIN DSA PRIVATE KEY-----\nMIIBuwIBAAKBgQCXv9AzQXjxvXWC1qu3CdEqskX9YomTfyG865gb4D02ZwWuRU/9\nC3I9/bEWLdaWgJYXIcFJsMCIkmWjjeSZyTmeoypI1iLifTHUxn3b7WNWi8AzKcVF\naBsBGiljsop9NiD1mEpA0G+nHHrhvTXz7pUvYrsrXcdMyM6rxqn77nbbnwIVALCi\nxFdHZADw5KAVZI7r6QatEkqLAoGBAI4L1TQGFkq5xQ/nIIciW8setAAIyrcWdK/z\n5/ZPeELdq70KDJxoLf81NL/8uIc4PoNyTRJjtT3R4f8Az1TsZWeh2+ReCEJxDWgG\nfbk2YhRqoQTtXPFsI4qvzBWct42WonWqyyb1bPBHk+JmXFscJu5yFQ+JUVNsENpY\n+Gkz3HqTAoGANlgcCuA4wrC+3Cic9CFkqiwO/Rn1vk8dvGuEQqFJ6f6LVfPfRTfa\nQU7TGVLk2CzY4dasrwxJ1f6FsT8DHTNGnxELPKRuLstGrFY/PR7KeafeFZDf+fJ3\nmbX5nxrld3wi5titTnX+8s4IKv29HJguPvOK/SI7cjzA+SqNfD7qEo8CFDIm1xRf\n8xAPsSKs6yZ6j1FNklfu\n-----END DSA PRIVATE KEY-----");
+
+
 // Used in receiveSession as the return value
 #define REPLY_REQUIRED  1
 #define NEW_CONNECTION  2
@@ -214,6 +230,7 @@
 	cfg.agentPass = "";
 	cfg.cups = 0;
 	cfg.encryption = true;
+	cfg.key = cert;
 	cfg.fullscreen = false; // If true, ignore cfg.geometry. 	
 	
 	cout << "NXCMD> Sending settings\n";



From sebjames at mail.berlios.de  Tue Sep 11 17:22:35 2007
From: sebjames at mail.berlios.de (sebjames at BerliOS)
Date: Tue, 11 Sep 2007 17:22:35 +0200
Subject: [Freenx-cvs] r376 - nxcl
Message-ID: <200709111522.l8BFMZUb027861@sheep.berlios.de>

Author: sebjames
Date: 2007-09-11 17:22:35 +0200 (Tue, 11 Sep 2007)
New Revision: 376

Modified:
   nxcl/README
Log:
"Qt" capitalization corrected.


Modified: nxcl/README
===================================================================
--- nxcl/README	2007-09-11 14:59:12 UTC (rev 375)
+++ nxcl/README	2007-09-11 15:22:35 UTC (rev 376)
@@ -3,8 +3,8 @@
 
   Seb James. July-September 2007. seb at esfnet.co.uk
 
-Based on nxclientlib by George Wright, but with all dependencies on QT
-removed and the QT build system replaced with GNU autotools.
+Based on nxclientlib by George Wright, but with all dependencies on Qt
+removed and the Qt build system replaced with GNU autotools.
 
 doxygen is required if you want to build source documentation.
 
@@ -27,7 +27,7 @@
 client which links directly to the nxcl library. 
 
 You should study nxcmd.cpp and nxlaunch if you are interested in
-writing an NX client using a different widget system (say Windows, QT,
+writing an NX client using a different widget system (say Windows, Qt,
 Tk, etc) which uses the Nxcl dbus daemon.
 
 Look at nxcl.cpp/h if you want to write an NX client which links



From fabianx at mail.berlios.de  Thu Sep 13 15:03:51 2007
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Thu, 13 Sep 2007 15:03:51 +0200
Subject: [Freenx-cvs] r377 - freenx-server/trunk
Message-ID: <200709131303.l8DD3pNO011779@sheep.berlios.de>

Author: fabianx
Date: 2007-09-13 15:03:50 +0200 (Thu, 13 Sep 2007)
New Revision: 377

Modified:
   freenx-server/trunk/ChangeLog
   freenx-server/trunk/nxnode
Log:
* Fixed diverse occurences of $sess_id in nxnode, when hostname
  contains whitespace.
  (fabianx at bat.berlios.de)



Modified: freenx-server/trunk/ChangeLog
===================================================================
--- freenx-server/trunk/ChangeLog	2007-09-11 15:22:35 UTC (rev 376)
+++ freenx-server/trunk/ChangeLog	2007-09-13 13:03:50 UTC (rev 377)
@@ -43,6 +43,9 @@
 	* Fix ownership of $SSH_AUTHORIZED_KEYS in nxkeygen, just in case
 	  it is run without nxsetup.
 	  (fabianx at bat.berlios.de, thx to sambiase on #nx)
+	* Fixed diverse occurences of $sess_id in nxnode, when hostname
+	  contains whitespace.
+	  (fabianx at bat.berlios.de)
 
 07.07.2007 FreeNX 0.7.0 "Jornade SPL Edition VI+1"
 	* Fixed the printing support for CUPS 1.2.

Modified: freenx-server/trunk/nxnode
===================================================================
--- freenx-server/trunk/nxnode	2007-09-11 15:22:35 UTC (rev 376)
+++ freenx-server/trunk/nxnode	2007-09-13 13:03:50 UTC (rev 377)
@@ -494,7 +494,7 @@
 		
 		# Start the agent
 		
-		$PATH_BIN/nxviewer -encodings tight hextile copyrect raw -passwd $USER_FAKE_HOME/.nx/C-$sess_id/scripts/.passwd -name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" -option "$USER_FAKE_HOME/.nx/C-$sess_id/options" $vncfullscreen $G $K $agent_server $AGENT_EXTRA_OPTIONS_RFB 2>&3 &
+		$PATH_BIN/nxviewer -encodings tight hextile copyrect raw -passwd "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/.passwd" -name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" -option "$USER_FAKE_HOME/.nx/C-$sess_id/options" $vncfullscreen $G $K $agent_server $AGENT_EXTRA_OPTIONS_RFB 2>&3 &
 
 	elif [ "$R" = "-R" -a "$rootless" != "1" ]
 	then
@@ -1118,7 +1118,7 @@
 	umask 0022
 	mkdir -p $USER_FAKE_HOME
 	umask 0077
-	mkdir -p $USER_FAKE_HOME/.nx/C-$sess_id
+	mkdir -p "$USER_FAKE_HOME/.nx/C-$sess_id"
 	umask $OLD_UMASK
 	
 	# cache=8M,images=32M,pack=nopack,link=lan,type=unix-kde,cleanup=0,accept=192.168.1.66,cookie=E38A94A77F975443AF04EC911881B120,id=Knoppix-1000-6A8269CC467264EAEF6349D062689755,samba=1,render=1:1000
@@ -1155,7 +1155,7 @@
 	OLD_UMASK=$(umask)
 	umask 0077
 
-cat << EOF > $USER_FAKE_HOME/.nx/C-$sess_id/options
+cat << EOF > "$USER_FAKE_HOME/.nx/C-$sess_id/options"
 ${kbtype:+kbtype=$kbtype,}${kbload:+kbload=$kbload,}${keymap:+keymap=$keymap,}${resize:+resize=$resize,}${CACHE}${IMAGES}${PACK}link=$link,nodelay=$nodelay,type=$realtype,cleanup=0,${ACCEPT}cookie=$proxy_cookie,id=$sess_id,samba=$samba,media=$media${sync:+,sync=$sync}${cups:+,cups=$cups}${keybd:+,keybd=$keybd}${http:+,http=$http}${rdpcolors:+,rdpcolors=$rdpcolors}${rdpcache:+,rdpcache=$rdpcache}${fullscreen:+,fullscreen=1}:$display
 EOF
 	umask $OLD_UMASK
@@ -1177,9 +1177,9 @@
 exit
 EOF
 
-	mkdir -m700 $USER_FAKE_HOME/.nx/C-$sess_id/scripts/ 2>/dev/null || chmod 700 $USER_FAKE_HOME/.nx/C-$sess_id/scripts/
+	mkdir -m700 "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/" 2>/dev/null || chmod 700 "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/"
 
-cat << EOF >$USER_FAKE_HOME/.nx/C-$sess_id/scripts/authority
+cat << EOF >"$USER_FAKE_HOME/.nx/C-$sess_id/scripts/authority"
 remove localhost:$display
 remove unix:$display
 exit
@@ -1187,16 +1187,16 @@
 
 if [ "$1" = "restore" ]
 then
-	echo > $USER_FAKE_HOME/.nx/C-$sess_id/session
-	sh -c 'echo "Info: tail -f running with pid '\'\$$\''."; exec tail -n1 -f '$USER_FAKE_HOME'/.nx/C-'$sess_id'/session' | node_start_monitor "$1" "$status" &
+	echo > "$USER_FAKE_HOME/.nx/C-$sess_id/session"
+	sh -c 'echo "Info: tail -f running with pid '\'\$$\''."; exec tail -n1 -f '"$USER_FAKE_HOME"'/.nx/C-'"$sess_id"'/session' | node_start_monitor "$1" "$status" &
 
 	MONITOR_PID=$!
 	export MONITOR_PID
 
-	mkdir -p $USER_FAKE_HOME/.nx/C-$sess_id/pids/
-	echo "$MONITOR_PID" > $USER_FAKE_HOME/.nx/C-$sess_id/pids/monitor
+	mkdir -p "$USER_FAKE_HOME/.nx/C-$sess_id/pids/"
+	echo "$MONITOR_PID" > "$USER_FAKE_HOME/.nx/C-$sess_id/pids/monitor"
 
-	node_suspend_session $sess_id || { echo "Info: Reconnection failed: NX Agent process could not be found." >>"$USER_FAKE_HOME/.nx/C-$sess_id/session"; node_fail_restore_session $sess_id; }
+	node_suspend_session "$sess_id" || { echo "Info: Reconnection failed: NX Agent process could not be found." >>"$USER_FAKE_HOME/.nx/C-$sess_id/session"; node_fail_restore_session "$sess_id"; }
 else
 	node_start_agent &
 	node_start_applications &
@@ -1204,7 +1204,6 @@
 
 if which "$NODE_AUTOSTART" >/dev/null 2>&1
 then
-	sess_id="$SERVER_NAME-$display-$uniqueid"
 	# go into background immediately
 	NXSESSIONID="$sess_id" DISPLAY=unix:$display "$NODE_AUTOSTART" "$1" >/dev/null 2>&1 &
 	# dont't wait for this child!
@@ -1338,7 +1337,7 @@
 		mkdir -p "$USER_FAKE_HOME/.nx/config/ppd/"
 		if [ "$MODEL" = "download_new" -o ! -r "$USER_FAKE_HOME/.nx/config/ppd/$printer.ppd" ]
 		then
-			curl --digest -o "$USER_FAKE_HOME/.nx/config/ppd/$printer.ppd" "http://$username:$password at 127.0.0.1:$port/ppd/${printer}_nxdl.ppd" >>$USER_FAKE_HOME/.nx/C-$sess_id/cups/curl.log 2>&1
+			curl --digest -o "$USER_FAKE_HOME/.nx/config/ppd/$printer.ppd" "http://$username:$password at 127.0.0.1:$port/ppd/${printer}_nxdl.ppd" >>"$USER_FAKE_HOME/.nx/C-$sess_id/cups/curl.log" 2>&1
 		RC=$?
 		[ $RC -eq 0 -a "$ENABLE_CUPS_SEAMLESS" != "1" ] && $PATH_BIN/nxclient --message "Download successful." -display :$display
 		[ $RC -ne 0 -a "$ENABLE_CUPS_SEAMLESS" != "1" ] && $PATH_BIN/nxclient --message "Download failed. Log is: $USER_FAKE_HOME/.nx/C-$sess_id/cups/curl.log" -display :$display



From sebjames at mail.berlios.de  Thu Sep 13 23:35:34 2007
From: sebjames at mail.berlios.de (sebjames at BerliOS)
Date: Thu, 13 Sep 2007 23:35:34 +0200
Subject: [Freenx-cvs] r378 - in nxcl: lib nxcl
Message-ID: <200709132135.l8DLZYVi029132@sheep.berlios.de>

Author: sebjames
Date: 2007-09-13 23:35:33 +0200 (Thu, 13 Sep 2007)
New Revision: 378

Modified:
   nxcl/lib/nxclientlib.cpp
   nxcl/lib/nxclientlib.h
   nxcl/nxcl/nxcl.cpp
   nxcl/nxcl/nxcl.h
Log:
Added error, debug callbacks to nxcl, and changed the way the callbacks 
are implemented - now the write callbacks (and there are two now, one 
has an extra numeric parameter for sending the NX message number) send 
dbus messages to the frontend gui client. This allows the frontend 
client to show progress on the connection. I still need to add a few 
extra messages from the nxssh output through to the frontend client so 
its progress user output can be more useful.


Modified: nxcl/lib/nxclientlib.cpp
===================================================================
--- nxcl/lib/nxclientlib.cpp	2007-09-13 13:03:50 UTC (rev 377)
+++ nxcl/lib/nxclientlib.cpp	2007-09-13 21:35:33 UTC (rev 378)
@@ -53,13 +53,13 @@
 void
 NXClientLibCallbacks::startedSignal (string name)
 {
-	this->parent->externalCallbacks->write(name + _(" process started"));
+	this->parent->externalCallbacks->write (name + _(" process started"));
 }
 
 void
 NXClientLibCallbacks::processFinishedSignal (string name)
 {
-	this->parent->externalCallbacks->write(name + _(" process exited"));
+	this->parent->externalCallbacks->write (name + _(" process exited"));
 	parent->setIsFinished (true);
 }
 
@@ -88,7 +88,7 @@
 		break;
 	}
 		
-	this->parent->externalCallbacks->write (message);
+	this->parent->externalCallbacks->error (message);
 }
 
 void 
@@ -289,14 +289,14 @@
 		int pid = response - 100000;
 		if (this->nxsshProcess.getPid() == pid) {
 			this->nxsshProcess.setError(NOTQPROCCRASHED);
-			this->externalCallbacks->write (_("nxsshProcess crashed or exited"));
+			this->externalCallbacks->error (_("nxsshProcess crashed or exited"));
 			this->isFinished = true;
 		} else if (this->nxproxyProcess.getPid() == pid) {
 			this->nxproxyProcess.setError(NOTQPROCCRASHED);
-			this->externalCallbacks->write (_("nxproxyProcess crashed or exited"));
+			this->externalCallbacks->error (_("nxproxyProcess crashed or exited"));
 			this->isFinished = true;
 		} else {
-			this->externalCallbacks->write (_("Warning: Don't know what crashed (in processParseStdout())"));
+			this->externalCallbacks->error (_("Warning: Don't know what crashed (in processParseStdout())"));
 		}
 		return;
 	}
@@ -338,7 +338,7 @@
 			stringstream ss;
 			ss << "127.0.0.1:" << proxyData.port << " cookie: " << proxyData.cookie << "\n";
 			switchCommand += ss.str();
-			this->write(switchCommand);
+			this->write (switchCommand);
 		} else if ((*msgiter).find("NX> 287 Redirected I/O to channel descriptors") != string::npos) {
 			dbgln ("287 message found on stdout");
 			this->externalCallbacks->write(_("The session has been started successfully"));
@@ -398,7 +398,7 @@
 			this->isFinished = true;
 
 		} else if ((*msgiter).find("NX> 280 Ignoring EOF on the monitored channel") != string::npos) {
-			this->externalCallbacks->write(_("Unknown problem..."));
+			this->externalCallbacks->write(_("Got \"NX> 280 Ignoring EOF on the monitored channel\" from nxssh..."));
 			this->isFinished = true;
 
 		} else if ((*msgiter).find("Host key verification failed") != string::npos) {
@@ -501,7 +501,7 @@
 {
 	dbgln ("invokeProxy called");
 
-	this->externalCallbacks->write(_("Starting NX session"));
+	this->externalCallbacks->write(100, _("Starting NX session"));
 	
 	int e;
 	char * home;
@@ -517,7 +517,7 @@
 				   // existing, though if there is a
 				   // _file_ called $HOME/.nx, we'll
 				   // get errors later.
-			this->externalCallbacks->write (_("Problem creating .nx directory"));
+			this->externalCallbacks->error (_("Problem creating .nx directory"));
 		}
 	}
 	// Now the per session directory
@@ -525,7 +525,7 @@
 	if (mkdir (nxdir.c_str(), 0770)) {
 		e = errno;
 		if (e != EEXIST) { // We don't mind .nx already
-			this->externalCallbacks->write (_("Problem creating Session directory"));
+			this->externalCallbacks->error (_("Problem creating Session directory"));
 		}
 	}
 

Modified: nxcl/lib/nxclientlib.h
===================================================================
--- nxcl/lib/nxclientlib.h	2007-09-13 13:03:50 UTC (rev 377)
+++ nxcl/lib/nxclientlib.h	2007-09-13 21:35:33 UTC (rev 378)
@@ -53,6 +53,8 @@
 		NXClientLibExternalCallbacks () {}
 		virtual ~NXClientLibExternalCallbacks () {}
 		virtual void write (string msg) {}
+		virtual void write (int num, string msg) {}
+		virtual void error (string msg) {}
 		virtual void debug (string msg) {}
 		virtual void stdoutSignal (string msg) {}
 		virtual void stderrSignal (string msg) {}

Modified: nxcl/nxcl/nxcl.cpp
===================================================================
--- nxcl/nxcl/nxcl.cpp	2007-09-13 13:03:50 UTC (rev 377)
+++ nxcl/nxcl/nxcl.cpp	2007-09-13 21:35:33 UTC (rev 378)
@@ -48,13 +48,25 @@
 void
 NxclCallbacks::write (string msg)
 {
-	cout << "NXCL> " << msg << endl;
+//	cout << "NXCL> " << msg << endl;
+	this->parent->sendDbusInfoMsg (msg);
 }
 void
+NxclCallbacks::write (int num, string msg)
+{
+	this->parent->sendDbusInfoMsg (num, msg);
+}
+void
+NxclCallbacks::error (string msg)
+{
+	cerr << "NXCL_ERROR> " << msg << endl;
+	this->parent->sendDbusErrorMsg (msg);
+}
+void
 NxclCallbacks::debug (string msg)
 {
 #if DEBUG==1
-	cout << "NXCL> " << msg << endl;
+	cout << "NXCL_DBG> " << msg << endl;
 #endif
 }
 void
@@ -182,7 +194,7 @@
 	}
 	if (DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER != ret) { 
 		/* What to do if someone else is running? Try another name? Exit? */
-		this->callbacks.write ("There appears to be another nxcl running, won't compete. Exiting.");
+		this->callbacks.error ("There appears to be another nxcl running, won't compete. Exiting.");
 		exit(1);
 	}
 	// Done getting connection to session bus
@@ -230,8 +242,7 @@
 	while (settings_transferred == false) {
 
 		if (dbus_error_is_set(&error)) { 
-			this->callbacks.write ("receiveSettings(): Got a dbus error");
-			dbus_error_free(&error); 
+			this->callbacks.error ("receiveSettings(): Got a dbus error");
 		}
 
 		// non blocking read of the next available message
@@ -240,7 +251,7 @@
 
 		// loop again if we haven't read a message
 		if (NULL == message) { 
-			//this->callbacks.write ("receiveSettings(): No message yet, sleep a second.");
+			//this->callbacks.debug ("receiveSettings(): No message yet, sleep a second.");
 			sleep(1);
 			continue;
 		}
@@ -319,7 +330,7 @@
 						this->sessionData.customCommand = ss.str();
 						break;
 					default:
-						this->callbacks.write ("ERROR: parameter type does not match its position in the message.");
+						this->callbacks.error ("ERROR: parameter type does not match its position in the message.");
 						break;
 					}
 					count++;
@@ -358,13 +369,13 @@
 						this->sessionData.fullscreen = (iparam>0) ? true : false;
 						break;
 					default:
-						this->callbacks.write ("ERROR: parameter type does not match its position in the message.");
+						this->callbacks.error ("ERROR: parameter type does not match its position in the message.");
 						break;
 					}
 					count++;
 
 				} else {
-					this->callbacks.write ("ERROR: parameter is not string or int.");
+					this->callbacks.error ("ERROR: parameter is not string or int.");
 				}
 			}
 			settings_transferred = true;			
@@ -448,7 +459,7 @@
 
 	/* If we have session info, start up the connection */
 	if (this->sessionData.key.size() == 0) { // Shouldn't need this->sessionData.encryption here.
-		this->callbacks.write (_("No key supplied! Please fix your client to send a key via dbus!"));
+		this->callbacks.error (_("No key supplied! Please fix your client to send a key via dbus!"));
 	} else {
 		this->nxclientlib.invokeNXSSH("supplied",
 					      this->nxserver,
@@ -539,12 +550,70 @@
 	DBusMessage *msg = dbus_message_new_signal ("/org/freenx/nxcl/dbus/AvailableSession",
 						    this->dbusSendInterface.c_str(),
 						    "ServerCapacityReached");
+	
+	dbus_connection_send (this->conn, msg, NULL);
+	dbus_message_unref (msg);
+}
 
+void
+Nxcl::sendDbusInfoMsg (string& info)
+{
+	DBusMessage *msg = dbus_message_new_signal ("/org/freenx/nxcl/dbus/SessionStatus",
+						    this->dbusSendInterface.c_str(),
+						    "InfoMessage");
+
+	/* Add info to msg*/
+	const char* infoptr = info.c_str();
+
+	// Bundle up the available session
+	dbus_message_append_args (msg,
+				  DBUS_TYPE_STRING, &infoptr,
+				  DBUS_TYPE_INVALID);
+
 	dbus_connection_send (this->conn, msg, NULL);
 	dbus_message_unref (msg);
 }
 
 void
+Nxcl::sendDbusInfoMsg (int num, string& info)
+{
+	DBusMessage *msg = dbus_message_new_signal ("/org/freenx/nxcl/dbus/SessionStatus",
+						    this->dbusSendInterface.c_str(),
+						    "InfoMessage");
+
+	/* Add info to msg*/
+	const char* infoptr = info.c_str();
+
+	// Bundle up the available session
+	dbus_message_append_args (msg,
+				  DBUS_TYPE_STRING, &infoptr,
+				  DBUS_TYPE_INT32, &num,
+				  DBUS_TYPE_INVALID);
+
+	dbus_connection_send (this->conn, msg, NULL);
+	dbus_message_unref (msg);
+}
+
+void
+Nxcl::sendDbusErrorMsg (string& errorMsg)
+{
+	DBusMessage *msg = dbus_message_new_signal ("/org/freenx/nxcl/dbus/SessionStatus",
+						    this->dbusSendInterface.c_str(),
+						    "ErrorMessage");
+
+	/* Add info to msg */
+	const char* errptr = errorMsg.c_str();
+
+	// Bundle up the available session
+	dbus_message_append_args (msg,
+				  DBUS_TYPE_STRING, &errptr,
+				  DBUS_TYPE_INVALID);
+
+	dbus_connection_send (this->conn, msg, NULL);
+	dbus_message_unref (msg);
+}
+
+void
 Nxcl::receiveStartInstruction (void)
 {
 	DBusMessage * message;
@@ -614,7 +683,7 @@
 void
 Nxcl::requestConfirmation (string msg)
 {
-	this->callbacks.write ("requestConfirmation(): This is a placeholder method "
+	this->callbacks.error ("WARNING: requestConfirmation(): This is a placeholder method "
 			       "to deal with sending back a yes "
 			       "or a no answer. For now, we just set "
 			       "this->nxclientlib.getSession().setContinue(true);");

Modified: nxcl/nxcl/nxcl.h
===================================================================
--- nxcl/nxcl/nxcl.h	2007-09-13 13:03:50 UTC (rev 377)
+++ nxcl/nxcl/nxcl.h	2007-09-13 21:35:33 UTC (rev 378)
@@ -51,6 +51,9 @@
 		virtual void haveResumableSessions (list<NXResumeData> resumeData) {}
 		virtual void noResumableSessions (void) {}
 		virtual void serverCapacityReached (void) {}
+		virtual void sendDbusInfoMsg (string&) {}
+		virtual void sendDbusInfoMsg (int, string&) {}
+		virtual void sendDbusErrorMsg (string&) {}
 	};
 
 	class NxclCallbacks : public NXClientLibExternalCallbacks
@@ -61,11 +64,30 @@
 
 		/*!
 		 * Send a message to the user. Here, this is
-		 * implemented as a message to stdout. It could be
-		 * (any may yet be) send on the dbus interface
+		 * implemented as a message sent on the dbus interface
+		 *
+		 * \param msg The message string to be sent
 		 */
 		void write (string msg);
 		/*!
+		 * Send a message to the user with a message
+		 * number. Here, this is implemented as a message sent
+		 * on the dbus interface
+		 * 
+		 * \param num A message number.This is for
+		 * transferring the NoMachine NX message number
+		 * accompanying the message. This number can be used
+		 * by the frontend client to determine the progress of
+		 * the session connection.
+		 *
+		 * \param msg The message string to be sent
+		 */
+		void write (int num, string msg);
+		/*!
+		 * Write an error message to stderr.
+		 */
+		void error (string msg);
+		/*!
 		 * Send a debugging message out. Here that's
 		 * implemented as a message on stdout.
 		 */
@@ -207,6 +229,23 @@
 		 * Called by \see NxclCallbacks::serverCapacitySignal
 		 */
 		void serverCapacityReached (void);
+		/*!
+		 * Send an informational status message - these are so
+		 * that the frontend client can show the user some
+		 * progress information in the UI.
+		 */
+		void sendDbusInfoMsg (string& info);
+		/*!
+		 * Send an informational status message - these are so
+		 * that the frontend client can show the user some
+		 * progress information in the UI. This one includes
+		 * the NX message number.
+		 */
+		void sendDbusInfoMsg (int num, string& info);
+		/*!
+		 * Send an error message via dbus.
+		 */
+		void sendDbusErrorMsg (string& errorMsg);
 		//@}
 
 		/*!



From sebjames at mail.berlios.de  Sun Sep 16 00:01:07 2007
From: sebjames at mail.berlios.de (sebjames at BerliOS)
Date: Sun, 16 Sep 2007 00:01:07 +0200
Subject: [Freenx-cvs] r379 - in nxcl: lib nxcl
Message-ID: <200709152201.l8FM17Un010351@sheep.berlios.de>

Author: sebjames
Date: 2007-09-16 00:01:07 +0200 (Sun, 16 Sep 2007)
New Revision: 379

Modified:
   nxcl/lib/nxclientlib.cpp
   nxcl/lib/nxclientlib.h
   nxcl/lib/nxdata.h
   nxcl/nxcl/main.cpp
   nxcl/nxcl/nxcl.cpp
Log:
1) Made nxcl send out a message saying "I'm alive" so that frontend client can catch this, then carry on with its business in the knowledge that nxcl is there to communicate with.

2) Made nxcl/nxclientlib classes chattier so that there is more progress information available to the frontend client

3) Added an integer field to the "write" callback for use by the frontend client, so that we don't base progress reports on bits of text which might in future be translated.

4) Added a few this-> keywords. One day I may go through the whole thing and add _all_ this-> keywords, because they're very helpful to new developers.



Modified: nxcl/lib/nxclientlib.cpp
===================================================================
--- nxcl/lib/nxclientlib.cpp	2007-09-13 21:35:33 UTC (rev 378)
+++ nxcl/lib/nxclientlib.cpp	2007-09-15 22:01:07 UTC (rev 379)
@@ -18,8 +18,8 @@
  *                                                                         *
  ***************************************************************************/
 #include "nxclientlib_i18n.h"
-
 #include "nxclientlib.h"
+#include "nxdata.h"
 
 #include <fstream>
 
@@ -53,13 +53,13 @@
 void
 NXClientLibCallbacks::startedSignal (string name)
 {
-	this->parent->externalCallbacks->write (name + _(" process started"));
+	this->parent->externalCallbacks->write (NXCL_PROCESS_STARTED, name + _(" process started"));
 }
 
 void
 NXClientLibCallbacks::processFinishedSignal (string name)
 {
-	this->parent->externalCallbacks->write (name + _(" process exited"));
+	this->parent->externalCallbacks->write (NXCL_PROCESS_EXITED, name + _(" process exited"));
 	parent->setIsFinished (true);
 }
 
@@ -139,10 +139,11 @@
 //@{
 NXClientLib::NXClientLib()
 {
-	isFinished = false;
-	readyForProxy = false;
-	proxyData.encrypted = false;
-	password = false;
+	this->isFinished = false;
+	this->readyForProxy = false;
+	this->sessionRunning = false;
+	this->proxyData.encrypted = false;
+	this->password = false;
 
 	dbgln ("In NXClientLib constructor");
 
@@ -161,7 +162,7 @@
 NXClientLib::~NXClientLib()
 {
 	dbgln ("In NXClientLib destructor");
-	nxsshProcess.terminate();
+	this->nxsshProcess.terminate();
 }
 
 void NXClientLib::invokeNXSSH (string publicKey, string serverHost, bool encryption, string key, int port)
@@ -259,7 +260,7 @@
 
 void NXClientLib::loginFailed()
 {
-	this->externalCallbacks->write (_("Got \"Login Failed\""));
+	this->externalCallbacks->write (NXCL_LOGIN_FAILED, _("Got \"Login Failed\""));
 	this->isFinished = true;
 	this->nxsshProcess.terminate();
 }
@@ -303,8 +304,10 @@
 
 	// If message 204 is picked, that's authentication failed.
 	if (response == 204) {
-		this->externalCallbacks->write (_("Got \"Authentication Failed\" from nxssh.\n"
-						  "Please check the certificate for the first SSL authentication stage,\n"
+		this->externalCallbacks->write (NXCL_AUTH_FAILED,
+						_("Got \"Authentication Failed\" from nxssh.\n"
+						  "Please check the certificate for the first SSL "
+						  "authentication stage,\n"
 						  "in which the \"nx\" user is authenticated."));
 		this->isFinished = true;
 		return;
@@ -312,8 +315,6 @@
 
 	// 147 is server capacity reached
 	if (response == 147) {
-		this->externalCallbacks->write (_("Got \"Server Capacity Reached\" from nxssh.\n"));
-		dbgln ("Got \"Server Capacity Reached\" from nxssh.");
 		this->externalCallbacks->serverCapacitySignal();
 		this->isFinished = true;
 		return;
@@ -340,13 +341,13 @@
 			switchCommand += ss.str();
 			this->write (switchCommand);
 		} else if ((*msgiter).find("NX> 287 Redirected I/O to channel descriptors") != string::npos) {
-			dbgln ("287 message found on stdout");
-			this->externalCallbacks->write(_("The session has been started successfully"));
+			this->externalCallbacks->write(287, _("The session has been started successfully"));
+			this->sessionRunning = true;
 		}
 
 		if ((*msgiter).find("Password") != string::npos) {
-			this->externalCallbacks->write(_("Authenticating with NX server"));
-			password = true;
+			this->externalCallbacks->write(NXCL_AUTHENTICATING, _("Authenticating with NX server"));
+			this->password = true;
 		}
 
 		if (!readyForProxy) {
@@ -391,18 +392,18 @@
 			this->write(switchCommand);
 
 		} else if ((*msgiter).find("NX> 287 Redirected I/O to channel descriptors") != string::npos) {
-			this->externalCallbacks->write(_("The session has been started successfully"));
+			this->externalCallbacks->write(287, _("The session has been started successfully"));
 
 		} else if ((*msgiter).find("NX> 209 Remote host identification has changed") != string::npos) {
-			this->externalCallbacks->write(_("SSH Host Key Problem"));
+			this->externalCallbacks->write(209, _("SSH Host Key Problem"));
 			this->isFinished = true;
 
 		} else if ((*msgiter).find("NX> 280 Ignoring EOF on the monitored channel") != string::npos) {
-			this->externalCallbacks->write(_("Got \"NX> 280 Ignoring EOF on the monitored channel\" from nxssh..."));
+			this->externalCallbacks->write(280, _("Got \"NX> 280 Ignoring EOF on the monitored channel\" from nxssh..."));
 			this->isFinished = true;
 
 		} else if ((*msgiter).find("Host key verification failed") != string::npos) {
-			this->externalCallbacks->write(_("SSH host key verification failed"));
+			this->externalCallbacks->write(NXCL_HOST_KEY_VERIFAILED, _("SSH host key verification failed"));
 			this->isFinished = true;			
 		}
 	}
@@ -458,42 +459,40 @@
 	dbgln ("NXClientLib::parseSSH called for message '" + message + "'");
 
 	if ((pos = message.find("NX> 700 Session id: ")) != string::npos) {
+		this->externalCallbacks->write (700, _("Got a session ID"));
 		proxyData.id = message.substr(pos+20, message.length()-pos);
-		dbgln ("proxyData.id = " + proxyData.id);
 	} else if ((pos = message.find("NX> 705 Session display: ")) != string::npos) {
 		stringstream portss;
 		int portnum;
 		portss << message.substr(pos+25, message.length()-pos);
 		portss >> portnum;		
 		proxyData.display = portnum;
-		dbgln ("proxyData.display = " << proxyData.display);
 		proxyData.port = portnum + 4000;
-		dbgln ("proxyData.port = " << proxyData.port);
 	} else if ((pos = message.find("NX> 706 Agent cookie: ")) != string::npos) {
 		proxyData.cookie = message.substr(pos+22, message.length()-pos);
-		dbgln ("proxyData.cookie = " + proxyData.cookie);
+		this->externalCallbacks->write (706, _("Got an agent cookie"));
 	} else if ((pos = message.find("NX> 702 Proxy IP: ")) != string::npos) {
 		proxyData.proxyIP = message.substr(pos+18, message.length()-pos);
-		dbgln ("proxyData.proxyIP = " + proxyData.proxyIP);
+		this->externalCallbacks->write (702, _("Got a proxy IP"));
 	} else if (message.find("NX> 707 SSL tunneling: 1") != string::npos) {
-		dbgln ("Setting proxyData.encrypted to true");
+		this->externalCallbacks->write (702, _("All data will be SSL tunnelled"));
 		proxyData.encrypted = true;
 	} else if (message.find("NX> 147 Server capacity") != string::npos) {
-		this->externalCallbacks->write (_("Got \"Server Capacity Reached\" from nxssh."));
+		this->externalCallbacks->write (147, _("Got \"Server Capacity Reached\" from nxssh."));
 		this->externalCallbacks->serverCapacitySignal();
 		this->isFinished = true;
 	} else if (message.find ("NX> 204 Authentication failed.") != string::npos) {
-		this->externalCallbacks->write (_("NX SSH Authentication Failed, finishing"));
+		this->externalCallbacks->write (204, _("NX SSH Authentication Failed, finishing"));
 		this->isFinished = true;
 	}
 
 	if (message.find("NX> 710 Session status: running") != string::npos) {
+		this->externalCallbacks->write (710, _("Session status is \"running\""));
 		invokeProxy();
 		session.wipeSessions();
 		rMessage = "bye\n";
 	}
 
-	dbgln ("NXClientLib::parseSSH returning");
 	return rMessage;
 }
 
@@ -501,7 +500,7 @@
 {
 	dbgln ("invokeProxy called");
 
-	this->externalCallbacks->write(100, _("Starting NX session"));
+	this->externalCallbacks->write(NXCL_INVOKE_PROXY, _("Starting NX session"));
 	
 	int e;
 	char * home;

Modified: nxcl/lib/nxclientlib.h
===================================================================
--- nxcl/lib/nxclientlib.h	2007-09-13 21:35:33 UTC (rev 378)
+++ nxcl/lib/nxclientlib.h	2007-09-15 22:01:07 UTC (rev 379)
@@ -28,6 +28,7 @@
 #include <list>
 #include "notQt.h"
 
+
 using namespace std;
 
 namespace nxcl {
@@ -269,6 +270,7 @@
 		NXSession* getSession (void) { return &this->session; }
 		void setIsFinished (bool status) { this->isFinished = status; }
 		void setExternalCallbacks (NXClientLibExternalCallbacks * cb) { this->externalCallbacks = cb; }
+		bool getSessionRunning (void) { return this->sessionRunning; }
 		//@}
 
 	private:
@@ -283,6 +285,13 @@
 		 */
 		bool readyForProxy;
 		/*!
+		 * Set true when the NX session is under way. This
+		 * means we can reduce the polling frequency right
+		 * down to a level which won't impact on power
+		 * consumption.
+		 */
+		bool sessionRunning;
+		/*!
 		 * Have we said we need to enter a password?
 		 */
 		bool password;

Modified: nxcl/lib/nxdata.h
===================================================================
--- nxcl/lib/nxdata.h	2007-09-13 21:35:33 UTC (rev 378)
+++ nxcl/lib/nxdata.h	2007-09-15 22:01:07 UTC (rev 379)
@@ -23,6 +23,21 @@
 
 #include <string>
 
+/*!
+ * Some definitions of numbers that we can send over to the frontend
+ * client to tell it how we're getting along with the connection...
+ */
+#define NXCL_PROCESS_STARTED        1000001
+#define NXCL_PROCESS_EXITED         1000002
+#define NXCL_AUTH_FAILED            1000003
+#define NXCL_AUTHENTICATING         1000004
+#define NXCL_LOGIN_FAILED           1000005
+#define NXCL_HOST_KEY_VERIFAILED    1000006
+#define NXCL_INVOKE_PROXY           1000007
+#define NXCL_STARTING               1000008
+#define NXCL_FINISHED               1000009
+#define NXCL_ALIVE                  1000010
+
 using namespace std;
 
 namespace nxcl {

Modified: nxcl/nxcl/main.cpp
===================================================================
--- nxcl/nxcl/main.cpp	2007-09-13 21:35:33 UTC (rev 378)
+++ nxcl/nxcl/main.cpp	2007-09-15 22:01:07 UTC (rev 379)
@@ -31,8 +31,10 @@
  */
 
 #include "../config.h"
+#include "nxclientlib_i18n.h"
 #include "nxclientlib.h"
 #include "nxcl.h"
+#include "nxdata.h"
 #include <fstream>
 
 /* This define is required for slightly older versions of dbus as
@@ -65,11 +67,11 @@
 
 	debugLogFile.open("/tmp/nxcl.log", ios::out|ios::trunc);
 	if (!debugLogFile.is_open()) {
-		nxcl.callbacks.write ("Odd, couldn't open /tmp/nxcl.log");
+		nxcl.callbacks.error ("Odd, couldn't open /tmp/nxcl.log");
 	}
 
 	if (argc!=2) {
-		nxcl.callbacks.write ("This program is usually executed by another program. "
+		nxcl.callbacks.error ("This program is usually executed by another program. "
 				      "Trying to execute it alone is probably not the right "
 				      "thing to do, unless you are sure it is. Provide a single "
 				      "argument - the identifier for the dbus messages");
@@ -82,20 +84,29 @@
 	ss >> id;
 	nxcl.setupDbus(id);
 
+	// Send a message to the frontend client to say we are up and running
+	nxcl.callbacks.write (NXCL_ALIVE, _("nxcl is up and running"));
+
 	if (-1 == (nxcl.receiveSettings())) {
 		cerr << "Failed to obtain server and user for the session." << endl;
 		return -1;
 	}
 
+	nxcl.callbacks.write (NXCL_STARTING, _("Connection is starting..."));
 	nxcl.startTheNXConnection();
 
 	NXClientLib* c = nxcl.getNXClientLib();
-	while (probeNXCL(c) == true) {
+	while (probeNXCL(c) == true && !c->getSessionRunning()) {
 		usleep (30000); // 3 100ths of a second => about 30 
-                                // probes a second (a lot).
+                                // probes a second. This will impact on power consumption.
 	}
 
-	nxcl.callbacks.write ("Program finished.");
+	// Now the process has started, reduce polling.
+	while (probeNXCL(c) == true) {
+		usleep (2000000); // poll once every 2 seconds.
+	}
+
+	nxcl.callbacks.write (NXCL_FINISHED, _("Program finished."));
 	debugLogFile.close();
 	return 0;
 }

Modified: nxcl/nxcl/nxcl.cpp
===================================================================
--- nxcl/nxcl/nxcl.cpp	2007-09-13 21:35:33 UTC (rev 378)
+++ nxcl/nxcl/nxcl.cpp	2007-09-15 22:01:07 UTC (rev 379)
@@ -48,7 +48,6 @@
 void
 NxclCallbacks::write (string msg)
 {
-//	cout << "NXCL> " << msg << endl;
 	this->parent->sendDbusInfoMsg (msg);
 }
 void
@@ -252,7 +251,7 @@
 		// loop again if we haven't read a message
 		if (NULL == message) { 
 			//this->callbacks.debug ("receiveSettings(): No message yet, sleep a second.");
-			sleep(1);
+			usleep(1000000);
 			continue;
 		}
 
@@ -500,6 +499,8 @@
 	list<NXResumeData>::iterator it;
 	for (it=resumable.begin(); it!=resumable.end(); it++) {
 
+		this->callbacks.debug ("Sending a session..");
+
 		DBusMessage *message;
 
 		/* Create a new signal "AvailableSession" on the
@@ -633,7 +634,7 @@
 
 		// loop again if we haven't read a message
 		if (NULL == message) { 
-			sleep(1);
+			usleep(1000000);
 			continue;
 		}
 



From sebjames at mail.berlios.de  Sun Sep 16 22:16:05 2007
From: sebjames at mail.berlios.de (sebjames at BerliOS)
Date: Sun, 16 Sep 2007 22:16:05 +0200
Subject: [Freenx-cvs] r380 - in nxcl: lib nxcl
Message-ID: <200709162016.l8GKG5i2013868@sheep.berlios.de>

Author: sebjames
Date: 2007-09-16 22:16:05 +0200 (Sun, 16 Sep 2007)
New Revision: 380

Modified:
   nxcl/lib/nxclientlib.cpp
   nxcl/lib/nxclientlib.h
   nxcl/lib/nxdata.h
   nxcl/nxcl/nxcl.cpp
Log:
Now do runtime checks to find suitable nxproxy and nxssh programs to 
run. nxproxy and nxssh can be in teh same bin directory that nxcl is 
installed in (first choice) or /usr/local/bin or /usr/bin or /usr/NX/bin 
or /bin.


Modified: nxcl/lib/nxclientlib.cpp
===================================================================
--- nxcl/lib/nxclientlib.cpp	2007-09-15 22:01:07 UTC (rev 379)
+++ nxcl/lib/nxclientlib.cpp	2007-09-16 20:16:05 UTC (rev 380)
@@ -24,7 +24,10 @@
 #include <fstream>
 
 extern "C" {
-#include "errno.h"
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
 }
 
 /*
@@ -178,9 +181,7 @@
 
 	// Start to build the arguments for the nxssh command.
 	// notQProcess requires that argv[0] contains the program name
-	// FIXME: Here, I place the PACKAGE_BIN_DIR path in front of
-	// nxssh, but nxssh may be installed in a different prefix...
-	arguments.push_back (PACKAGE_BIN_DIR"/nxssh");
+	arguments.push_back ("nxssh");
 	
 	argtmp << "-nx";
 	arguments.push_back (argtmp.str());
@@ -235,10 +236,12 @@
 	// ...so there you have the meaning.
 	arguments.push_back ("-E");
 	
-	this->nxsshProcess.start (PACKAGE_BIN_DIR"/nxssh", arguments);
-
-	if (nxsshProcess.waitForStarted() == false) {
-		dbgln ("nx ssh process didn't start :(");
+	// Find a path for the nxssh process using getPath()
+	string nxsshPath = this->getPath ("nxssh");
+	this->nxsshProcess.start(nxsshPath, arguments);
+	if (this->nxsshProcess.waitForStarted() == false) {
+		this->externalCallbacks->write (NXCL_PROCESS_ERROR, _("Error starting nxssh!"));
+		this->isFinished = true;
 	}
 }
 
@@ -498,8 +501,6 @@
 
 void NXClientLib::invokeProxy()
 {
-	dbgln ("invokeProxy called");
-
 	this->externalCallbacks->write(NXCL_INVOKE_PROXY, _("Starting NX session"));
 	
 	int e;
@@ -552,18 +553,19 @@
 
 	// Build arguments for the call to the nxproxy command
 	list<string> arguments;
-	arguments.push_back(PACKAGE_BIN_DIR"/nxproxy"); // argv[0] has to be the program name
+	arguments.push_back("nxproxy"); // argv[0] has to be the program name
 	arguments.push_back("-S");
 	ss.str("");
 	ss << "options=" << nxdir;
 	ss << ":" << proxyData.display;
 	arguments.push_back(ss.str());	
 
-	// This is of type notQProcess.
-	this->nxproxyProcess.start(PACKAGE_BIN_DIR"/nxproxy", arguments);
-
-	if (nxproxyProcess.waitForStarted() == false) {
-		dbgln ("nxproxy process didn't start :(");
+	// Find a path for the nxproxy process using getPath()
+	string nxproxyPath = this->getPath ("nxproxy");
+	this->nxproxyProcess.start(nxproxyPath, arguments);
+	if (this->nxproxyProcess.waitForStarted() == false) {
+		this->externalCallbacks->write (NXCL_PROCESS_ERROR, _("Error starting nxproxy!"));
+		this->isFinished = true;
 	}
 }
 
@@ -576,4 +578,61 @@
 {
 	return (this->session.terminateSession(n));
 }
+
+string NXClientLib::getPath (string prog)
+{
+	string path;
+	struct stat * buf;
+
+	buf = static_cast<struct stat*>(malloc (sizeof (struct stat)));
+	if (!buf) {
+		// Malloc error.
+		return prog;
+	}
+
+	path = PACKAGE_BIN_DIR"/" + prog;
+	memset (buf, 0, sizeof(struct stat));
+	stat (path.c_str(), buf);
+	if (S_ISREG (buf->st_mode) || S_ISLNK (buf->st_mode)) {
+		// Found prog in PACKAGE_BIN_DIR
+	} else {
+		path = "/usr/local/bin/" + prog;
+		memset (buf, 0, sizeof(struct stat));
+		stat (path.c_str(), buf);
+		if (S_ISREG (buf->st_mode) || S_ISLNK (buf->st_mode)) {
+			// Found prog in /usr/local/bin
+		} else {
+			path = "/usr/bin/" + prog;
+			memset (buf, 0, sizeof(struct stat));
+			stat (path.c_str(), buf);
+			if (S_ISREG (buf->st_mode) || 
+			    S_ISLNK (buf->st_mode)) {
+				// Found prog in /usr/bin
+			} else {
+				path = "/usr/NX/bin/" + prog;
+				memset (buf, 0, sizeof(struct stat));
+				stat (path.c_str(), buf);
+				if (S_ISREG (buf->st_mode) || 
+				    S_ISLNK (buf->st_mode)) {
+
+				} else {
+					path = "/bin/" + prog;
+					memset (buf, 0, sizeof(struct stat));
+					stat (path.c_str(), buf);
+					if (S_ISREG (buf->st_mode) || 
+					    S_ISLNK (buf->st_mode)) {
+						// Found prog in /bin
+					} else {
+						// Just return the
+						// prog name.
+						path = prog;
+					}
+				}
+			}
+		}
+	}
+
+	free (buf);
+	return path;
+}
 //@}

Modified: nxcl/lib/nxclientlib.h
===================================================================
--- nxcl/lib/nxclientlib.h	2007-09-15 22:01:07 UTC (rev 379)
+++ nxcl/lib/nxclientlib.h	2007-09-16 20:16:05 UTC (rev 380)
@@ -275,6 +275,17 @@
 
 	private:
 		/*!
+		 * Try a number of different paths to try to find the
+		 * program prog's full path.
+		 *
+		 * \param prog The program to find, likely to be nxssh
+		 * or nxproxy.
+		 *
+		 * \return The full path; e.g. /usr/bin/nxssh
+		 */
+		string getPath (string prog);
+
+		/*!
 		 * Set true when the program is ready to end, e.g if
 		 * authentication failed, nxssh failed to start amoung
 		 * other reasons.

Modified: nxcl/lib/nxdata.h
===================================================================
--- nxcl/lib/nxdata.h	2007-09-15 22:01:07 UTC (rev 379)
+++ nxcl/lib/nxdata.h	2007-09-16 20:16:05 UTC (rev 380)
@@ -37,6 +37,7 @@
 #define NXCL_STARTING               1000008
 #define NXCL_FINISHED               1000009
 #define NXCL_ALIVE                  1000010
+#define NXCL_PROCESS_ERROR          1000011
 
 using namespace std;
 

Modified: nxcl/nxcl/nxcl.cpp
===================================================================
--- nxcl/nxcl/nxcl.cpp	2007-09-15 22:01:07 UTC (rev 379)
+++ nxcl/nxcl/nxcl.cpp	2007-09-16 20:16:05 UTC (rev 380)
@@ -434,13 +434,14 @@
 void
 Nxcl::startTheNXConnection (void)
 {
-	// First things first; set the sessionData. FIXME: Should check if sessionData has been set.
+	// First things first; set the sessionData.
+	// FIXME: Should check if this->sessionData has been set.
 	this->nxclientlib.setSessionData (&this->sessionData);
 
 	this->nxclientlib.setUsername (this->nxuser);
 	this->nxclientlib.setPassword (this->nxpass);
 
-	// FIXME: Need to pull in res from the dbus message or probe for it.	
+	// Probe for X display resolution in nxcl.
 	this->nxclientlib.setResolution (this->xRes, this->yRes); 
                                                // This is the size of
                                                // your screen... We need



From sebjames at mail.berlios.de  Mon Sep 17 16:13:40 2007
From: sebjames at mail.berlios.de (sebjames at BerliOS)
Date: Mon, 17 Sep 2007 16:13:40 +0200
Subject: [Freenx-cvs] r382 - nxlaunch/src
Message-ID: <200709171413.l8HEDeE4028270@sheep.berlios.de>

Author: sebjames
Date: 2007-09-17 16:13:40 +0200 (Mon, 17 Sep 2007)
New Revision: 382

Modified:
   nxlaunch/src/nxconfig.glade
Log:
Whoops - had NoMachine in the title of the config window. Removed.


Modified: nxlaunch/src/nxconfig.glade
===================================================================
--- nxlaunch/src/nxconfig.glade	2007-09-17 12:30:56 UTC (rev 381)
+++ nxlaunch/src/nxconfig.glade	2007-09-17 14:13:40 UTC (rev 382)
@@ -5,7 +5,7 @@
 <requires lib="gnome"/>
 
 <widget class="GtkDialog" id="conn_new_nx">
-  <property name="title" translatable="yes">NoMachine NX Connection Details</property>
+  <property name="title" translatable="yes">NX Connection Details</property>
   <property name="type">GTK_WINDOW_TOPLEVEL</property>
   <property name="window_position">GTK_WIN_POS_CENTER_ON_PARENT</property>
   <property name="modal">True</property>



From sebjames at mail.berlios.de  Mon Sep 17 17:10:06 2007
From: sebjames at mail.berlios.de (sebjames at BerliOS)
Date: Mon, 17 Sep 2007 17:10:06 +0200
Subject: [Freenx-cvs] r383 - nxlaunch/src
Message-ID: <200709171510.l8HFA6AI030975@sheep.berlios.de>

Author: sebjames
Date: 2007-09-17 17:10:05 +0200 (Mon, 17 Sep 2007)
New Revision: 383

Modified:
   nxlaunch/src/nxconfig.glade
   nxlaunch/src/nxlaunch.c
   nxlaunch/src/nxlaunch.h
Log:
Fixed the edit connection feature and implemented the delete connection feature.


Modified: nxlaunch/src/nxconfig.glade
===================================================================
--- nxlaunch/src/nxconfig.glade	2007-09-17 14:13:40 UTC (rev 382)
+++ nxlaunch/src/nxconfig.glade	2007-09-17 15:10:05 UTC (rev 383)
@@ -1957,4 +1957,91 @@
   </child>
 </widget>
 
+<widget class="GtkDialog" id="confirm_delete">
+  <property name="title" translatable="yes">Confirm delete</property>
+  <property name="type">GTK_WINDOW_TOPLEVEL</property>
+  <property name="window_position">GTK_WIN_POS_CENTER_ON_PARENT</property>
+  <property name="modal">False</property>
+  <property name="resizable">True</property>
+  <property name="destroy_with_parent">False</property>
+  <property name="icon">nx-icon.png</property>
+  <property name="decorated">True</property>
+  <property name="skip_taskbar_hint">False</property>
+  <property name="skip_pager_hint">False</property>
+  <property name="type_hint">GDK_WINDOW_TYPE_HINT_DIALOG</property>
+  <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
+  <property name="has_separator">True</property>
+
+  <child internal-child="vbox">
+    <widget class="GtkVBox" id="dialog-vbox8">
+      <property name="visible">True</property>
+      <property name="homogeneous">False</property>
+      <property name="spacing">0</property>
+
+      <child internal-child="action_area">
+	<widget class="GtkHButtonBox" id="dialog-action_area8">
+	  <property name="visible">True</property>
+	  <property name="layout_style">GTK_BUTTONBOX_END</property>
+
+	  <child>
+	    <widget class="GtkButton" id="cancelbutton1">
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-cancel</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <property name="response_id">-6</property>
+	      <signal name="clicked" handler="gtk_widget_hide" object="confirm_delete" last_modification_time="Mon, 17 Sep 2007 14:58:26 GMT"/>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkButton" id="okbutton1">
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-ok</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <property name="response_id">-5</property>
+	      <signal name="clicked" handler="on_button_confirm_delete_clicked" last_modification_time="Mon, 17 Sep 2007 14:58:41 GMT"/>
+	      <signal name="clicked" handler="gtk_widget_hide" object="confirm_delete" last_modification_time="Mon, 17 Sep 2007 14:58:52 GMT"/>
+	    </widget>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">True</property>
+	  <property name="pack_type">GTK_PACK_END</property>
+	</packing>
+      </child>
+
+      <child>
+	<widget class="GtkLabel" id="label_confirm_delete">
+	  <property name="visible">True</property>
+	  <property name="label" translatable="yes">Please confirm that you want to delete that connection.</property>
+	  <property name="use_underline">False</property>
+	  <property name="use_markup">False</property>
+	  <property name="justify">GTK_JUSTIFY_LEFT</property>
+	  <property name="wrap">True</property>
+	  <property name="selectable">False</property>
+	  <property name="xalign">0.5</property>
+	  <property name="yalign">0.5</property>
+	  <property name="xpad">8</property>
+	  <property name="ypad">13</property>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">False</property>
+	</packing>
+      </child>
+    </widget>
+  </child>
+</widget>
+
 </glade-interface>

Modified: nxlaunch/src/nxlaunch.c
===================================================================
--- nxlaunch/src/nxlaunch.c	2007-09-17 14:13:40 UTC (rev 382)
+++ nxlaunch/src/nxlaunch.c	2007-09-17 15:10:05 UTC (rev 383)
@@ -204,7 +204,7 @@
 
 	// Read in nx_conn for the highlighted entry
 	nx_conn = g_malloc0 (sizeof (struct nx_connection));
-	getActiveConnection (nx_conn);
+	getActiveConnection (nx_conn);	
 	setup_nx_popup (nx_conn);
 	nx_connection_free (nx_conn);
 
@@ -213,10 +213,42 @@
 
 void on_button_nxlaunch_delete_clicked (GtkButton * button)
 {
-	printerr ("%s\n", __FUNCTION__);
+	GtkWidget * widget;
+	widget = glade_xml_get_widget (xml_glob, "confirm_delete");
+	gtk_widget_show_all (widget);
 	return;
 }
 
+void on_button_confirm_delete_clicked (GtkButton * button)
+{
+	GtkTreeView * list_tree;
+	GtkTreeSelection * selected;
+	GtkTreeIter iter;
+	GtkTreeModel * tree_model;
+	gchar * name;
+
+	/* Get iter for current row and update connection list. */
+	list_tree = GTK_TREE_VIEW (glade_xml_get_widget (xml_nxlaunch_glob, "treeview_nxconnection"));
+	selected = gtk_tree_view_get_selection (list_tree);
+	tree_model = GTK_TREE_MODEL (conn_store);
+	if (gtk_tree_selection_get_selected (selected, &tree_model, &iter)) {
+		/* Get connection name */
+		gtk_tree_model_get (tree_model, &iter, CONN_CONNECTIONNAME, &name, -1);
+
+		/* delete the row */
+		if (FALSE == gtk_list_store_remove (conn_store, &iter)) {
+			printerr ("NXLAUNCH> Failed to remove that row..\n");
+		}
+	}
+
+	/* Unlink the connection file */
+	delete_nx_connection (name);
+
+	if (name) { g_free (name); }
+
+	return;
+}
+
 void on_conn_new_ok_clicked (GtkButton * button)
 {
 	GtkTreeView * list_tree;
@@ -279,6 +311,9 @@
 				    -1);
 	}
 
+	/* Re-write the connection to the xml file */
+	write_nx_connection (nx_conn);
+
 	nx_connection_free (nx_conn);
 	return;
 }

Modified: nxlaunch/src/nxlaunch.h
===================================================================
--- nxlaunch/src/nxlaunch.h	2007-09-17 14:13:40 UTC (rev 382)
+++ nxlaunch/src/nxlaunch.h	2007-09-17 15:10:05 UTC (rev 383)
@@ -163,6 +163,7 @@
 void on_button_nxlaunch_new_clicked (GtkButton * button);
 void on_button_nxlaunch_edit_clicked (GtkButton * button);
 void on_button_nxlaunch_delete_clicked (GtkButton * button);
+void on_button_confirm_delete_clicked (GtkButton * button);
 /*!
  * Called when the OK button is clicked in the config window. On this
  * callback we need to read the data from the window into an nx_conn



From sebjames at mail.berlios.de  Mon Sep 17 22:50:22 2007
From: sebjames at mail.berlios.de (sebjames at BerliOS)
Date: Mon, 17 Sep 2007 22:50:22 +0200
Subject: [Freenx-cvs] r384 - in nxcl: lib nxcl
Message-ID: <200709172050.l8HKoMjn003376@sheep.berlios.de>

Author: sebjames
Date: 2007-09-17 22:50:22 +0200 (Mon, 17 Sep 2007)
New Revision: 384

Modified:
   nxcl/lib/nxdata.h
   nxcl/lib/nxsession.cpp
   nxcl/nxcl/nxcl.cpp
Log:
Fixed console and custom command applications. Added virtualDesktop boolean to sessions - this is important when you 
run a console or a custom command.



Modified: nxcl/lib/nxdata.h
===================================================================
--- nxcl/lib/nxdata.h	2007-09-17 15:10:05 UTC (rev 383)
+++ nxcl/lib/nxdata.h	2007-09-17 20:50:22 UTC (rev 384)
@@ -68,6 +68,7 @@
 		string key;
 		bool encryption;
 		bool fullscreen;
+		bool virtualDesktop;
 		string customCommand;
 	};
 
@@ -93,6 +94,7 @@
 		string key;
 		bool encryption;
 		bool fullscreen;
+		bool virtualDesktop;
 		string customCommand;
 		bool suspended;
 		int xRes;

Modified: nxcl/lib/nxsession.cpp
===================================================================
--- nxcl/lib/nxsession.cpp	2007-09-17 15:10:05 UTC (rev 383)
+++ nxcl/lib/nxsession.cpp	2007-09-17 20:50:22 UTC (rev 384)
@@ -317,8 +317,24 @@
 						"\" --agent_server=\"" << this->sessionData->agentServer <<
 						"\" --agent_user=\"" << this->sessionData->agentUser <<
 						"\" --agent_password=\"" << this->sessionData->agentPass << "\"";
+					ss << " --title=\"sebtest\""; // testing a window title
 					if (this->sessionData->sessionType == "unix-application") {
 						ss << " --application=\"" << this->sessionData->customCommand << "\"";
+						if (this->sessionData->virtualDesktop == true) {
+							ss << " --rootless=\"0\" --virtualdesktop=\"1\"";
+						} else {
+							ss << " --rootless=\"1\" --virtualdesktop=\"0\"";
+						}
+
+					} else if (this->sessionData->sessionType == "unix-console") {
+						if (this->sessionData->virtualDesktop == true) {
+							ss << " --rootless=\"0\" --virtualdesktop=\"1\"";
+						} else {
+							ss << " --rootless=\"1\" --virtualdesktop=\"0\"";
+						}
+
+					} else if (this->sessionData->sessionType == "unix-default") {
+						// ignore this - does anyone use it?
 					}
 					returnMessage = ss.str();
 					dbgln ("session parameter command: " + ss.str());

Modified: nxcl/nxcl/nxcl.cpp
===================================================================
--- nxcl/nxcl/nxcl.cpp	2007-09-17 15:10:05 UTC (rev 383)
+++ nxcl/nxcl/nxcl.cpp	2007-09-17 20:50:22 UTC (rev 384)
@@ -367,6 +367,9 @@
 					case 23:
 						this->sessionData.fullscreen = (iparam>0) ? true : false;
 						break;
+					case 25:
+						this->sessionData.virtualDesktop = (iparam>0) ? true : false;
+						break;
 					default:
 						this->callbacks.error ("ERROR: parameter type does not match its position in the message.");
 						break;
@@ -427,6 +430,7 @@
 	this->sessionData.suspended = false;
 	this->sessionData.fullscreen = false; // If true, session.geometry
 					  // is ignored
+	this->sessionData.virtualDesktop = false;
 
 	return;
 }



From sebjames at mail.berlios.de  Mon Sep 17 23:05:25 2007
From: sebjames at mail.berlios.de (sebjames at BerliOS)
Date: Mon, 17 Sep 2007 23:05:25 +0200
Subject: [Freenx-cvs] r385 - nxcl
Message-ID: <200709172105.l8HL5PE1004093@sheep.berlios.de>

Author: sebjames
Date: 2007-09-17 23:05:25 +0200 (Mon, 17 Sep 2007)
New Revision: 385

Modified:
   nxcl/README
Log:
Added a note to help with compiling


Modified: nxcl/README
===================================================================
--- nxcl/README	2007-09-17 20:50:22 UTC (rev 384)
+++ nxcl/README	2007-09-17 21:05:25 UTC (rev 385)
@@ -32,3 +32,15 @@
 
 Look at nxcl.cpp/h if you want to write an NX client which links
 directly to libnxcl.
+
+Building:
+
+If you checked out the svn code, you need to do:
+
+autoconf -is
+
+then:
+
+./configure [--enable-debug-output]
+make
+make install



From sebjames at mail.berlios.de  Mon Sep 17 23:06:25 2007
From: sebjames at mail.berlios.de (sebjames at BerliOS)
Date: Mon, 17 Sep 2007 23:06:25 +0200
Subject: [Freenx-cvs] r386 - in nxlaunch: . lib src
Message-ID: <200709172106.l8HL6PEx004144@sheep.berlios.de>

Author: sebjames
Date: 2007-09-17 23:06:24 +0200 (Mon, 17 Sep 2007)
New Revision: 386

Modified:
   nxlaunch/README
   nxlaunch/lib/callbacks_nx.c
   nxlaunch/lib/callbacks_nx.h
   nxlaunch/src/main.c
   nxlaunch/src/nxconfig.glade
   nxlaunch/src/nxlaunch.c
   nxlaunch/src/nxlaunch.h
Log:
Fixed support for console and standalone applications and started working towards Windows, VNC and Shadow support 
(these are supported in nxcl, but a bit more work is required in nxlaunch yet).


Modified: nxlaunch/README
===================================================================
--- nxlaunch/README	2007-09-17 21:05:25 UTC (rev 385)
+++ nxlaunch/README	2007-09-17 21:06:24 UTC (rev 386)
@@ -13,3 +13,15 @@
 It would be quite possible to write a GTK client which links directly
 to the nxcl library, but that is left as a further exercise for
 someone.
+
+Building:
+
+If you checked out the svn code, you need to do:
+
+autoconf -is
+
+then:
+
+./configure [--enable-debug-output]
+make
+make install

Modified: nxlaunch/lib/callbacks_nx.c
===================================================================
--- nxlaunch/lib/callbacks_nx.c	2007-09-17 21:05:25 UTC (rev 385)
+++ nxlaunch/lib/callbacks_nx.c	2007-09-17 21:06:24 UTC (rev 386)
@@ -61,7 +61,7 @@
 		valid = gtk_tree_model_iter_next (GTK_TREE_MODEL (prog_list), &iter);
 	}
 
-	/* FIXME: new_iter undefined if no match is found */
+	/* new_iter undefined if no match is found */
 	if (have_match == TRUE) {
 		gtk_combo_box_set_active_iter (GTK_COMBO_BOX (widget), &new_iter);		
 	} else {
@@ -320,6 +320,8 @@
 
 	/* hardcoded options */
 	if (new_config_file == TRUE) {
+		/* FIXME: This needs to be fixed to match the system
+		   it was compiled for */
 		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
 		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "CUPSD path");
 		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "/usr/sbin/cupsd");
@@ -332,12 +334,7 @@
 		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Backingstore");
 		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "when_requested");
 
-		/* We don't use NX for vnc or rdp sessions so this is hardcoded to "unix" */
 		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
-		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Session");
-		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "unix"); 
-
-		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
 		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Use render");
 		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "true");
 
@@ -350,6 +347,10 @@
 	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
 	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Desktop");
 	xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST nx_conn->Desktop);
+
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Session");
+	xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST nx_conn->Session);
 	
 	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
 	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Custom Unix Desktop");
@@ -671,6 +672,9 @@
 			else if ((!xmlStrcmp (option_key, BAD_CAST "Desktop"))) {
 				strncpy (nx_conn->Desktop, (gchar *) xmlGetProp (cur, BAD_CAST "value"), NX_FIELDLEN-1);
 			}
+			else if ((!xmlStrcmp (option_key, BAD_CAST "Session"))) {
+				strncpy (nx_conn->Session, (gchar *) xmlGetProp (cur, BAD_CAST "value"), NX_FIELDLEN-1);
+			}
 			else if ((!xmlStrcmp (option_key, BAD_CAST "Custom Unix Desktop"))) {
 				strncpy (nx_conn->CustomUnixDesktop, (gchar *) xmlGetProp (cur, BAD_CAST "value"), NX_FIELDLEN-1);
 			}
@@ -1175,6 +1179,7 @@
 	nx_conn->Geometry = g_malloc0 (NX_FIELDLEN * sizeof(gchar));
 	nx_conn->LinkSpeed = g_malloc0 (NX_FIELDLEN * sizeof(gchar));
 	nx_conn->Desktop = g_malloc0 (NX_FIELDLEN * sizeof(gchar));
+	nx_conn->Session = g_malloc0 (NX_FIELDLEN * sizeof(gchar));
 	nx_conn->CustomUnixDesktop = g_malloc0 (NX_FIELDLEN * sizeof(gchar));
 	nx_conn->XdmMode = g_malloc0 (NX_FIELDLEN * sizeof(gchar));
 	nx_conn->XdmHost = g_malloc0 (NX_FIELDLEN * sizeof(gchar));
@@ -1199,6 +1204,7 @@
 	strcpy (nx_conn->Pass, "");
 	strcpy (nx_conn->LinkSpeed, "wan");
 	strcpy (nx_conn->Desktop, "kde");
+	strcpy (nx_conn->Session, "unix");
 	strcpy (nx_conn->CustomUnixDesktop, "console");
 	strncpy (nx_conn->PublicKey, NXDefaultKey, SSLKEYLEN-1); /* Set to default */
 	strcpy (nx_conn->CommandLine, "");
@@ -1246,6 +1252,8 @@
 		g_free (nx_conn->LinkSpeed);
 	if (nx_conn->Desktop)
 		g_free (nx_conn->Desktop);
+	if (nx_conn->Session)
+		g_free (nx_conn->Session);
 	if (nx_conn->CustomUnixDesktop)
 		g_free (nx_conn->CustomUnixDesktop);
 	if (nx_conn->PublicKey)
@@ -1327,37 +1335,51 @@
 
 	widget = glade_xml_get_widget (xml_glob, "combobox_nx_desktop_session");
 
-	if (!strncmp (nx_conn->Desktop, "kde", NX_FIELDLEN)) {
-		set_combobox (widget, "KDE");
+	if (!strncmp (nx_conn->Session, "unix", NX_FIELDLEN)) {
 
-	} else 	if (!strncmp (nx_conn->Desktop, "gnome", NX_FIELDLEN)) {
-		set_combobox (widget, "GNOME");
+		// Unix sessions
+		if (!strncmp (nx_conn->Desktop, "kde", NX_FIELDLEN)) {
+			set_combobox (widget, "KDE");
 
-	} else 	if (!strncmp (nx_conn->Desktop, "cde", NX_FIELDLEN)) {
-		set_combobox (widget, "CDE");
+		} else 	if (!strncmp (nx_conn->Desktop, "gnome", NX_FIELDLEN)) {
+			set_combobox (widget, "GNOME");
 
-	} else 	if (!strncmp (nx_conn->Desktop, "xdm", NX_FIELDLEN)) {
-		set_combobox (widget, "XDM");
+		} else 	if (!strncmp (nx_conn->Desktop, "cde", NX_FIELDLEN)) {
+			set_combobox (widget, "CDE");
 
-	} else 	if (!strncmp (nx_conn->Desktop, "console", NX_FIELDLEN)) {
+		} else 	if (!strncmp (nx_conn->Desktop, "xdm", NX_FIELDLEN)) {
+			set_combobox (widget, "XDM");
 
-		if (!strncmp (nx_conn->CustomUnixDesktop, "console", NX_FIELDLEN)) {
+		} else 	if (!strncmp (nx_conn->Desktop, "console", NX_FIELDLEN)) {
 
-			set_combobox (widget, _("Console"));
+			if (!strncmp (nx_conn->CustomUnixDesktop, "console", NX_FIELDLEN)) {
 
-		} else if (!strncmp (nx_conn->CustomUnixDesktop, "default", NX_FIELDLEN)) {
+				set_combobox (widget, _("Console"));
 
-			set_combobox (widget, _("Default X client script on server"));
+			} else if (!strncmp (nx_conn->CustomUnixDesktop, "default", NX_FIELDLEN)) {
 
-		} else if (!strncmp (nx_conn->CustomUnixDesktop, "application", NX_FIELDLEN)) {
+				set_combobox (widget, _("Default X client script on server"));
 
-			set_combobox (widget, _("Custom command"));
+			} else if (!strncmp (nx_conn->CustomUnixDesktop, "application", NX_FIELDLEN)) {
+
+				set_combobox (widget, _("Custom command"));
+			} else {
+				set_combobox (widget, _("Console"));
+			}
+
 		} else {
-			set_combobox (widget, _("Console"));
+			set_combobox (widget, "KDE");
 		}
 
-	} else {
-		set_combobox (widget, "KDE");
+	} else if (!strncmp (nx_conn->Session, "windows", NX_FIELDLEN)) {
+		// Windows
+		set_combobox (widget, "Windows");
+	} else if (!strncmp (nx_conn->Session, "vnc", NX_FIELDLEN)) {
+		// VNC
+		set_combobox (widget, "VNC");
+	} else if (!strncmp (nx_conn->Session, "shadow", NX_FIELDLEN)) {
+		// Shadow sessions
+		set_combobox (widget, "Shadow");
 	}
 
 	widget = glade_xml_get_widget (xml_glob, "entry_nx_custom_command");
@@ -1622,34 +1644,57 @@
 
 	if (strstr (str, _("KDE"))) {
 		strncpy (nx_conn->Desktop, "kde", NX_FIELDLEN);
+		strncpy (nx_conn->Session, "unix", NX_FIELDLEN);
 		strncpy (nx_conn->CustomUnixDesktop, "console", NX_FIELDLEN);
 
 	} else if (strstr (str, _("GNOME"))) {
 		strncpy (nx_conn->Desktop, "gnome", NX_FIELDLEN);
+		strncpy (nx_conn->Session, "unix", NX_FIELDLEN);
 		strncpy (nx_conn->CustomUnixDesktop, "console", NX_FIELDLEN);
 
 	} else if (strstr (str, _("CDE"))) {
 		strncpy (nx_conn->Desktop, "cde", NX_FIELDLEN);
+		strncpy (nx_conn->Session, "unix", NX_FIELDLEN);
 		strncpy (nx_conn->CustomUnixDesktop, "console", NX_FIELDLEN);
 
 	} else if (strstr (str, _("XDM"))) {
 		strncpy (nx_conn->Desktop, "xdm", NX_FIELDLEN);
+		strncpy (nx_conn->Session, "unix", NX_FIELDLEN);
 		strncpy (nx_conn->CustomUnixDesktop, "console", NX_FIELDLEN);
 
 	} else if (strstr (str, _("Console"))) {
 		strncpy (nx_conn->Desktop, "console", NX_FIELDLEN);
+		strncpy (nx_conn->Session, "unix", NX_FIELDLEN);
 		strncpy (nx_conn->CustomUnixDesktop, "console", NX_FIELDLEN);
 
 	} else if (strstr (str, _("Default X client script on server"))) {
 		strncpy (nx_conn->Desktop, "console", NX_FIELDLEN);
+		strncpy (nx_conn->Session, "unix", NX_FIELDLEN);
 		strncpy (nx_conn->CustomUnixDesktop, "default", NX_FIELDLEN);
 
 	} else if (strstr (str, _("Custom command"))) {
 		strncpy (nx_conn->Desktop, "console", NX_FIELDLEN);
+		strncpy (nx_conn->Session, "unix", NX_FIELDLEN);
 		strncpy (nx_conn->CustomUnixDesktop, "application", NX_FIELDLEN);
 
+	} else if (strstr (str, _("Windows"))) {
+		strncpy (nx_conn->Desktop, "console", NX_FIELDLEN);
+		strncpy (nx_conn->Session, "windows", NX_FIELDLEN);
+		strncpy (nx_conn->CustomUnixDesktop, "application", NX_FIELDLEN);
+
+	} else if (strstr (str, _("VNC"))) {
+		strncpy (nx_conn->Desktop, "console", NX_FIELDLEN);
+		strncpy (nx_conn->Session, "vnc", NX_FIELDLEN);
+		strncpy (nx_conn->CustomUnixDesktop, "application", NX_FIELDLEN);
+
+	} else if (strstr (str, _("Shadow"))) {
+		strncpy (nx_conn->Desktop, "console", NX_FIELDLEN);
+		strncpy (nx_conn->Session, "shadow", NX_FIELDLEN);
+		strncpy (nx_conn->CustomUnixDesktop, "application", NX_FIELDLEN);
+
 	} else {
 		strncpy (nx_conn->Desktop, "kde", NX_FIELDLEN);
+		strncpy (nx_conn->Session, "unix", NX_FIELDLEN);
 		strncpy (nx_conn->CustomUnixDesktop, "console", NX_FIELDLEN);
 	}
 

Modified: nxlaunch/lib/callbacks_nx.h
===================================================================
--- nxlaunch/lib/callbacks_nx.h	2007-09-17 21:05:25 UTC (rev 385)
+++ nxlaunch/lib/callbacks_nx.h	2007-09-17 21:06:24 UTC (rev 386)
@@ -91,8 +91,9 @@
 
 	/* Configurable variables in the desktop page */
 	gchar * Desktop;                // NXCL:sessionType
+	gchar * Session;                // New - matches XML file.
 	gchar * CustomUnixDesktop;      // NXCL:in customCommand
-	gchar * CommandLine;            // NXCL:customeCommand and sessionType?
+	gchar * CommandLine;            // NXCL:customCommand and sessionType?
 	gboolean VirtualDesktop; /* if false, then "Floating Window" is true */ // NXCL:
 	gboolean XAgentEncoding;        // NXCL:?
 	gboolean UseTaint;              // NXCL:?
@@ -144,7 +145,7 @@
 "<option key=\"Hide Full Screen Info\" value=\"false\" />\n"
 "<option key=\"Last session\" value=\"Nx1\" />\n"
 "<option key=\"Permit Root Login\" value=\"false\" />\n"
-"<option key=\"Personal NX dir\" value=\"/etc/persistent/hc/.nx\" />\n"
+"<option key=\"Personal NX dir\" value=\"~/.nx\" />\n"
 "<option key=\"Remove old sessions\" value=\"true\" />\n"
 "<option key=\"System NX dir\" value=\"/opt/nx\" />\n"
 "</group>\n"

Modified: nxlaunch/src/main.c
===================================================================
--- nxlaunch/src/main.c	2007-09-17 21:05:25 UTC (rev 385)
+++ nxlaunch/src/main.c	2007-09-17 21:06:24 UTC (rev 386)
@@ -121,6 +121,7 @@
 					 G_TYPE_STRING,
 					 G_TYPE_STRING,
 					 G_TYPE_STRING,
+					 G_TYPE_STRING,
 					 G_TYPE_BOOLEAN,
 					 G_TYPE_BOOLEAN,
 					 G_TYPE_BOOLEAN,

Modified: nxlaunch/src/nxconfig.glade
===================================================================
--- nxlaunch/src/nxconfig.glade	2007-09-17 21:05:25 UTC (rev 385)
+++ nxlaunch/src/nxconfig.glade	2007-09-17 21:06:24 UTC (rev 386)
@@ -2,7 +2,6 @@
 <!DOCTYPE glade-interface SYSTEM "http://glade.gnome.org/glade-2.0.dtd">
 
 <glade-interface>
-<requires lib="gnome"/>
 
 <widget class="GtkDialog" id="conn_new_nx">
   <property name="title" translatable="yes">NX Connection Details</property>
@@ -17,6 +16,8 @@
   <property name="skip_pager_hint">False</property>
   <property name="type_hint">GDK_WINDOW_TYPE_HINT_DIALOG</property>
   <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
+  <property name="focus_on_map">True</property>
+  <property name="urgency_hint">False</property>
   <property name="has_separator">True</property>
   <signal name="delete_event" handler="gtk_widget_hide" object="conn_new_nx" last_modification_time="Fri, 14 Oct 2005 14:18:27 GMT"/>
 
@@ -166,6 +167,10 @@
 		      <property name="yalign">0.5</property>
 		      <property name="xpad">0</property>
 		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
 		    </widget>
 		    <packing>
 		      <property name="type">label_item</property>
@@ -227,6 +232,10 @@
 				  <property name="yalign">0.5</property>
 				  <property name="xpad">0</property>
 				  <property name="ypad">0</property>
+				  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				  <property name="width_chars">-1</property>
+				  <property name="single_line_mode">False</property>
+				  <property name="angle">0</property>
 				</widget>
 				<packing>
 				  <property name="left_attach">0</property>
@@ -277,6 +286,10 @@
 				      <property name="yalign">0.5</property>
 				      <property name="xpad">0</property>
 				      <property name="ypad">0</property>
+				      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				      <property name="width_chars">-1</property>
+				      <property name="single_line_mode">False</property>
+				      <property name="angle">0</property>
 				    </widget>
 				    <packing>
 				      <property name="padding">0</property>
@@ -327,6 +340,10 @@
 				  <property name="yalign">0.5</property>
 				  <property name="xpad">0</property>
 				  <property name="ypad">0</property>
+				  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				  <property name="width_chars">-1</property>
+				  <property name="single_line_mode">False</property>
+				  <property name="angle">0</property>
 				</widget>
 				<packing>
 				  <property name="left_attach">0</property>
@@ -425,6 +442,10 @@
 				  <property name="yalign">0.5</property>
 				  <property name="xpad">0</property>
 				  <property name="ypad">0</property>
+				  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				  <property name="width_chars">-1</property>
+				  <property name="single_line_mode">False</property>
+				  <property name="angle">0</property>
 				</widget>
 				<packing>
 				  <property name="padding">0</property>
@@ -490,6 +511,10 @@
 					      <property name="yalign">0.5</property>
 					      <property name="xpad">0</property>
 					      <property name="ypad">0</property>
+					      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+					      <property name="width_chars">-1</property>
+					      <property name="single_line_mode">False</property>
+					      <property name="angle">0</property>
 					    </widget>
 					    <packing>
 					      <property name="padding">0</property>
@@ -533,6 +558,10 @@
 		      <property name="yalign">0.5</property>
 		      <property name="xpad">0</property>
 		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
 		    </widget>
 		    <packing>
 		      <property name="type">label_item</property>
@@ -664,6 +693,10 @@
 			      <property name="yalign">0.5</property>
 			      <property name="xpad">0</property>
 			      <property name="ypad">0</property>
+			      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			      <property name="width_chars">-1</property>
+			      <property name="single_line_mode">False</property>
+			      <property name="angle">0</property>
 			    </widget>
 			    <packing>
 			      <property name="padding">0</property>
@@ -689,6 +722,10 @@
 		      <property name="yalign">0.5</property>
 		      <property name="xpad">0</property>
 		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
 		    </widget>
 		    <packing>
 		      <property name="type">label_item</property>
@@ -721,6 +758,10 @@
 	      <property name="yalign">0.5</property>
 	      <property name="xpad">0</property>
 	      <property name="ypad">0</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
 	    </widget>
 	    <packing>
 	      <property name="type">tab</property>
@@ -766,9 +807,14 @@
 GNOME
 CDE
 XDM
+Shadow
+Windows
+VNC
 Console
 Default X client script on server
 Custom command</property>
+			      <property name="add_tearoffs">False</property>
+			      <property name="focus_on_click">True</property>
 			      <signal name="changed" handler="on_combobox_nx_desktop_session_changed" last_modification_time="Thu, 13 Apr 2006 12:26:55 GMT"/>
 			    </widget>
 			    <packing>
@@ -823,6 +869,10 @@
 					      <property name="yalign">0.5</property>
 					      <property name="xpad">0</property>
 					      <property name="ypad">0</property>
+					      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+					      <property name="width_chars">-1</property>
+					      <property name="single_line_mode">False</property>
+					      <property name="angle">0</property>
 					    </widget>
 					    <packing>
 					      <property name="padding">0</property>
@@ -972,6 +1022,10 @@
 				  <property name="yalign">0.5</property>
 				  <property name="xpad">0</property>
 				  <property name="ypad">0</property>
+				  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				  <property name="width_chars">-1</property>
+				  <property name="single_line_mode">False</property>
+				  <property name="angle">0</property>
 				</widget>
 				<packing>
 				  <property name="type">label_item</property>
@@ -1019,6 +1073,8 @@
 Broadcast an XDM query
 Get a list of available X display managers
 </property>
+					  <property name="add_tearoffs">False</property>
+					  <property name="focus_on_click">True</property>
 					  <signal name="changed" handler="on_combobox_nx_xdm_mode_changed" last_modification_time="Thu, 13 Apr 2006 12:58:45 GMT"/>
 					</widget>
 					<packing>
@@ -1047,6 +1103,10 @@
 					      <property name="yalign">0.5</property>
 					      <property name="xpad">0</property>
 					      <property name="ypad">0</property>
+					      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+					      <property name="width_chars">-1</property>
+					      <property name="single_line_mode">False</property>
+					      <property name="angle">0</property>
 					    </widget>
 					    <packing>
 					      <property name="padding">0</property>
@@ -1088,6 +1148,10 @@
 					      <property name="yalign">0.5</property>
 					      <property name="xpad">0</property>
 					      <property name="ypad">0</property>
+					      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+					      <property name="width_chars">-1</property>
+					      <property name="single_line_mode">False</property>
+					      <property name="angle">0</property>
 					    </widget>
 					    <packing>
 					      <property name="padding">0</property>
@@ -1141,6 +1205,10 @@
 				  <property name="yalign">0.5</property>
 				  <property name="xpad">0</property>
 				  <property name="ypad">0</property>
+				  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				  <property name="width_chars">-1</property>
+				  <property name="single_line_mode">False</property>
+				  <property name="angle">0</property>
 				</widget>
 				<packing>
 				  <property name="type">label_item</property>
@@ -1171,6 +1239,10 @@
 		      <property name="yalign">0.5</property>
 		      <property name="xpad">0</property>
 		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
 		    </widget>
 		    <packing>
 		      <property name="type">label_item</property>
@@ -1230,6 +1302,10 @@
 				  <property name="yalign">0.5</property>
 				  <property name="xpad">0</property>
 				  <property name="ypad">0</property>
+				  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				  <property name="width_chars">-1</property>
+				  <property name="single_line_mode">False</property>
+				  <property name="angle">0</property>
 				</widget>
 				<packing>
 				  <property name="padding">0</property>
@@ -1247,6 +1323,8 @@
 1280 x 1024
 Custom
 Full Screen</property>
+				  <property name="add_tearoffs">False</property>
+				  <property name="focus_on_click">True</property>
 				  <signal name="changed" handler="on_combobox_nx_window_size_changed" last_modification_time="Thu, 13 Apr 2006 12:28:43 GMT"/>
 				</widget>
 				<packing>
@@ -1283,6 +1361,10 @@
 				  <property name="yalign">0.5</property>
 				  <property name="xpad">0</property>
 				  <property name="ypad">0</property>
+				  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				  <property name="width_chars">-1</property>
+				  <property name="single_line_mode">False</property>
+				  <property name="angle">0</property>
 				</widget>
 				<packing>
 				  <property name="padding">0</property>
@@ -1324,6 +1406,10 @@
 				  <property name="yalign">0.5</property>
 				  <property name="xpad">0</property>
 				  <property name="ypad">0</property>
+				  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				  <property name="width_chars">-1</property>
+				  <property name="single_line_mode">False</property>
+				  <property name="angle">0</property>
 				</widget>
 				<packing>
 				  <property name="padding">0</property>
@@ -1375,6 +1461,10 @@
 		      <property name="yalign">0.5</property>
 		      <property name="xpad">0</property>
 		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
 		    </widget>
 		    <packing>
 		      <property name="type">label_item</property>
@@ -1421,6 +1511,8 @@
 PNG
 JPEG
 X Bitmap</property>
+			      <property name="add_tearoffs">False</property>
+			      <property name="focus_on_click">True</property>
 			      <signal name="changed" handler="on_combobox_nx_image_encoding_changed" last_modification_time="Tue, 18 Apr 2006 12:29:08 GMT"/>
 			    </widget>
 			    <packing>
@@ -1443,6 +1535,10 @@
 			      <property name="yalign">0.5</property>
 			      <property name="xpad">0</property>
 			      <property name="ypad">0</property>
+			      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			      <property name="width_chars">-1</property>
+			      <property name="single_line_mode">False</property>
+			      <property name="angle">0</property>
 			    </widget>
 			    <packing>
 			      <property name="padding">0</property>
@@ -1488,6 +1584,10 @@
 		      <property name="yalign">0.5</property>
 		      <property name="xpad">0</property>
 		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
 		    </widget>
 		    <packing>
 		      <property name="type">label_item</property>
@@ -1550,6 +1650,10 @@
 		      <property name="yalign">0.5</property>
 		      <property name="xpad">0</property>
 		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
 		    </widget>
 		    <packing>
 		      <property name="type">label_item</property>
@@ -1582,6 +1686,10 @@
 	      <property name="yalign">0.5</property>
 	      <property name="xpad">0</property>
 	      <property name="ypad">0</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
 	    </widget>
 	    <packing>
 	      <property name="type">tab</property>
@@ -1613,6 +1721,8 @@
   <property name="skip_pager_hint">False</property>
   <property name="type_hint">GDK_WINDOW_TYPE_HINT_DIALOG</property>
   <property name="gravity">GDK_GRAVITY_CENTER</property>
+  <property name="focus_on_map">True</property>
+  <property name="urgency_hint">False</property>
 
   <child>
     <widget class="GtkVBox" id="vbox62">
@@ -1721,6 +1831,10 @@
 			  <property name="yalign">0.5</property>
 			  <property name="xpad">0</property>
 			  <property name="ypad">0</property>
+			  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			  <property name="width_chars">-1</property>
+			  <property name="single_line_mode">False</property>
+			  <property name="angle">0</property>
 			</widget>
 			<packing>
 			  <property name="padding">0</property>
@@ -1793,6 +1907,10 @@
 			  <property name="yalign">0.5</property>
 			  <property name="xpad">0</property>
 			  <property name="ypad">0</property>
+			  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			  <property name="width_chars">-1</property>
+			  <property name="single_line_mode">False</property>
+			  <property name="angle">0</property>
 			</widget>
 			<packing>
 			  <property name="padding">0</property>
@@ -1864,6 +1982,10 @@
 			  <property name="yalign">0.5</property>
 			  <property name="xpad">0</property>
 			  <property name="ypad">0</property>
+			  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			  <property name="width_chars">-1</property>
+			  <property name="single_line_mode">False</property>
+			  <property name="angle">0</property>
 			</widget>
 			<packing>
 			  <property name="padding">0</property>
@@ -1893,6 +2015,7 @@
   <property name="local_only">False</property>
   <property name="select_multiple">False</property>
   <property name="show_hidden">True</property>
+  <property name="do_overwrite_confirmation">False</property>
   <property name="title" translatable="yes">Locate SSL Public Key text file</property>
   <property name="type">GTK_WINDOW_TOPLEVEL</property>
   <property name="window_position">GTK_WIN_POS_CENTER_ON_PARENT</property>
@@ -1905,6 +2028,8 @@
   <property name="skip_pager_hint">False</property>
   <property name="type_hint">GDK_WINDOW_TYPE_HINT_DIALOG</property>
   <property name="gravity">GDK_GRAVITY_CENTER</property>
+  <property name="focus_on_map">True</property>
+  <property name="urgency_hint">False</property>
 
   <child internal-child="vbox">
     <widget class="GtkVBox" id="dialog-vbox7">
@@ -1970,6 +2095,8 @@
   <property name="skip_pager_hint">False</property>
   <property name="type_hint">GDK_WINDOW_TYPE_HINT_DIALOG</property>
   <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
+  <property name="focus_on_map">True</property>
+  <property name="urgency_hint">False</property>
   <property name="has_separator">True</property>
 
   <child internal-child="vbox">
@@ -2033,6 +2160,10 @@
 	  <property name="yalign">0.5</property>
 	  <property name="xpad">8</property>
 	  <property name="ypad">13</property>
+	  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	  <property name="width_chars">-1</property>
+	  <property name="single_line_mode">False</property>
+	  <property name="angle">0</property>
 	</widget>
 	<packing>
 	  <property name="padding">0</property>

Modified: nxlaunch/src/nxlaunch.c
===================================================================
--- nxlaunch/src/nxlaunch.c	2007-09-17 21:05:25 UTC (rev 385)
+++ nxlaunch/src/nxlaunch.c	2007-09-17 21:06:24 UTC (rev 386)
@@ -225,7 +225,7 @@
 	GtkTreeSelection * selected;
 	GtkTreeIter iter;
 	GtkTreeModel * tree_model;
-	gchar * name;
+	gchar * name = NULL;
 
 	/* Get iter for current row and update connection list. */
 	list_tree = GTK_TREE_VIEW (glade_xml_get_widget (xml_nxlaunch_glob, "treeview_nxconnection"));
@@ -287,6 +287,7 @@
 				    CONN_LINKSPEED,         nx_conn->LinkSpeed,
 				    CONN_PUBLICKEY,         nx_conn->PublicKey,
 				    CONN_DESKTOP,           nx_conn->Desktop,
+				    CONN_SESSION,           nx_conn->Session,
 				    CONN_CUSTOMUNIXDESKTOP, nx_conn->CustomUnixDesktop,
 				    CONN_COMMANDLINE,       nx_conn->CommandLine,
 				    CONN_VIRTUALDESKTOP,    nx_conn->VirtualDesktop ? TRUE : FALSE,
@@ -506,6 +507,7 @@
 						    CONN_LINKSPEED,         nx_conn->LinkSpeed,
 						    CONN_PUBLICKEY,         nx_conn->PublicKey,
 						    CONN_DESKTOP,           nx_conn->Desktop,
+						    CONN_SESSION,           nx_conn->Session,
 						    CONN_CUSTOMUNIXDESKTOP, nx_conn->CustomUnixDesktop,
 						    CONN_COMMANDLINE,       nx_conn->CommandLine,
 						    CONN_VIRTUALDESKTOP,    nx_conn->VirtualDesktop ? TRUE : FALSE,
@@ -570,7 +572,7 @@
 							   "text", CONN_CONNECTIONNAME,
 							   NULL);
 	gtk_tree_view_column_set_resizable (column, TRUE);
-	g_object_set (renderer, "width", 200, NULL);
+	g_object_set (renderer, "width", 160, NULL);
 	gtk_tree_view_append_column (list_tree, column);
 
 
@@ -590,9 +592,17 @@
 	g_object_set (renderer, "width", 60, NULL);
 	gtk_tree_view_append_column (list_tree, column);
 
-	/* Type column */
+	/* Session column */
 	renderer = gtk_cell_renderer_text_new ();
-	column = gtk_tree_view_column_new_with_attributes (_("Session Type"), renderer,
+	column = gtk_tree_view_column_new_with_attributes (_("Session"), renderer,
+							   "text", CONN_SESSION,
+							   NULL);
+	g_object_set (renderer, "width", 60, NULL);
+	gtk_tree_view_append_column (list_tree, column);
+
+	/* Desktop column */
+	renderer = gtk_cell_renderer_text_new ();
+	column = gtk_tree_view_column_new_with_attributes (_("Desktop"), renderer,
 							   "text", CONN_DESKTOP,
 							   NULL);
 	g_object_set (renderer, "width", 60, NULL);
@@ -676,18 +686,54 @@
 		return -1;
 	}
 
-	int media=0, enc=0, fs=0, cups=0;
+	int media=0, enc=0, fs=0, cups=0, vdesk=0;
 	if (nx_conn->enableSound == TRUE) { media = 1; }
 	if (nx_conn->EnableSSLOnly == TRUE) { enc = 1; }
 	if (nx_conn->FullScreen == TRUE) { fs = 1; }
 	if (nx_conn->IPPPrinting == TRUE) { cups = 1; }
+	if (nx_conn->VirtualDesktop == TRUE) { vdesk = 1; }
 	int cache = 8, images = 24, render = 1;
 	const char * backingstore = "when_requested";
 	/* FIXME: Would like to store these in the .nxs file */
 	const char * keyboard = "";
 	const char * kbtype = "";
-	printerr ("Sending settings for connection %s, to Server %s\n",
+
+	printerr ("NXLAUNCH> Sending settings for connection %s, to Server %s\n",
 		  nx_conn->ConnectionName, nx_conn->ServerHost);
+
+	/* We have to translate the Desktop setting a bit - adding
+	 * unix- to the start of some of them. We're likely to need to
+	 * add to this logic for full functionality. */
+	char * session_type = NULL;
+	session_type = g_malloc0 (NX_FIELDLEN * sizeof (char));
+	if ( !strcmp (nx_conn->Session, "unix") ) {
+		
+		if ( !strcmp (nx_conn->Desktop, "gnome") || 
+		     !strcmp (nx_conn->Desktop, "kde") || 
+		     !strcmp (nx_conn->Desktop, "cde") || 
+		     !strcmp (nx_conn->Desktop, "xdm") ) {
+			snprintf (session_type, NX_FIELDLEN, "unix-%s", nx_conn->Desktop);
+
+		} else if (!strcmp (nx_conn->Desktop, "console") ) {
+
+			if (!strcmp (nx_conn->CustomUnixDesktop, "application") ) {
+				snprintf (session_type, NX_FIELDLEN, "unix-application");
+			} else {
+				snprintf (session_type, NX_FIELDLEN, "unix-console");
+			}
+		}
+	} else if ( !strcmp (nx_conn->Session, "shadow") ) {
+
+		snprintf (session_type, NX_FIELDLEN, "shadow");
+
+	} else if ( !strcmp (nx_conn->Session, "windows") ) {
+		printerr ("NXLAUNCH> FIXME Add windows support (with agentServer etc)\n");
+
+	} else if ( !strcmp (nx_conn->Session, "vnc") ) {
+		printerr ("NXLAUNCH> FIXME Add vnc support (with agentServer etc)\n");
+
+	}
+
 	dbus_message_append_args 
 		(message,
 		 DBUS_TYPE_STRING, &nx_conn->ServerHost,     //0
@@ -695,7 +741,7 @@
 		 DBUS_TYPE_STRING, &nx_conn->User,           //2
 		 DBUS_TYPE_STRING, &nx_conn->Pass,
 		 DBUS_TYPE_STRING, &nx_conn->ConnectionName, //4
-		 DBUS_TYPE_STRING, &nx_conn->Desktop,        // FIXME - but not exactly.. If Desktop == gnome, sessionType == unix-gnome.
+		 DBUS_TYPE_STRING, &session_type,   
 		 DBUS_TYPE_INT32,  &cache,                //6
 		 DBUS_TYPE_INT32,  &images,
 		 DBUS_TYPE_STRING, &nx_conn->LinkSpeed,      //8
@@ -715,8 +761,9 @@
 		 DBUS_TYPE_INT32,  &enc,                  //22
 		 DBUS_TYPE_INT32,  &fs,
 		 DBUS_TYPE_STRING, &nx_conn->CommandLine,    //24
+		 DBUS_TYPE_INT32,  &vdesk,
 		 DBUS_TYPE_INVALID);
-	printerr ("Sent settings to server\n");
+
 	/* Send the signal */
 	if (!dbus_connection_send (bus, message, NULL)) {
 		printerr ("NXLAUNCH> Out Of Memory!\n");
@@ -726,7 +773,7 @@
 	/* Clean up */
 	dbus_message_unref (message);
 	dbus_connection_flush (bus);
-	printerr ("Returning\n");
+	g_free (session_type);
 	return 1;
 }
 
@@ -1197,15 +1244,11 @@
 	printerr ("NXLAUNCH> %s() called\n", __FUNCTION__);
 
 	if (nx_conn_glob == NULL) {
-		printerr ("NXLAUNCH> Reading the active connection from the tree model\n");
 		nx_conn = g_malloc0 (sizeof (struct nx_connection));
 		getActiveConnection (nx_conn);
 	} else { /* we already populated nx_conn in launch_named_connection() */
-		printerr ("NXLAUNCH> Using global nx_conn pointer, which is 0x%x\n", 
-			  (unsigned int)nx_conn_glob);
 		nx_conn = nx_conn_glob;
 		nx_conn_glob = NULL;
-		printerr ("NXLAUNCH> nx_conn is still 0x%x\n", (int)nx_conn);
 	}
 
 	/* Read the password into nx_conn->Pass, mallocing if necessary */
@@ -1213,7 +1256,13 @@
 	if (!(nx_conn->Pass = g_try_realloc (nx_conn->Pass, NX_FIELDLEN * sizeof(gchar)))) {
 		printerr ("NXLAUNCH> Failed g_try_realloc\n");
 	}
-	strncpy (nx_conn->Pass, gtk_entry_get_text (GTK_ENTRY (widget)),  NX_FIELDLEN);
+	if (strlen (gtk_entry_get_text (GTK_ENTRY(widget))) > 0) {
+		strncpy (nx_conn->Pass, gtk_entry_get_text (GTK_ENTRY (widget)),  NX_FIELDLEN);
+	} else {
+		printerr ("NXLAUNCH> Zero length password\n");
+		// FIXME: Need better user feedback here.
+		return;
+	}
 
 	/* Hide the password window (this may not happen until this
 	 * callback returns, which is not what we want, really) */
@@ -1266,6 +1315,7 @@
 				    CONN_LINKSPEED,         &nx_conn->LinkSpeed,//
 				    CONN_PUBLICKEY,         &nx_conn->PublicKey,//
 				    CONN_DESKTOP,           &nx_conn->Desktop,//
+				    CONN_SESSION,           &nx_conn->Session,//
 				    CONN_CUSTOMUNIXDESKTOP, &nx_conn->CustomUnixDesktop,//
 				    CONN_COMMANDLINE,       &nx_conn->CommandLine,//
 				    CONN_VIRTUALDESKTOP,    &nx_conn->VirtualDesktop,
@@ -1338,6 +1388,7 @@
 					    CONN_LINKSPEED,         &nx_conn->LinkSpeed,
 					    CONN_PUBLICKEY,         &nx_conn->PublicKey,
 					    CONN_DESKTOP,           &nx_conn->Desktop,
+					    CONN_SESSION,           &nx_conn->Session,
 					    CONN_CUSTOMUNIXDESKTOP, &nx_conn->CustomUnixDesktop,
 					    CONN_COMMANDLINE,       &nx_conn->CommandLine,
 					    CONN_VIRTUALDESKTOP,    &nx_conn->VirtualDesktop,
@@ -1396,20 +1447,9 @@
 void launch_connection (struct nx_connection * nx_conn)
 {
 	GtkWidget * widget;
-	gchar temp[32];
 
 	printerr ("%s() called\n", __FUNCTION__);
 
-	/* FIXME
-	 * Not quite sure what to do with nx_conn->Desktop
-	 * here. Mostly, gnome goes to unix-gnome, kde to unix-kde and
-	 * so on, but not sure what sessionType should be for console,
-	 * custom and RDP/VNC sessions.
-	 * For now, apply this hack:
-	 */
-	snprintf (temp, 31, "unix-%s", nx_conn->Desktop);
-	snprintf (nx_conn->Desktop, 255, "%s", temp);
-
 	execNxcl();
 	sendNxclSettings (nx_conn);
 	callReceiveSession (FALSE);

Modified: nxlaunch/src/nxlaunch.h
===================================================================
--- nxlaunch/src/nxlaunch.h	2007-09-17 21:05:25 UTC (rev 385)
+++ nxlaunch/src/nxlaunch.h	2007-09-17 21:06:24 UTC (rev 386)
@@ -73,6 +73,7 @@
 	CONN_LINKSPEED,
 	CONN_PUBLICKEY,
 	CONN_DESKTOP,
+	CONN_SESSION,
 	CONN_CUSTOMUNIXDESKTOP,
 	CONN_COMMANDLINE,
 	CONN_VIRTUALDESKTOP,



From sebjames at mail.berlios.de  Tue Sep 18 00:07:35 2007
From: sebjames at mail.berlios.de (sebjames at BerliOS)
Date: Tue, 18 Sep 2007 00:07:35 +0200
Subject: [Freenx-cvs] r387 - nxcl
Message-ID: <200709172207.l8HM7ZQu006874@sheep.berlios.de>

Author: sebjames
Date: 2007-09-18 00:07:34 +0200 (Tue, 18 Sep 2007)
New Revision: 387

Modified:
   nxcl/README
Log:
Typo fixed.


Modified: nxcl/README
===================================================================
--- nxcl/README	2007-09-17 21:06:24 UTC (rev 386)
+++ nxcl/README	2007-09-17 22:07:34 UTC (rev 387)
@@ -37,7 +37,7 @@
 
 If you checked out the svn code, you need to do:
 
-autoconf -is
+autoreconf -is
 
 then:
 



From sebjames at mail.berlios.de  Tue Sep 18 00:08:30 2007
From: sebjames at mail.berlios.de (sebjames at BerliOS)
Date: Tue, 18 Sep 2007 00:08:30 +0200
Subject: [Freenx-cvs] r388 - nxlaunch
Message-ID: <200709172208.l8HM8UfA006947@sheep.berlios.de>

Author: sebjames
Date: 2007-09-18 00:08:30 +0200 (Tue, 18 Sep 2007)
New Revision: 388

Modified:
   nxlaunch/README
Log:
Typo fixed.


Modified: nxlaunch/README
===================================================================
--- nxlaunch/README	2007-09-17 22:07:34 UTC (rev 387)
+++ nxlaunch/README	2007-09-17 22:08:30 UTC (rev 388)
@@ -18,7 +18,7 @@
 
 If you checked out the svn code, you need to do:
 
-autoconf -is
+autoreconf -is
 
 then:
 



From sebjames at mail.berlios.de  Tue Sep 18 16:02:57 2007
From: sebjames at mail.berlios.de (sebjames at BerliOS)
Date: Tue, 18 Sep 2007 16:02:57 +0200
Subject: [Freenx-cvs] r389 - nxcl
Message-ID: <200709181402.l8IE2vCF013053@sheep.berlios.de>

Author: sebjames
Date: 2007-09-18 16:02:57 +0200 (Tue, 18 Sep 2007)
New Revision: 389

Modified:
   nxcl/README
Log:
More build/install information


Modified: nxcl/README
===================================================================
--- nxcl/README	2007-09-17 22:08:30 UTC (rev 388)
+++ nxcl/README	2007-09-18 14:02:57 UTC (rev 389)
@@ -33,14 +33,47 @@
 Look at nxcl.cpp/h if you want to write an NX client which links
 directly to libnxcl.
 
-Building:
+Building nxcl
+-------------
 
+Prerequisites are:
+
+* libXcomp from NoMachine, provided by the nxcomp package.
+* nxssh from NoMachine
+* nxproxy from NoMachine
+
+(These three NX components all should be from the 3.0.0 series. You can
+obtain them from NoMachine's servers at http://www.nomachine.com/sources.php)
+
+And for the standalong dbus client you'll also need:
+
+* libdbus-1 - http://dbus.freedesktop.org/ Note that you'll need the dbus
+daemon to be running to use the nxcl standalone binary, but NOT if you link
+your client directly to libnxcl.so*
+
+If you have doxygen on your system, (imperfect) documentation will be
+generated from the source header files.
+
+Compile and install libXcomp, nxssh and nxproxy following the instructions
+in the readme file for each package. You can install the nxssh and nxproxy
+in any of the following locations:
+
+/bin
+/usr/bin
+/usr/local/bin
+/usr/NX/bin
+_or_ the same place that you will install the nxcl binary, determined from
+your --prefix directive to the configure script.
+
 If you checked out the svn code, you need to do:
 
 autoreconf -is
 
-then:
+to create the configure script (from configure.ac) and the Makefiles (from
+Makefile.am files).
 
-./configure [--enable-debug-output]
+then configure, make and install in the usual way:
+
+./configure [--enable-debug-output] [--prefix=/opt/myNXstuff]
 make
 make install



From sebjames at mail.berlios.de  Tue Sep 18 16:30:09 2007
From: sebjames at mail.berlios.de (sebjames at BerliOS)
Date: Tue, 18 Sep 2007 16:30:09 +0200
Subject: [Freenx-cvs] r390 - nxcl
Message-ID: <200709181430.l8IEU94E014956@sheep.berlios.de>

Author: sebjames
Date: 2007-09-18 16:30:08 +0200 (Tue, 18 Sep 2007)
New Revision: 390

Modified:
   nxcl/README
Log:
Typos, minor tweaks.


Modified: nxcl/README
===================================================================
--- nxcl/README	2007-09-18 14:02:57 UTC (rev 389)
+++ nxcl/README	2007-09-18 14:30:08 UTC (rev 390)
@@ -45,7 +45,7 @@
 (These three NX components all should be from the 3.0.0 series. You can
 obtain them from NoMachine's servers at http://www.nomachine.com/sources.php)
 
-And for the standalong dbus client you'll also need:
+And (only) for the standalone dbus client you'll need:
 
 * libdbus-1 - http://dbus.freedesktop.org/ Note that you'll need the dbus
 daemon to be running to use the nxcl standalone binary, but NOT if you link
@@ -70,9 +70,9 @@
 autoreconf -is
 
 to create the configure script (from configure.ac) and the Makefiles (from
-Makefile.am files).
+the Makefile.am files).
 
-then configure, make and install in the usual way:
+Then configure, make and install in the usual way:
 
 ./configure [--enable-debug-output] [--prefix=/opt/myNXstuff]
 make



From sebjames at mail.berlios.de  Tue Sep 11 14:49:23 2007
From: sebjames at mail.berlios.de (sebjames at BerliOS)
Date: Tue, 11 Sep 2007 12:49:23 -0000
Subject: [Freenx-cvs] r373 - / nxcl nxcl/doc nxcl/lib nxcl/nxcl nxcl/test
Message-ID: <200709111248.l8BCmmiO017817@sheep.berlios.de>

Author: sebjames
Date: 2007-09-11 14:48:46 +0200 (Tue, 11 Sep 2007)
New Revision: 373

Added:
   nxcl/
   nxcl/Makefile.am
   nxcl/README
   nxcl/configure.ac
   nxcl/doc/
   nxcl/doc/Doxyfile
   nxcl/doc/Doxyfile.in
   nxcl/doc/Makefile.am
   nxcl/lib/
   nxcl/lib/Makefile.am
   nxcl/lib/i18n.h
   nxcl/lib/notQt.cpp
   nxcl/lib/notQt.h
   nxcl/lib/nxclientlib.cpp
   nxcl/lib/nxclientlib.h
   nxcl/lib/nxclientlib_i18n.h
   nxcl/lib/nxdata.h
   nxcl/lib/nxsession.cpp
   nxcl/lib/nxsession.h
   nxcl/nxcl/
   nxcl/nxcl/Makefile.am
   nxcl/nxcl/main.cpp
   nxcl/nxcl/nxcl.cpp
   nxcl/nxcl/nxcl.h
   nxcl/test/
   nxcl/test/Makefile.am
   nxcl/test/libtest.cpp
   nxcl/test/notQttest.cpp
   nxcl/test/nxcmd.cpp
Log:
Initial import of nxcl, an update to nxclientlib

Added: nxcl/Makefile.am
===================================================================
--- nxcl/Makefile.am	2007-08-19 15:44:16 UTC (rev 372)
+++ nxcl/Makefile.am	2007-09-11 12:48:46 UTC (rev 373)
@@ -0,0 +1,10 @@
+
+AUTOMAKE_OPTIONS = check-news dist-bzip2
+
+SUBDIRS = lib nxcl test doc
+
+CLEANFILES = *~
+
+MAINTAINERCLEANFILES = aclocal.m4 nxcl-*.tar.gz nxcl-*.tar.bz2 nxcl-*.diff
+
+INCLUDES = -I./lib

Added: nxcl/README
===================================================================
--- nxcl/README	2007-08-19 15:44:16 UTC (rev 372)
+++ nxcl/README	2007-09-11 12:48:46 UTC (rev 373)
@@ -0,0 +1,34 @@
+
+  nxcl: A library for building NX clients.
+
+  Seb James. July-September 2007. seb at esfnet.co.uk
+
+Based on nxclientlib by George Wright, but with all dependencies on QT
+removed and the QT build system replaced with GNU autotools.
+
+doxygen is required if you want to build source documentation.
+
+The library code is in nxcl-release/lib/. 
+
+A binary, called nxcl - the "nxcl dbus daemon" is built in
+nxcl-release/nxcl/. nxcl links to libnxcl and can negotiate an nx
+connection.
+
+nxcl-release/test/ contains some test programs. notQtTest tests some
+of the features of the notQt classes in nxcl-release/lib/. libtest
+is a simple command line NX client linking straight to the libnxcl
+library. nxcmd is a second command line NX client, but it launches
+nxcl, then sends session data there and allows nxcl to negotiate the
+NX connection. This could be extended into quite a complete command
+line NX client.
+
+A GTK+ NX client called nxlaunch is distributed separately. Nxlaunch
+uses the nxcl daemon, though it would be quite possible to write a GTK
+client which links directly to the nxcl library. 
+
+You should study nxcmd.cpp and nxlaunch if you are interested in
+writing an NX client using a different widget system (say Windows, QT,
+Tk, etc) which uses the Nxcl dbus daemon.
+
+Look at nxcl.cpp/h if you want to write an NX client which links
+directly to libnxcl.

Added: nxcl/configure.ac
===================================================================
--- nxcl/configure.ac	2007-08-19 15:44:16 UTC (rev 372)
+++ nxcl/configure.ac	2007-09-11 12:48:46 UTC (rev 373)
@@ -0,0 +1,76 @@
+dnl Process this file with autoconf to produce a configure script.
+AC_PREREQ(2.59)
+AC_INIT([nxcl], [1.0], [seb at esfnet.co.uk])
+AC_CONFIG_SRCDIR(nxcl/nxcl.cpp)
+AC_REVISION([$Revision: 1.3 $])
+AC_PREFIX_DEFAULT(/usr/local)
+
+AM_INIT_AUTOMAKE([1.9 foreign])
+
+AM_CONFIG_HEADER(config.h)
+AM_MAINTAINER_MODE
+
+AC_LANG_CPLUSPLUS
+
+dnl Checks for programs.
+AC_PROG_CXX
+AC_PROG_CC
+AC_PROG_INSTALL
+AC_PROG_LIBTOOL
+AC_CHECK_PROG(DOXYGEN, doxygen, doxygen, /bin/echo)
+
+dnl check for boost library
+dnl I would prefer to include boost code and compile in place and statically link.
+dnl AC_CHECK_LIB(boost_signals, LIB_BOOST_SIGNALS="-lboost_signals")
+dnl AC_SUBST(LIB_BOOST_SIGNALS)
+
+PKG_CHECK_MODULES(PACKAGE, dbus-1)
+
+dnl Checks for library functions.
+AC_HEADER_STDC
+AC_HEADER_TIME
+AC_CHECK_FUNCS(strftime gettimeofday uname)
+
+dnl Determine host system type
+AC_CANONICAL_HOST
+AC_DEFINE_UNQUOTED(HOST, "$host", [The host system nxcl was configured for])
+
+dnl pkg_modules="libxml2" <- Check this and modify when necessary
+dnl PKG_CHECK_MODULES(PACKAGE, [$pkg_modules])
+AC_SUBST(PACKAGE_CFLAGS)
+AC_SUBST(PACKAGE_LIBS)
+
+dnl enable/disable compiler warnings (using gcc), if specified
+AC_ARG_ENABLE(warnings,
+  [  --disable-warnings      disable gcc warnings [default=no]],
+  [case "${enableval}" in
+    yes) nxcl_warnings=yes ;; 
+    no)  nxcl_warnings=no ;;
+    *) AC_MSG_ERROR(bad value ${enableval} for --enable-warnings) ;;
+  esac], nxcl_warnings=yes)
+AC_MSG_CHECKING(whether to use gcc verbose warnings)
+AC_MSG_RESULT($nxcl_warnings)
+if (test "$nxcl_warnings" = yes && test "$GCC" = yes); then
+  CXXFLAGS="-Wall $CXXFLAGS"
+fi
+
+dnl enable/disable debug logging, if specified
+AC_ARG_ENABLE(debug-output,
+  [  --enable-debug-output  enable debug output [default=no]],
+  [case "${enableval}" in
+    yes) nxcl_debug=yes ;;
+    no)  nxcl_debug=no ;;
+    *) AC_MSG_ERROR(bad value ${enableval} for --enable-debug-output) ;;
+  esac], nxcl_debug=no)
+AC_MSG_CHECKING(whether to enable debugging output)
+AC_MSG_RESULT($nxcl_debug)
+if test "$nxcl_debug" = yes; then
+  AC_DEFINE(DEBUG, 1, Define if debugging output should be enabled)
+else
+  AC_DEFINE(DEBUG, 0, Define if debugging output should be enabled)
+fi
+
+dnl Add in doc/Makefile to this:
+AC_CONFIG_FILES([Makefile lib/Makefile nxcl/Makefile test/Makefile doc/Makefile])
+
+AC_OUTPUT

Added: nxcl/doc/Doxyfile
===================================================================
--- nxcl/doc/Doxyfile	2007-08-19 15:44:16 UTC (rev 372)
+++ nxcl/doc/Doxyfile	2007-09-11 12:48:46 UTC (rev 373)
@@ -0,0 +1,209 @@
+# Doxyfile 1.3.6
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+PROJECT_NAME           = nxcl
+PROJECT_NUMBER         = @VERSION@
+OUTPUT_DIRECTORY       = 
+OUTPUT_LANGUAGE        = English
+USE_WINDOWS_ENCODING   = NO
+BRIEF_MEMBER_DESC      = YES
+REPEAT_BRIEF           = YES
+ABBREVIATE_BRIEF       = 
+ALWAYS_DETAILED_SEC    = NO
+INLINE_INHERITED_MEMB  = NO
+FULL_PATH_NAMES        = NO
+STRIP_FROM_PATH        = 
+SHORT_NAMES            = NO
+JAVADOC_AUTOBRIEF      = NO
+MULTILINE_CPP_IS_BRIEF = NO
+DETAILS_AT_TOP         = NO
+INHERIT_DOCS           = YES
+DISTRIBUTE_GROUP_DOC   = NO
+TAB_SIZE               = 8
+ALIASES                = 
+OPTIMIZE_OUTPUT_FOR_C  = NO
+OPTIMIZE_OUTPUT_JAVA   = NO
+SUBGROUPING            = YES
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+EXTRACT_ALL            = NO
+EXTRACT_PRIVATE        = NO
+EXTRACT_STATIC         = NO
+EXTRACT_LOCAL_CLASSES  = YES
+HIDE_UNDOC_MEMBERS     = NO
+HIDE_UNDOC_CLASSES     = NO
+HIDE_FRIEND_COMPOUNDS  = NO
+HIDE_IN_BODY_DOCS      = NO
+INTERNAL_DOCS          = NO
+CASE_SENSE_NAMES       = YES
+HIDE_SCOPE_NAMES       = NO
+SHOW_INCLUDE_FILES     = YES
+INLINE_INFO            = YES
+SORT_MEMBER_DOCS       = YES
+SORT_BRIEF_DOCS        = NO
+SORT_BY_SCOPE_NAME     = NO
+GENERATE_TODOLIST      = YES
+GENERATE_TESTLIST      = YES
+GENERATE_BUGLIST       = YES
+GENERATE_DEPRECATEDLIST= YES
+ENABLED_SECTIONS       = 
+MAX_INITIALIZER_LINES  = 30
+SHOW_USED_FILES        = YES
+#---------------------------------------------------------------------------
+# configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+QUIET                  = NO
+WARNINGS               = YES
+WARN_IF_UNDOCUMENTED   = YES
+WARN_IF_DOC_ERROR      = YES
+WARN_FORMAT            = "$file:$line: $text"
+WARN_LOGFILE           = 
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+INPUT                  = .. ../nxcl ../lib ../test
+FILE_PATTERNS          = *.h
+RECURSIVE              = NO
+EXCLUDE                = 
+EXCLUDE_SYMLINKS       = NO
+EXCLUDE_PATTERNS       = 
+EXAMPLE_PATH           = 
+EXAMPLE_PATTERNS       = 
+EXAMPLE_RECURSIVE      = NO
+IMAGE_PATH             = images
+INPUT_FILTER           = 
+FILTER_SOURCE_FILES    = NO
+#---------------------------------------------------------------------------
+# configuration options related to source browsing
+#---------------------------------------------------------------------------
+SOURCE_BROWSER         = YES
+INLINE_SOURCES         = NO
+STRIP_CODE_COMMENTS    = YES
+REFERENCED_BY_RELATION = YES
+REFERENCES_RELATION    = YES
+VERBATIM_HEADERS       = YES
+#---------------------------------------------------------------------------
+# configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+ALPHABETICAL_INDEX     = NO
+COLS_IN_ALPHA_INDEX    = 4
+IGNORE_PREFIX          = 
+#---------------------------------------------------------------------------
+# configuration options related to the HTML output
+#---------------------------------------------------------------------------
+GENERATE_HTML          = YES
+HTML_OUTPUT            = html
+HTML_FILE_EXTENSION    = .html
+HTML_HEADER            = 
+HTML_FOOTER            = 
+HTML_STYLESHEET        = 
+HTML_ALIGN_MEMBERS     = YES
+GENERATE_HTMLHELP      = NO
+CHM_FILE               = 
+HHC_LOCATION           = 
+GENERATE_CHI           = NO
+BINARY_TOC             = NO
+TOC_EXPAND             = NO
+DISABLE_INDEX          = NO
+ENUM_VALUES_PER_LINE   = 4
+GENERATE_TREEVIEW      = NO
+TREEVIEW_WIDTH         = 250
+#---------------------------------------------------------------------------
+# configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+GENERATE_LATEX         = NO
+LATEX_OUTPUT           = latex
+LATEX_CMD_NAME         = latex
+MAKEINDEX_CMD_NAME     = makeindex
+COMPACT_LATEX          = NO
+PAPER_TYPE             = a4wide
+EXTRA_PACKAGES         = 
+LATEX_HEADER           = 
+PDF_HYPERLINKS         = NO
+USE_PDFLATEX           = NO
+LATEX_BATCHMODE        = NO
+LATEX_HIDE_INDICES     = NO
+#---------------------------------------------------------------------------
+# configuration options related to the RTF output
+#---------------------------------------------------------------------------
+GENERATE_RTF           = NO
+RTF_OUTPUT             = rtf
+COMPACT_RTF            = NO
+RTF_HYPERLINKS         = NO
+RTF_STYLESHEET_FILE    = 
+RTF_EXTENSIONS_FILE    = 
+#---------------------------------------------------------------------------
+# configuration options related to the man page output
+#---------------------------------------------------------------------------
+GENERATE_MAN           = NO
+MAN_OUTPUT             = man
+MAN_EXTENSION          = .3
+MAN_LINKS              = NO
+#---------------------------------------------------------------------------
+# configuration options related to the XML output
+#---------------------------------------------------------------------------
+GENERATE_XML           = NO
+XML_OUTPUT             = xml
+XML_SCHEMA             = 
+XML_DTD                = 
+XML_PROGRAMLISTING     = YES
+#---------------------------------------------------------------------------
+# configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+GENERATE_AUTOGEN_DEF   = NO
+#---------------------------------------------------------------------------
+# configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+GENERATE_PERLMOD       = NO
+PERLMOD_LATEX          = NO
+PERLMOD_PRETTY         = YES
+PERLMOD_MAKEVAR_PREFIX = 
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor   
+#---------------------------------------------------------------------------
+ENABLE_PREPROCESSING   = YES
+MACRO_EXPANSION        = YES
+EXPAND_ONLY_PREDEF     = YES
+SEARCH_INCLUDES        = YES
+INCLUDE_PATH           = 
+INCLUDE_FILE_PATTERNS  = 
+PREDEFINED             = DEBUG=0
+EXPAND_AS_DEFINED      = 
+SKIP_FUNCTION_MACROS   = YES
+#---------------------------------------------------------------------------
+# Configuration::additions related to external references   
+#---------------------------------------------------------------------------
+TAGFILES               = 
+GENERATE_TAGFILE       = 
+ALLEXTERNALS           = NO
+EXTERNAL_GROUPS        = YES
+PERL_PATH              = /usr/bin/perl
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool   
+#---------------------------------------------------------------------------
+CLASS_DIAGRAMS         = YES
+HIDE_UNDOC_RELATIONS   = YES
+HAVE_DOT               = NO
+CLASS_GRAPH            = YES
+COLLABORATION_GRAPH    = YES
+UML_LOOK               = NO
+TEMPLATE_RELATIONS     = NO
+INCLUDE_GRAPH          = YES
+INCLUDED_BY_GRAPH      = YES
+CALL_GRAPH             = NO
+GRAPHICAL_HIERARCHY    = YES
+DOT_IMAGE_FORMAT       = png
+DOT_PATH               = 
+DOTFILE_DIRS           = 
+MAX_DOT_GRAPH_WIDTH    = 1024
+MAX_DOT_GRAPH_HEIGHT   = 1024
+MAX_DOT_GRAPH_DEPTH    = 0
+GENERATE_LEGEND        = YES
+DOT_CLEANUP            = YES
+#---------------------------------------------------------------------------
+# Configuration::additions related to the search engine   
+#---------------------------------------------------------------------------
+SEARCHENGINE           = NO

Added: nxcl/doc/Doxyfile.in
===================================================================
--- nxcl/doc/Doxyfile.in	2007-08-19 15:44:16 UTC (rev 372)
+++ nxcl/doc/Doxyfile.in	2007-09-11 12:48:46 UTC (rev 373)
@@ -0,0 +1,209 @@
+# Doxyfile 1.3.6
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+PROJECT_NAME           = nxcl
+PROJECT_NUMBER         = @VERSION@
+OUTPUT_DIRECTORY       = 
+OUTPUT_LANGUAGE        = English
+USE_WINDOWS_ENCODING   = NO
+BRIEF_MEMBER_DESC      = YES
+REPEAT_BRIEF           = YES
+ABBREVIATE_BRIEF       = 
+ALWAYS_DETAILED_SEC    = NO
+INLINE_INHERITED_MEMB  = NO
+FULL_PATH_NAMES        = NO
+STRIP_FROM_PATH        = 
+SHORT_NAMES            = NO
+JAVADOC_AUTOBRIEF      = NO
+MULTILINE_CPP_IS_BRIEF = NO
+DETAILS_AT_TOP         = NO
+INHERIT_DOCS           = YES
+DISTRIBUTE_GROUP_DOC   = NO
+TAB_SIZE               = 8
+ALIASES                = 
+OPTIMIZE_OUTPUT_FOR_C  = NO
+OPTIMIZE_OUTPUT_JAVA   = NO
+SUBGROUPING            = YES
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+EXTRACT_ALL            = NO
+EXTRACT_PRIVATE        = NO
+EXTRACT_STATIC         = NO
+EXTRACT_LOCAL_CLASSES  = YES
+HIDE_UNDOC_MEMBERS     = NO
+HIDE_UNDOC_CLASSES     = NO
+HIDE_FRIEND_COMPOUNDS  = NO
+HIDE_IN_BODY_DOCS      = NO
+INTERNAL_DOCS          = NO
+CASE_SENSE_NAMES       = YES
+HIDE_SCOPE_NAMES       = NO
+SHOW_INCLUDE_FILES     = YES
+INLINE_INFO            = YES
+SORT_MEMBER_DOCS       = YES
+SORT_BRIEF_DOCS        = NO
+SORT_BY_SCOPE_NAME     = NO
+GENERATE_TODOLIST      = YES
+GENERATE_TESTLIST      = YES
+GENERATE_BUGLIST       = YES
+GENERATE_DEPRECATEDLIST= YES
+ENABLED_SECTIONS       = 
+MAX_INITIALIZER_LINES  = 30
+SHOW_USED_FILES        = YES
+#---------------------------------------------------------------------------
+# configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+QUIET                  = NO
+WARNINGS               = YES
+WARN_IF_UNDOCUMENTED   = YES
+WARN_IF_DOC_ERROR      = YES
+WARN_FORMAT            = "$file:$line: $text"
+WARN_LOGFILE           = 
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+INPUT                  = .. ../nxcl ../lib ../test
+FILE_PATTERNS          = *.h
+RECURSIVE              = NO
+EXCLUDE                = 
+EXCLUDE_SYMLINKS       = NO
+EXCLUDE_PATTERNS       = 
+EXAMPLE_PATH           = 
+EXAMPLE_PATTERNS       = 
+EXAMPLE_RECURSIVE      = NO
+IMAGE_PATH             = images
+INPUT_FILTER           = 
+FILTER_SOURCE_FILES    = NO
+#---------------------------------------------------------------------------
+# configuration options related to source browsing
+#---------------------------------------------------------------------------
+SOURCE_BROWSER         = YES
+INLINE_SOURCES         = NO
+STRIP_CODE_COMMENTS    = YES
+REFERENCED_BY_RELATION = YES
+REFERENCES_RELATION    = YES
+VERBATIM_HEADERS       = YES
+#---------------------------------------------------------------------------
+# configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+ALPHABETICAL_INDEX     = NO
+COLS_IN_ALPHA_INDEX    = 4
+IGNORE_PREFIX          = 
+#---------------------------------------------------------------------------
+# configuration options related to the HTML output
+#---------------------------------------------------------------------------
+GENERATE_HTML          = YES
+HTML_OUTPUT            = html
+HTML_FILE_EXTENSION    = .html
+HTML_HEADER            = 
+HTML_FOOTER            = 
+HTML_STYLESHEET        = 
+HTML_ALIGN_MEMBERS     = YES
+GENERATE_HTMLHELP      = NO
+CHM_FILE               = 
+HHC_LOCATION           = 
+GENERATE_CHI           = NO
+BINARY_TOC             = NO
+TOC_EXPAND             = NO
+DISABLE_INDEX          = NO
+ENUM_VALUES_PER_LINE   = 4
+GENERATE_TREEVIEW      = NO
+TREEVIEW_WIDTH         = 250
+#---------------------------------------------------------------------------
+# configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+GENERATE_LATEX         = NO
+LATEX_OUTPUT           = latex
+LATEX_CMD_NAME         = latex
+MAKEINDEX_CMD_NAME     = makeindex
+COMPACT_LATEX          = NO
+PAPER_TYPE             = a4wide
+EXTRA_PACKAGES         = 
+LATEX_HEADER           = 
+PDF_HYPERLINKS         = NO
+USE_PDFLATEX           = NO
+LATEX_BATCHMODE        = NO
+LATEX_HIDE_INDICES     = NO
+#---------------------------------------------------------------------------
+# configuration options related to the RTF output
+#---------------------------------------------------------------------------
+GENERATE_RTF           = NO
+RTF_OUTPUT             = rtf
+COMPACT_RTF            = NO
+RTF_HYPERLINKS         = NO
+RTF_STYLESHEET_FILE    = 
+RTF_EXTENSIONS_FILE    = 
+#---------------------------------------------------------------------------
+# configuration options related to the man page output
+#---------------------------------------------------------------------------
+GENERATE_MAN           = NO
+MAN_OUTPUT             = man
+MAN_EXTENSION          = .3
+MAN_LINKS              = NO
+#---------------------------------------------------------------------------
+# configuration options related to the XML output
+#---------------------------------------------------------------------------
+GENERATE_XML           = NO
+XML_OUTPUT             = xml
+XML_SCHEMA             = 
+XML_DTD                = 
+XML_PROGRAMLISTING     = YES
+#---------------------------------------------------------------------------
+# configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+GENERATE_AUTOGEN_DEF   = NO
+#---------------------------------------------------------------------------
+# configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+GENERATE_PERLMOD       = NO
+PERLMOD_LATEX          = NO
+PERLMOD_PRETTY         = YES
+PERLMOD_MAKEVAR_PREFIX = 
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor   
+#---------------------------------------------------------------------------
+ENABLE_PREPROCESSING   = YES
+MACRO_EXPANSION        = YES
+EXPAND_ONLY_PREDEF     = YES
+SEARCH_INCLUDES        = YES
+INCLUDE_PATH           = 
+INCLUDE_FILE_PATTERNS  = 
+PREDEFINED             = DEBUG=0
+EXPAND_AS_DEFINED      = 
+SKIP_FUNCTION_MACROS   = YES
+#---------------------------------------------------------------------------
+# Configuration::additions related to external references   
+#---------------------------------------------------------------------------
+TAGFILES               = 
+GENERATE_TAGFILE       = 
+ALLEXTERNALS           = NO
+EXTERNAL_GROUPS        = YES
+PERL_PATH              = /usr/bin/perl
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool   
+#---------------------------------------------------------------------------
+CLASS_DIAGRAMS         = YES
+HIDE_UNDOC_RELATIONS   = YES
+HAVE_DOT               = NO
+CLASS_GRAPH            = YES
+COLLABORATION_GRAPH    = YES
+UML_LOOK               = NO
+TEMPLATE_RELATIONS     = NO
+INCLUDE_GRAPH          = YES
+INCLUDED_BY_GRAPH      = YES
+CALL_GRAPH             = NO
+GRAPHICAL_HIERARCHY    = YES
+DOT_IMAGE_FORMAT       = png
+DOT_PATH               = 
+DOTFILE_DIRS           = 
+MAX_DOT_GRAPH_WIDTH    = 1024
+MAX_DOT_GRAPH_HEIGHT   = 1024
+MAX_DOT_GRAPH_DEPTH    = 0
+GENERATE_LEGEND        = YES
+DOT_CLEANUP            = YES
+#---------------------------------------------------------------------------
+# Configuration::additions related to the search engine   
+#---------------------------------------------------------------------------
+SEARCHENGINE           = NO

Added: nxcl/doc/Makefile.am
===================================================================
--- nxcl/doc/Makefile.am	2007-08-19 15:44:16 UTC (rev 372)
+++ nxcl/doc/Makefile.am	2007-09-11 12:48:46 UTC (rev 373)
@@ -0,0 +1,31 @@
+CLEANFILES = *~
+
+DOXYFILE = Doxyfile
+
+docdir = $(prefix)/doc/$(PACKAGE)-$(VERSION)
+
+EXTRA_DIST = html
+
+SEDCMD1 = s/$$title/GNU nxcl documentation version $(VERSION)/g
+SEDCMD2 = s/$$(VERSION)/$(VERSION)/g
+
+all: html
+
+html:
+	doxygen
+
+install-data-local:
+	$(mkinstalldirs) $(DESTDIR)$(docdir)
+	@for file in $(srcdir)/html/*; do \
+		bn="`basename $$file`"; \
+		echo " $(INSTALL_DATA) $$file $(DESTDIR)$(docdir)/$$bn"; \
+		$(INSTALL_DATA) $$file $(DESTDIR)$(docdir)/$$bn; \
+	done
+
+uninstall-local:
+	@for file in $(srcdir)/html/*; do \
+		bn="`basename $$file`"; \
+		echo " rm -f $(DESTDIR)$(docdir)/$$bn"; \
+		rm -f $(DESTDIR)$(docdir)/$$bn; \
+	done
+

Added: nxcl/lib/Makefile.am
===================================================================
--- nxcl/lib/Makefile.am	2007-08-19 15:44:16 UTC (rev 372)
+++ nxcl/lib/Makefile.am	2007-09-11 12:48:46 UTC (rev 373)
@@ -0,0 +1,7 @@
+CLEANFILES = *~
+AM_CPPFLAGS = @PACKAGE_CFLAGS@  -DPACKAGE_BIN_DIR=\""$(bindir)"\"
+INCLUDES = -I$(top_srcdir) -I$(top_builddir)
+lib_LTLIBRARIES = libnxcl.la
+libnxcl_la_SOURCES = notQt.cpp nxsession.cpp nxclientlib.cpp
+libnxcl_la_LDFLAGS = -version-info 1:0:0
+pkginclude_HEADERS = notQt.h nxsession.h nxclientlib.h nxdata.h nxclientlib_i18n.h

Added: nxcl/lib/i18n.h
===================================================================
--- nxcl/lib/i18n.h	2007-08-19 15:44:16 UTC (rev 372)
+++ nxcl/lib/i18n.h	2007-09-11 12:48:46 UTC (rev 373)
@@ -0,0 +1,22 @@
+#ifndef __NXCL_I18N__
+#  define __NXCL_I18N__
+#  ifdef HAVE_CONFIG_H
+#    include <config.h>
+#  endif
+#  ifdef ENABLE_NLS
+#    include "../lib/gettext.h"
+#    define _(String) gettext (String)
+#    define gettext_noop(String) String
+#    define N_(String) gettext_noop (String)
+#  else
+#    define _(String) (String)
+#    define N_(String) String
+#    define textdomain(Domain) (Domain)
+#    define gettext(String) (String)
+#    define dgettext(Domain,String) (String)
+#    define dcgettext(Domain,String,Type) (String)
+#    define bindtextdomain(Domain, Directory) (Domain) 
+#    define bind_textdomain_codeset(Domain,Codeset) (Codeset) 
+#  endif /* ENABLE_NLS */
+#endif /* __NXCL_I18N__ */
+

Added: nxcl/lib/notQt.cpp
===================================================================
--- nxcl/lib/notQt.cpp	2007-08-19 15:44:16 UTC (rev 372)
+++ nxcl/lib/notQt.cpp	2007-09-11 12:48:46 UTC (rev 373)
@@ -0,0 +1,469 @@
+/*!
+ * A set of QT like functionality, especially related to the starting
+ * of processes.
+ *
+ * Author: Sebastian James <seb at esfnet.co.uk>
+ * This code is copyright (C) Embedded Software Foundry Ltd. 2007
+ *
+ * It is released under the terms of the GNU GPL version 2.
+ */
+
+#include <iostream>
+#include <sstream>
+extern "C" {
+#include <unistd.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <sys/stat.h>
+#include <sys/poll.h>	
+#include <signal.h>
+}
+#include "notQt.h"
+
+using namespace std;
+using namespace nxcl;
+
+/*!
+ * Implementation of the notQProcess class
+ */
+//@{
+
+// Used when dealing with pipes
+#define READING_END 0
+#define WRITING_END 1
+#define STDIN  0
+#define STDOUT 1
+#define STDERR 2
+
+// Constructor
+notQProcess::notQProcess () :
+	progName("unknown"),
+	error (NOTQPROCNOERROR),
+	pid(0),
+	signalledStart(false)
+{
+	// Set up the polling structs
+	this->p = static_cast<struct pollfd*>(malloc (2*sizeof (struct pollfd)));	
+}
+
+// Destructor
+notQProcess::~notQProcess ()
+{
+	free (this->p);
+}
+
+void
+notQProcess::writeIn (string& input)
+{
+	write (this->parentToChild[WRITING_END], input.c_str(), input.size());
+}
+
+// fork and exec a new process using execv, which takes stdin via a
+// fifo and returns output also via a fifo.
+int
+notQProcess::start (const string& program, const list<string>& args)
+{
+	char** argarray;
+	list<string> myargs = args;
+	list<string>::iterator i;
+	unsigned int j = 0;
+	int theError;
+
+	// NB: The first item in the args list should be the program name.
+	this->progName = program;
+
+	// Set up our pipes
+	if (pipe(parentToChild) == -1 || pipe(childToParent) == -1 || pipe(childErrToParent) == -1) {
+		return NOTQTPROCESS_FAILURE;
+	}
+
+	this->pid = fork();
+	switch (this->pid) {
+	case -1:
+		return NOTQTPROCESS_FAILURE;
+	case 0:
+		// This is the CHILD process
+
+		// Close unwanted ends of the pipes
+		close (parentToChild[WRITING_END]);
+		close (childToParent[READING_END]);
+		close (childErrToParent[READING_END]);
+
+		// Now all we have to do is make the writing file
+		// descriptors 0,1 or 2 and they will be used instead
+		// of stdout, stderr and stdin.
+		if ((dup2 (parentToChild[READING_END], STDIN)) == -1  ||
+		    (dup2 (childToParent[WRITING_END], STDOUT)) == -1 || 
+		    (dup2 (childErrToParent[WRITING_END], STDERR)) == -1) {
+			theError = errno;
+			cout << "ERROR! Couldn't get access to stdin/out/err! errno was " << theError << endl;
+			return NOTQTPROCESS_FAILURE;	
+		}
+
+		// Allocate memory for the program arguments
+		// 1+ to allow space for NULL terminating pointer
+		argarray = static_cast<char**>(malloc ((1+args.size()) * sizeof (char*))); 
+		for (i=myargs.begin(); i!=myargs.end(); i++) {
+			argarray[j] = static_cast<char*>(malloc ( (1+(*i).size()) * sizeof (char) ));
+			snprintf (argarray[j++], 1+(*i).size(), "%s", (*i).c_str());
+			dbgln(*i);
+		}
+		argarray[j] = NULL;
+
+		dbgln ("About to execute '" + program + "' with those arguments..");
+
+		execv (program.c_str(), argarray);
+
+		// If process returns, error occurred
+		theError = errno; 
+		// This'll get picked up by parseResponse
+		cout << "notQProcess error: " << this->pid << " crashed. errno:" << theError << endl;
+		
+		// This won't get picked up by the parent process.
+		this->error = NOTQPROCCRASHED;
+
+		// In this case, we close the pipes to signal to the parent that we crashed
+		close (parentToChild[READING_END]);
+		close (childToParent[WRITING_END]);
+		close (childErrToParent[WRITING_END]);
+		
+		// Child should exit now.
+		exit(-1);
+
+	default:
+		// This is the PARENT process
+
+		// Close unwanted ends of the pipes
+		close (parentToChild[READING_END]);
+		close (childToParent[WRITING_END]);
+		close (childErrToParent[WRITING_END]);
+
+		// Write to this->parentToChild[WRITING_END] to write to stdin of the child
+		// Read from this->childToParent[READING_END] to read from stdout of child
+		// Read from this->childErrToParent[READING_END] to read from stderr of child
+
+		break;
+	}
+	return NOTQTPROCESS_MAIN_APP;
+}
+
+
+// If no pid after a while, return false.
+bool
+notQProcess::waitForStarted (void)
+{
+	unsigned int i=0;
+	while (this->pid == 0 && i<1000) {
+		usleep (1000);
+		i++;
+	}
+	if (this->pid>0) {
+		dbgln ("The process started!");
+		this->callbacks->startedSignal (this->progName);
+		this->signalledStart = true;
+		return true;
+	} else {
+		this->error = NOTQPROCFAILEDTOSTART;
+		this->callbacks->errorSignal (this->error);
+		return false;
+	}
+
+}
+
+// Send a TERM signal to the process.
+void
+notQProcess::terminate (void)
+{
+	kill (this->pid, 15); // 15 is TERM
+	// Now check if the process has gone and kill it with signal 9 (KILL)
+	this->pid = 0;
+	this->error = NOTQPROCNOERROR;
+	this->signalledStart = false;
+	return;
+}
+
+// Check on this process
+void
+notQProcess::probeProcess (void)
+{
+	// Has the process started?
+	if (!this->signalledStart) {
+		if (this->pid > 0) {
+			this->callbacks->startedSignal (this->progName);
+			this->signalledStart = true;
+			dbgln ("notQProcess::probeProcess set signalledStart and signalled the start...");
+		}
+	}
+
+	// Check for error condition
+	if (this->error>0) {
+		this->callbacks->errorSignal (this->error);
+		dbgln ("have error in probeProcess, returning");
+		return;
+	}
+
+	if (this->pid == 0) {
+		// Not yet started.
+		return;
+	}
+
+	// Why can't these 4 lines go in contructor?
+	this->p[0].fd = this->childToParent[READING_END];
+	this->p[0].events = POLLIN | POLLPRI;
+	this->p[1].fd = this->childErrToParent[READING_END];
+	this->p[1].events = POLLIN | POLLPRI;
+
+	// Poll to determine if data is available
+	this->p[0].revents = 0;
+	this->p[1].revents = 0;
+
+	poll (this->p, 2, 0);
+
+	if (this->p[0].revents & POLLNVAL || this->p[1].revents & POLLNVAL) {
+		dbgln ("notQProcess::probeProcess: pipes closed, process must have crashed");
+		this->error = NOTQPROCCRASHED;
+		this->callbacks->errorSignal (this->error);
+		return;
+	}
+
+	if (this->p[0].revents & POLLIN || this->p[0].revents & POLLPRI) {
+		this->callbacks->readyReadStandardOutputSignal();
+	}
+	if (this->p[1].revents & POLLIN || this->p[1].revents & POLLPRI) {
+		this->callbacks->readyReadStandardErrorSignal();
+	}
+
+	// Is the process running? We check last, so that we get any
+	// messages on stdout/stderr that we may wish to process, such
+	// as error messages from nxssh key authentication.
+	int theError;
+	if (this->signalledStart == true) {
+		int rtn = 0;
+		if ((rtn = waitpid (this->pid, (int *)0, WNOHANG)) == this->pid) {
+			this->callbacks->processFinishedSignal (this->progName);
+			return;
+		} else if (rtn == -1) {
+			theError = errno;
+			if (theError != 10) { // We ignore errno 10 "no child" as this commonly occurs
+				cerr << "waitpid returned errno: " << theError;
+			}
+		} // else rtn == 0
+	}
+
+	return;
+}
+
+// Read stdout pipe, without blocking.
+string
+notQProcess::readAllStandardOutput (void)
+{
+	string s;
+	int bytes = 0;
+	char c;
+	struct pollfd p;
+	
+	p.fd = this->childToParent[READING_END];
+	p.events = POLLIN | POLLPRI;
+	// We know we have at least one character to read, so seed revents
+	p.revents = POLLIN;
+	while (p.revents & POLLIN || p.revents & POLLPRI) {
+		// This read of 1 byte should never block
+		if ((bytes = read (this->childToParent[READING_END], &c, 1)) == 1) {
+			s.append (1, c);
+		}
+		p.revents = 0;
+		poll (&p, 1, 0);
+	}
+	return s;
+}
+
+// Read stderr pipe without blocking
+string
+notQProcess::readAllStandardError (void)
+{
+	string s;
+	int bytes = 0;
+	char c;
+	struct pollfd p;
+	
+	p.fd = this->childErrToParent[READING_END];
+	p.events = POLLIN | POLLPRI;
+	// We know we have at least one character to read, so seed revents
+	p.revents = POLLIN;
+	while (p.revents & POLLIN || p.revents & POLLPRI) {
+		// This read of 1 byte should never block because a poll() call tells us there is data
+		if ((bytes = read (this->childErrToParent[READING_END], &c, 1)) == 1) {
+			s.append (1, c);
+		}
+		p.revents = 0;
+		poll (&p, 1, 0);
+	}
+	return s;
+}
+
+//@}
+
+/*!
+ * Implementation of the notQTemporaryFile class
+ */
+//@{
+
+// Constructor
+notQTemporaryFile::notQTemporaryFile ()
+{
+}
+
+// Destructor
+notQTemporaryFile::~notQTemporaryFile ()
+{
+}
+
+void
+notQTemporaryFile::open (void)
+{
+	stringstream fn;
+	fn << "/tmp/notQt" << time(NULL);
+	this->theFileName = fn.str();
+	this->f.open (this->theFileName.c_str(), ios::in|ios::out|ios::trunc);
+}
+
+void
+notQTemporaryFile::write (string input)
+{
+	f << input;
+}
+
+void
+notQTemporaryFile::close (void)
+{
+	this->f.close();
+}
+
+// getter for fileName
+string
+notQTemporaryFile::fileName (void)
+{
+	return this->theFileName;
+}
+
+//@}
+
+
+/*!
+ * Implementation of the notQtUtilities class
+ */
+//@{
+
+// Constructor
+notQtUtilities::notQtUtilities ()
+{
+}
+
+// Destructor
+notQtUtilities::~notQtUtilities ()
+{
+}
+
+string
+notQtUtilities::simplify (string& input)
+{
+	string workingString;
+	unsigned int i=0, start, end;
+
+	// Find the first non-whitespace character.
+	while (input[i] != '\0' && 
+	       (input[i] == ' '  || input[i] == '\t' || input[i] == '\n' || input[i] == '\r')
+	       && i<input.size()) {
+		i++;
+	}
+	start=i;
+
+	// Now find the last non-whitespace character.
+	i = input.size();
+	i--;
+	while ((input[i] == ' '  || input[i] == '\t' || input[i] == '\n' || input[i] == '\r')
+	       && i>0) {
+		i--;
+	}
+	end = ++i;
+	
+	// Copy the substring into a working string.
+	if (end>start) {
+		workingString = input.substr (start, end-start);
+	} else {
+		return "";
+	}
+
+	// Now we replace internal white spaces in workingString with single spaces.
+	for (i=workingString.size(); i>1; --i) {
+		if ( (workingString[i] == ' '   || workingString[i] == '\t'   
+		      || workingString[i] == '\n' || workingString[i] == '\r')
+		     &&
+		     (workingString[i-1] == ' ' || workingString[i-1] == '\t'
+		      ||  workingString[i-1] == '\n' || workingString[i-1] == '\r') ) {
+			// ...then this is a whitespace we can remove
+			workingString.erase(i,1);
+
+		} else if ( (workingString[i] == '\t' ||  workingString[i] == '\n'
+			     || workingString[i] == '\r') 
+			    &&
+			    (workingString[i-1] != ' ' && workingString[i-1] != '\t'
+			     &&  workingString[i-1] != '\n' && workingString[i-1] != '\r') ) {
+			// ...then this is a non-space whitespace to be replaced
+			workingString.replace(i, 1, " ");
+		}
+	}
+
+	return workingString;
+}
+
+// split based on token ' '
+void
+notQtUtilities::splitString (string& line, char token, vector<string>& rtn)
+{
+	rtn.clear();
+	unsigned int i=0;
+	while (i < (line.size())-1) {
+		string tstring;
+		while (line[i] && line[i] != token) {
+			tstring.push_back(line[i++]);
+		}
+		rtn.push_back(tstring);
+		i++;
+	}
+	return;
+}
+
+void
+notQtUtilities::splitString (string& line, char token, list<string>& rtn)
+{
+	rtn.clear();
+	unsigned int i=0;
+	while (i < (line.size())-1) {
+		string tstring;
+		while (line[i] && line[i] != token) {
+			//dbgln ("tstring.push_back line[i] which is '" << line[i] << "'");
+			tstring.push_back(line[i++]);
+		}
+		//dbgln ("rtn.push_back() tstring which is '" + tstring + "'");
+		rtn.push_back(tstring);
+		i++;
+	}
+	return;
+}
+
+int
+notQtUtilities::ensureUnixNewlines (std::string& input)
+{
+	int num = 0;
+
+	for (unsigned int i=0; i<input.size(); i++) {
+		if (input[i] == '\r') {
+			input.erase(i,1);
+			num++;
+		}
+	}
+	
+	return num; // The number of \r characters we found in the string.
+}

Added: nxcl/lib/notQt.h
===================================================================
--- nxcl/lib/notQt.h	2007-08-19 15:44:16 UTC (rev 372)
+++ nxcl/lib/notQt.h	2007-09-11 12:48:46 UTC (rev 373)
@@ -0,0 +1,236 @@
+/* -*-c++-*- */
+/*
+ * Simple re-implementations of some QT-like functionality.  In
+ * particular, there's a QProcess-like (though much simplified) class,
+ * a QTemporaryFile like class and a couple of the methods that you
+ * get with QString.
+ *
+ * (C) 2007 Sebastian James, Embedded Software Foundry Ltd (U.K.).
+ *
+ * Released under the terms of the GNU General Public Licence Version 2. 
+ */
+
+#ifndef _NOTQT_H_
+#define _NOTQT_H_
+
+#include "../config.h"
+
+#include <list>
+#include <vector>
+#include <string>
+#include <fstream>
+extern "C" {
+#include <sys/poll.h>
+}
+#define NOTQTPROCESS_MAIN_APP 0
+#define NOTQTPROCESS_FAILURE -1
+
+// Possible errors to be generated
+#define NOTQPROCNOERROR       0
+#define NOTQPROCFAILEDTOSTART 1
+#define NOTQPROCCRASHED       2
+#define NOTQPROCTIMEDOUT      3
+#define NOTQPROCWRITEERR      4
+#define NOTQPROCREADERR       5
+#define NOTQPROCUNKNOWN       6
+
+using namespace std;
+
+#ifdef DEBUG
+extern ofstream debugLogFile;
+# define dbgln(msg)  debugLogFile << __FUNCTION__ << ": " << msg << endl;
+# define dbglln(msg) debugLogFile << __PRETTY_FUNCTION__ << ": " << msg << endl;
+# define dbg(msg)    debugLogFile << msg;
+#else
+# define dbgln(msg)
+# define dbglln(msg)
+# define dbg(msg)
+#endif
+
+namespace nxcl {
+
+	/*!
+	 * A set of virtual callbacks. These should be derived in the
+	 * client code. They're called by notQProcess via the
+	 * notQProcessCallbacks* callbacks member variable.
+	 */
+	class notQProcessCallbacks
+	{
+	public:
+		notQProcessCallbacks() {}
+		virtual ~notQProcessCallbacks() {}
+		virtual void startedSignal (string) {}
+		virtual void errorSignal (int) {}
+		virtual void processFinishedSignal (string) {}
+		virtual void readyReadStandardOutputSignal (void) {}
+		virtual void readyReadStandardErrorSignal (void) {}
+	};
+
+	/*!
+	 * notQProcess is a simple replacement for the QT class QProcess.
+	 */
+	class notQProcess
+	{
+	public:
+		notQProcess();
+		~notQProcess();
+		/*!
+		 * Write \arg input to the stdin of the process.
+		 */
+		void writeIn (string& input);
+		/*!
+		 * fork and exec the process.
+		 */
+		int start (const string& program, const list<string>& args);
+		/*!
+		 * Send a TERM signal to the process.
+		 */
+		void terminate (void);
+
+		/*!
+		 * poll to see if there is data on stderr or stdout
+		 * and to see if the process has exited.
+		 *
+		 * This must be called on a scheduled basis. It checks
+		 * for any stdout/stderr data and also checks whether
+		 * the process is still running.
+		 */
+		void probeProcess (void);
+
+		/*!
+		 * Accessors
+		 */
+		//@{
+		pid_t getPid (void) { return this->pid; }
+		int getError (void) { return this->error; }
+		void setError (int e) { this->error = e; }
+
+		/*!
+		 * Setter for the callbacks.
+		 */
+		void setCallbacks (notQProcessCallbacks * cb) { this->callbacks = cb; }
+		//@}
+
+		/*! 
+		 * Slots
+		 */
+		//@{
+		string readAllStandardOutput (void);
+		string readAllStandardError (void);
+		/*!
+		 * Wait for the process to get itself going. Do this
+		 * by looking at pid.  If no pid after a while,
+		 * return false.
+		 */
+		bool waitForStarted (void);
+		//@}
+	private:
+		/*!
+		 * The name of the program to execute
+		 */
+		string progName;
+		/*!
+		 * The environment and arguments of the program to execute
+		 */
+		list<string> environment;
+		/*!
+		 * Holds a notQProcess error, defined above. NOTQPROCNOERROR, etc.
+		 */
+		int error;
+		/*!
+		 * Process ID of the program
+		 */
+		pid_t pid;
+		/*!
+		 * Set to true if the fact that the program has been
+		 * started has been signalled using the callback
+		 * callbacks->startedSignal
+		 */
+		bool signalledStart;
+		/*!
+		 * stdin parent to child
+		 */
+		int parentToChild[2];
+		/*!
+		 * stdout child to parent
+		 */
+		int childToParent[2];
+		/*!
+		 * stderr child to parent
+		 */
+		int childErrToParent[2];
+		/*!
+		 * Used in the poll() call in probeProcess()
+		 */
+		struct pollfd * p;
+		/*!
+		 * Pointer to a callback object
+		 */
+		notQProcessCallbacks * callbacks;
+	};
+
+	/*!
+	 * A simple replacement for the QT Class QTemporaryFile.
+	 */
+	class notQTemporaryFile
+	{
+	public:
+		notQTemporaryFile();
+		~notQTemporaryFile();
+		/*!
+		 * Open a file with a (not really) random name. The
+		 * filename will be /tmp/notQtXXXXXX where XXXXXX will
+		 * be the time in seconds since the unix epoch.
+		 */
+		void open (void);
+		/*!
+		 * Write \arg input to the temporary file.
+		 */
+		void write (string input);
+		/*!
+		 * Close the temporary file's stream.
+		 */
+		void close (void);
+		/*!
+		 * A getter for the file name of the temporary file
+		 */
+		string fileName (void);
+
+	private:
+		/*!
+		 * The file name of the temporary file
+		 */
+		string theFileName;
+		/*!
+		 * The file stream for the temporary file
+		 */
+		fstream f;
+	};
+
+	/*!
+	 * A few useful utility functions.
+	 */
+	class notQtUtilities
+	{
+	public:
+		notQtUtilities();
+		~notQtUtilities();
+
+		/*! The same (more or less) as QT QString::simplified */
+		static string simplify (string& input);
+		/*!
+		 * Split a string 'line' based on token, placing the portions in the vector rtn
+		 */
+		static void splitString (string& line, char token, vector<string>& rtn);
+		/*!
+		 * Split a string 'line' based on token, placing the portions in the list rtn
+		 */
+		static void splitString (string& line, char token, list<string>& rtn);
+		/*!
+		 * Run through input and replace any DOS newlines with unix newlines.
+		 */
+		static int ensureUnixNewlines (std::string& input);
+	};
+
+} // namespace
+#endif

Added: nxcl/lib/nxclientlib.cpp
===================================================================
--- nxcl/lib/nxclientlib.cpp	2007-08-19 15:44:16 UTC (rev 372)
+++ nxcl/lib/nxclientlib.cpp	2007-09-11 12:48:46 UTC (rev 373)
@@ -0,0 +1,591 @@
+/***************************************************************************
+                               nxclientlib.cpp
+                             -------------------
+    begin                : Sat 22nd July 2006
+    modifications        : July 2007
+    copyright            : (C) 2006 by George Wright
+    modifications        : (C) 2007 Embedded Software Foundry Ltd. (U.K.)
+                         :     Author: Sebastian James
+    email                : seb at esfnet.co.uk, gwright at kde.org
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "nxclientlib_i18n.h"
+
+#include "nxclientlib.h"
+
+#include <fstream>
+
+extern "C" {
+#include "errno.h"
+}
+
+/*
+ * On the location of nxproxy and nxssh binaries
+ * --------------------------------------------- 
+ * We expect them to be installed in PACKAGE_BIN_DIR (See
+ * Makefile.am). So, if nxcl is installed in /usr/bin/nxcl then we
+ * call /usr/bin/nxssh and /usr/bin/nxproxy, etc etc.
+ */
+
+using namespace std;
+using namespace nxcl;
+
+// Default NoMachine certificate for FALLBACK
+string cert("-----BEGIN DSA PRIVATE KEY-----\nMIIBuwIBAAKBgQCXv9AzQXjxvXWC1qu3CdEqskX9YomTfyG865gb4D02ZwWuRU/9\nC3I9/bEWLdaWgJYXIcFJsMCIkmWjjeSZyTmeoypI1iLifTHUxn3b7WNWi8AzKcVF\naBsBGiljsop9NiD1mEpA0G+nHHrhvTXz7pUvYrsrXcdMyM6rxqn77nbbnwIVALCi\nxFdHZADw5KAVZI7r6QatEkqLAoGBAI4L1TQGFkq5xQ/nIIciW8setAAIyrcWdK/z\n5/ZPeELdq70KDJxoLf81NL/8uIc4PoNyTRJjtT3R4f8Az1TsZWeh2+ReCEJxDWgG\nfbk2YhRqoQTtXPFsI4qvzBWct42WonWqyyb1bPBHk+JmXFscJu5yFQ+JUVNsENpY\n+Gkz3HqTAoGANlgcCuA4wrC+3Cic9CFkqiwO/Rn1vk8dvGuEQqFJ6f6LVfPfRTfa\nQU7TGVLk2CzY4dasrwxJ1f6FsT8DHTNGnxELPKRuLstGrFY/PR7KeafeFZDf+fJ3\nmbX5nxrld3wi5titTnX+8s4IKv29HJguPvOK/SI7cjzA+SqNfD7qEo8CFDIm1xRf\n8xAPsSKs6yZ6j1FNklfu\n-----END DSA PRIVATE KEY-----");
+
+/*!
+ * Implementation of the NXClientLibCallbacks class
+ */
+//@{
+NXClientLibCallbacks::NXClientLibCallbacks()
+{
+}
+
+NXClientLibCallbacks::~NXClientLibCallbacks()
+{
+}
+
+void
+NXClientLibCallbacks::startedSignal (string name)
+{
+	this->parent->externalCallbacks->write(name + _(" process started"));
+}
+
+void
+NXClientLibCallbacks::processFinishedSignal (string name)
+{
+	this->parent->externalCallbacks->write(name + _(" process exited"));
+	parent->setIsFinished (true);
+}
+
+void
+NXClientLibCallbacks::errorSignal (int error)
+{
+	string message;
+	switch (error) {
+	case NOTQPROCFAILEDTOSTART:
+		message = _("The process failed to start");
+		break;
+	case NOTQPROCCRASHED:
+		message = _("The process has crashed");
+		break;
+	case NOTQPROCTIMEDOUT:
+		message = _("The process timed out");
+		break;
+	case NOTQPROCWRITEERR:
+		message = _("There was an error writing to the process");
+		break;
+	case NOTQPROCREADERR:
+		message = _("There was an error reading from the process");
+		break;
+	default:
+		message = _("There was an unknown error with the process");
+		break;
+	}
+		
+	this->parent->externalCallbacks->write (message);
+}
+
+void 
+NXClientLibCallbacks::readyReadStandardOutputSignal (void)
+{
+	this->parent->processParseStdout();
+}
+
+void 
+NXClientLibCallbacks::readyReadStandardErrorSignal (void)
+{
+	this->parent->processParseStderr();
+}
+/*!
+ * This gets called from within the NXSession object...
+ */
+void 
+NXClientLibCallbacks::noSessionsSignal (void)
+{
+	/* ...and it calls another callback function in the client code */
+	this->parent->externalCallbacks->noSessionsSignal();
+}
+void
+NXClientLibCallbacks::loginFailedSignal (void)
+{
+	this->parent->loginFailed();
+}
+void
+NXClientLibCallbacks::readyForProxySignal (void)
+{
+	this->parent->readyproxy();
+}
+void
+NXClientLibCallbacks::authenticatedSignal (void)
+{
+	this->parent->doneAuth();
+}
+void
+NXClientLibCallbacks::sessionsSignal (list<NXResumeData> data)
+{
+	this->parent->externalCallbacks->resumeSessionsSignal (data);
+}
+//@}
+
+/*!e
+ * Implementation of the NXClientLib class
+ */
+//@{
+NXClientLib::NXClientLib()
+{
+	isFinished = false;
+	readyForProxy = false;
+	proxyData.encrypted = false;
+	password = false;
+
+	dbgln ("In NXClientLib constructor");
+
+	this->pNxsshProcess = &this->nxsshProcess;
+	this->pNxproxyProcess = &this->nxproxyProcess;
+
+	/* Set up callback pointers */
+	this->nxsshProcess.setCallbacks (&callbacks);
+	this->nxproxyProcess.setCallbacks (&callbacks);
+	this->session.setCallbacks (&callbacks);
+	this->callbacks.setParent (this);
+
+	dbgln ("Returning from NXClientLib constructor");
+}
+
+NXClientLib::~NXClientLib()
+{
+	dbgln ("In NXClientLib destructor");
+	nxsshProcess.terminate();
+}
+
+void NXClientLib::invokeNXSSH(string publicKey, string serverHost, bool encryption, string key, int port)
+{
+	list<string> arguments;
+	stringstream argtmp;
+	proxyData.server = serverHost;
+
+	dbgln("invokeNXSSH called");
+
+	// We use same environment for the process as was used for the
+	// parent, so remove nxsshProcess.setEnvironment();
+
+	// Start to build the arguments for the nxssh command.
+	// notQProcess requires that argv[0] contains the program name
+	arguments.push_back (PACKAGE_BIN_DIR"/nxssh");
+	
+	if (publicKey == "default") {
+		usingHardcodedKey = true;
+	}
+
+	argtmp << "-nx";
+	arguments.push_back (argtmp.str());
+
+	argtmp.str("");
+	argtmp << "-p" << port;
+	arguments.push_back(argtmp.str());
+
+	if (publicKey == "default" || publicKey == "supplied") {
+		if (publicKey == "default") {
+			this->externalCallbacks->stderrSignal (_("WARNING: Using hardcoded NoMachine public key for "
+					"outer/first stage SSH encryption."));
+		}
+		
+		keyFile = new notQTemporaryFile;
+		keyFile->open();
+		
+		argtmp.str("");
+		argtmp << "-i" << keyFile->fileName();
+		arguments.push_back (argtmp.str());
+
+		if (publicKey == "default") {
+			keyFile->write(cert);
+		} else {
+			keyFile->write(key);
+		}
+			
+		keyFile->close();
+	} else {
+		argtmp.str("");
+		argtmp << "-i" << publicKey;
+		arguments.push_back(argtmp.str());
+	}
+	
+	argtmp.str("");
+	argtmp << "nx@" << serverHost;
+	arguments.push_back(argtmp.str());
+
+	// These options copied from the way Nomachine's client
+	// specifies the nxssh command - they make good sense.
+	arguments.push_back ("-x");
+	arguments.push_back ("-2");
+	arguments.push_back ("-oRhostsAuthentication no");
+	arguments.push_back ("-oPasswordAuthentication no");
+	arguments.push_back ("-oRSAAuthentication no");
+	arguments.push_back ("-oRhostsRSAAuthentication no");
+	arguments.push_back ("-oPubkeyAuthentication yes");
+
+	if (encryption == true) {
+		arguments.push_back("-B");
+		session.setEncryption (true);
+	} else {
+		session.setEncryption (false);
+	}
+
+	// -E appears in the call to nxssh for Nomachine's nxclient
+	// -version 3 but not 1.5. Is it there in 2?
+	// nxssh -E gives this message when called:
+	// NX> 285 Enabling skip of SSH config files
+	// ...so there you have the meaning.
+	arguments.push_back ("-E");
+	
+	this->nxsshProcess.start (PACKAGE_BIN_DIR"/nxssh", arguments);
+
+	if (nxsshProcess.waitForStarted() == false) {
+		dbgln ("nx ssh process didn't start :(");
+	}
+}
+
+void NXClientLib::requestConfirmation (string msg)
+{
+	this->externalCallbacks->stdoutSignal (_("This is a placeholder method to deal with sending back a yes or a no answer. "
+						 "For now, we just set this->session.setContinue(true);"));
+	this->session.setContinue(true);
+}
+
+void NXClientLib::reset()
+{
+	this->nxsshProcess.terminate();       
+	this->isFinished = false;
+	this->proxyData.encrypted = false;
+	this->password = false;	
+	this->session.resetSession();
+}
+
+void NXClientLib::loginFailed()
+{
+	this->externalCallbacks->write (_("Got \"Login Failed\""));
+	this->isFinished = true;
+	this->nxsshProcess.terminate();
+}
+
+void NXClientLib::processParseStdout()
+{
+	string message = nxsshProcess.readAllStandardOutput();
+
+	this->externalCallbacks->stdoutSignal (message);
+
+	dbgln ("NXClientLib::processParseStdout() called");
+
+	int response = 0;
+	// Message 211 is sent if ssh is asking to continue with an unknown host
+	if ((response = session.parseResponse(message)) == 211) {
+		this->requestConfirmation (message);
+	}
+
+	dbgln ("NXClientLib::processPraseStdout(): response = " << response);
+
+	if (response == 100000) {
+		// A program never started.
+		this->isFinished = true;
+		return;
+	} else if (response > 100000) {
+		dbgln ("A process crashed or exited");
+		int pid = response - 100000;
+		if (this->nxsshProcess.getPid() == pid) {
+			this->nxsshProcess.setError(NOTQPROCCRASHED);
+			this->externalCallbacks->write (_("nxsshProcess crashed or exited"));
+			this->isFinished = true;
+		} else if (this->nxproxyProcess.getPid() == pid) {
+			this->nxproxyProcess.setError(NOTQPROCCRASHED);
+			this->externalCallbacks->write (_("nxproxyProcess crashed or exited"));
+			this->isFinished = true;
+		} else {
+			this->externalCallbacks->write (_("Warning: Don't know what crashed (in processParseStdout())"));
+		}
+		return;
+	}
+
+	// If message 204 is picked, that's authentication failed.
+	if (response == 204) {
+		this->externalCallbacks->write (_("Got \"Authentication Failed\" from nxssh.\n"
+						  "Please check the certificate for the first SSL authentication stage,\n"
+						  "in which the \"nx\" user is authenticated."));
+		this->isFinished = true;
+		return;
+	}
+
+	// 147 is server capacity reached
+	if (response == 147) {
+		this->externalCallbacks->write (_("Got \"Server Capacity Reached\" from nxssh.\n"));
+		dbgln ("Got \"Server Capacity Reached\" from nxssh.");
+		this->externalCallbacks->serverCapacitySignal();
+		this->isFinished = true;
+		return;
+	}
+	
+	dbgln ("NXClientLib::processParseStdout(): The message is '" + message + "'(msg end)");
+	dbgln ("...and response is " << response);
+
+	notQtUtilities::ensureUnixNewlines (message);
+	list<string> msglist;
+	list<string>::iterator msgiter;
+	notQtUtilities::splitString (message, '\n', msglist);
+
+	for (msgiter = msglist.begin(); msgiter != msglist.end(); msgiter++) {
+		dbgln ("NXClientLib::processParseStdout(): Processing the message '" + (*msgiter) + "'(end msg)");
+		// On some connections this is sent via stdout instead of stderr?
+		if (proxyData.encrypted && readyForProxy && ((*msgiter).find("NX> 999 Bye")!=string::npos)) {
+			// This is "NX> 299 Switching connection to: " in
+			// version 1.5.0. This was changed in nxssh version
+			// 2.0.0-8 (see the nxssh CHANGELOG).
+			string switchCommand = "NX> 299 Switch connection to: ";
+			stringstream ss;
+			ss << "127.0.0.1:" << proxyData.port << " cookie: " << proxyData.cookie << "\n";
+			switchCommand += ss.str();
+			this->write(switchCommand);
+		} else if ((*msgiter).find("NX> 287 Redirected I/O to channel descriptors") != string::npos) {
+			dbgln ("287 message found on stdout");
+			this->externalCallbacks->write(_("The session has been started successfully"));
+		}
+
+		if ((*msgiter).find("Password") != string::npos) {
+			this->externalCallbacks->write(_("Authenticating with NX server"));
+			password = true;
+		}
+
+		if (!readyForProxy) {
+			string msg = session.parseSSH (*msgiter);
+			if (msg == "204\n" || msg == "147\n") {
+				// Auth failed.
+				dbgln ("NXClientLib::processParseStdout: Got auth failed or capacity reached, calling this->parseSSH.");
+				msg = this->parseSSH (*msgiter);
+			}
+			if (msg.size() > 0) {
+				this->write (msg);
+			}
+		} else {
+			this->write (this->parseSSH (*msgiter));
+		}
+	}
+	return;
+}
+
+void NXClientLib::processParseStderr()
+{
+	string message = nxsshProcess.readAllStandardError();
+
+	dbgln ("In NXClientLib::processParseStderr for message: '" + message + "'(msg end)");
+
+	this->externalCallbacks->stderrSignal (message);
+
+	// Now we need to split the message if necessary based on the \n or \r characters
+	notQtUtilities::ensureUnixNewlines (message);
+
+	list<string> msglist;
+	list<string>::iterator msgiter;
+	notQtUtilities::splitString (message, '\n', msglist);
+
+	for (msgiter=msglist.begin(); msgiter!=msglist.end(); msgiter++) {
+		dbgln ("NXClientLib::processParseStderr: Processing the message '" + (*msgiter) + "'(end msg)");
+		if (proxyData.encrypted && readyForProxy && ((*msgiter).find("NX> 999 Bye") != string::npos)) {
+			string switchCommand = "NX> 299 Switch connection to: ";
+			stringstream ss;
+			ss << "127.0.0.1:" << proxyData.port << " cookie: " << proxyData.cookie << "\n";
+			switchCommand += ss.str();
+			this->write(switchCommand);
+
+		} else if ((*msgiter).find("NX> 287 Redirected I/O to channel descriptors") != string::npos) {
+			this->externalCallbacks->write(_("The session has been started successfully"));
+
+		} else if ((*msgiter).find("NX> 209 Remote host identification has changed") != string::npos) {
+			this->externalCallbacks->write(_("SSH Host Key Problem"));
+			this->isFinished = true;
+
+		} else if ((*msgiter).find("NX> 280 Ignoring EOF on the monitored channel") != string::npos) {
+			this->externalCallbacks->write(_("Unknown problem..."));
+			this->isFinished = true;
+
+		} else if ((*msgiter).find("Host key verification failed") != string::npos) {
+			this->externalCallbacks->write(_("SSH host key verification failed"));
+			this->isFinished = true;			
+		}
+	}
+}
+
+void NXClientLib::write (string data)
+{
+	if (data.size() == 0) { return; }
+
+	dbgln ("Writing '" << data << "' to nxssh process.");
+	
+	this->nxsshProcess.writeIn(data);
+
+	if (password) {
+		data = "********";
+		password = false;
+	}
+
+	// Output this to the user via a signal - this is data going in to nxssh.
+	this->externalCallbacks->stdinSignal (data);
+}
+
+void NXClientLib::doneAuth()
+{
+	// FIXME: Don't think this is correctly removing the keyfile data.
+	if (usingHardcodedKey)
+		delete keyFile;
+}
+
+void NXClientLib::allowSSHConnect (bool auth)
+{
+	session.setContinue (auth);
+}
+
+void NXClientLib::setSessionData (NXSessionData *nxSessionData)
+{
+	session.setSessionData (nxSessionData);
+	string a = "NX> 105";
+	string d = session.parseSSH(a);
+	if (d.size()>0) {
+		this->write(d);
+	}
+}
+
+string NXClientLib::parseSSH (string message)
+{
+	string rMessage;
+	string::size_type pos;
+	rMessage = "";
+
+	dbgln ("NXClientLib::parseSSH called for message '" + message + "'");
+
+	if ((pos = message.find("NX> 700 Session id: ")) != string::npos) {
+		proxyData.id = message.substr(pos+20, message.length()-pos);
+		dbgln ("proxyData.id = " + proxyData.id);
+	} else if ((pos = message.find("NX> 705 Session display: ")) != string::npos) {
+		stringstream portss;
+		int portnum;
+		portss << message.substr(pos+25, message.length()-pos);
+		portss >> portnum;		
+		proxyData.display = portnum;
+		dbgln ("proxyData.display = " << proxyData.display);
+		proxyData.port = portnum + 4000;
+		dbgln ("proxyData.port = " << proxyData.port);
+	} else if ((pos = message.find("NX> 706 Agent cookie: ")) != string::npos) {
+		proxyData.cookie = message.substr(pos+22, message.length()-pos);
+		dbgln ("proxyData.cookie = " + proxyData.cookie);
+	} else if ((pos = message.find("NX> 702 Proxy IP: ")) != string::npos) {
+		proxyData.proxyIP = message.substr(pos+18, message.length()-pos);
+		dbgln ("proxyData.proxyIP = " + proxyData.proxyIP);
+	} else if (message.find("NX> 707 SSL tunneling: 1") != string::npos) {
+		dbgln ("Setting proxyData.encrypted to true");
+		proxyData.encrypted = true;
+	} else if (message.find("NX> 147 Server capacity") != string::npos) {
+		this->externalCallbacks->write (_("Got \"Server Capacity Reached\" from nxssh."));
+		this->externalCallbacks->serverCapacitySignal();
+		this->isFinished = true;
+	} else if (message.find ("NX> 204 Authentication failed.") != string::npos) {
+		this->externalCallbacks->write (_("NX SSH Authentication Failed, finishing"));
+		this->isFinished = true;
+	}
+
+	if (message.find("NX> 710 Session status: running") != string::npos) {
+		invokeProxy();
+		session.wipeSessions();
+		rMessage = "bye\n";
+	}
+
+	dbgln ("NXClientLib::parseSSH returning");
+	return rMessage;
+}
+
+void NXClientLib::invokeProxy()
+{
+	dbgln ("invokeProxy called");
+
+	this->externalCallbacks->write(_("Starting NX session"));
+	
+	int e;
+	char * home;
+	home = getenv ("HOME");
+	stringstream ss;
+	ss << home;
+	string nxdir = ss.str();
+	nxdir += "/.nx";
+	// Create the .nx directory first.
+	if (mkdir (nxdir.c_str(), 0770)) {
+		e = errno;
+		if (e != EEXIST) { // We don't mind .nx already
+				   // existing, though if there is a
+				   // _file_ called $HOME/.nx, we'll
+				   // get errors later.
+			this->externalCallbacks->write (_("Problem creating .nx directory"));
+		}
+	}
+	// Now the per session directory
+	nxdir += "/S-" + proxyData.id;
+	if (mkdir (nxdir.c_str(), 0770)) {
+		e = errno;
+		if (e != EEXIST) { // We don't mind .nx already
+			this->externalCallbacks->write (_("Problem creating Session directory"));
+		}
+	}
+
+	stringstream data;
+	if (proxyData.encrypted) {
+		data << "nx/nx,session=session,encryption=1,cookie=" << proxyData.cookie 
+		     << ",root=" << home << "/.nx"
+		     << ",id=" << proxyData.id << ",listen=" << proxyData.port << ":" << proxyData.display << "\n";
+		// may also need shmem=1,shpix=1,font=1,product=...
+
+	} else {
+		// Not tested yet
+		data << "nx,session=session,cookie=" << proxyData.cookie
+		     << ",root=" << home
+		     << "/.nx,id=" << proxyData.id
+		     << ",connect=" << proxyData.server << ":" << proxyData.display << "\n";
+	}
+	
+	// Filename is nxdir plus "/options"
+	nxdir += "/options";
+	std::ofstream options;
+	options.open (nxdir.c_str(), std::fstream::out);
+	options << data.str();
+	options.close();
+
+	// Build arguments for the call to the nxproxy command
+	list<string> arguments;
+	arguments.push_back(PACKAGE_BIN_DIR"/nxproxy"); // argv[0] has to be the program name
+	arguments.push_back("-S");
+	ss.str("");
+	ss << "options=" << nxdir;
+	ss << ":" << proxyData.display;
+	arguments.push_back(ss.str());	
+
+	// This is of type notQProcess.
+	this->nxproxyProcess.start(PACKAGE_BIN_DIR"/nxproxy", arguments);
+
+	if (nxproxyProcess.waitForStarted() == false) {
+		dbgln ("nxproxy process didn't start :(");
+	}
+}
+
+bool NXClientLib::chooseResumable (int n)
+{
+	return (this->session.chooseResumable(n));
+}
+
+bool NXClientLib::terminateSession (int n)
+{
+	return (this->session.terminateSession(n));
+}
+//@}

Added: nxcl/lib/nxclientlib.h
===================================================================
--- nxcl/lib/nxclientlib.h	2007-08-19 15:44:16 UTC (rev 372)
+++ nxcl/lib/nxclientlib.h	2007-09-11 12:48:46 UTC (rev 373)
@@ -0,0 +1,335 @@
+/* -*-c++-*- */
+/***************************************************************************
+                                nxclientlib.h
+                             -------------------
+    begin                : Sat 22nd July 2006
+    remove QT dependency : Started June 2007
+    modifications        : June-July 2007
+    copyright            : (C) 2006 by George Wright
+    modifications        : (C) 2007 Embedded Software Foundry Ltd. (U.K.)
+                         :     Author: Sebastian James
+    email                : seb at esfnet.co.uk, gwright at kde.org
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef _NXCLIENTLIB_H_
+#define _NXCLIENTLIB_H_
+
+#include <iostream>
+#include "nxsession.h"
+#include <list>
+#include "notQt.h"
+
+using namespace std;
+
+namespace nxcl {
+
+	struct ProxyData {
+		string id;
+		int    display;
+		string cookie;
+		string proxyIP;
+		bool   encrypted;
+		int    port;
+		string server;
+	};
+
+	/*!
+	 * Callbacks which are to be defined by the client code of
+	 * NXClientLib objects. In the case of nxcl, that means the
+	 * code in the class Nxcl in nxcl.cpp.
+	 */
+	class NXClientLibExternalCallbacks
+	{
+	public:
+		NXClientLibExternalCallbacks () {}
+		virtual ~NXClientLibExternalCallbacks () {}
+		virtual void write (string msg) {}
+		virtual void debug (string msg) {}
+		virtual void stdoutSignal (string msg) {}
+		virtual void stderrSignal (string msg) {}
+		virtual void stdinSignal (string msg) {}
+		virtual void resumeSessionsSignal (list<NXResumeData>) {}
+		virtual void noSessionsSignal (void) {}
+		virtual void serverCapacitySignal (void) {}
+
+	};
+
+	/*!
+	 * Have to derive NXClientLib from an abstract base class,
+	 * NXClientLibBase, so that NXClientLibCallbacks can
+	 * hold a pointer to an NXClientLib object.
+	 *
+	 * The functions that are declared in NXClientLibBase are the
+	 * ones that we want to call via this->parent in
+	 * NXClientLibCallbacks. They're the ones that are called from
+	 * within objects of other classes (such as this->session
+	 * (NXSession) or this->nxsshProcess (notQProcess).
+	 */
+	class NXClientLibBase 
+	{
+	public:
+		NXClientLibBase() {}
+		virtual ~NXClientLibBase() {}
+
+		virtual void setIsFinished (bool status) {}
+		virtual void processParseStdout (void) {}
+		virtual void processParseStderr (void) {}
+		virtual void loginFailed (void) {}
+		virtual void readyproxy (void) {}
+		virtual void doneAuth (void) {}
+
+		/*!
+		 * External callbacks pointer is held in NXClientLibBase
+		 * because NXClientLibProcessCallbacks::parent is of
+		 * type NXClientLibBase and in NXClientLibProcessCallbacks we
+		 * refer to this->parent->externalCallbacks->write()
+		 */
+		NXClientLibExternalCallbacks * externalCallbacks;
+	};
+
+	/*!
+	 * Callbacks class. This derives from several other base
+	 * callbacks classes, defining the behaviour of the callbacks.
+	 */
+	class NXClientLibCallbacks : public notQProcessCallbacks, public NXSessionCallbacks
+	{
+	public:
+		NXClientLibCallbacks();
+		~NXClientLibCallbacks();
+		
+		/*!
+		 * The callback signals
+		 */
+		//@{
+		/*!
+		 * From notQProcess:
+		 */
+		//@{
+		void startedSignal (string name);
+		void errorSignal (int error);
+		void processFinishedSignal (string name);
+		void readyReadStandardOutputSignal (void);
+		void readyReadStandardErrorSignal (void);
+		//@}
+		/*!
+		 * From NXSession:
+		 */
+		//@{
+		void noSessionsSignal (void);
+		void loginFailedSignal (void);
+		void readyForProxySignal (void);
+		void authenticatedSignal (void);
+		void sessionsSignal (list<NXResumeData>);
+		//@}
+		//@}
+
+		/*!
+		 * Accessor function to set a pointer to the parent NXCLientLib object.
+		 */
+		void setParent (NXClientLibBase * p) { this->parent = p; }
+	private:
+		NXClientLibBase * parent;
+	};
+
+	class NXClientLib : public NXClientLibBase
+	{
+	public:
+		NXClientLib();
+		~NXClientLib();
+
+		/*!
+		 * Set up data and then call this->nxsshProcess.start().
+		 * 
+		 * \arg publicKey is the path to the ssh public key
+		 * file to authenticate with.  Pass "default" to use
+		 * the default NoMachine key.
+		 *
+		 * \arg serverHost is the hostname of the NX server to
+		 * connect to
+		 *
+		 * \arg encryption is whether to use an encrypted NX
+		 * session
+		 */
+		void invokeNXSSH (string publicKey = "default", string serverHost = "",
+				  bool encryption = true, string key = "", int port = 22);
+
+		/*!
+		 * Overloaded to give callback data on write.
+		 * 
+		 * Writes \arg data to this->nxsshProcess stdin and also
+		 * out to the user via stdoutCallback
+		 */
+		void write (string data);
+
+		/*!
+		 * Passes \arg auth to this->session.setContinue()
+		 */
+		void allowSSHConnect (bool auth);
+
+		/*!
+		 * Set up data and then call this->nxproxyProcess.start()
+		 */
+		void invokeProxy (void);
+
+		/*!
+		 * Parse a line of output from
+		 * this->nxsshProcess. This is called when the proxy
+		 * has started, or if NX authentication
+		 * failed. Otherwise, this->session.parseSSH() is
+		 * used.
+		 */
+		string parseSSH (string message);
+
+		/*!
+		 * Read through the nx session file, and if we find a
+		 * message saying "Session: Terminating session at
+		 * 'some date'" we need to set isFinished to true.
+		 */
+		//void checkSession (void);
+
+		/*!
+		 * Re-set the contents of this->session.sessionData
+		 * with the nth choice.
+		 *
+		 * \return true if the nth session is resumable, false
+		 * if not, or if there is no nth session.
+		 */
+		bool chooseResumable (int n); 
+
+		/*!
+		 * Re-set the contents of this->session.sessionData
+		 * with the nth choice such that a terminate session
+		 * message will be sent to the nxserver
+		 *
+		 * \return true if the nth session is terminatable, false
+		 * if not, or if there is no nth session.
+		 */
+		bool terminateSession (int n); 
+
+		// public slots:
+		//@{
+		void doneAuth (void);
+		void loginFailed (void);
+		void finished (void) { dbgln ("Finishing up on signal"); this->isFinished = true; }
+		void readyproxy (void) { dbgln ("ready for nxproxy"); this->readyForProxy = true; }
+		void reset (void);
+		void processParseStdout (void);
+		void processParseStderr (void);
+
+		/*!
+		 * SSH requests confirmation to go ahead with
+		 * connecting (e.g. if you haven't connected to the
+		 * host before)
+		 */
+		void requestConfirmation (string msg);
+		//@}
+
+		// Accessors
+		//@{
+		/*!
+		 *  Set the username for NX to log in with
+		 */
+		void setUsername (string& user) {
+			this->nxuser = user;
+			this->session.setUsername (this->nxuser); 
+		}
+		/*!
+		 *  Set the password for NX to log in with
+		 */
+		void setPassword (string& pass) {
+			this->nxpass = pass;
+			this->session.setPassword (this->nxpass); 
+		}
+
+		void setResolution (int x, int y) { this->session.setResolution(x, y); }
+		void setDepth (int depth) { this->session.setDepth(depth); }
+		void setRender (bool render) { this->session.setRender(render); }
+		void setSessionData (NXSessionData *);
+		notQProcess* getNXSSHProcess (void) { return this->pNxsshProcess; }
+		notQProcess* getNXProxyProcess (void) { return this->pNxproxyProcess; }
+		bool getIsFinished (void) { return this->isFinished; }
+		bool getReadyForProxy (void) { return this->readyForProxy; }
+		NXSession* getSession (void) { return &this->session; }
+		void setIsFinished (bool status) { this->isFinished = status; }
+		void setExternalCallbacks (NXClientLibExternalCallbacks * cb) { this->externalCallbacks = cb; }
+		//@}
+
+	private:
+		/*!
+		 * true if we're using the hardcoded SSL key (the
+		 * default NoMachine one). To be removed.
+		 */
+		bool usingHardcodedKey;
+		/*!
+		 * Set true when the program is ready to end, e.g if
+		 * authentication failed, nxssh failed to start amoung
+		 * other reasons.
+		 */
+		bool isFinished;
+		/*!
+		 * Set true when nxssh is ready to launch the nxproxy process.
+		 */
+		bool readyForProxy;
+		/*!
+		 * Have we said we need to enter a password?
+		 */
+		bool password;
+		
+		// FIXME: I hold the actual data, and a pointer to the
+		// data here. I tried to get rid of the pointer, and
+		// modify main.cpp in ../nxcl and that didn't work
+		// properly - I'm not sure why. I suppose I could get
+		// rid of the objects here, and then call
+		// pNxsshProcess = new notQProcess; in the
+		// constructor...
+		/*!
+		 * The nxssh process object
+		 */
+		notQProcess nxsshProcess;
+		notQProcess* pNxsshProcess;
+		/*!
+		 * The nxproxy process object
+		 */
+		notQProcess nxproxyProcess;
+		notQProcess* pNxproxyProcess;
+		/*!
+		 * A callbacks object. This holds the various callback
+		 * methods. The callback methods are defined here, but
+		 * are callable from notQProcess etc.
+		 */
+		NXClientLibCallbacks callbacks;
+		/*!
+		 * A temporary file to hold the ssl key
+		 */
+		notQTemporaryFile *keyFile;
+		/*!
+		 * The NX Session object.
+		 */
+		NXSession session;
+		/*!
+		 * A structure holding information about the
+		 * connection to be made, such as server address, port
+		 * and id.
+		 */
+		ProxyData proxyData;
+		/*!
+		 * Username for the connection
+		 */
+		string nxuser;
+		/*!
+		 * Password for the connection
+		 */
+		string nxpass;
+	};
+
+} // namespace
+#endif

Added: nxcl/lib/nxclientlib_i18n.h
===================================================================
--- nxcl/lib/nxclientlib_i18n.h	2007-08-19 15:44:16 UTC (rev 372)
+++ nxcl/lib/nxclientlib_i18n.h	2007-09-11 12:48:46 UTC (rev 373)
@@ -0,0 +1,30 @@
+extern "C" {
+#ifndef __NXCLIENTLIB_I18N__
+#  define __NXCLIENTLIB_I18N__
+
+#define _(String) (String)
+#define N_(String) String
+
+
+/*
+#  ifdef HAVE_CONFIG_H
+#    include <config.h>
+#  endif
+#  ifdef ENABLE_NLS
+#    include "../lib/gettext.h"
+#    define _(String) gettext (String)
+#    define gettext_noop(String) String
+#    define N_(String) gettext_noop (String)
+#  else
+#    define _(String) (String)
+#    define N_(String) String
+#    define textdomain(Domain) (Domain)
+#    define gettext(String) (String)
+#    define dgettext(Domain,String) (String)
+#    define dcgettext(Domain,String,Type) (String)
+#    define bindtextdomain(Domain, Directory) (Domain) 
+#    define bind_textdomain_codeset(Domain,Codeset) (Codeset) 
+#  endif
+*/
+#endif /* __NXCLIENTLIB_I18N__ */
+}

Added: nxcl/lib/nxdata.h
===================================================================
--- nxcl/lib/nxdata.h	2007-08-19 15:44:16 UTC (rev 372)
+++ nxcl/lib/nxdata.h	2007-09-11 12:48:46 UTC (rev 373)
@@ -0,0 +1,101 @@
+/***************************************************************************
+                                nxdata.h
+                             -------------------
+    begin                : Wednesday 9th August 2006
+    modifications        : July 2007
+    copyright            : (C) 2006 by George Wright
+    modifications        : (C) 2007 Embedded Software Foundry Ltd. (U.K.)
+                         :     Author: Sebastian James
+    email                : seb at esfnet.co.uk, gwright at kde.org
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef _NXDATA_H_
+#define _NXDATA_H_
+
+#include <string>
+
+using namespace std;
+
+namespace nxcl {
+
+	struct NXConfigData {
+		string serverHost;
+		int serverPort;
+		string sessionUser;
+		string sessionPass;
+		string sessionName;
+		string sessionType;
+		int cache;
+		int images;
+		string linkType;
+		bool render;
+		string backingstore;
+		int imageCompressionMethod;
+		int imageCompressionLevel;
+		string geometry;
+		string keyboard;
+		string kbtype;
+		bool media;
+		string agentServer;
+		string agentUser;
+		string agentPass;
+		int cups;
+		string key;
+		bool encryption;
+		bool fullscreen;
+		string customCommand;
+	};
+
+	struct NXSessionData {
+		string sessionName;
+		string sessionType;
+		int cache;
+		int images;
+		string linkType;
+		bool render;
+		string backingstore;
+		int imageCompressionMethod;
+		int imageCompressionLevel;
+		string geometry;
+		string keyboard;
+		string kbtype;
+		bool media;
+		string agentServer;
+		string agentUser;
+		string agentPass;
+		int cups;
+		string id;
+		string key;
+		bool encryption;
+		bool fullscreen;
+		string customCommand;
+		bool suspended;
+		int xRes;
+		int yRes;
+		int depth;
+		int display;
+		bool terminate;
+	};
+
+	struct NXResumeData {
+		int display;
+		string sessionType;
+		string sessionID;
+		string options;
+		int depth;
+		string screen;
+		string available;
+		string sessionName;
+	};
+
+} // namespace
+#endif

Added: nxcl/lib/nxsession.cpp
===================================================================
--- nxcl/lib/nxsession.cpp	2007-08-19 15:44:16 UTC (rev 372)
+++ nxcl/lib/nxsession.cpp	2007-09-11 12:48:46 UTC (rev 373)
@@ -0,0 +1,575 @@
+/***************************************************************************
+                               nxsession.h
+                             -------------------
+    begin                : Wed 26th July 2006
+    modifications        : July 2007
+    copyright            : (C) 2006 by George Wright
+    modifications        : (C) 2007 Embedded Software Foundry Ltd. (U.K.)
+                         :     Author: Sebastian James
+    email                : seb at esfnet.co.uk, gwright at kde.org
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+ 
+// Enumerated type defining the stages through which the client goes when connecting
+enum { HELLO_NXCLIENT, ACKNOWLEDGE, SHELL_MODE, AUTH_MODE, LOGIN, LIST_SESSIONS, PARSESESSIONS, STARTSESSION, FINISHED };
+
+/*
+	0 HELLO NXCLIENT
+	1 Acknowledgement from server
+	2 SET SHELL_MODE SHELL
+	3 SET AUTH_MODE PASSWORD
+	4 login
+	5 listsession
+	6 resumesession/startsession
+*/
+
+#define CLIENT_VERSION "3.0.0"
+
+#include <iostream>
+#include "nxsession.h"
+#include "nxclientlib.h" // nxclientlib provides some signals used here.
+#include "notQt.h"
+
+using namespace std;
+using namespace nxcl;
+
+NXSession::NXSession()
+{
+	this->devurand_fd = -1;
+	this->stage = 0;
+	this->sessionDataSet = false;
+	this->nxUsername = "nouser";
+	this->nxPassword = "nopass";
+}
+
+NXSession::~NXSession()
+{
+}
+
+void NXSession::resetSession()
+{
+	this->stage = 0;
+	this->sessionDataSet = false;
+}
+
+string NXSession::parseSSH(string message)
+{
+	dbgln ("NXSession::parseSSH called for: " + message);
+
+	int response = parseResponse (message);
+	string returnMessage;
+	
+	if (response == 211) {
+		if (doSSH == true) {
+			returnMessage = "yes";
+			doSSH = false;
+		} else
+			returnMessage = "no";
+	}
+
+	if (response == 204) { // Authentication failed
+		returnMessage = "204";
+	}
+	
+	if (response == 147) { // Server capacity reached
+		returnMessage = "147";
+		this->stage = FINISHED;
+	}
+
+	switch (this->stage) {
+		case HELLO_NXCLIENT:
+			dbgln ("HELLO_NXCLIENT stage");
+			if (message.find("HELLO NXSERVER - Version") != string::npos) {
+				this->callbacks->authenticatedSignal();
+				returnMessage = "hello NXCLIENT - Version ";
+				returnMessage.append(CLIENT_VERSION);
+				this->stage++;
+			}
+			break;
+		case ACKNOWLEDGE:
+			dbgln ("ACKNOWLEDGE stage");
+			if (response == 105)
+				this->stage++;
+			break;
+		case SHELL_MODE:
+			dbgln ("SHELL_MODE stage");
+			if (response == 105) {
+				returnMessage = "SET SHELL_MODE SHELL";
+				this->stage++;
+			}
+			break;
+		case AUTH_MODE:
+			dbgln ("AUTH_MODE stage");
+			if (response == 105) {
+				returnMessage = "SET AUTH_MODE PASSWORD";
+				this->stage++;
+			}
+			break;
+		case LOGIN:
+			dbgln ("LOGIN stage");
+			switch (response) {
+				case 105:
+					returnMessage = "login";
+					break;
+				case 101:
+					returnMessage = nxUsername;
+					break;
+				case 102:
+					returnMessage = nxPassword;
+					break;
+				case 103:
+					this->stage++;
+					break;
+				case 404:
+					this->callbacks->loginFailedSignal();
+				}
+			break;
+		case LIST_SESSIONS:
+			dbgln ("LIST_SESSIONS stage");
+			if (this->sessionData->terminate == true) {
+				// Wait for termination
+				dbgln ("Waiting for termination");
+				if (response == 900) {
+					stringstream termsession;
+					termsession << "NX> 900 Session id: " << this->sessionData->id << " terminated.";
+					if (message.find (termsession.str().c_str(), 0) == 0) {
+						// Session terminated.
+						this->sessionData->terminate = false;
+					} else {
+						usleep (10000);
+					}
+				}
+
+			} else if (response == 105) {
+				// Get a list of the available
+				// sessions on the server, for given
+				// user, with given status, and any
+				// type. Not sure if geometry is
+				// ignored or not.
+				stringstream ss;
+				// We want to list suspended or running sessions, with this command:
+				
+				dbgln ("this->resumeSessions.size() == " << this->resumeSessions.size());
+				
+				if (this->sessionData->sessionType == "shadow") {
+					// This is how to list shadow
+					// sessions. Run NoMachine's
+					// client and see
+					// ~/.nx/temp/(pid)/sshlog for
+					// connection details
+					ss << "Listsession --type=\"shadow\"";
+
+				} else {
+
+					ss << "Listsession --user=\"" << nxUsername
+					   << "\" --status=\"suspended,running\" --geometry=\"" 
+					   << this->sessionData->xRes << "x"
+					   << this->sessionData->yRes << "x" 
+					   << this->sessionData->depth 
+					   << (this->sessionData->render ? "+render" : "") 
+						// If you leave --type blank, you can re-connect to any sessions available.
+					   <<  "\" --type=\"" << this->sessionData->sessionType << "\"";
+				}
+				
+				returnMessage = ss.str();
+				this->stage++;
+			}
+			break;
+		case PARSESESSIONS:
+			dbgln ("PARSESESSIONS stage");
+
+			if ((this->sessionData->sessionType == "shadow" && response != 105) ||
+			    (this->sessionData->sessionType != "shadow" && response != 148)  ) {
+
+				dbgln ("Building resumeSessions: resumeSessions.push_back(message);");
+				this->resumeSessions.push_back(message);
+
+			} else if ( (this->sessionData->sessionType == "shadow" && response == 105 ) || 
+				    (this->sessionData->sessionType != "shadow" && response == 148)  ) {
+
+				dbgln ("Parsing resumeSessions: parseResumeSessions(resumeSessions);");
+				parseResumeSessions (this->resumeSessions);
+				dbgln ("parseResumeSessions(resumeSessions) returned");
+				// Now, the problem we have here, is that when
+				// we return from the last 105 response, we
+				// don't then get another stdout message to
+				// act upon. So, we want to recurse back into parseSSH to get onto the STARTSESSION stage here:
+				returnMessage = this->parseSSH (message);
+			}
+			break;
+
+		case STARTSESSION:
+			dbgln ("STARTSESSION stage");
+			if (response == 105 && sessionDataSet) {
+
+				dbgln ("response is 105 and sessionDataSet is true");;
+				int media = 0;
+				string fullscreen = "";
+				if (this->sessionData->media) {
+					media = 1;
+				}
+				if (this->sessionData->fullscreen) {
+					this->sessionData->geometry = "fullscreen";
+					fullscreen = "+fullscreen";
+				}
+
+				if (this->sessionData->sessionType == "shadow" && this->sessionData->terminate == false) {
+					dbgln ("It's a shadow session!");
+					stringstream ss;
+					// These are the session parameters that NoMachine's client sends for resume
+					ss << "Attachsession "
+					   << "--link=\"" << this->sessionData->linkType << "\" "
+					   << "--backingstore=\"" << this->sessionData->backingstore << "\" "
+					   << "--encryption=\"" << this->sessionData->encryption << "\" "
+					   << "--cache=\"" << this->sessionData->cache << "M\" "
+					   << "--images=\"" << this->sessionData->images << "M\" "
+					   << "--shmem=\"1\" " // probably has been autodetected from my display
+					   << "--shpix=\"1\" " // probably has been autodetected from my display
+					   << "--strict=\"0\" " // probably has been autodetected from my display
+					   << "--composite=\"1\" " // probably has been autodetected from my display
+					   << "--media=\"" << media << "\" "
+					   << "--session=\"" << this->sessionData->sessionName << "\" "
+					   << "--type=\"" << this->sessionData->sessionType << "\" "
+					   << "--client=\"linux\" " // FIXME: This may be some other OS if you compile it on Sun, Windows, etc.
+					   << "--keyboard=\"" << this->sessionData->keyboard << "\" "
+					   << "--id=\"" << this->sessionData->id << "\" "
+					   << "--display=\"0\" " // This may be the key?
+					   << "--geometry=\"" << this->sessionData->geometry << "\" ";
+
+					/* These appear not to be necessary for the shadow connection, for one reason and another.
+					        // Not required:
+						"\" --cookie=\"" << generateCookie() <<
+						// optional:
+						"\" --kbtype=\"" << this->sessionData->kbtype <<
+						// optional:
+						"\" --nodelay=\"1" << 
+						// These are obviously not required
+						"\" --agent_server=\"" << this->sessionData->agentServer <<
+						"\" --agent_user=\"" << this->sessionData->agentUser <<
+						"\" --agent_password=\"" << this->sessionData->agentPass << "\"";
+					*/
+
+					returnMessage = ss.str();
+					dbgln ("session parameter command: " + ss.str());
+					this->stage++;
+
+				} else if (this->sessionData->terminate == true) {
+					stringstream ss;
+					// These are the session parameters that NoMachine's client sends for resume
+					ss << "Terminate --sessionid=\"" << this->sessionData->id << "\"";
+					returnMessage = ss.str();
+					dbgln ("session parameter command: " + ss.str());
+					this->stage -= 2; // Back to listsessions after terminating a session.
+					// clear the list of sessions to resume
+					this->resumeSessions.clear();
+					this->runningSessions.clear();
+
+				} else if (this->sessionData->suspended) {
+					dbgln ("this->sessionData->suspended is true");
+					stringstream ss;
+					// These are the session parameters that NoMachine's client sends for resume
+					ss << "restoresession --id=\"" << this->sessionData->id <<
+						"\" --session=\"" << this->sessionData->sessionName <<
+						"\" --type=\"" << this->sessionData->sessionType <<
+						"\" --cache=\"" << this->sessionData->cache <<
+						"M\" --images=\"" << this->sessionData->images <<
+						"M\" --cookie=\"" << generateCookie() <<
+						"\" --link=\"" << this->sessionData->linkType <<
+						"\" --kbtype=\"" << this->sessionData->kbtype <<
+						"\" --nodelay=\"1\" --encryption=\"" << this->sessionData->encryption <<
+						"\" --backingstore=\"" << this->sessionData->backingstore <<
+						"\" --geometry=\"" << this->sessionData->geometry <<
+						"\" --media=\"" << media <<
+						"\" --agent_server=\"" << this->sessionData->agentServer <<
+						"\" --agent_user=\"" << this->sessionData->agentUser <<
+						"\" --agent_password=\"" << this->sessionData->agentPass << "\"";
+					returnMessage = ss.str();
+					dbgln ("session parameter command: " + ss.str());
+					this->stage++;
+
+				} else { 
+					dbgln ("this->sessionData->suspended is false, and it's not a shadow session.");
+					stringstream ss;
+					ss << "startsession --session=\"" << this->sessionData->sessionName <<
+						"\" --type=\"" << this->sessionData->sessionType <<
+						"\" --cache=\"" << this->sessionData->cache <<
+						"M\" --images=\"" << this->sessionData->images <<
+						"M\" --cookie=\"" << generateCookie() <<
+						"\" --link=\"" << this->sessionData->linkType <<
+						"\" --render=\"" << (this->sessionData->render ? 1 : 0) <<
+						"\" --encryption=\"" << this->sessionData->encryption <<
+						"\" --backingstore=\"" << this->sessionData->backingstore <<
+						"\" --imagecompressionmethod=\"" << this->sessionData->imageCompressionMethod <<
+						"\" --geometry=\"" << this->sessionData->geometry << 
+						"\" --screeninfo=\"" << this->sessionData->xRes << "x" << this->sessionData->yRes << "x" << this->sessionData->depth << 
+						(this->sessionData->render ? "+render" : "") << fullscreen <<
+						"\" --keyboard=\"" << this->sessionData->keyboard <<
+						"\" --kbtype=\"" << this->sessionData->kbtype <<
+						"\" --media=\"" << media <<
+						"\" --agent_server=\"" << this->sessionData->agentServer <<
+						"\" --agent_user=\"" << this->sessionData->agentUser <<
+						"\" --agent_password=\"" << this->sessionData->agentPass << "\"";
+					if (this->sessionData->sessionType == "unix-application") {
+						ss << " --application=\"" << this->sessionData->customCommand << "\"";
+					}
+					returnMessage = ss.str();
+					dbgln ("session parameter command: " + ss.str());
+					this->stage++;
+				}
+			} else {
+				dbgln ("either response is not 105 or sessionDataSet is false.");;				
+			}
+			break;
+
+		case FINISHED:
+			dbgln ("FINISHED stage. Response is " << response 
+			       << ". That should mean that session set up is complete.");
+			this->callbacks->readyForProxySignal();
+	}
+
+	dbgln ("NXSession::parseSSH, about to return a message: " + returnMessage);
+	if (!returnMessage.empty()) {
+		returnMessage.append("\n");
+		return returnMessage;
+	} else
+		return "";
+}
+
+void NXSession::setSessionData (NXSessionData *sd)
+{
+	this->sessionData = sd;
+	this->sessionDataSet = true;
+}
+
+int NXSession::parseResponse(string message)
+{
+	string::size_type idx1, idx2;
+	int response;
+	dbgln ("NXSession::parseResponse called for message:" << message);
+
+	if ((idx1 = message.find ("notQProcess error", 0)) != string::npos) {
+		dbgln ("Found notQProcess error");
+		// This means a process crashed, we're going to return a number >100000 to indicate this.
+		if ( ((idx2 = message.find ("crashed", 0)) != string::npos) && idx2 > idx1) {
+			stringstream ss;
+			ss << message.substr((idx1+19), idx2-1-(idx1+19));
+			ss >> response; // this is the pid that crashed
+			response += 100000; // add 100000 and return this.
+			return response;
+		} else {
+			dbgln ("Uh oh, didn't find \"crashed\"");
+		}
+	}
+
+	// Find out the server response number
+	// This will only be present in strings which contain "NX>"
+	if (message.find("NX>") != string::npos && message.find("NX>") == 0) {
+		idx1 = message.find("NX>") + 4;
+		if ((idx2 = message.find(" ", idx1)) == string::npos) {
+			if ((idx2 = message.find("\n", idx1)) == string::npos) {
+				//dbgln ("NXSession::parseResponse: warning: reading up to the end of message.");
+				idx2 = message.size();
+			}
+		}
+		if (idx2>idx1) {
+			stringstream ss;
+			ss << message.substr(idx1, idx2-idx1);
+			ss >> response;
+		} else {
+			response = 0;
+		}
+	} else {
+		response = 0;
+	}
+
+	dbgln ("NXSession::parseResponse() returning " << response);
+	return response;
+}
+
+void NXSession::parseResumeSessions(list<string> rawdata)
+{
+	// Was: QStringList sessions, and got rawdata appended to it?
+	list<string> sessions;
+	list<string>::iterator iter, at;
+
+	dbgln ("NXSession::parseResumeSessions called.");
+
+	for (iter = rawdata.begin(); iter != rawdata.end(); iter++) {
+		if (((*iter).find("-------") != string::npos) && !(*iter).empty()) {
+			at = iter;
+		}
+	}
+
+	for (iter = ++at; iter != rawdata.end(); iter++) {
+		if ((!(*iter).find("NX> 148") != string::npos) && !(*iter).empty()) {
+			sessions.push_back(*iter);
+		}
+	}
+
+	list < vector<string> > rawsessions;
+	list < vector<string> >::iterator rsIter;
+
+	// Clean up each string in sessions[i], then push back
+	// sessions[i] onto rawsessions., except that means
+	// rawsessions is then just a list<string>...
+	vector<string> session;
+	vector<string>::iterator seshIter;
+	for (iter = sessions.begin(); iter != sessions.end(); iter++) {
+		session.clear();
+		/* simplify one line of list<string> sessions */
+		(*iter) = notQtUtilities::simplify (*iter); 
+		/* split one line of list<string> sessions into a vector<string> */
+		notQtUtilities::splitString (*iter, ' ', session); 
+		/* Add that to rawsessions */
+		rawsessions.push_back(session);
+	}
+
+	NXResumeData resData;
+	
+	for (rsIter = rawsessions.begin(); rsIter != rawsessions.end(); rsIter++) {
+		stringstream ss1, ss2;
+		int tmp;
+		dbgln ("*rsIter.size() == " << (*rsIter).size());
+		ss1 << (*rsIter)[0];
+		ss1 >> tmp;
+		resData.display = tmp;
+		dbgln ("resData.display = " << resData.display);
+		resData.sessionType = (*rsIter)[1];
+		dbgln ("resData.sessionType = " << resData.sessionType);
+		resData.sessionID = (*rsIter)[2];
+		dbgln ("resData.sessionID = " << resData.sessionID);
+		resData.options = (*rsIter)[3];
+		dbgln ("resData.options = " << resData.options);
+		ss2 << (*rsIter)[4];
+		ss2 >> tmp;
+		resData.depth = tmp;
+		dbgln ("resData.depth = " << resData.depth);
+		resData.screen = (*rsIter)[5];
+		dbgln ("resData.screen = " << resData.screen);
+		resData.available = (*rsIter)[6];
+		dbgln ("resData.available = " << resData.available);
+		resData.sessionName = (*rsIter)[7];
+		dbgln ("resData.sessionName = " << resData.sessionName);
+		this->runningSessions.push_back(resData);
+	}
+
+	if (this->runningSessions.size() != 0) {
+		this->suspendedSessions = true;
+		dbgln ("NXSession::parseResumeSessions(): Calling sessionsSignal.");
+		// runningSessions is a list of NXResumeData
+		this->callbacks->sessionsSignal (this->runningSessions);
+	} else {
+		dbgln ("NXSession::parseResumeSessions(): Calling this->callbacks->noSessionsSignal()");
+		// In case we previously had one resumable session,
+		// which the user terminated, then we listsessions and
+		// got no resumable sessions, we need to make sure
+		// startsession is called, not restoresession. hence
+		// set sessionData->suspended to false.
+		this->sessionData->suspended = false;
+		this->callbacks->noSessionsSignal();
+	}
+	
+	dbgln ("Increment stage");
+	this->stage++;
+	dbgln ("NXSession::parseResumeSessions() returning.");
+}
+
+void NXSession::wipeSessions()
+{
+	while (!this->runningSessions.empty()) {
+		this->runningSessions.pop_front();
+	}
+}
+
+string NXSession::generateCookie()
+{
+	unsigned long long int int1, int2;
+	stringstream cookie;
+	
+	devurand_fd = open("/dev/urandom", O_RDONLY);
+
+	fillRand((unsigned char*)&int1, sizeof(int1));
+	fillRand((unsigned char*)&int2, sizeof(int2));
+	cookie << int1 << int2;
+	return cookie.str();
+}
+
+void NXSession::fillRand(unsigned char *buf, size_t nbytes) {
+	ssize_t r;
+	unsigned char *where = buf;
+
+	while (nbytes) {
+		while ((r = read(devurand_fd, where, nbytes)) == -1)
+		where  += r;
+		nbytes -= r;
+	}
+}
+
+bool NXSession::chooseResumable (int n)
+{
+	dbgln ("NXSession::chooseResumable called.");
+	if (this->runningSessions.size() <= static_cast<unsigned int>(n)) {
+		// No nth session to resume.
+		dbgln ("No nth session to resume, return false.");
+		return false;
+	}
+
+	this->sessionDataSet = false; // Set to false while we change
+				      // contents of sessionData
+
+	list<NXResumeData>::iterator it = this->runningSessions.begin();
+	for (int i = 0; i<n; i++) { it++; }
+
+	// If it's a shadow session, we don't want to replace "shadow" with X11-local
+	if (this->sessionData->sessionType != "shadow") {
+		this->sessionData->sessionType = (*it).sessionType;
+	}
+	this->sessionData->display = (*it).display;
+	this->sessionData->sessionName = (*it).sessionName;
+	this->sessionData->id = (*it).sessionID;
+	stringstream geom;	
+	geom << (*it).screen << "x" << (*it).display; // plus render, if necessary.
+	// FIXME: This not yet quite complete.
+	this->sessionData->geometry = geom.str(); // with depth in there too?
+	this->sessionData->suspended=true;
+
+	this->sessionDataSet = true;
+
+	dbgln ("NXSession::chooseResumable returning true.");
+	return true;
+}
+
+bool NXSession::terminateSession (int n)
+{
+	dbgln ("NXSession::terminateSession called.");
+	if (this->runningSessions.size() <= static_cast<unsigned int>(n)) {
+		// No nth session to resume.
+		dbgln ("No nth session to terminate, return false.");
+		return false;
+	}
+
+	this->sessionDataSet = false; // Set to false while we change
+				      // contents of sessionData
+
+	list<NXResumeData>::iterator it = this->runningSessions.begin();
+	for (int i = 0; i<n; i++) { it++; }
+
+	this->sessionData->terminate = true;
+	this->sessionData->display = (*it).display;
+	this->sessionData->sessionName = (*it).sessionName;
+	this->sessionData->id = (*it).sessionID;
+	this->sessionData->suspended=true;
+
+	this->sessionDataSet = true;
+
+	return true;
+}
+

Added: nxcl/lib/nxsession.h
===================================================================
--- nxcl/lib/nxsession.h	2007-08-19 15:44:16 UTC (rev 372)
+++ nxcl/lib/nxsession.h	2007-09-11 12:48:46 UTC (rev 373)
@@ -0,0 +1,153 @@
+/* -*-c++-*- */
+/***************************************************************************
+                                 nxsession.h
+                             -------------------
+    begin                : Sat 22nd July 2006
+    modifications        : July 2007
+    copyright            : (C) 2006 by George Wright
+    modifications        : (C) 2007 Embedded Software Foundry Ltd. (U.K.)
+                         :     Author: Sebastian James
+    email                : seb at esfnet.co.uk, gwright at kde.org
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef _NXSESSION_H_
+#define _NXSESSION_H_
+
+#include <sstream>
+#include <fstream>
+#include <fcntl.h>
+#include <unistd.h>
+#include "nxdata.h"
+#include <list>
+
+namespace nxcl {
+
+	/*!
+	 * Virtual Callback class. These callbacks are called based on
+	 * the output which we get from the nxssh process.
+	 */
+	class NXSessionCallbacks
+	{
+	public:
+		NXSessionCallbacks() {}
+		virtual ~NXSessionCallbacks() {}
+		virtual void noSessionsSignal (void) {}
+		virtual void loginFailedSignal (void) {}
+		virtual void readyForProxySignal (void) {}
+		/*!
+		 * Emitted when the initial public key authentication
+		 * is successful 
+		 */
+		virtual void authenticatedSignal (void) {}
+		virtual void sessionsSignal (list<NXResumeData>) {}
+	};
+
+	/*!
+	 * This class is used to parse the output from the nxssh
+	 * session to the server.
+	 */
+	class NXSession
+	{
+	public:
+		NXSession();
+		~NXSession();
+		
+		string parseSSH (string);
+		int parseResponse (string);
+		void parseResumeSessions (list<string>);
+		void resetSession (void);
+		void wipeSessions (void);
+		bool chooseResumable (int n);
+		bool terminateSession (int n);
+		string generateCookie (void);
+
+		/*!
+		 * Accessors
+		 */
+		//@{
+		void setUsername (string& user) { nxUsername = user; }
+		void setPassword (string& pass) { nxPassword = pass; }
+		void setResolution (int x, int y) {
+			if (this->sessionDataSet) {
+				this->sessionData->xRes = x;
+				this->sessionData->yRes = y;
+			}
+		}
+		void setDepth (int d) { if (this->sessionDataSet) {this->sessionData->depth = d;} }
+		void setRender (bool isRender) { if (this->sessionDataSet) {this->sessionData->render = isRender;} }
+		void setEncryption (bool enc) { if (this->sessionDataSet) {this->sessionData->encryption = enc;} }
+
+		void setContinue (bool allow) { doSSH = allow; }
+		void setSessionData (NXSessionData*);
+		bool getSessionDataSet (void) { return this->sessionDataSet; }
+		void setCallbacks (NXSessionCallbacks * cb) { this->callbacks = cb; }
+		//@}
+		
+	private:
+		void reset (void);
+		void fillRand(unsigned char *, size_t);
+
+		/*!
+		 * This is the answer to give to the ssh server if it
+		 * asks whether we want to continue (say, if we're
+		 * connecting for the first time and we don't
+		 * necessarily trust its SSL key).
+		 */
+		bool doSSH;
+		/*!
+		 * Set to true if there are suspended sessions on the
+		 * server which are owned by nxUsername.
+		 */
+		bool suspendedSessions;
+		/*!
+		 * Set to true of sessionData has been populated
+		 */
+		bool sessionDataSet;
+		/*!
+		 * Holds the stage of the process which we have
+		 * reached as we go through the process of
+		 * authenticating with the NX Server.
+		 */
+		int stage;
+		/*!
+		 * File descriptor for the random number device
+		 */
+		int devurand_fd;
+		/*!
+		 * Holds the username for this session
+		 */
+		string nxUsername;
+		/*!
+		 * Holds the password for this session
+		 */
+		string nxPassword;
+		/*!
+		 * A list of sessions which can be resumed, as strings.
+		 */
+		list<string> resumeSessions;
+		/*!
+		 * A list of running sessions, held as NXResumeData
+		 * structures.
+		 */
+		list<NXResumeData> runningSessions;
+		/*!
+		 * Data for this session.
+		 */
+		NXSessionData *sessionData;
+		/*!
+		 * Pointer to a class containing callback methods.
+		 */
+		NXSessionCallbacks * callbacks;
+	};
+
+} // namespace
+#endif

Added: nxcl/nxcl/Makefile.am
===================================================================
--- nxcl/nxcl/Makefile.am	2007-08-19 15:44:16 UTC (rev 372)
+++ nxcl/nxcl/Makefile.am	2007-09-11 12:48:46 UTC (rev 373)
@@ -0,0 +1,8 @@
+AM_CPPFLAGS = @PACKAGE_CFLAGS@ -DPACKAGE_DATA_DIR=\""$(datadir)"\" -DLOCALEDIR=\"$(localedir)\" -DPACKAGE_BIN_DIR=\""$(bindir)"\"
+INCLUDES = -I../lib
+bin_PROGRAMS = nxcl
+nxcl_SOURCES = main.cpp nxcl.cpp
+# This links to X11 so that nxcl can obtain the X server's actual screen size
+nxcl_LDADD = @PACKAGE_LIBS@ $(LIBINTL) -L../lib -lnxcl -lX11
+pkginclude_HEADERS = nxcl.h
+

Added: nxcl/nxcl/main.cpp
===================================================================
--- nxcl/nxcl/main.cpp	2007-08-19 15:44:16 UTC (rev 372)
+++ nxcl/nxcl/main.cpp	2007-09-11 12:48:46 UTC (rev 373)
@@ -0,0 +1,114 @@
+/*
+ * nxcld: The NXCL dbus daemon.
+ *
+ * This program should be launched by a client - that might be gnxc,
+ * qtnxc, fltknxc, tknxc, emacsnxc.... etc etc you get the picture.
+ *
+ * This graphical launcher program is the place where the user can
+ * select the connection type, and enter his username and password. It
+ * launches nxcld via a dbus call (or some other way?), then transmits
+ * the settings to nxcld via dbus. nxcld then negotiates the NX
+ * connection - launching nxssh and nxproxy. nxcld will send back a
+ * list of sessions to the launching NX client (if there are
+ * multiple available sessions) and a signal to say if the connection
+ * has been launched or if an error occurred.
+ *
+ * (C) 2007 Embedded Software Foundry Ltd. (U.K.)
+ * Author: Sebastian James
+ * Email:  seb at esfnet.co.uk
+ *
+ * Released under the terms of the GNU GPL version 2.
+ */
+
+#include "../config.h"
+#include "nxclientlib.h"
+#include "nxcl.h"
+#include <fstream>
+
+/* This define is required for slightly older versions of dbus as
+ * found, for example, in Ubuntu 6.06. */
+#define DBUS_API_SUBJECT_TO_CHANGE 1
+extern "C" {
+#include <string.h>
+#include <dbus/dbus.h>
+}
+
+using namespace nxcl;
+using namespace std;
+
+/*!
+ * Log file ofstream is a global variable, as required by nxcl.
+ */
+ofstream debugLogFile;
+
+/*!
+ * This probing routine is executed on a regular basis. It will set
+ * off suitable signals if there is stdout or stderr to be analysed
+ * from the nxssh process. It also recognises when the nxssh program
+ * has exited.
+ */
+bool probeNXCL (NXClientLib* lib);
+
+int main (int argc, char **argv)
+{
+	Nxcl nxcl;
+
+	debugLogFile.open("/tmp/nxcl.log", ios::out|ios::trunc);
+	if (!debugLogFile.is_open()) {
+		nxcl.callbacks.write ("Odd, couldn't open /tmp/nxcl.log");
+	}
+
+	if (argc!=2) {
+		nxcl.callbacks.write ("This program is usually executed by another program. "
+				      "Trying to execute it alone is probably not the right "
+				      "thing to do, unless you are sure it is. Provide a single "
+				      "argument - the identifier for the dbus messages");
+		return -1;
+	}
+
+	stringstream ss;
+	int id;
+	ss << argv[1];
+	ss >> id;
+	nxcl.setupDbus(id);
+
+	if (-1 == (nxcl.receiveSettings())) {
+		cerr << "Failed to obtain server and user for the session." << endl;
+		return -1;
+	}
+
+	nxcl.startTheNXConnection();
+
+	NXClientLib* c = nxcl.getNXClientLib();
+	while (probeNXCL(c) == true) {
+		usleep (30000); // 3 100ths of a second => about 30 
+                                // probes a second (a lot).
+	}
+
+	nxcl.callbacks.write ("Program finished.");
+	debugLogFile.close();
+	return 0;
+}
+
+
+bool
+probeNXCL (NXClientLib* lib)
+{
+	notQProcess* p = lib->getNXSSHProcess();
+
+	if ((lib->getIsFinished()) == false) {
+		// We need to repeatedly check if there is any output to parse.
+		if (lib->getReadyForProxy() == false) {
+			//p = lib->getNXSSHProcess();
+			p->probeProcess();
+		} else {
+			//p = lib->getNXSSHProcess();
+			p->probeProcess();
+			p = lib->getNXProxyProcess();
+			p->probeProcess();
+		}
+		return true;
+	} else {
+		return false;
+	}
+}

Added: nxcl/nxcl/nxcl.cpp
===================================================================
--- nxcl/nxcl/nxcl.cpp	2007-08-19 15:44:16 UTC (rev 372)
+++ nxcl/nxcl/nxcl.cpp	2007-09-11 12:48:46 UTC (rev 373)
@@ -0,0 +1,627 @@
+/*
+ * nxcl: The NXCL dbus daemon.
+ *
+ * See main.cpp for general notes.
+ *
+ * This file contains the implementation of the Nxcl class used by
+ * the nxcl program.
+ *
+ * (C) 2007 Embedded Software Foundry Ltd. (U.K.)
+ * Author: Sebastian James
+ * Email:  seb at esfnet.co.uk
+ *
+ * Released under the terms of the GNU GPL version 2.
+ */
+
+#include "../config.h"
+#include "nxclientlib.h"
+#include <fstream>
+
+#include "nxcl.h"
+
+/* This define is required for slightly older versions of dbus as
+ * found, for example, in Ubuntu 6.06. */
+#define DBUS_API_SUBJECT_TO_CHANGE 1
+extern "C" {
+#include <dbus/dbus.h>
+#include <X11/Xlib.h>
+}
+
+using namespace nxcl;
+using namespace std;
+
+
+/*!
+ * NxclCallbacks class
+ */
+//@{
+NxclCallbacks::NxclCallbacks ()
+{
+}
+NxclCallbacks::~NxclCallbacks ()
+{
+}
+void
+NxclCallbacks::write (string msg)
+{
+	cout << "NXCL> " << msg << endl;
+}
+void
+NxclCallbacks::debug (string msg)
+{
+#if DEBUG==1
+	cout << "NXCL> " << msg << endl;
+#endif
+}
+void
+NxclCallbacks::stdoutSignal (string msg)
+{
+#if DEBUG==1
+	cout << "nxssh-stdout->" << endl << msg << endl; 
+#endif
+}
+void
+NxclCallbacks::stderrSignal (string msg)
+{
+#if DEBUG==1
+	cout << "nxssh-stderr->" << endl << msg << endl; 
+#endif
+}
+void
+NxclCallbacks::stdinSignal (string msg)
+{
+#if DEBUG==1
+	cout << "nxssh<-stdin-" << endl << msg << endl;
+#endif
+}
+void
+NxclCallbacks::resumeSessionsSignal (list<NXResumeData> data)
+{
+	this->parent->haveResumableSessions (data);
+}
+void
+NxclCallbacks::noSessionsSignal (void)
+{
+	this->parent->noResumableSessions();
+}
+void
+NxclCallbacks::serverCapacitySignal (void)
+{
+	this->parent->serverCapacityReached();
+}
+//@}
+
+/*!
+ * Implementation of the Nxcl class, which manages an NX session on
+ * behalf of a calling client, which communicates with this class via
+ * a dbus connection.
+ */
+//@{
+Nxcl::Nxcl ()
+{
+	this->dbusNum = 0;
+	this->initiate();
+}
+
+Nxcl::Nxcl (int n)
+{
+	this->dbusNum = n;
+	this->initiate();
+}
+
+
+Nxcl::~Nxcl ()
+{
+}
+
+void
+Nxcl::initiate (void)
+{
+	this->setSessionDefaults();
+
+	this->nxclientlib.setExternalCallbacks (&callbacks);
+	this->callbacks.setParent (this);
+
+	// Get the X display information
+	Display* display;
+	display = XOpenDisplay (getenv("DISPLAY"));
+	if (display == NULL) {
+		cerr << "Cannot connect to local X server :0\n";
+		exit (-1);
+	}
+
+	int screenNum = DefaultScreen (display);
+	this->xRes = DisplayWidth (display, screenNum);
+	this->yRes = DisplayHeight (display, screenNum);
+	dbgln ("screen is " << xRes << "x" << yRes);
+	unsigned long wp = WhitePixel (display, screenNum);
+	unsigned long bp = BlackPixel (display, screenNum);
+	unsigned long d = wp-bp+1;
+	dbgln ("wp is " << wp << " bp is " << bp << " and difference plus 1 (d) is " << d);
+	this->displayDepth = 0;
+	while (d > 1) {
+		d = d>>1;
+		this->displayDepth++;
+	}
+	dbgln ("displayDepth is " << this->displayDepth << " and d is now " << d);
+	XCloseDisplay (display);
+}
+
+void
+Nxcl::setupDbus (int id)
+{
+	this->dbusNum = id;
+	this->setupDbus();
+}
+
+void
+Nxcl::setupDbus (void)
+{
+	/* Get a connection to the session bus */
+	dbus_error_init (&this->error);
+	this->conn = dbus_bus_get (DBUS_BUS_SESSION, &this->error);
+	if (!this->conn) {
+		cerr << "Failed to connect to the D-BUS daemon: " 
+		     << this->error.message << ". Exiting.\n";
+		dbus_error_free (&this->error);
+		exit (1);
+	}
+	stringstream ss;
+	ss << "org.freenx.nxcl.nxcl" << this->dbusNum;
+	this->dbusName = ss.str();
+	int ret = dbus_bus_request_name(this->conn, this->dbusName.c_str(),
+					DBUS_NAME_FLAG_REPLACE_EXISTING, 
+					&this->error);
+	if (dbus_error_is_set(&this->error)) { 
+		cerr << "Name Error (" << this->error.message << ")\n";
+		dbus_error_free(&this->error); 
+	}
+	if (DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER != ret) { 
+		/* What to do if someone else is running? Try another name? Exit? */
+		this->callbacks.write ("There appears to be another nxcl running, won't compete. Exiting.");
+		cout << "(DEBUG) ret == " << ret << endl;
+		exit(1);
+	}
+	// Done getting connection to session bus
+
+
+	// Prepare interface - add a rule for which messages we want
+	// to see. We listen for messages from the _client_
+	// connection.
+	ss.str("");
+	ss << "type='signal',interface='org.freenx.nxcl.client" << this->dbusNum << "'";
+	this->dbusMatch = ss.str();
+
+	dbus_bus_add_match(this->conn, this->dbusMatch.c_str(), &this->error);
+	dbus_connection_flush (this->conn);
+	if (dbus_error_is_set(&this->error)) {
+		cerr << "Match Error (" << this->error.message << ")\n";
+		exit(1);
+	}
+
+	ss.str("");
+	ss << "org.freenx.nxcl.client" << this->dbusNum;
+	this->dbusMatchInterface = ss.str();
+	ss.str("");
+	ss << "org.freenx.nxcl.nxcl" << this->dbusNum;
+	this->dbusSendInterface = ss.str();
+
+	return;
+}
+
+
+int
+Nxcl::receiveSettings (void)
+{
+	DBusMessage * message;
+	DBusMessageIter args;
+	DBusError error;
+	char * parameter = NULL;
+	bool settings_transferred = false;
+	stringstream ss;
+	int count = 0;
+
+	this->callbacks.write ("receiveSettings called");
+
+	// loop listening for signals being emitted
+	while (settings_transferred == false) {
+
+		if (dbus_error_is_set(&error)) { 
+			this->callbacks.write ("receiveSettings(): Got a dbus error");
+			dbus_error_free(&error); 
+		}
+
+		// non blocking read of the next available message
+		dbus_connection_read_write(this->conn, 0);
+		message = dbus_connection_pop_message(this->conn);
+
+		// loop again if we haven't read a message
+		if (NULL == message) { 
+			//this->callbacks.write ("receiveSettings(): No message yet, sleep a second.");
+			sleep(1);
+			continue;
+		}
+
+		// check if the message is a signal from the
+		// correct interface and with the correct name
+		this->callbacks.write ("call dbus_message_is_signal()");
+		if (dbus_message_is_signal (message, this->dbusMatchInterface.c_str(), "sessionConfig")) {
+
+			if (!dbus_message_iter_init(message, &args)) {
+				cerr << "Message has no arguments!\n";
+				dbus_connection_flush (conn);
+				dbus_message_unref (message);
+				continue;
+			}
+			
+			if (DBUS_TYPE_STRING != dbus_message_iter_get_arg_type(&args)) {
+				cerr << "First argument is not a string!\n";
+			} else {
+				dbus_message_iter_get_basic(&args, &parameter);
+				ss.str("");
+				ss << parameter;
+				this->nxserver = ss.str();
+				count++;
+			}
+
+			// read the rest of the parameters
+			int t;
+			while (dbus_message_iter_next (&args)) {
+				if (DBUS_TYPE_STRING == (t = dbus_message_iter_get_arg_type(&args))) {
+					dbus_message_iter_get_basic(&args, &parameter);
+					//cout << "Arg-" << count << ": " << parameter << endl;
+					ss.str("");
+					ss << parameter;
+					switch (count) {
+					case 2:
+						this->nxuser = ss.str();
+						break;
+					case 3:
+						this->nxpass = ss.str();
+						break;
+					case 4:
+						this->sessionData.sessionName = ss.str();
+						break;
+					case 5:
+						this->sessionData.sessionType = ss.str();
+						break;
+					case 8:
+						this->sessionData.linkType = ss.str();
+						break;
+					case 10:
+						this->sessionData.backingstore = ss.str();
+						break;
+					case 13:
+						this->sessionData.geometry = ss.str();
+						break;
+					case 14:
+						this->sessionData.keyboard = ss.str();
+						break;
+					case 15:
+						this->sessionData.kbtype = ss.str();
+						break;
+					case 17:
+						this->sessionData.agentServer = ss.str();
+						break;
+					case 18:
+						this->sessionData.agentUser = ss.str();
+						break;
+					case 19:
+						this->sessionData.agentPass = ss.str();
+						break;
+					case 21:
+						this->sessionData.key = ss.str();
+						break;
+					case 24:
+						this->sessionData.customCommand = ss.str();
+						break;
+					default:
+						this->callbacks.write ("ERROR: parameter type does not match its position in the message.");
+						break;
+					}
+					count++;
+				} else if (t == DBUS_TYPE_INT32) {
+					int iparam = 0;
+					dbus_message_iter_get_basic(&args, &iparam);
+					switch (count) {
+					case 1:
+						this->nxport = iparam;
+						break;
+					case 6:
+						this->sessionData.cache = iparam;
+						break;
+					case 7:
+						this->sessionData.images = iparam;
+						break;
+					case 9:
+						this->sessionData.render = (iparam>0) ? true : false;
+						break;
+					case 11:
+						this->sessionData.imageCompressionMethod = iparam;
+						break;
+					case 12:
+						this->sessionData.imageCompressionLevel = iparam;
+						break;
+					case 16:
+						this->sessionData.media = (iparam>0) ? true : false;
+						break;
+					case 20:
+						this->sessionData.cups = iparam;
+						break;
+					case 22:
+						this->sessionData.encryption = (iparam>0) ? true : false;
+						break;
+					case 23:
+						this->sessionData.fullscreen = (iparam>0) ? true : false;
+						break;
+					default:
+						this->callbacks.write ("ERROR: parameter type does not match its position in the message.");
+						break;
+					}
+					count++;
+
+				} else {
+					this->callbacks.write ("ERROR: parameter is not string or int.");
+				}
+			}
+			settings_transferred = true;			
+		} else {
+			this->callbacks.write ("this message is not a signal");
+		}
+
+		// Anything else required for cleanup?
+		dbus_connection_flush (this->conn);
+
+		// free the message
+		dbus_message_unref (message);
+
+	} // while()
+	this->callbacks.write ("Got the session settings over the dbus\n");
+
+	if (this->nxserver.size() == 0 || this->nxuser.size() == 0) {
+		// We need at least these to be able to connect. Leave
+		// nxpass out, in case that has been set to an empty
+		// string.
+		return -1;
+	} else {
+		return 0;
+	}
+}
+
+
+void
+Nxcl::setSessionDefaults (void)
+{
+	// Some defaults
+	this->sessionData.sessionName = "default session";
+	this->sessionData.sessionType = "unix-gnome";
+	this->sessionData.cache = 8;
+	this->sessionData.images = 32;
+	this->sessionData.linkType = "adsl";
+	this->sessionData.render = true;
+	this->sessionData.backingstore = "when_requested";
+	this->sessionData.imageCompressionMethod = 2;
+	// this->sessionData.imageCompressionLevel;
+	this->sessionData.geometry = "800x600+0+0"; // This'll be the size of the session
+	this->sessionData.keyboard = "defkeymap";
+	this->sessionData.kbtype = "pc102/defkeymap";
+	this->sessionData.media = false;
+	this->sessionData.agentServer = "";
+	this->sessionData.agentUser = "";
+	this->sessionData.agentPass = "";
+	this->sessionData.cups = 0;
+	this->sessionData.encryption = true;
+	this->sessionData.suspended = false;
+	this->sessionData.fullscreen = false; // If true, session.geometry
+					  // is ignored
+
+	return;
+}
+
+void
+Nxcl::startTheNXConnection (void)
+{
+	// First things first; set the sessionData. FIXME: Should check if sessionData has been set.
+	this->nxclientlib.setSessionData (&this->sessionData);
+
+	this->nxclientlib.setUsername (this->nxuser);
+	this->nxclientlib.setPassword (this->nxpass);
+
+	// FIXME: Need to pull in res from the dbus message or probe for it.	
+	this->nxclientlib.setResolution (this->xRes, this->yRes); 
+                                               // This is the size of
+                                               // your screen... We need
+					       // to set this from the
+					       // client, unless we can
+					       // probe within nxcl.
+	this->nxclientlib.setDepth (this->displayDepth); 
+                                               // depth gets stored
+	                                       // in NXSession
+					       // object. nxcl.setDepth
+					       // is a wrapper
+					       // around
+					       // NXSession's
+					       // setDepth method.
+
+	/* If we have session info, start up the connection */
+	if (this->sessionData.key.size() == 0) { // Shouldn't need this->sessionData.encryption here.
+		this->nxclientlib.invokeNXSSH("default",
+					      this->nxserver,
+					      this->sessionData.encryption, 
+					      "", this->nxport);
+	} else {
+		this->nxclientlib.invokeNXSSH("supplied",
+					      this->nxserver,
+					      this->sessionData.encryption,
+					      this->sessionData.key, this->nxport);
+	} // Is there another case here, other than "default" or "supplied"?
+
+}
+
+void
+Nxcl::haveResumableSessions (list<NXResumeData> resumable)
+{
+	this->callbacks.debug ("haveResumableSessions Called");
+	// Send the list to the calling client:
+	this->sendResumeList (resumable);
+	this->callbacks.debug ("sent the resume list, about to receiveStartInstruction");
+	// Wait (and block) until we are told whether to resume one of
+	// the sessions or start a new one.
+	this->receiveStartInstruction();
+	this->callbacks.debug ("receiveStartInstruction() returned.");
+}
+
+void
+Nxcl::noResumableSessions (void)
+{
+	this->callbacks.write ("noResumableSessions Called");
+	DBusMessage *msg = dbus_message_new_signal ("/org/freenx/nxcl/dbus/AvailableSession",
+						    this->dbusSendInterface.c_str(),
+						    "Connecting");
+
+	dbus_connection_send (this->conn, msg, NULL);
+	dbus_message_unref (msg);
+}
+
+void
+Nxcl::sendResumeList (list<NXResumeData>& resumable)
+{
+	this->callbacks.debug ("sendResumeList called, will send on " + this->dbusSendInterface + " interface");
+	list<NXResumeData>::iterator it;
+	for (it=resumable.begin(); it!=resumable.end(); it++) {
+
+		DBusMessage *message;
+
+		/* Create a new signal "AvailableSession" on the
+		 * "org.freenx.nxcl.nxcl" interface, from the object
+		 * "/org/freenx/nxcl/dbus/AvailableSession". */
+		message = dbus_message_new_signal ("/org/freenx/nxcl/dbus/AvailableSession",
+						   this->dbusSendInterface.c_str(),
+						   "AvailableSession");
+
+		// We have to create a const char* pointer or each
+		// string variable in the NXResumeSessions struct.
+		const char* sessionType = (*it).sessionType.c_str();
+		const char* sessionID = (*it).sessionID.c_str();
+		const char* options = (*it).options.c_str();
+		const char* screen = (*it).screen.c_str();
+		const char* available = (*it).available.c_str();
+		const char* sessionName = (*it).sessionName.c_str();
+
+		// Bundle up the available session
+		dbus_message_append_args 
+			(message,
+			 DBUS_TYPE_INT32,  &(*it).display,
+			 DBUS_TYPE_STRING, &sessionType,
+			 DBUS_TYPE_STRING, &sessionID,
+			 DBUS_TYPE_STRING, &options,
+			 DBUS_TYPE_INT32,  &(*it).depth,
+			 DBUS_TYPE_STRING, &screen,
+			 DBUS_TYPE_STRING, &available,
+			 DBUS_TYPE_STRING, &sessionName,
+			 DBUS_TYPE_INVALID);
+		dbus_connection_send (this->conn, message, NULL);
+		dbus_message_unref (message);
+	}
+
+	DBusMessage *complete = dbus_message_new_signal ("/org/freenx/nxcl/dbus/AvailableSession",
+						         this->dbusSendInterface.c_str(),
+							 "NoMoreAvailable");
+
+	this->callbacks.debug ("About to send the finishup message");
+	dbus_connection_send (this->conn, complete, NULL);
+	this->callbacks.debug ("Sent the finishup message");
+	dbus_message_unref (complete);
+}
+
+void
+Nxcl::serverCapacityReached (void)
+{
+	DBusMessage *msg = dbus_message_new_signal ("/org/freenx/nxcl/dbus/AvailableSession",
+						    this->dbusSendInterface.c_str(),
+						    "ServerCapacityReached");
+
+	dbus_connection_send (this->conn, msg, NULL);
+	dbus_message_unref (msg);
+}
+
+void
+Nxcl::receiveStartInstruction (void)
+{
+	DBusMessage * message;
+	DBusMessageIter args;
+	dbus_int32_t parameter = 0;
+	bool instruction_received = false;
+	stringstream ss;
+
+	this->callbacks.write ("receiveStartInstruction() called");
+
+	// loop listening for signals being emitted
+	while (instruction_received == false) {
+		
+		// non blocking read of the next available message
+		dbus_connection_read_write(this->conn, 0);
+		message = dbus_connection_pop_message(this->conn);
+
+		// loop again if we haven't read a message
+		if (NULL == message) { 
+			sleep(1);
+			continue;
+		}
+
+		// check if the message is a signal from the
+		// correct interface and with the correct name
+		if (dbus_message_is_signal (message, this->dbusMatchInterface.c_str(), "sessionChoice")) {
+			// read the parameters
+			if (!dbus_message_iter_init(message, &args))
+				cerr << "Message has no arguments!\n"; 
+			else if (DBUS_TYPE_INT32 != dbus_message_iter_get_arg_type(&args))
+				cerr << "Argument is not int32!\n";
+			else {
+				dbus_message_iter_get_basic(&args, &parameter);
+				//ss.str("");
+				//ss << parameter;
+				//this->callbacks.write ("Choice: " + ss.str());
+				instruction_received = true;
+				if (parameter < 0) {
+					// No action, start a new connection
+				} else {
+					this->nxclientlib.chooseResumable (parameter);
+				}
+			}
+
+		} else if (dbus_message_is_signal (message, this->dbusMatchInterface.c_str(), "terminateSession")) {
+			// read the parameters
+			if (!dbus_message_iter_init(message, &args))
+				cerr << "Message has no arguments!\n"; 
+			else if (DBUS_TYPE_INT32 != dbus_message_iter_get_arg_type(&args))
+				cerr << "Argument is not int32!\n";
+			else {
+				dbus_message_iter_get_basic(&args, &parameter);
+				ss.str("");
+				ss << parameter;
+				this->callbacks.write ("Terminating: " + ss.str());
+				instruction_received = true;
+				if (parameter < 0) {
+					// No action, start a new connection
+				} else {
+					this->nxclientlib.terminateSession (parameter);
+				}
+			}
+		}
+		dbus_connection_flush (this->conn);
+		dbus_message_unref (message);
+	}
+
+}
+
+void
+Nxcl::requestConfirmation (string msg)
+{
+	this->callbacks.write ("requestConfirmation(): This is a placeholder method "
+			       "to deal with sending back a yes "
+			       "or a no answer. For now, we just set "
+			       "this->nxclientlib.getSession().setContinue(true);");
+	this->nxclientlib.getSession()->setContinue (true);
+}
+//@}

Added: nxcl/nxcl/nxcl.h
===================================================================
--- nxcl/nxcl/nxcl.h	2007-08-19 15:44:16 UTC (rev 372)
+++ nxcl/nxcl/nxcl.h	2007-09-11 12:48:46 UTC (rev 373)
@@ -0,0 +1,316 @@
+/* -*-c++-*- */
+/*
+ * nxcl: The NXCL dbus daemon.
+ *
+ * See main.cpp for general notes.
+ *
+ * This file contains the definition of the Nxcl class used by the
+ * nxcl program.
+ *
+ * (C) 2007 Embedded Software Foundry Ltd. (U.K.)
+ * Author: Sebastian James
+ * Email:  seb at esfnet.co.uk
+ *
+ * Released under the terms of the GNU GPL version 2.
+ */
+
+#ifndef _NXCL_H_
+#define _NXCL_H_ 1
+
+#include "nxdata.h"
+#include "../lib/nxclientlib.h"
+
+/* This define is required for slightly older versions of dbus as
+ * found, for example, in Ubuntu 6.06. */
+#define DBUS_API_SUBJECT_TO_CHANGE 1
+extern "C" {
+#include <dbus/dbus.h>
+}
+
+using namespace std;
+
+namespace nxcl 
+{
+
+	class NxclBase
+	{
+	public:
+		NxclBase() {}
+		virtual ~NxclBase() {}
+
+		virtual void haveResumableSessions (list<NXResumeData> resumeData) {}
+		virtual void noResumableSessions (void) {}
+		virtual void serverCapacityReached (void) {}
+	};
+
+	class NxclCallbacks : public NXClientLibExternalCallbacks
+	{
+	public:
+		NxclCallbacks ();
+		~NxclCallbacks ();
+
+		/*!
+		 * Send a message to the user. Here, this is
+		 * implemented as a message to stdout. It could be
+		 * (any may yet be) send on the dbus interface
+		 */
+		void write (string msg);
+		/*!
+		 * Send a debugging message out. Here that's
+		 * implemented as a message on stdout.
+		 */
+		void debug (string msg);
+		/*!
+		 * This is called when some data comes from the stdout
+		 * of the nxssh process. This implementation sends a
+		 * copy of that data to stdout of nxcl, for debugging
+		 * purposes (and only when DEBUG==1,
+		 * i.e. --enable-debug-output was given as an option
+		 * to the configure script.
+		 */
+		void stdoutSignal (string msg);
+		/*!
+		 * Outputs a copy of stderr output from the nxssh
+		 * process.
+		 */
+		void stderrSignal (string msg);
+		/*!
+		 * Outputs a copy of the stdin input sent to the nxssh
+		 * process to the stdout of nxcl for debugging
+		 * purposes.
+		 */
+		void stdinSignal (string msg);
+		/*!
+		 * Sends the list of resumable sessions (resumeData)
+		 * to the client of the nxcl program via a dbus
+		 * message.
+		 */
+		void resumeSessionsSignal (list<NXResumeData> resumeData);		
+		/*!
+		 * Tells nxcl that there are no suspended sessions and
+		 * that connection is proceeding with a new
+		 * connection. This fact is sent to the client of nxcl
+		 * as a dbus message.
+		 */
+		void noSessionsSignal (void);
+		/*!
+		 * This callback sends a message via dbus to the
+		 * client of the nxcl program saying "the server has
+		 * no more capacity". This basically means that there
+		 * are not enough licences to allow the connection,
+		 * but it may also occur if there is any sort of RAM
+		 * limit checking in nxserver (I don't know if this is
+		 * true).
+		 */
+		void serverCapacitySignal (void);
+
+		/*!
+		 * Accessor function to set a pointer to the parent Nxcl object.
+		 */
+		void setParent (NxclBase * p) { this->parent = p; }
+	private:
+		NxclBase * parent;
+
+	};
+
+	class Nxcl : public NxclBase
+	{
+	public:
+		Nxcl();
+		Nxcl(int n);
+		~Nxcl();
+
+		// Public Methods
+		/*!
+		 * \brief Sets up a connection to the dbus daemon, based on
+		 * the member attribute \see dbusNum. 
+		 *
+		 * Sets the connection up to listen for messages on
+		 * the interface org.freenx.nxcl.clientX where X
+		 * starts at 0 and the first available number is taken
+		 * (if another nxcl is running with
+		 * org.freenx.nxcl.client0, then 1 is
+		 * chosen). Messages are sent out on the interface
+		 * org.freenx.nxcl.nxclX
+		 */
+		void setupDbus (void);
+		/*!
+		 * \brief Sets dbusNum to be \arg id, then calls \see
+		 * setupDbus().
+		 *
+		 * \param id The number to use to set up the dbus
+		 * connection (used as a suffix for interface names).
+		 */
+		void setupDbus (int id);
+		/*!
+		 * \brief Wait for a dbus message containing session settings.
+		 *
+		 * This waits for a dbus signal message called
+		 * 'sessionConfig' to come in on the listen interface,
+		 * then sets \see sessionData based on its contents.
+		 *
+		 * \return 0 if settings received ok, -1 if we didn't
+		 * receive at least the nxserver host and the nxuser
+		 * name.
+		 */
+		int receiveSettings (void);
+		/*!
+		 * \brief Set default values for \see sessionData
+		 */
+		void setSessionDefaults (void);
+		/*!
+		 * \brief Configure the \see nxclientlib object and
+		 * then call its \see invokeSSH method.
+		 *
+		 * This also calls nxclientlib.setResolution to detect
+		 * the size of your screen (that's why nxcl links to X
+		 * libraries).
+		 */
+		void startTheNXConnection (void);
+
+		// Accessors
+		//@{
+		NXClientLib* getNXClientLib (void) { return &(this->nxclientlib); }
+		//@}
+
+		// Public Slots
+		//@{
+		/*!
+		 * Called by \see NxclCallbacks::resumeSessionsSignal
+		 */
+		void haveResumableSessions (list<NXResumeData> resumable);
+		/*!
+		 * Called by \see NxclCallbacks::noSessionsSignal
+		 */
+		void noResumableSessions (void);
+		/*!
+		 * This _should_ send a dbus message to the client of
+		 * nxcl, saying "You've never connected to this
+		 * (NX)SSH server before, do you wish to
+		 * continue?"
+		 *
+		 * For now, it just sets
+		 * this->nxclientlib.getSession()->setContinue (true);
+		 */
+		void requestConfirmation (string msg);
+		/*!
+		 * Called by \see NxclCallbacks::serverCapacitySignal
+		 */
+		void serverCapacityReached (void);
+		//@}
+
+		/*!
+		 * Public pointer to the callback functions
+		 */
+		NxclCallbacks callbacks;
+
+	private:
+		/*!
+		 * \brief Set up data structures, determine display height and width.
+		 *
+		 * This is called by the constructors.
+		 */
+		void initiate (void);
+		/*!
+		 * Send the resumable sessions as dbus messages. One
+		 * message (called "AvailableSession") is sent for
+		 * each resumable session available on the NX
+		 * server. When they have all been sent, a message is
+		 * sent called "NoMoreAvailable".
+		 *
+		 * Called by \see haveResumableSessions.
+		 *
+		 * \param resumable a list of resumable sessions to be
+		 * sent on the dbus interface.
+		 *
+		 */
+		void sendResumeList (list<NXResumeData>& resumable);
+		/*!
+		 * Wait for a message on the dbus interface to tell us
+		 * which of the resumable sessions available on the NX
+		 * server we should start. Call
+		 * nxclientlib.chooseResumable() or
+		 * nxclientlib.terminateSession based on the contents
+		 * of the received message.
+		 *
+		 * Called by \see haveResumableSessions.
+		 */
+		void receiveStartInstruction (void);
+
+		/*!
+		 * The nxclientlib object whose methods will negotiate
+		 * the NX session.
+		 */
+		NXClientLib nxclientlib;
+		/*!
+		 * We populate this data structure before passing the
+		 * information to the nxclientlib object so it can
+		 * start up the desired connection.
+		 */
+		NXSessionData sessionData;
+		/*!
+		 * The connection to the dbus daemon.
+		 */
+		DBusConnection *conn;
+		/*!
+		 * Used when calling dbus functions.
+		 */
+		DBusError error;
+		/*!
+		 * Used to make our dbus interfaces unique. This
+		 * number is appended to the dbus interface names.
+		 */
+		int dbusNum;
+		/*!
+		 * The name to use for our connection to DBUS.
+		 */
+		string dbusName;
+		/*!
+		 * Match messages from this DBUS source.
+		 */
+		string dbusMatch;
+		/*!
+		 * The DBUS interface which we will listen to.
+		 */
+		string dbusMatchInterface;
+		/*!
+		 * The DBUS interface we'll send on.
+		 */
+		string dbusSendInterface;
+		/*!
+		 * Holds the username for the connection to the NX
+		 * Server.
+		 */
+		string nxuser;
+		/*!
+		 * Holds the password for the connection to the NX
+		 * Server.
+		 */
+		string nxpass;
+		/*!
+		 * Holds the ip/hostname of the NX Server to which we
+		 * will try to connect.
+		 */
+		string nxserver;
+		/*!
+		 * Holds the port on the NX Server to which we will
+		 * try to connect.
+		 */
+		int nxport;
+		/*!
+		 * Width of the screen in pixels.
+		 */
+		int xRes;
+		/*!
+		 * Height of the screen in pixels.
+		 */
+		int yRes;
+		/*!
+		 * Colour depth of the screen.
+		 */
+		int displayDepth;
+	};
+
+} // namespace
+
+#endif // ifndef _NXCL_H_

Added: nxcl/test/Makefile.am
===================================================================
--- nxcl/test/Makefile.am	2007-08-19 15:44:16 UTC (rev 372)
+++ nxcl/test/Makefile.am	2007-09-11 12:48:46 UTC (rev 373)
@@ -0,0 +1,11 @@
+AM_CPPFLAGS = @PACKAGE_CFLAGS@ -DPACKAGE_DATA_DIR=\""$(datadir)"\" -DLOCALEDIR=\"$(localedir)\" -DPACKAGE_BIN_DIR=\""$(bindir)"\"
+INCLUDES = -I../lib
+bin_PROGRAMS = libtest nxcmd notQttest
+libtest_SOURCES = libtest.cpp
+libtest_LDADD = @PACKAGE_LIBS@ $(LIBINTL) -L../lib -lnxcl
+notQttest_SOURCES = notQttest.cpp
+notQttest_LDADD = @PACKAGE_LIBS@ $(LIBINTL) -L../lib -lnxcl
+nxcmd_SOURCES = nxcmd.cpp
+nxcmd_LDADD = @PACKAGE_LIBS@ $(LIBINTL)
+#pkginclude_HEADERS = header.h
+

Added: nxcl/test/libtest.cpp
===================================================================
--- nxcl/test/libtest.cpp	2007-08-19 15:44:16 UTC (rev 372)
+++ nxcl/test/libtest.cpp	2007-09-11 12:48:46 UTC (rev 373)
@@ -0,0 +1,111 @@
+#include "nxclientlib.h"
+#include <fstream>
+
+using namespace nxcl;
+using namespace std;
+
+ofstream debugLogFile;
+
+// Signal handlers
+void writeOut (string msg)
+{
+	cout << "NXCL> " << msg << endl;
+}
+void stdinInfo (string msg)
+{
+	cout << "nxssh<-stdin-" << endl << msg << endl;
+}
+void stdoutInfo (string msg)
+{
+	cout << "nxssh-stdout->" << endl << msg << endl;
+}
+void stderrInfo (string msg)
+{
+	cout << "nxssh-stderr->" << endl << msg << endl;
+}
+
+int main (int argc, char **argv)
+{
+	NXClientLib lib;
+	stringstream ss;
+
+	ss << argv[2];
+	string un = ss.str();
+	ss.str("");
+	ss << argv[3];
+	string pw = ss.str();
+	ss.str("");
+
+	if (argc!=4) {
+		cout << "Usage: libtest IP user pass" << endl;
+		return -1;
+	}
+
+	debugLogFile.open("/tmp/libtest.log", ios::out|ios::trunc);
+
+	lib.invokeNXSSH("default", argv[1], true, "", 22);
+	lib.setUsername(un);
+	lib.setPassword(pw);
+	lib.setResolution(1280,1024); // This is the size of your screen
+	lib.setDepth(24);
+	lib.setRender(true);
+
+	NXSessionData theSesh;
+
+	// HARDCODED TEST CASE
+	theSesh.sessionName = "TEST";
+	theSesh.sessionType = "unix-gnome";
+	theSesh.cache = 8;
+	theSesh.images = 32;
+	theSesh.linkType = "adsl";
+	theSesh.render = true;
+	theSesh.backingstore = "when_requested";
+	theSesh.imageCompressionMethod = 2;
+	// theSesh.imageCompressionLevel;
+	theSesh.geometry = "800x600+0+0"; // This'll be the size of the session
+	theSesh.keyboard = "defkeymap";
+	theSesh.kbtype = "pc102/defkeymap";
+	theSesh.media = false;
+	theSesh.agentServer = "";
+	theSesh.agentUser = "";
+	theSesh.agentPass = "";
+	theSesh.cups = 0;
+	theSesh.suspended = false;
+	theSesh.fullscreen = true; // If true, theSesh.geometry is ignored
+
+	lib.setSessionData(&theSesh);
+
+	// Set the handler you would like to output messages to the user. We'll just use stdout for this test.
+	//lib.callbackWriteSignal.connect (&writeOut);
+
+	// If you want a nice quiet session, leave these signals unconnected
+	/*
+	lib.stdinSignal.connect (&stdinInfo);
+	lib.stdoutSignal.connect (&stdoutInfo);
+	lib.stderrSignal.connect (&stderrInfo);
+	*/
+
+	//notQProcess& p = lib.getNXSSHProcess();
+	notQProcess* p;
+
+	while ((lib.getIsFinished()) == false) {
+		// We need to repeatedly check if there is any output to parse.
+		if (lib.getReadyForProxy() == false) {
+			p = lib.getNXSSHProcess();
+			p->probeProcess();
+		} else {
+			p = lib.getNXSSHProcess();
+			p->probeProcess();
+			p = lib.getNXProxyProcess();
+			p->probeProcess();
+		}
+
+		usleep (1000);
+	}
+
+	writeOut ("Program finished.");
+
+	debugLogFile.close();
+
+	return 0;
+}

Added: nxcl/test/notQttest.cpp
===================================================================
--- nxcl/test/notQttest.cpp	2007-08-19 15:44:16 UTC (rev 372)
+++ nxcl/test/notQttest.cpp	2007-09-11 12:48:46 UTC (rev 373)
@@ -0,0 +1,141 @@
+/*
+ * notQttest.cpp - A test of some of the features in ../lib/notQt.cpp
+ *
+
+ *
+ * (C) 2007 Embedded Software Foundry Ltd. (U.K.)
+ * Author: Sebastian James
+ * Email:  seb at esfnet.co.uk
+ *
+ * Released under the terms of the GNU GPL version 2.
+ */
+
+#include <iostream>
+#include <string>
+#include <list>
+
+#include "notQt.h"
+
+using namespace std;
+using namespace nxcl;
+
+ofstream debugLogFile;
+
+notQProcess p2;
+
+void processParseStdout()
+{
+	string message = p2.readAllStandardOutput();
+	cout << "processParseStdout called, message is: " << message << endl;
+}
+void processParseStderr()
+{
+	string message = p2.readAllStandardError();	
+	cout << "processParseStderr called, message is: " << message << endl;
+}
+
+int main()
+{
+
+	debugLogFile.open("/tmp/notQttest.log", ios::out|ios::trunc);
+
+	// Test temporary files
+	notQTemporaryFile tf;
+	tf.open();
+	tf.write ("this is a temporary file, jim");
+	cout << "tmp filename is " << tf.fileName() << endl;
+	tf.close();
+
+	// Test utilities
+	string tstring = "\n\n  this \t  is\n a\t\t   test string    ";
+	cout << "test string is '" << tstring << "'" << endl;
+	cout << "simplify returns '" << notQtUtilities::simplify (tstring) << "'" << endl;
+
+        tstring = "Nowhitespaceatall";
+	cout << "test string is '" << tstring << "'" << endl;
+	cout << "simplify returns '" << notQtUtilities::simplify (tstring) << "'" << endl;
+
+	tstring = "one two three\tfour";
+	vector<string> v;
+	notQtUtilities::splitString (tstring, ' ', v);
+	cout << "v.size() = " << v.size() << endl;
+	for (unsigned int i=0; i<v.size(); i++) {
+		cout << "v["<<i<<"]='" << v[i] << "'" << endl;
+	}
+	/*
+	vector<string> v2;
+	notQtUtilities::splitString (tstring, 'h', v2);
+	cout << "v2.size() = " << v2.size() << endl;
+	for (unsigned int i=0; i<v2.size(); i++) {
+		cout << "v2["<<i<<"]='" << v2[i] << "'" << endl;
+	}
+	*/
+
+	// Test processes to read some input
+	notQProcess p;
+	string program = "/usr/bin/tee";
+	list<string> args;       
+	// Always push_back the program first.
+	args.push_back(program);
+	args.push_back("teeout");
+	p.start (program, args);
+	cout << "p.getPid=" << p.getPid() << endl;
+	if (p.waitForStarted() == true) {
+		string data = "Some input text";
+		p.writeIn (data);
+
+	} else { 
+		cout << "not started" << endl;
+		return -1;
+	}
+
+	// Test process that generates output
+	bool finished = false;
+//	program = "/usr/bin/eo";
+	program = "/usr/bin/tee";
+	args.clear();
+	// Always push_back the program first.
+	args.push_back(program);
+	args.push_back("hello");
+
+	// p2 is a global in this test
+
+/* FIXME: This needs to be changed, now that we got rid of boost signals.
+	p2.readyReadStandardOutputSignal.connect (&processParseStdout);
+	p2.readyReadStandardErrorSignal.connect (&processParseStderr);
+*/
+	p2.start (program, args);
+	cout << "p2.getPid=" << p2.getPid() << endl;
+	if (p2.waitForStarted() == true) {
+		string output;
+		string errout;
+		string instring = "data, data";
+		while (finished == false) {
+			p2.probeProcess();
+/* You can get the output without signals:
+			output = p2.readAllStandardOutput();
+			errout = p2.readAllStandardError();
+			if (output.size()>0) {
+				cout << program << " generated this output: " << output << endl;
+				finished = true;
+			}
+			if (errout.size()>0) {
+				cout << program << " generated this error: " << errout << endl;
+				finished = true;
+			}
+			cout << "sleeping" << endl;
+*/	
+			usleep (1000000);
+			p2.writeIn (instring);
+			usleep (1000000);
+		}
+
+	} else { 
+		cout << "not started" << endl;
+		return -1;
+	}
+
+	debugLogFile.close();
+
+	return 0;
+}

Added: nxcl/test/nxcmd.cpp
===================================================================
--- nxcl/test/nxcmd.cpp	2007-08-19 15:44:16 UTC (rev 372)
+++ nxcl/test/nxcmd.cpp	2007-09-11 12:48:46 UTC (rev 373)
@@ -0,0 +1,544 @@
+/*
+ * nxcmd: A simple command line test for the NXCL dbus daemon.
+ *
+ * See ../nxcl/main.cpp for general notes on the nxcl program.
+ *
+ * This program will fork a process and run nxcl, then it will send
+ * user, password and some settings to nxcl using a dbus
+ * connection. nxcl will then start up the NX connection for you.
+ *
+ * This is a very hacked together program, part C, part C++, but it
+ * serves its purpose of demonstrating the techniques you'll need to
+ * write a simple client to nxcl.
+ *
+ * (C) 2007 Embedded Software Foundry Ltd. (U.K.)
+ * Author: Sebastian James
+ * Email:  seb at esfnet.co.uk
+ *
+ * Released under the terms of the GNU GPL version 2.
+ */
+
+#include <iostream>
+#include <sstream>
+
+extern "C" {
+#include <stdlib.h>
+#include <stdio.h>
+#define DBUS_API_SUBJECT_TO_CHANGE 1
+#include <dbus/dbus.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <signal.h>
+}
+
+// This is the only dependency on nxcl here. If you want, all you have
+// to do is copy the NXConfigData structure out of nxdata.h and you
+// remove the dependency.
+#include "../lib/nxdata.h"
+
+using namespace std;
+
+// Used in receiveSession as the return value
+#define REPLY_REQUIRED  1
+#define NEW_CONNECTION  2
+#define SERVER_CAPACITY 3
+
+/*!
+ * Send all the settings in a single dbus signal.
+ */
+static int sendSettings (DBusConnection *bus, nxcl::NXConfigData& cfg);
+
+/*!
+ * Listen to the dbus, waiting for a signal to say either that
+ * connection is in progress, or giving us a list of possible sessions
+ * we could connect to. Return true if nxcld requires a reply such
+ * as "please resume session 1".
+ */
+static int receiveSession (DBusConnection* conn);
+
+/*!
+ * Send a signal containing the identifier for the NX session that the
+ * user would like to start.
+ */
+static int sendReply (DBusConnection *bus, int sessionNum);
+
+/*!
+ * Send a signal containing the identifier for the NX session that the
+ * user would like to terminate.
+ */
+static int terminateSession (DBusConnection *bus, int sessionNum);
+
+/*!
+ * Lazily use some globals, as this is just an example command line program.
+ */
+string dbusSendInterface;
+string dbusRecvInterface;
+string dbusMatchString;
+
+
+int
+main (int argc, char **argv)
+{
+	nxcl::NXConfigData cfg;
+	DBusConnection *conn;
+	DBusError error;
+	int ret;
+	int theError;
+	pid_t pid;
+	bool gotName = false;
+	int i = 0;
+
+	if (argc != 5) {
+		cout << "NXCMD> Usage: nxcmd IP/DNSName user pass sessiontype\n";
+		cout << "NXCMD> Eg:    nxcmd 192.168.0.1 me mypass unix-gnome\n";
+		return -1;
+	}
+
+	cout << "NXCMD> Starting...\n";
+
+	/* Get a connection to the session bus */
+	dbus_error_init (&error);
+	conn = dbus_bus_get (DBUS_BUS_SESSION, &error);
+	if (!conn) {
+		cerr << "Failed to connect to the D-BUS daemon: " << error.message << endl;
+		dbus_error_free (&error);
+		return 1;
+	}
+
+	while (gotName == false) {
+
+		stringstream ss;
+		string base = "org.freenx.nxcl.";
+		ss << base << "client" << i;
+		dbusSendInterface = ss.str();
+
+		ss.str("");
+		ss << base << "nxcld" << i;
+		dbusRecvInterface = ss.str();
+
+		ss.str("");
+		ss << "type='signal',interface='org.freenx.nxcl.nxcld" << i << "'";
+		dbusMatchString = ss.str();
+
+
+		// We request a name on the bus which is the same string as the send interface.
+		ret = dbus_bus_request_name (conn, dbusSendInterface.c_str(),
+					     DBUS_NAME_FLAG_REPLACE_EXISTING, 
+					     &error);
+
+		if (dbus_error_is_set(&error)) { 
+			cerr << "NXCMD> Name Error (" << error.message << ")\n"; 
+			dbus_error_free(&error);
+		}
+
+		if (DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER != ret) {
+			cerr << "NXCMD> Couldn't get the name; trying another\n";
+			i++;
+		} else {
+			cout << "NXCMD> Got the name '" << dbusSendInterface << "' on the dbus\n";
+			gotName = true;
+		}
+	}
+
+	stringstream arg;
+	arg << i;		
+
+	/* fork and exec the nxcld */
+	pid = fork();
+	switch (pid) {
+	case -1:
+		cerr << "Can't fork()!" << endl;
+		exit (-1);
+	case 0:
+		// This is the CHILD process
+		// Allocate memory for the program arguments
+		// 1+ to allow space for NULL terminating pointer
+		execl (PACKAGE_BIN_DIR"/nxcld", "nxcld", arg.str().c_str(), static_cast<char*>(NULL));
+		// If process returns, error occurred
+		theError = errno; 
+		// This'll get picked up by parseResponse
+		cerr << "NXCMD> Process error: " << pid << " crashed. errno:" << theError << endl;
+		// Child should exit now.
+		exit(-1);
+
+	default:
+		// This is the PARENT process
+		cout << "NXCMD> forked the nxcld process; continuing.\n";
+		break;
+	}
+
+
+	/* Prepare interface - add a rule for which messages we want
+	   to see - those that are sent to us from the nxcld
+	   connection. */
+	dbus_bus_add_match(conn, dbusMatchString.c_str(), &error);
+	dbus_connection_flush (conn);
+	if (dbus_error_is_set(&error)) { 
+		cerr << "NXCMD> Match Error (" << error.message << ")\n";
+		exit(1);
+	} else {
+		cout << "NXCMD> Added match '" << dbusMatchString << "'\n";
+	}
+
+	// Crude 2 second wait to let nxcld get going before we send
+	// the settings. This _must_ be more sophisticated in your
+	// application ;)
+	sleep (2);
+
+	cout << "NXCMD> Configure session\n";
+
+	// We now set up the config data structure. We take user, host
+	// and pass from the command line, but for the sake of
+	// simplicity, we hard-code the rest of the settings here.
+	cfg.serverHost = argv[1];
+	cfg.serverPort = 22;
+	cfg.sessionUser = argv[2];
+	cfg.sessionPass = argv[3];
+	cfg.sessionName = "nxcldtest";
+	cfg.sessionType = argv[4];
+	cfg.cache = 8;
+	cfg.images = 32;
+	cfg.linkType = "adsl";
+	cfg.render = true;
+	cfg.backingstore = "when_requested";
+	cfg.imageCompressionMethod = 2;
+	cfg.imageCompressionLevel = 1;
+	cfg.geometry = "800x600+0+0";
+	cfg.keyboard = "defkeymap";
+	cfg.kbtype = "pc105/defkeymap";
+	cfg.media = false;
+	cfg.agentServer = "";
+	cfg.agentUser = "";
+	cfg.agentPass = "";
+	cfg.cups = 0;
+	cfg.encryption = true;
+	cfg.fullscreen = false; // If true, ignore cfg.geometry. 	
+	
+	cout << "NXCMD> Sending settings\n";
+
+	// ...and then send it on dbus.
+	sendSettings (conn, cfg);
+
+	cout << "NXCMD> Sent settings\n";
+	
+	// In real application, we'd now listen on the dbus for a list
+	// of sessions we might be able to re-connect to, or
+	// confirmation that a session is starting. Then we could return.
+	bool done = false;
+	while (false == done) {
+		if (REPLY_REQUIRED == (ret = receiveSession (conn))) {
+			// Need to send back a reply saying which connection
+			// to reconnect.
+			cout << "NXCMD> Please choose a session. 0 for the first, etc.\nT0 to terminate the first, etc\n";
+			if (cfg.sessionType != "shadow") {
+				cout << "Enter -1 to start a new session\n";
+			}
+			// Choose 0 for first connection, 1 for next etc, or
+			// <0 for a new connection, even if there are existing
+			// sessions.
+			int connNum = 0;
+			string response;
+			cin >> response;
+			stringstream ss;
+			if (response[0] == 'T') {
+				ss << response.substr(1);
+				ss >> connNum;
+				cout << "NXCMD> Terminating session " << connNum << endl;
+				terminateSession (conn, connNum);
+			} else {
+				ss << response;
+				ss >> connNum;
+				sendReply (conn, connNum);
+				if (connNum < 0) {
+					cout << "NXCMD> Starting new NX session\n";			
+				} else {
+					cout << "NXCMD> Attaching to session " << connNum << endl;
+				}
+				done = true;
+			}
+
+		} else if (SERVER_CAPACITY == ret) {
+			// Have run out of capacity (licences) on the server.
+			done = true;
+		} else {
+			cout << "NXCMD> Starting new NX session\n";
+			done = true;
+		}
+	}
+
+	// wait and block for nxcld process to end before exiting.
+	int status = 0;
+	wait (&status);
+
+	return 0;
+}
+
+static int
+sendSettings (DBusConnection *bus, nxcl::NXConfigData& cfg)
+{
+	cout << "NXCMD> sendSettings called\n";
+
+	DBusMessage *message;
+
+	/* Create a new setting signal on the "org.freenx.nxcl.client"
+	 * interface, from the object "/org/freenx/nxcl/dbus/settingSignal". */
+	message = dbus_message_new_signal ("/org/freenx/nxcl/dbus/settingSignal",
+					   dbusSendInterface.c_str(), 
+					   "sessionConfig");
+	if (NULL == message) {
+		cerr << "NXCMD> Message Null\n";
+		return -1;
+	}
+
+	int media=0, enc=0, fs=0;
+	if (cfg.media == true) { media = 1; }
+	if (cfg.encryption == true) { enc = 1; }
+	if (cfg.fullscreen == true) { fs = 1; }
+	dbus_message_append_args 
+		(message,
+		 DBUS_TYPE_STRING, &cfg.serverHost,  //0
+		 DBUS_TYPE_INT32,  &cfg.serverPort,
+		 DBUS_TYPE_STRING, &cfg.sessionUser, //2
+		 DBUS_TYPE_STRING, &cfg.sessionPass,
+		 DBUS_TYPE_STRING, &cfg.sessionName, //4
+		 DBUS_TYPE_STRING, &cfg.sessionType,
+		 DBUS_TYPE_INT32,  &cfg.cache,       //6
+		 DBUS_TYPE_INT32,  &cfg.images,
+		 DBUS_TYPE_STRING, &cfg.linkType,    //8
+		 DBUS_TYPE_INT32,  &cfg.render, 
+		 DBUS_TYPE_STRING, &cfg.backingstore,//10
+		 DBUS_TYPE_INT32,  &cfg.imageCompressionMethod,
+		 DBUS_TYPE_INT32,  &cfg.imageCompressionLevel, //12
+		 DBUS_TYPE_STRING, &cfg.geometry,
+		 DBUS_TYPE_STRING, &cfg.keyboard,    //14
+		 DBUS_TYPE_STRING, &cfg.kbtype,
+		 DBUS_TYPE_INT32,  &media,           //16
+		 DBUS_TYPE_STRING, &cfg.agentServer,
+		 DBUS_TYPE_STRING, &cfg.agentUser,   //18
+		 DBUS_TYPE_STRING, &cfg.agentPass,
+		 DBUS_TYPE_INT32,  &cfg.cups,        //20
+		 DBUS_TYPE_STRING, &cfg.key,
+		 DBUS_TYPE_INT32,  &enc,             //22
+		 DBUS_TYPE_INT32,  &fs,
+		 DBUS_TYPE_STRING, &cfg.customCommand,//24
+		 DBUS_TYPE_INVALID);
+
+	/* Send the signal */
+	if (!dbus_connection_send (bus, message, NULL)) {
+		cerr << "NXCMD> Out Of Memory!\n"; 
+		exit(1);
+	}
+
+	/* Clean up */
+	dbus_message_unref (message);
+	dbus_connection_flush (bus);
+
+	return 1;
+}
+
+static int
+sendReply (DBusConnection *bus, int sessionNum)
+{
+	DBusMessage *message;
+	DBusMessageIter args;
+
+	/* Create a new session choice signal on the "org.freenx.nxcl.client"
+	 * interface, from the object "/org/freenx/nxcl/dbus/sessionChoice". */
+	message = dbus_message_new_signal ("/org/freenx/nxcl/dbus/sessionChoice",
+					   dbusSendInterface.c_str(),
+					   "sessionChoice");
+	if (NULL == message) { 
+		cerr << "NXCMD> Message Null\n";
+		return -1;
+	}
+
+	dbus_message_iter_init_append (message, &args);
+	if (!dbus_message_iter_append_basic (&args,
+					     DBUS_TYPE_INT32,
+					     (const void*)&sessionNum)) {
+		cerr << "NXCMD> Out Of Memory!\n";
+		exit(1);
+	}
+
+	/* Send the signal */
+	if (!dbus_connection_send (bus, message, NULL)) {
+		cerr << "NXCMD> Out Of Memory!\n";
+		exit(1);	  
+	}
+
+	/* Clean up */
+	dbus_message_unref (message);
+	dbus_connection_flush (bus);
+
+	return 1;
+}
+
+
+static int
+terminateSession (DBusConnection *bus, int sessionNum)
+{
+	DBusMessage *message;
+	DBusMessageIter args;
+
+	/* Create a new session choice signal on the "org.freenx.nxcl.client"
+	 * interface, from the object "/org/freenx/nxcl/dbus/sessionChoice". */
+	message = dbus_message_new_signal ("/org/freenx/nxcl/dbus/sessionChoice",
+					   dbusSendInterface.c_str(),
+					   "terminateSession");
+	if (NULL == message) { 
+		cerr << "NXCMD> Message Null\n";
+		return -1;
+	}
+
+	dbus_message_iter_init_append (message, &args);
+	if (!dbus_message_iter_append_basic (&args,
+					     DBUS_TYPE_INT32,
+					     (const void*)&sessionNum)) {
+		cerr << "NXCMD> Out Of Memory!\n";
+		exit(1);
+	}
+
+	/* Send the signal */
+	if (!dbus_connection_send (bus, message, NULL)) {
+		cerr << "NXCMD> Out Of Memory!\n";
+		exit(1);	  
+	}
+
+	/* Clean up */
+	dbus_message_unref (message);
+	dbus_connection_flush (bus);
+
+	return 1;
+}
+
+
+/*
+ * Wait for and receive a message with available sessions, or a
+ * message saying there are no available sessions
+ */
+static int
+receiveSession (DBusConnection* conn)
+{
+	DBusMessage * message;
+	DBusMessageIter args;
+	DBusError error;
+	char * parameter = NULL;
+	dbus_int32_t iparam = 0, t = 0;
+	int count = 0;
+	bool sessions_obtained = false;
+	int rtn = 0;
+	stringstream ss;
+
+	cout << "NXCMD> In receiveSession, listening to " << dbusRecvInterface << "\n";
+
+	dbus_error_init (&error);
+
+	int sessionNum = 0;
+	// loop listening for signals being emitted
+	while (sessions_obtained == false) {
+		
+		if (dbus_error_is_set(&error)) { 
+			cerr << "NXCMD> Name Error (" << error.message << ")\n"; 
+			dbus_error_free(&error); 
+		}
+
+		count = 0;
+
+		// non blocking read of the next available message
+		dbus_connection_read_write(conn, 0);
+		message = dbus_connection_pop_message(conn);
+
+		// loop again if we haven't read a message
+		if (NULL == message) {
+			sleep (1);
+			continue;
+		}
+
+		// check if the message is a signal from the
+		// correct interface and with the correct name
+		if (dbus_message_is_signal (message,
+					    dbusRecvInterface.c_str(),
+					    "AvailableSession")) {
+
+			if (!dbus_message_iter_init (message, &args)) {
+				cerr << "NXCMD> Message has no arguments!\n";
+				dbus_connection_flush (conn);
+				dbus_message_unref (message);
+				continue;
+			}
+			
+			if (DBUS_TYPE_INT32 != dbus_message_iter_get_arg_type (&args)) {
+				cerr << "NXCMD> First argument is not int32!\n";
+			} else {
+				dbus_message_iter_get_basic (&args, &iparam);
+				if (sessionNum == 0) {
+					cout << "NXCMD> Available sessions:\n";
+				}
+				cout << sessionNum++ << ": " << iparam;
+				count++;
+			}
+
+			// read the parameters - something like:
+			while (dbus_message_iter_next (&args)) {
+				if (DBUS_TYPE_STRING == (t = dbus_message_iter_get_arg_type(&args))) {
+					dbus_message_iter_get_basic(&args, &parameter);
+					cout << " " << parameter;
+					ss.str("");
+					ss << parameter;
+					count++;
+				} else if (t == DBUS_TYPE_INT32) {
+					dbus_message_iter_get_basic (&args, &iparam);
+					cout << " " << iparam;
+					ss.str("");
+					ss << iparam;
+					count++;
+
+				} else {
+					cerr << "NXCMD> Error, parameter is not string or int.\n";
+				}
+				// Now we'd do something sensible with the data...
+			}
+			cout << endl;
+
+		} else if (dbus_message_is_signal (message,
+						   dbusRecvInterface.c_str(),
+						   "NoMoreAvailable")) {
+			sessions_obtained = true;
+			rtn = REPLY_REQUIRED;
+
+		} else if (dbus_message_is_signal (message,
+						   dbusRecvInterface.c_str(),
+						   "Connecting")) {
+			sessions_obtained = true;
+			rtn = NEW_CONNECTION;
+
+		} else if (dbus_message_is_signal (message,
+						   dbusRecvInterface.c_str(),
+						   "ServerCapacityReached")) {
+			sessions_obtained = true;
+			rtn = SERVER_CAPACITY;
+		} else {
+#ifdef DEBUG
+			cout << "NXCMD> None of the above...\n";
+			if (!dbus_message_iter_init(message, &args)) {
+				cerr << "NXCMD> Message has no arguments!\n";
+				dbus_connection_flush (conn);
+				dbus_message_unref (message);
+				continue;
+			}
+			if (DBUS_TYPE_STRING == (t = dbus_message_iter_get_arg_type(&args))) {
+				dbus_message_iter_get_basic(&args, &parameter);
+				cout << "NXCMD> Parameter: " << parameter << endl;
+			}
+#endif
+		}	
+
+		dbus_connection_flush (conn);
+		dbus_message_unref (message);
+
+	} // while()
+
+	return rtn;
+}



From sebjames at mail.berlios.de  Tue Sep 11 15:15:24 2007
From: sebjames at mail.berlios.de (sebjames at BerliOS)
Date: Tue, 11 Sep 2007 13:15:24 -0000
Subject: [Freenx-cvs] r374 - in nxcl: nxcl test
Message-ID: <200709111314.l8BDEewO019856@sheep.berlios.de>

Author: sebjames
Date: 2007-09-11 15:14:39 +0200 (Tue, 11 Sep 2007)
New Revision: 374

Modified:
   nxcl/nxcl/nxcl.cpp
   nxcl/test/nxcmd.cpp
Log:
Sorted out some extraneous debugging output in nxcl.cpp. Fixed nxcmd.cpp to actually work again.


Modified: nxcl/nxcl/nxcl.cpp
===================================================================
--- nxcl/nxcl/nxcl.cpp	2007-09-11 12:48:46 UTC (rev 373)
+++ nxcl/nxcl/nxcl.cpp	2007-09-11 13:14:39 UTC (rev 374)
@@ -179,7 +179,6 @@
 	if (DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER != ret) { 
 		/* What to do if someone else is running? Try another name? Exit? */
 		this->callbacks.write ("There appears to be another nxcl running, won't compete. Exiting.");
-		cout << "(DEBUG) ret == " << ret << endl;
 		exit(1);
 	}
 	// Done getting connection to session bus
@@ -221,7 +220,7 @@
 	stringstream ss;
 	int count = 0;
 
-	this->callbacks.write ("receiveSettings called");
+	this->callbacks.debug ("receiveSettings called");
 
 	// loop listening for signals being emitted
 	while (settings_transferred == false) {
@@ -244,7 +243,7 @@
 
 		// check if the message is a signal from the
 		// correct interface and with the correct name
-		this->callbacks.write ("call dbus_message_is_signal()");
+		this->callbacks.debug ("call dbus_message_is_signal()");
 		if (dbus_message_is_signal (message, this->dbusMatchInterface.c_str(), "sessionConfig")) {
 
 			if (!dbus_message_iter_init(message, &args)) {
@@ -366,7 +365,7 @@
 			}
 			settings_transferred = true;			
 		} else {
-			this->callbacks.write ("this message is not a signal");
+			this->callbacks.debug ("this message is not a signal");
 		}
 
 		// Anything else required for cleanup?
@@ -376,7 +375,7 @@
 		dbus_message_unref (message);
 
 	} // while()
-	this->callbacks.write ("Got the session settings over the dbus\n");
+	this->callbacks.debug ("Got the session settings over the dbus\n");
 
 	if (this->nxserver.size() == 0 || this->nxuser.size() == 0) {
 		// We need at least these to be able to connect. Leave
@@ -474,7 +473,7 @@
 void
 Nxcl::noResumableSessions (void)
 {
-	this->callbacks.write ("noResumableSessions Called");
+	this->callbacks.debug ("noResumableSessions Called");
 	DBusMessage *msg = dbus_message_new_signal ("/org/freenx/nxcl/dbus/AvailableSession",
 						    this->dbusSendInterface.c_str(),
 						    "Connecting");
@@ -554,7 +553,7 @@
 	bool instruction_received = false;
 	stringstream ss;
 
-	this->callbacks.write ("receiveStartInstruction() called");
+	this->callbacks.debug ("receiveStartInstruction() called");
 
 	// loop listening for signals being emitted
 	while (instruction_received == false) {
@@ -579,9 +578,6 @@
 				cerr << "Argument is not int32!\n";
 			else {
 				dbus_message_iter_get_basic(&args, &parameter);
-				//ss.str("");
-				//ss << parameter;
-				//this->callbacks.write ("Choice: " + ss.str());
 				instruction_received = true;
 				if (parameter < 0) {
 					// No action, start a new connection
@@ -600,7 +596,7 @@
 				dbus_message_iter_get_basic(&args, &parameter);
 				ss.str("");
 				ss << parameter;
-				this->callbacks.write ("Terminating: " + ss.str());
+				this->callbacks.debug ("Terminating: " + ss.str());
 				instruction_received = true;
 				if (parameter < 0) {
 					// No action, start a new connection

Modified: nxcl/test/nxcmd.cpp
===================================================================
--- nxcl/test/nxcmd.cpp	2007-09-11 12:48:46 UTC (rev 373)
+++ nxcl/test/nxcmd.cpp	2007-09-11 13:14:39 UTC (rev 374)
@@ -53,7 +53,7 @@
 /*!
  * Listen to the dbus, waiting for a signal to say either that
  * connection is in progress, or giving us a list of possible sessions
- * we could connect to. Return true if nxcld requires a reply such
+ * we could connect to. Return true if nxcl requires a reply such
  * as "please resume session 1".
  */
 static int receiveSession (DBusConnection* conn);
@@ -115,11 +115,11 @@
 		dbusSendInterface = ss.str();
 
 		ss.str("");
-		ss << base << "nxcld" << i;
+		ss << base << "nxcl" << i;
 		dbusRecvInterface = ss.str();
 
 		ss.str("");
-		ss << "type='signal',interface='org.freenx.nxcl.nxcld" << i << "'";
+		ss << "type='signal',interface='org.freenx.nxcl.nxcl" << i << "'";
 		dbusMatchString = ss.str();
 
 
@@ -145,7 +145,7 @@
 	stringstream arg;
 	arg << i;		
 
-	/* fork and exec the nxcld */
+	/* fork and exec the nxcl */
 	pid = fork();
 	switch (pid) {
 	case -1:
@@ -155,7 +155,7 @@
 		// This is the CHILD process
 		// Allocate memory for the program arguments
 		// 1+ to allow space for NULL terminating pointer
-		execl (PACKAGE_BIN_DIR"/nxcld", "nxcld", arg.str().c_str(), static_cast<char*>(NULL));
+		execl (PACKAGE_BIN_DIR"/nxcl", "nxcl", arg.str().c_str(), static_cast<char*>(NULL));
 		// If process returns, error occurred
 		theError = errno; 
 		// This'll get picked up by parseResponse
@@ -165,13 +165,13 @@
 
 	default:
 		// This is the PARENT process
-		cout << "NXCMD> forked the nxcld process; continuing.\n";
+		cout << "NXCMD> forked the nxcl process; continuing.\n";
 		break;
 	}
 
 
 	/* Prepare interface - add a rule for which messages we want
-	   to see - those that are sent to us from the nxcld
+	   to see - those that are sent to us from the nxcl
 	   connection. */
 	dbus_bus_add_match(conn, dbusMatchString.c_str(), &error);
 	dbus_connection_flush (conn);
@@ -182,7 +182,7 @@
 		cout << "NXCMD> Added match '" << dbusMatchString << "'\n";
 	}
 
-	// Crude 2 second wait to let nxcld get going before we send
+	// Crude 2 second wait to let nxcl get going before we send
 	// the settings. This _must_ be more sophisticated in your
 	// application ;)
 	sleep (2);
@@ -196,7 +196,7 @@
 	cfg.serverPort = 22;
 	cfg.sessionUser = argv[2];
 	cfg.sessionPass = argv[3];
-	cfg.sessionName = "nxcldtest";
+	cfg.sessionName = "nxcmd";
 	cfg.sessionType = argv[4];
 	cfg.cache = 8;
 	cfg.images = 32;
@@ -268,7 +268,7 @@
 		}
 	}
 
-	// wait and block for nxcld process to end before exiting.
+	// wait and block for nxcl process to end before exiting.
 	int status = 0;
 	wait (&status);
 



From sebjames at mail.berlios.de  Mon Sep 17 14:31:33 2007
From: sebjames at mail.berlios.de (sebjames at BerliOS)
Date: Mon, 17 Sep 2007 12:31:33 -0000
Subject: [Freenx-cvs] r381 - / nxlaunch nxlaunch/lib nxlaunch/src
	nxlaunch/src/pixmaps
Message-ID: <200709171230.l8HCUxKI022390@sheep.berlios.de>

Author: sebjames
Date: 2007-09-17 14:30:56 +0200 (Mon, 17 Sep 2007)
New Revision: 381

Added:
   nxlaunch/
   nxlaunch/Makefile.am
   nxlaunch/README
   nxlaunch/configure.ac
   nxlaunch/lib/
   nxlaunch/lib/Makefile.am
   nxlaunch/lib/callbacks_nx.c
   nxlaunch/lib/callbacks_nx.h
   nxlaunch/src/
   nxlaunch/src/Makefile.am
   nxlaunch/src/i18n.h
   nxlaunch/src/main.c
   nxlaunch/src/nxconfig.glade
   nxlaunch/src/nxlaunch.c
   nxlaunch/src/nxlaunch.glade
   nxlaunch/src/nxlaunch.h
   nxlaunch/src/pixmaps/
   nxlaunch/src/pixmaps/gnome-nx-session.png
   nxlaunch/src/pixmaps/kde-nx-session.png
   nxlaunch/src/pixmaps/nx-icon.png
   nxlaunch/src/pixmaps/nx-icon.xcf
   nxlaunch/src/pixmaps/nxclient-icon.png
   nxlaunch/src/pixmaps/rdp-nx-session.png
   nxlaunch/src/pixmaps/unknown-nx-session.png
   nxlaunch/src/pixmaps/vnc-nx-session.png
Log:
First import of nxlaunch GTK+ NX client based on nxcl

Added: nxlaunch/Makefile.am
===================================================================
--- nxlaunch/Makefile.am	2007-09-16 20:16:05 UTC (rev 380)
+++ nxlaunch/Makefile.am	2007-09-17 12:30:56 UTC (rev 381)
@@ -0,0 +1,10 @@
+
+AUTOMAKE_OPTIONS = check-news dist-bzip2
+
+SUBDIRS = src lib
+
+CLEANFILES = *~
+
+MAINTAINERCLEANFILES = aclocal.m4 nxlaunch-*.tar.gz nxlaunch-*.tar.bz2 nxlaunch-*.diff
+
+INCLUDES = -I./lib
\ No newline at end of file

Added: nxlaunch/README
===================================================================
--- nxlaunch/README	2007-09-16 20:16:05 UTC (rev 380)
+++ nxlaunch/README	2007-09-17 12:30:56 UTC (rev 381)
@@ -0,0 +1,15 @@
+
+  nxlaunch: A GTK+ NX client.
+
+  Seb James. September 2007. seb at esfnet.co.uk
+
+Nxlaunch uses a program called nxcl (distributed separately) to
+negotiate the NX connection. Nxlaunch sends settings via dbus to
+nxcl so that it can then negotiate the correct sort of NX session
+for you. 
+
+nxcl is distributed separately with the nxcl library.
+
+It would be quite possible to write a GTK client which links directly
+to the nxcl library, but that is left as a further exercise for
+someone.

Added: nxlaunch/configure.ac
===================================================================
--- nxlaunch/configure.ac	2007-09-16 20:16:05 UTC (rev 380)
+++ nxlaunch/configure.ac	2007-09-17 12:30:56 UTC (rev 381)
@@ -0,0 +1,86 @@
+dnl Process this file with autoconf to produce a configure script.
+AC_PREREQ(2.59)
+AC_INIT([nxlaunch], [1.0], [seb at esfnet.co.uk])
+AC_CONFIG_SRCDIR(src/main.c)
+AC_REVISION([$Revision: 1.3 $])
+AC_PREFIX_DEFAULT(/usr/local)
+
+AM_INIT_AUTOMAKE([1.9 foreign])
+
+AM_CONFIG_HEADER(config.h)
+AM_MAINTAINER_MODE
+
+dnl Checks for programs.
+AC_PROG_CC
+AC_PROG_INSTALL
+AC_PROG_LIBTOOL
+AC_CHECK_PROG(DOXYGEN, doxygen, doxygen, /bin/echo)
+AC_CHECK_PROG(NXCLD, nxcld, nxcld, /bin/echo)
+
+PKG_CHECK_MODULES(PACKAGE, glib-2.0 gtk+-2.0 libglade-2.0 libxml-2.0 dbus-1)
+
+dnl Checks for library functions.
+AC_HEADER_STDC
+AC_HEADER_TIME
+AC_CHECK_FUNCS(strftime gettimeofday uname)
+
+dnl Determine host system type
+AC_CANONICAL_HOST
+AC_DEFINE_UNQUOTED(HOST, "$host", [The host system nxlaunch was configured for])
+
+dnl pkg_modules="libxml2" <- Check this and modify when necessary
+dnl PKG_CHECK_MODULES(PACKAGE, [$pkg_modules])
+AC_SUBST(PACKAGE_CFLAGS)
+AC_SUBST(PACKAGE_LIBS)
+
+dnl enable/disable compiler warnings (using gcc), if specified
+AC_ARG_ENABLE(warnings,
+  [  --disable-warnings      disable gcc warnings [default=no]],
+  [case "${enableval}" in
+    yes) nxlaunch_warnings=yes ;; 
+    no)  nxlaunch_warnings=no ;;
+    *) AC_MSG_ERROR(bad value ${enableval} for --enable-warnings) ;;
+  esac], nxlaunch_warnings=yes)
+AC_MSG_CHECKING(whether to use gcc verbose warnings)
+AC_MSG_RESULT($nxlaunch_warnings)
+if (test "$nxlaunch_warnings" = yes && test "$GCC" = yes); then
+  CFLAGS="-Wall $CFLAGS"
+fi
+
+dnl enable/disable debug logging, if specified
+AC_ARG_ENABLE(debug-output,
+  [  --enable-debug-output   enable debug output [default=no]],
+  [case "${enableval}" in
+    yes) nxlaunch_debug=yes ;;
+    no)  nxlaunch_debug=no ;;
+    *) AC_MSG_ERROR(bad value ${enableval} for --enable-debug-output) ;;
+  esac], nxlaunch_debug=no)
+AC_MSG_CHECKING(whether to enable debugging output)
+AC_MSG_RESULT($nxlaunch_debug)
+if test "$nxlaunch_debug" = yes; then
+  AC_DEFINE(DEBUG, 1, Define if debugging output should be enabled)
+else
+  AC_DEFINE(DEBUG, 0, Define if debugging output should be enabled)
+fi
+
+dnl enable build of configuration feature, if required
+AC_ARG_ENABLE(build-config,
+  [  --enable-build-config   enable build of configuration features [default=yes]],
+  [case "${enableval}" in
+    yes) nxlaunch_config=yes ;;
+    no)  nxlaunch_config=no ;;
+    *) AC_MSG_ERROR(bad value ${enableval} for --enable-build-config) ;;
+  esac], nxlaunch_config=yes)
+AC_MSG_CHECKING(whether to enable the build of the configuration features in nxlaunch - most users should say yes)
+AC_MSG_RESULT($nxlaunch_config)
+if test "$nxlaunch_config" = yes; then
+  AC_DEFINE(BUILT_IN_CONFIGURATION, 1, Define if this program should have the features to configure connections)
+else
+  AC_DEFINE(BUILT_IN_CONFIGURATION, 0, Define if this program should have the features to configure connections)
+fi
+
+dnl Always output certain files
+
+AC_CONFIG_FILES([Makefile src/Makefile lib/Makefile])
+
+AC_OUTPUT

Added: nxlaunch/lib/Makefile.am
===================================================================
--- nxlaunch/lib/Makefile.am	2007-09-16 20:16:05 UTC (rev 380)
+++ nxlaunch/lib/Makefile.am	2007-09-17 12:30:56 UTC (rev 381)
@@ -0,0 +1,7 @@
+CLEANFILES = *~
+AM_CFLAGS = @PACKAGE_CFLAGS@ -DPACKAGE_DATA_DIR=\""$(datadir)"\" -DLOCALEDIR=\"$(localedir)\"
+lib_LTLIBRARIES = libcallbacks_nx.la
+libcallbacks_nx_la_SOURCES = callbacks_nx.c
+libcallbacks_nx_la_LIBADD = @PACKAGE_LIBS@ $(LIBINTL)
+libcallbacks_nx_la_LDFLAGS = -version-info 1:0:0
+pkginclude_HEADERS = callbacks_nx.h

Added: nxlaunch/lib/callbacks_nx.c
===================================================================
--- nxlaunch/lib/callbacks_nx.c	2007-09-16 20:16:05 UTC (rev 380)
+++ nxlaunch/lib/callbacks_nx.c	2007-09-17 12:30:56 UTC (rev 381)
@@ -0,0 +1,2369 @@
+/***************************************************************************
+                   nxlaunch: A GTK NX Client based on nxcl
+                   ---------------------------------------
+    begin                : September 2007
+    copyright            : (C) 2007 Embedded Software Foundry Ltd. (U.K.)
+                         :     Author: Sebastian James
+    email                : seb at esfnet.co.uk
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "callbacks_nx.h"
+
+#include <unistd.h>
+#include <string.h>
+#include <time.h>
+
+#include <glade/glade.h>
+
+/* Use libxml to write out the configuration file */
+#include <libxml/xmlmemory.h>
+#include <libxml/parser.h>
+
+extern GladeXML * xml_glob;
+
+/* A global variable for locking. */
+gboolean can_update_nx_settings = TRUE;
+
+extern int xmlIndentTreeOutput;
+
+/*!
+ * A useful utility function to set the value of a combobox.
+ */
+gboolean set_combobox (GtkWidget * widget, gchar * match_string)
+{
+	GtkListStore * prog_list;
+	GtkTreeIter iter;
+	GtkTreeIter new_iter;
+	gchar * str_data;
+	gboolean valid;
+	gboolean have_match = FALSE;
+
+	prog_list = GTK_LIST_STORE (gtk_combo_box_get_model (GTK_COMBO_BOX (widget)));
+	valid = gtk_tree_model_get_iter_first (GTK_TREE_MODEL (prog_list), &iter);
+
+	while (valid) {
+		gtk_tree_model_get (GTK_TREE_MODEL (prog_list), &iter, 
+				    PROGRAM, &str_data, -1);
+		if (strstr (match_string, str_data)) {
+			new_iter = iter;
+			have_match = TRUE;
+		}
+		g_free (str_data);
+		valid = gtk_tree_model_iter_next (GTK_TREE_MODEL (prog_list), &iter);
+	}
+
+	/* FIXME: new_iter undefined if no match is found */
+	if (have_match == TRUE) {
+		gtk_combo_box_set_active_iter (GTK_COMBO_BOX (widget), &new_iter);		
+	} else {
+		/* do nothing */
+	}
+
+	return have_match;
+}
+
+/*!
+ * Utility function. Places an error in a glade window which you must
+ * define in the glade file.
+ */
+void nx_general_error (const gchar * msg, const gchar * title)
+{
+	GtkWidget * widget;
+	widget = glade_xml_get_widget (xml_glob, "label_general_error");
+	gtk_label_set_text (GTK_LABEL(widget), msg);
+	widget = glade_xml_get_widget (xml_glob, "dialog_general_error");
+	gtk_window_set_title (GTK_WINDOW(widget), title);
+	gtk_widget_show (widget);
+	return;
+}
+
+/*!
+ * Reads the password from the XML file into xmlChar * password, so
+ * that we can re-write it out into our re-created XML file.
+ *
+ * FIXME:
+ * This is a quick and dirty solution to remembering the password that
+ * the NX Client sets. Ideally, write_nx_connection should read in the
+ * XML tree from file if it exists and then only change/replace those 
+ * nodes that it needs to.
+ */
+gint get_nx_password (gchar * password, gchar * filename)
+{
+	xmlDocPtr doc;
+	xmlNodePtr n1, n2;
+	xmlChar * group_name;
+	xmlChar * option_key;
+
+	printerr ("%s called\n", __FUNCTION__);
+
+	doc = xmlParseFile (filename);
+
+	if (doc == NULL ) {
+		/* document not parsed successfully */
+		printerr ("doc not parsed\n");
+		return NX_XML_NOT_PARSED;
+	}
+
+	n1 = xmlDocGetRootElement (doc);
+
+	if (n1 == NULL) {
+		/* empty document */
+		printerr ("doc is empty\n");
+		xmlFreeDoc (doc);
+		return NX_XML_EMPTY;
+	}
+
+	if (xmlStrcmp (n1->name, BAD_CAST "NXClientSettings")) {
+		/* document of the wrong type, root node != NXClientSettings */
+		printerr ("doc wrong root node\n");
+		xmlFreeDoc (doc);
+		return NX_XML_WRONG_ROOT_NODE;
+	}
+
+	n1 = n1->xmlChildrenNode;
+	printerr ("while no 1\n");
+	while (n1 != NULL) {
+		if ((!xmlStrcmp (n1->name, BAD_CAST "group"))){
+
+			printerr ("group match!\n");
+			group_name = xmlGetProp (n1, BAD_CAST "name");
+			if ((!xmlStrcmp (group_name, BAD_CAST "Login"))) {
+
+				printerr ("Login match!\n");
+				n2 = n1->xmlChildrenNode;
+				printerr ("while no 2\n");
+				while (n2 != NULL) {
+					if ((!xmlStrcmp (n2->name, BAD_CAST "option"))) {
+							
+						option_key = xmlGetProp (n2, BAD_CAST "key");
+						if ((!xmlStrcmp (option_key, BAD_CAST "Auth"))) {
+							printerr ("Auth match!\n");
+							/* This is the password */
+							strncpy (password, 
+								 (gchar *)xmlGetProp (n2, BAD_CAST "value"), 
+								 NX_FIELDLEN-1); /* 254 chars probably enough */
+						}
+						xmlFree (option_key);
+					}
+					n2 = n2->next;
+				}
+			}
+			xmlFree (group_name);
+		}
+		n1 = n1->next;
+	}
+	xmlFreeDoc (doc);
+	printerr ("%s returning\n", __FUNCTION__);
+	return 0;
+}
+
+
+
+/* Add a connection file (theConnectionName.nxs) */
+gint write_nx_connection (struct nx_connection * nx_conn)
+{
+	struct stat * buf;
+	FILE * fp;
+	gchar connection_file[1024];
+	int rtn = 0;
+
+	gboolean new_config_file = TRUE;
+
+	/* for generation of the xml file */
+	xmlDocPtr doc;
+	xmlNodePtr docRoot;
+	xmlNodePtr group;
+	xmlNodePtr optionNode;
+	xmlDtdPtr dtd = NULL; 
+	char str[16];
+	char* homepath;
+	gchar path[1024];
+	gchar * password = NULL;
+
+	printerr ("%s called\n", __FUNCTION__);
+
+	homepath = getenv("HOME");
+	snprintf (path, 1023, "%s/.nx", homepath);
+	mkdir (path, 0770);
+	snprintf (path, 1023, "%s/.nx/config", homepath);
+	mkdir (path, 0770);
+
+	/* 
+	 * Check we have the required general config files
+	 */
+	buf = g_malloc0 (sizeof (struct stat));
+	snprintf (path, 1023, "%s/.nx/config/nxclient.conf", homepath);	
+	stat (path, buf);
+	if (!S_ISREG (buf->st_mode)) {
+		fp = fopen (path, "w");
+		if (fp) {
+			fwrite (nxclient_conf, sizeof (gchar), strlen (nxclient_conf), fp);
+			fclose (fp);
+		} else {
+			/* Calling fn generates popup */
+			/*nx_general_error (_("Couldn't create file ~/.nx/config/nxclient.conf. Please check disk space"), 
+			  _("Can't create file"));*/
+			return -1;
+		}
+	}
+	g_free (buf);
+
+	/*
+	 * Generate the filename which the connection will be written into
+	 */
+	snprintf (connection_file, 1023, "%s/.nx/config/%s.nxs",
+		 homepath, nx_conn->ConnectionName);
+
+
+	/* Read the file in, if it exists, and take the values of Auth, the password, which
+	   may have been written by the nxclient. Then only need to create the tree if 
+	   we had no file to read in. */
+	password = g_malloc0 (NX_FIELDLEN * sizeof (gchar));
+	get_nx_password (password, connection_file);
+	if (strlen (password) <= 0) {
+		strncpy (password, "EMPTY_PASSWORD", NX_FIELDLEN-1);
+	}
+
+	/*
+	 * Create and populate the XML config file....
+	 */
+
+	/* create new xml document with XML version 1.0 */
+
+	/*if (new_config_file == TRUE) {*/
+	doc = xmlNewDoc (BAD_CAST "1.0");
+	docRoot = xmlNewNode (NULL, BAD_CAST "NXClientSettings");
+	xmlDocSetRootElement(doc, docRoot);
+	xmlNewProp (docRoot, BAD_CAST "application", BAD_CAST "nxclient");
+	xmlNewProp (docRoot, BAD_CAST "version", BAD_CAST "1.3"); 
+
+	dtd = xmlCreateIntSubset(doc, BAD_CAST "NXClientSettings", NULL, NULL);
+
+	/*} else { alternative }*/
+
+	/* 
+	 * create the first group, "Advanced" 
+	 */
+	group = xmlNewChild (docRoot, NULL, BAD_CAST "group", NULL);
+	xmlNewProp (group, BAD_CAST "name", BAD_CAST "Advanced");
+
+	/* hardcoded */
+	if (new_config_file == TRUE) {
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Cache size");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "8");
+
+		/* Hardcode a zero cache size on disk for now */
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Cache size on disk");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "0");
+
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Current keyboard");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "true");
+
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Custom keyboard layout");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "us");
+
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Restore cache");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "true");
+
+		/* This options seems never to change (deprecated in nx 1.5 perhaps?) */
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "StreamCompression");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "");
+	}
+	/* configurable */
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Disable ZLIB stream compression");
+	xmlNewProp (optionNode, BAD_CAST "value", 
+		    nx_conn->DisableZLIB ? BAD_CAST "true" : BAD_CAST "false");
+
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Disable TCP no-delay");
+	xmlNewProp (optionNode, BAD_CAST "value",  
+		    nx_conn->DisableNoDelay ? BAD_CAST "true" : BAD_CAST "false");
+
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Enable SSL encryption");
+	xmlNewProp (optionNode, BAD_CAST "value",  
+		    nx_conn->EnableSSLOnly ? BAD_CAST "true" : BAD_CAST "false");
+
+
+	/* 
+	 * create the second group, "Environment" 
+	 */
+	if (new_config_file == TRUE) {
+		group = xmlNewChild (docRoot, NULL, BAD_CAST "group", NULL);
+		xmlNewProp (group, BAD_CAST "name", BAD_CAST "Environment");
+		/* single option for Environment group */
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "CUPSD path");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "/usr/sbin/cupsd");
+	}
+	/* 
+	 * create the third group, "General" 
+	 */
+	group = xmlNewChild (docRoot, NULL, BAD_CAST "group", NULL);
+	xmlNewProp (group, BAD_CAST "name", BAD_CAST "General");
+
+	/* hardcoded options */
+	if (new_config_file == TRUE) {
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "CUPSD path");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "/usr/sbin/cupsd");
+
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Automatic reconnect");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "true");
+
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Backingstore");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "when_requested");
+
+		/* We don't use NX for vnc or rdp sessions so this is hardcoded to "unix" */
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Session");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "unix"); 
+
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Use render");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "true");
+
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "displaySaveOnExit");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "true");
+	}
+
+	/* options which are set via our interface */
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Desktop");
+	xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST nx_conn->Desktop);
+	
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Custom Unix Desktop");
+	xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST nx_conn->CustomUnixDesktop);
+	
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Command line");
+	xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST nx_conn->CommandLine);
+	
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Link speed");
+	xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST nx_conn->LinkSpeed);
+	
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Remember password");
+	xmlNewProp (optionNode, BAD_CAST "value", 
+		    nx_conn->RememberPassword ? BAD_CAST "true" : BAD_CAST "false" );
+	
+	/* We _could_ offer "Available Area" here */
+	sprintf (str, "%dx%d", nx_conn->ResolutionWidth, nx_conn->ResolutionHeight);
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Resolution");
+	xmlNewProp (optionNode, BAD_CAST "value", 
+		    nx_conn->FullScreen ? BAD_CAST "fullscreen" : BAD_CAST str );
+
+	sprintf (str, "%d", nx_conn->ResolutionWidth);
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Resolution width");
+	xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST str); 
+
+	sprintf (str, "%d", nx_conn->ResolutionHeight);
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Resolution height");
+	xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST str); 
+
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Server host");
+	xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST nx_conn->ServerHost); 
+
+	sprintf (str, "%d", nx_conn->ServerPort);
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Server port");
+	xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST str); 
+
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Use default image encoding");
+	xmlNewProp (optionNode, BAD_CAST "value", 
+		    nx_conn->ImageEncoding == 0 ? BAD_CAST "0" : BAD_CAST "1");
+
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Use taint");
+	xmlNewProp (optionNode, BAD_CAST "value", 
+		    nx_conn->UseTaint ? BAD_CAST "true" : BAD_CAST "false" );
+
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Virtual desktop");
+	xmlNewProp (optionNode, BAD_CAST "value", 
+		    nx_conn->VirtualDesktop ? BAD_CAST "true" : BAD_CAST "false" );
+
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "XAgent encoding");
+	xmlNewProp (optionNode, BAD_CAST "value", 
+		    nx_conn->XAgentEncoding ? BAD_CAST "true" : BAD_CAST "false" );
+
+	/* the xdm entries */
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "xdm mode");
+	xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST nx_conn->XdmMode);
+
+	sprintf (str, "%d", nx_conn->XdmPort);
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "xdm list port");
+	xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST str);
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "xdm broadcast port");
+	xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST str);
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "xdm query port");
+	xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST str);
+
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "xdm list host");
+	xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST nx_conn->XdmHost);
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "xdm query host");
+	xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST nx_conn->XdmHost);
+	
+	/* 
+	 * create the fourth group, "Images" 
+	 */
+	group = xmlNewChild (docRoot, NULL, BAD_CAST "group", NULL);
+	xmlNewProp (group, BAD_CAST "name", BAD_CAST "Images");
+
+	/* hardcoded options, most of these probably to do with VNC/RDP connections */
+	if (new_config_file == TRUE) {
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Disable JPEG Compression");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "0");
+	
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Disable all image optimisations");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "false");
+	
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Image Encoding Type");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "0");
+	
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Image JPEG Encoding");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "false");
+	
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "RDP optimization for low-bandwidth link");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "false");
+	
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Reduce colors to");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "");
+	
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "VNC images compression");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "0");
+	
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Windows Image Compression");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "1");
+	}
+
+	/* configurable options */
+
+	/* nx_conn->ImageEncoding: 0:Default
+	                           1:PNG
+	                           2:JPEG
+                                   3:XBM   */
+
+	/* 0:JPEG no custom 
+	   1:JPEG with custom
+	   2:PNG/XBM */
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Image Compression Type");
+	if (nx_conn->ImageEncoding == 1 || nx_conn->ImageEncoding == 3) {
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "2");
+	} else {
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "1");
+	}
+
+	/* The value of the image quality spinbutton */
+	sprintf (str, "%d", nx_conn->JPEGQuality);
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "JPEG Quality");
+	xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST str);
+
+	/* PNG: true, otherwise false */
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Use PNG Compression");
+	xmlNewProp (optionNode, BAD_CAST "value", 
+		    nx_conn->ImageEncoding == 1 ? BAD_CAST "true" : BAD_CAST "false");
+
+	/* 
+	 * create the 5th group, "Login" 
+	 */
+	group = xmlNewChild (docRoot, NULL, BAD_CAST "group", NULL);
+	xmlNewProp (group, BAD_CAST "name", BAD_CAST "Login");
+
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "User");
+	xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST nx_conn->User);
+
+	/* nx_conn->PublicKey should have been set to the default NX one to begin with */
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Public Key");
+	xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST nx_conn->PublicKey);
+
+	/* Don't do anything right now about key="Auth", the saved password */
+	optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+	xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Auth");
+	xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST password);
+
+	/* Now we can free the password memory */
+       g_free (password);
+
+	/* 
+	 * create the 6th group, "Services", all currently hardcoded except for sound
+	 */
+	if (new_config_file == TRUE) {
+		group = xmlNewChild (docRoot, NULL, BAD_CAST "group", NULL);
+		xmlNewProp (group, BAD_CAST "name", BAD_CAST "Services");
+
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Audio");
+		xmlNewProp (optionNode, BAD_CAST "value", 
+			    nx_conn->enableSound ? BAD_CAST "true" : BAD_CAST "false" );
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "IPPPort");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "631");
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "IPPPrinting");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "false");
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Shares");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "false");
+	}
+
+	/* 
+	 * create the 7th group, "Share0" - the on client print queue, which we hardcode
+	 */
+	if (new_config_file == TRUE) {
+		group = xmlNewChild (docRoot, NULL, BAD_CAST "group", NULL);
+		xmlNewProp (group, BAD_CAST "name", BAD_CAST "Share0");
+
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Default");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "true");
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Driver");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "cups printer");
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Password");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "");
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Public");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "false");
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Sharename");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "wm");
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Type");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "cupsprinter");
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Username");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "hc");
+	}
+
+	/* 
+	 * create the 8th group, "share chosen" again hardcoded
+	 */
+	if (new_config_file == TRUE) {
+		group = xmlNewChild (docRoot, NULL, BAD_CAST "group", NULL);
+		xmlNewProp (group, BAD_CAST "name", BAD_CAST "share chosen");
+
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Share number");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "1");
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "Share0");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "Share0");
+		optionNode = xmlNewChild (group, NULL, BAD_CAST "option", NULL);
+		xmlNewProp (optionNode, BAD_CAST "key", BAD_CAST "default printer");
+		xmlNewProp (optionNode, BAD_CAST "value", BAD_CAST "Share0");
+	}
+
+	/* Save with Indentation */
+	xmlIndentTreeOutput = 1;
+
+	rtn = xmlSaveFormatFile (connection_file, doc, 1);
+	/* specifying encoding: rtn = xmlSaveFormatFileEnc (connection_file, doc, "iso8859-1", 1);*/
+
+	xmlFreeDoc (doc);
+
+	if (rtn == -1) {
+		/* Calling function generates popup */
+		/*nx_general_error (_("Error saving NX configuration. Please check disk space"), 
+		  _("Error saving configuration"));*/
+		return -1;
+	}
+
+	printerr ("%s returning\n", __FUNCTION__);
+	/* Clean up and return */
+	return rtn;
+}
+
+/* Delete a connection file */
+gint delete_nx_connection (gchar * name)
+{
+	gchar connection_file[1024];
+	snprintf (connection_file, 1023, "%s/.nx/config/%s.nxs", getenv("HOME"), name);
+	unlink (connection_file);
+	return 0;
+}
+
+/**
+ * Replace a connection config file. You do: 
+ * delete_nx_connection (); 
+ * write_nx_connection ();
+ *
+ */
+gint replace_nx_connection (struct nx_connection * nx_conn, gchar * name)
+{
+	delete_nx_connection (name);	
+	return (write_nx_connection (nx_conn));
+}
+
+/* places contents of the general group in nx_conn */
+void parse_general (xmlDocPtr doc, xmlNodePtr cur, 
+		    struct nx_connection * nx_conn)
+{
+	xmlChar * option_key;
+
+	xmlChar * xdm_mode = NULL;
+	guint xdm_li_port = 177;
+	xmlChar * xdm_li_host = NULL;
+	guint xdm_bc_port = 177;
+	guint xdm_qu_port = 177;
+	xmlChar * xdm_qu_host = NULL;
+
+	cur = cur->xmlChildrenNode;
+
+	while (cur != NULL) {
+		if ((!xmlStrcmp (cur->name, BAD_CAST "option"))) {
+
+			option_key = xmlGetProp (cur, BAD_CAST "key");
+
+			if ((!xmlStrcmp (option_key, BAD_CAST "Server host"))) {
+				strncpy (nx_conn->ServerHost, (gchar *) xmlGetProp (cur, BAD_CAST "value"), NX_FIELDLEN-1);
+			}
+			else if ((!xmlStrcmp (option_key, BAD_CAST "Server port"))) {
+				nx_conn->ServerPort = atoi ((gchar *) xmlGetProp (cur, BAD_CAST "value"));
+			}
+			else if ((!xmlStrcmp (option_key, BAD_CAST "Desktop"))) {
+				strncpy (nx_conn->Desktop, (gchar *) xmlGetProp (cur, BAD_CAST "value"), NX_FIELDLEN-1);
+			}
+			else if ((!xmlStrcmp (option_key, BAD_CAST "Custom Unix Desktop"))) {
+				strncpy (nx_conn->CustomUnixDesktop, (gchar *) xmlGetProp (cur, BAD_CAST "value"), NX_FIELDLEN-1);
+			}
+			else if ((!xmlStrcmp (option_key, BAD_CAST "Command line"))) {
+				strncpy (nx_conn->CommandLine, (gchar *) xmlGetProp (cur, BAD_CAST "value"), NX_FIELDLEN-1);
+			}
+			else if ((!xmlStrcmp (option_key, BAD_CAST "Link speed"))) {
+				strncpy (nx_conn->LinkSpeed, (gchar *) xmlGetProp (cur, BAD_CAST "value"), NX_FIELDLEN-1);
+			}
+			else if ((!xmlStrcmp (option_key, BAD_CAST "Remember password"))) {
+				nx_conn->RememberPassword = 
+					(!xmlStrcmp (xmlGetProp (cur, BAD_CAST "value"), BAD_CAST "true"))
+					? TRUE : FALSE;
+			}
+			/* bit of a pain */
+			else if ((!xmlStrcmp (option_key, BAD_CAST "Resolution"))) {
+				nx_conn->FullScreen = 
+					(!xmlStrcmp (xmlGetProp (cur, BAD_CAST "value"), BAD_CAST "fullscreen"))
+					? TRUE : FALSE;
+			}
+			else if ((!xmlStrcmp (option_key, BAD_CAST "Resolution width"))) {
+				nx_conn->ResolutionWidth = atoi ((gchar *)xmlGetProp (cur, BAD_CAST "value"));
+			}
+			else if ((!xmlStrcmp (option_key, BAD_CAST "Resolution height"))) {
+				nx_conn->ResolutionHeight = atoi ((gchar *)xmlGetProp (cur, BAD_CAST "value"));
+			}
+			else if ((!xmlStrcmp (option_key, BAD_CAST "Use default image encoding"))) {
+				if (!xmlStrcmp (xmlGetProp (cur, BAD_CAST "value"), BAD_CAST "0")) {
+					nx_conn->ImageEncoding = 0; /* default */
+				}
+			}
+			else if ((!xmlStrcmp (option_key, BAD_CAST "Use taint"))) {
+				nx_conn->UseTaint = 
+					(!xmlStrcmp (xmlGetProp (cur, BAD_CAST "value"), BAD_CAST "true"))
+					? TRUE : FALSE;
+			}
+			else if ((!xmlStrcmp (option_key, BAD_CAST "Virtual desktop"))) {
+				nx_conn->VirtualDesktop = 
+					(!xmlStrcmp (xmlGetProp (cur, BAD_CAST "value"), BAD_CAST "true"))
+					? TRUE : FALSE;
+				printerr ("VirtualDesktop is %d\n", nx_conn->VirtualDesktop);
+			}
+			else if ((!xmlStrcmp (option_key, BAD_CAST "XAgent encoding"))) {
+				nx_conn->XAgentEncoding = 
+					(!xmlStrcmp (xmlGetProp (cur, BAD_CAST "value"), BAD_CAST "true"))
+					? TRUE : FALSE;
+			}
+			else if ((!xmlStrcmp (option_key, BAD_CAST "xdm mode"))) {
+				xdm_mode = xmlGetProp (cur, BAD_CAST "value");
+			}
+			else if ((!xmlStrcmp (option_key, BAD_CAST "xdm list port"))) {
+				xdm_li_port = atoi ((gchar *) xmlGetProp (cur, BAD_CAST "value"));
+			}
+			else if ((!xmlStrcmp (option_key, BAD_CAST "xdm broadcast port"))) {
+				xdm_bc_port = atoi ((gchar *) xmlGetProp (cur, BAD_CAST "value"));
+			}
+			else if ((!xmlStrcmp (option_key, BAD_CAST "xdm query port"))) {
+				xdm_qu_port = atoi ((gchar *) xmlGetProp (cur, BAD_CAST "value"));
+			}
+			else if ((!xmlStrcmp (option_key, BAD_CAST "xdm list host"))) {
+				xdm_li_host = xmlGetProp (cur, BAD_CAST "value");
+			}
+			else if ((!xmlStrcmp (option_key, BAD_CAST "xdm query host"))) {
+				xdm_qu_host = xmlGetProp (cur, BAD_CAST "value");
+			}
+
+			xmlFree (option_key);
+		}
+		cur = cur->next;
+	}
+
+	/* Now we need to do a little extra work to set nx_conn->XdmHost and XdmPort */
+	if (xdm_mode != NULL) {
+		
+		strncpy (nx_conn->XdmMode, (gchar *)xdm_mode, NX_FIELDLEN-1);
+
+		if ((!xmlStrcmp (xdm_mode, BAD_CAST "list"))) {
+			if (xdm_li_host != NULL) {
+				strncpy (nx_conn->XdmHost, (gchar *)xdm_li_host, NX_FIELDLEN-1);
+			} else {
+				strncpy (nx_conn->XdmHost, "your.X.host", NX_FIELDLEN-1);
+			}
+			nx_conn->XdmPort = xdm_li_port;
+			
+		} else if ((!xmlStrcmp (xdm_mode, BAD_CAST "query"))) {
+			if (xdm_qu_host != NULL) {
+				strncpy (nx_conn->XdmHost, (gchar *)xdm_qu_host, NX_FIELDLEN-1);
+			} else {
+				strncpy (nx_conn->XdmHost, "your.X.host", NX_FIELDLEN-1);
+			}
+			nx_conn->XdmPort = xdm_qu_port;
+			
+		} else if ((!xmlStrcmp (xdm_mode, BAD_CAST "broadcast"))) {
+			if (xdm_qu_host != NULL) {
+				strncpy (nx_conn->XdmHost, (gchar *)xdm_qu_host, NX_FIELDLEN-1);
+			} else {
+				strncpy (nx_conn->XdmHost, "your.X.host", NX_FIELDLEN-1);
+			}
+			nx_conn->XdmPort = xdm_bc_port;
+
+		} else {
+			/* xdm_mode is "server decide", null or something random  */
+			strncpy (nx_conn->XdmHost, (gchar *)xdm_qu_host, NX_FIELDLEN-1);
+			nx_conn->XdmPort = 177;	
+		}
+
+		if (xdm_qu_host != NULL) {
+			xmlFree (xdm_qu_host);
+		}
+		if (xdm_li_host != NULL) {
+			xmlFree (xdm_li_host);
+		}
+
+		xmlFree (xdm_mode);
+
+	} else {
+		strncpy (nx_conn->XdmHost, "your.X.host", NX_FIELDLEN-1);
+		nx_conn->XdmPort = 177;		
+	}
+
+	return;
+}
+
+/* places contents of the advanced group in nx_conn */
+void parse_advanced (xmlDocPtr doc, xmlNodePtr cur, 
+		     struct nx_connection * nx_conn)
+{
+	xmlChar * option_key;
+
+	cur = cur->xmlChildrenNode;
+
+	while (cur != NULL) {
+		if ((!xmlStrcmp (cur->name, BAD_CAST "option"))) {
+
+			option_key = xmlGetProp (cur, BAD_CAST "key");
+
+			if ((!xmlStrcmp (option_key, BAD_CAST "Disable ZLIB stream compression"))) {
+				nx_conn->DisableZLIB = 
+					(!xmlStrcmp (xmlGetProp (cur, BAD_CAST "value"), BAD_CAST "true"))
+					? TRUE : FALSE;
+			}
+			else if ((!xmlStrcmp (option_key, BAD_CAST "Disable TCP no-delay"))) {
+				nx_conn->DisableNoDelay = 
+					(!xmlStrcmp (xmlGetProp (cur, BAD_CAST "value"), BAD_CAST "true"))
+					? TRUE : FALSE;
+			}
+			else if ((!xmlStrcmp (option_key, BAD_CAST "Enable SSL encryption"))) {
+				nx_conn->EnableSSLOnly = 
+					(!xmlStrcmp (xmlGetProp (cur, BAD_CAST "value"), BAD_CAST "true"))
+					? TRUE : FALSE;
+			}
+
+			xmlFree (option_key);
+		}
+		cur = cur->next;
+	}
+	return;
+}
+
+/* places contents of the general group def im enc in data */
+gint read_default_image_encoding (xmlDocPtr doc, xmlNodePtr cur)
+{
+	xmlChar * option_key;
+	gint rtn = -1;
+	cur = cur->xmlChildrenNode;
+
+	while (cur != NULL) {
+		if ((!xmlStrcmp (cur->name, BAD_CAST "option"))) {
+			
+			option_key = xmlGetProp (cur, BAD_CAST "key");
+							
+			if ((!xmlStrcmp (option_key, BAD_CAST "Use default image encoding"))) {
+				if (!xmlStrcmp (xmlGetProp (cur, BAD_CAST "value"), BAD_CAST "0")) {
+					rtn = 0; /* default */
+				} else if (!xmlStrcmp (xmlGetProp (cur, BAD_CAST "value"), BAD_CAST "1")) { 
+					rtn = 1;
+				} else {
+					rtn = -1;
+				}
+			}
+			xmlFree (option_key);
+			if (rtn != -1) {
+				break;
+			}
+		}
+		cur = cur->next;
+	}
+	return rtn;
+}
+
+/*!
+ * Return value of "Use default image encoding" node 
+ * which is 0 or 1. -1 on failure.
+ */
+gint find_def_im_enc_in_general (xmlDocPtr doc, xmlNodePtr cur)
+{
+	xmlChar * group_name;
+	gint rtn = -1;
+	gboolean rtn_ready = FALSE;
+
+	if (!xmlStrcmp (cur->name, BAD_CAST "NXClientSettings")) {
+
+		cur = cur->xmlChildrenNode;
+		while (cur != NULL) {
+			if ((!xmlStrcmp (cur->name, BAD_CAST "group"))){
+
+				group_name = xmlGetProp (cur, BAD_CAST "name");
+
+				if ((!xmlStrcmp (group_name, BAD_CAST "General"))) {
+					printerr ("\"General\" group found (lookin for def. im. enc.)\n");
+
+					rtn = read_default_image_encoding (doc, cur);
+					rtn_ready = TRUE;
+				}
+				xmlFree (group_name);
+				if (rtn_ready == TRUE) { break; }
+			}
+			cur = cur->next;
+		}
+	} else {
+		printerr ("Got passed the wrong parent node\n");
+	}
+
+	return rtn;
+}
+
+
+#define NOT_YET_SET 99
+/* places contents of the images group in nx_conn */
+void parse_images (xmlDocPtr doc, xmlNodePtr cur, 
+		   struct nx_connection * nx_conn)
+{
+	xmlChar * option_key;
+	guint comp = 5;
+	gboolean png = FALSE;
+	xmlNodePtr parent; /* used to get the "Use default image encoding" setting. */
+	gint default_image_encoding = -1;
+
+	/* At this point, cur is <group name="Images"> */
+	parent = cur->parent;
+
+	default_image_encoding = find_def_im_enc_in_general (doc, parent);
+	printerr ("default_image_encoding = %d\n", default_image_encoding);
+
+	if (default_image_encoding == 0) {
+		/* This means "USE DEFAULT" */
+		nx_conn->ImageEncoding = 0;
+	} else if (default_image_encoding == 1) {
+		/* This means "DON'T USE DEFAULT" */
+		nx_conn->ImageEncoding = NOT_YET_SET; /* used a few lines down */
+	} else {
+		nx_conn->ImageEncoding = NOT_YET_SET;
+	}
+
+	cur = cur->children;
+
+	while (cur != NULL) {
+		if ((!xmlStrcmp (cur->name, BAD_CAST "option"))) {
+
+			option_key = xmlGetProp (cur, BAD_CAST "key");
+
+			if ((!xmlStrcmp (option_key, BAD_CAST "Image Compression Type"))) {				
+				comp = atoi ((gchar *) xmlGetProp (cur, BAD_CAST "value"));
+			}
+			else if ((!xmlStrcmp (option_key, BAD_CAST "JPEG Quality"))) {
+				nx_conn->JPEGQuality = atoi ((gchar *) xmlGetProp (cur, BAD_CAST "value"));
+			}
+			else if ((!xmlStrcmp (option_key, BAD_CAST "Use PNG Compression"))) {
+				png = (!xmlStrcmp (xmlGetProp (cur, BAD_CAST "value"), BAD_CAST "true"))
+					? TRUE : FALSE;	
+			}
+
+			xmlFree (option_key);
+		}
+		cur = cur->next;
+	}
+
+	if (nx_conn->ImageEncoding == NOT_YET_SET) {
+		if (png) {
+			nx_conn->ImageEncoding = 1; /* PNG */
+		} else {
+			if (comp == 2) {
+				nx_conn->ImageEncoding = 3; /* XBM */
+			} else if (comp == 0 || comp == 1) {
+				nx_conn->ImageEncoding = 2; /* JPEG */
+			}
+		}
+	}
+
+	return;
+}
+
+/* places contents of the login group in nx_conn */
+void parse_login (xmlDocPtr doc, xmlNodePtr cur, 
+		  struct nx_connection * nx_conn)
+{
+	xmlChar * option_key;
+	gint i, end;
+
+	cur = cur->xmlChildrenNode;
+
+	while (cur != NULL) {
+		if ((!xmlStrcmp (cur->name, BAD_CAST "option"))) {
+
+			option_key = xmlGetProp (cur, BAD_CAST "key");
+
+			if ((!xmlStrcmp (option_key, BAD_CAST "User"))) {
+				strncpy (nx_conn->User, (gchar *) xmlGetProp (cur, BAD_CAST "value"), NX_FIELDLEN-1);
+			}
+			else if ((!xmlStrcmp (option_key, BAD_CAST "Public Key"))) {
+				strncpy (nx_conn->PublicKey, (gchar *) xmlGetProp (cur, BAD_CAST "value"), SSLKEYLEN-1);
+				/* We need to parse the PublicKey now and replace and spaces with new lines, because
+				   the nxclient program seems to incorrectly save \n characters in the .nxs file which
+				   are read in and converted to whitespace (the space char 0x20) by libxml2. */
+				
+				/* Need to avoid the -----BEGIN DSA PRIVATE KEY----- string and the
+				   -----END DSA PRIVATE KEY----- string, but escape all other characters.
+				*/
+
+				/* Find the end of the key */
+				end = 0;
+				while (nx_conn->PublicKey[end++]) {}
+
+				i = 30; /* 30 means this should start on a '-' character */
+				while (nx_conn->PublicKey[i] && i<(end-29)) {
+
+					/*printerr ("PublicKey[%d] = '%c' or 0x%x\n", 
+					  i, nx_conn->PublicKey[i], nx_conn->PublicKey[i]);*/
+					
+					/* Replace spaces in the actual key with newline characters */
+					if (nx_conn->PublicKey[i] == 0x20) {
+						nx_conn->PublicKey[i] = 0xa;
+					}
+					i++;
+				}
+			}
+
+			xmlFree (option_key);
+		}
+		cur = cur->next;
+	}
+	return;
+}
+
+void parse_services (xmlDocPtr doc, xmlNodePtr cur, 
+		     struct nx_connection * nx_conn)
+{
+	xmlChar * option_key;
+
+	cur = cur->children;
+
+	while (cur != NULL) {
+		if ((!xmlStrcmp (cur->name, BAD_CAST "option"))) {
+
+			option_key = xmlGetProp (cur, BAD_CAST "key");
+
+			if ((!xmlStrcmp (option_key, BAD_CAST "Audio"))) {
+				nx_conn->enableSound =
+					(!xmlStrcmp (xmlGetProp (cur, BAD_CAST "value"), BAD_CAST "true")) ? TRUE : FALSE;
+
+			} else if ((!xmlStrcmp (option_key, BAD_CAST "IPPPort"))) {
+				nx_conn->IPPPort = atoi ((gchar *) xmlGetProp (cur, BAD_CAST "value"));
+
+			} else if ((!xmlStrcmp (option_key, BAD_CAST "IPPPrinting"))) {
+				nx_conn->IPPPrinting =
+					(!xmlStrcmp (xmlGetProp (cur, BAD_CAST "value"), BAD_CAST "true")) ? TRUE : FALSE;
+
+			} else if ((!xmlStrcmp (option_key, BAD_CAST "Shares"))) {
+				nx_conn->Shares =
+					(!xmlStrcmp (xmlGetProp (cur, BAD_CAST "value"), BAD_CAST "true")) ? TRUE : FALSE;
+			}
+
+			xmlFree (option_key);
+		}
+		cur = cur->next;
+	}
+
+	return;
+}
+
+
+/**
+ * Read an entry in theConn.nxs to display in the nx pop up.
+ *
+ * Returns 0 if all ok. Otherwise, an error code as found in callbacks_nx.h
+ */
+gint read_nx_connection (struct nx_connection * nx_conn, const gchar * name)
+{
+	xmlDocPtr doc;
+	xmlNodePtr cur;
+	xmlChar * group_name;
+
+	gchar * doc_name;
+
+	strncpy (nx_conn->ConnectionName, name, NX_FIELDLEN-1);
+
+	doc_name = g_malloc (1024 * sizeof (gchar));
+	snprintf (doc_name, 1023, "%s/.nx/config/%s.nxs", getenv("HOME"), name);
+	doc = xmlParseFile (doc_name);
+	/* Assume it's ok to free up docname here */
+	g_free (doc_name);
+
+	if (doc == NULL ) {
+		/* document not parsed successfully */
+		return NX_XML_NOT_PARSED;
+	}
+
+	cur = xmlDocGetRootElement (doc);
+
+	if (cur == NULL) {
+		/* empty document */
+		xmlFreeDoc (doc);
+		return NX_XML_EMPTY;
+	}
+
+	if (xmlStrcmp (cur->name, BAD_CAST "NXClientSettings")) {
+		/* document of the wrong type, root node != NXClientSettings */
+		xmlFreeDoc (doc);
+		return NX_XML_WRONG_ROOT_NODE;
+	}
+
+	cur = cur->xmlChildrenNode;
+	while (cur != NULL) {
+		if ((!xmlStrcmp (cur->name, BAD_CAST "group"))){
+
+			group_name = xmlGetProp (cur, BAD_CAST "name");
+
+			if ((!xmlStrcmp (group_name, BAD_CAST "General"))) {
+				printerr ("\"General\" group found\n");
+				parse_general (doc, cur, nx_conn);
+
+			} else if ((!xmlStrcmp (group_name, BAD_CAST "Advanced"))) {
+				printerr ("\"Advanced\" group found\n");
+				parse_advanced (doc, cur, nx_conn);
+
+			} else if ((!xmlStrcmp (group_name, BAD_CAST "Images"))) {
+				printerr ("\"Images\" group found\n");
+				parse_images (doc, cur, nx_conn);
+
+			} else if ((!xmlStrcmp (group_name, BAD_CAST "Login"))) {
+				printerr ("\"Login\" group found\n");
+				parse_login (doc, cur, nx_conn);
+
+			} else if ((!xmlStrcmp (group_name, BAD_CAST "Services"))) {
+				printerr ("\"Services\" group found\n");
+				parse_services (doc, cur, nx_conn);
+
+#ifdef EXTRAXMLNEEDED
+			} else if ((!xmlStrcmp (group_name, BAD_CAST "Environment"))) {
+				printerr ("\"Environment\" group found\n");
+				/* don't need (hardcoded): 
+				   parse_environment (doc, cur, nx_conn);*/
+
+			} else if ((!xmlStrcmp (group_name, BAD_CAST "Share0"))) {
+				printerr ("\"Share0\" group found\n");
+				/* don't need:
+				   parse_share0 (doc, cur, nx_conn);*/
+
+			} else if ((!xmlStrcmp (group_name, BAD_CAST "share chosen"))) {
+				printerr ("\"share chosen\" group found\n");
+				/* don't need:
+				   parse_share_chosen (doc, cur, nx_conn);*/
+#endif
+			} else {
+				printerr ("hardcoded/unknown group found\n");
+			}
+
+			xmlFree (group_name);
+
+		}
+		cur = cur->next;
+	}
+
+	/* the Geometry field is not stored in the XML, but we create it, for convenience of other apps */
+	snprintf (nx_conn->Geometry, 32, "%dx%d", nx_conn->ResolutionWidth, nx_conn->ResolutionHeight);
+
+	xmlFreeDoc (doc);
+	printerr ("returning from %s\n", __FUNCTION__);
+	return 0;
+}
+
+
+
+/*
+ * Allocate memory for an nx connection data structure.
+ * Note that if you use gtk tree models, you may prefer to only malloc
+ * the struct nx_connection, as some of the gtk functions will malloc
+ * before they copy a string into you nx_connection structure.
+ */
+struct nx_connection * nx_connection_malloc (void)
+{
+	struct nx_connection * nx_conn;
+
+	/* malloc the structure itself */
+	nx_conn = g_malloc0 (sizeof (struct nx_connection));
+	
+	/* and all the gchars that it has to point to */
+	nx_conn->ConnectionName = g_malloc0 (NX_FIELDLEN * sizeof(gchar));
+	nx_conn->ServerHost = g_malloc0 (NX_FIELDLEN * sizeof(gchar));
+	nx_conn->User = g_malloc0 (NX_FIELDLEN * sizeof(gchar));
+	nx_conn->Pass = g_malloc0 (NX_FIELDLEN * sizeof(gchar));
+	nx_conn->Geometry = g_malloc0 (NX_FIELDLEN * sizeof(gchar));
+	nx_conn->LinkSpeed = g_malloc0 (NX_FIELDLEN * sizeof(gchar));
+	nx_conn->Desktop = g_malloc0 (NX_FIELDLEN * sizeof(gchar));
+	nx_conn->CustomUnixDesktop = g_malloc0 (NX_FIELDLEN * sizeof(gchar));
+	nx_conn->XdmMode = g_malloc0 (NX_FIELDLEN * sizeof(gchar));
+	nx_conn->XdmHost = g_malloc0 (NX_FIELDLEN * sizeof(gchar));
+
+	/* More memory required for SSLKey and the command line */
+	nx_conn->PublicKey = g_malloc0 (SSLKEYLEN * sizeof(gchar));
+	nx_conn->CommandLine = g_malloc0 (CMDLINELEN * sizeof(gchar));
+
+	nx_conn->agentServer = g_malloc0 (NX_FIELDLEN * sizeof(gchar));
+	nx_conn->agentUser = g_malloc0 (NX_FIELDLEN * sizeof(gchar));
+	nx_conn->agentPass = g_malloc0 (NX_FIELDLEN * sizeof(gchar));
+
+	return nx_conn;
+}
+
+/* reset an nx connection data structure to default values */
+void nx_connection_zero (struct nx_connection * nx_conn)
+{
+	strcpy (nx_conn->ConnectionName, "");
+	strcpy (nx_conn->ServerHost, "");
+	strcpy (nx_conn->User, "");
+	strcpy (nx_conn->Pass, "");
+	strcpy (nx_conn->LinkSpeed, "wan");
+	strcpy (nx_conn->Desktop, "kde");
+	strcpy (nx_conn->CustomUnixDesktop, "console");
+	strncpy (nx_conn->PublicKey, NXDefaultKey, SSLKEYLEN-1); /* Set to default */
+	strcpy (nx_conn->CommandLine, "");
+	strcpy (nx_conn->XdmMode, "server decide");
+	strcpy (nx_conn->XdmHost, "");
+	strcpy (nx_conn->agentServer, "");
+	strcpy (nx_conn->agentUser, "");
+	strcpy (nx_conn->agentPass, "");
+
+
+	nx_conn->ServerPort = 22;
+	nx_conn->ResolutionWidth = 800;
+	nx_conn->ResolutionHeight = 600;
+	strcpy (nx_conn->Geometry, "800x600");
+	nx_conn->ImageEncoding = 0;
+	nx_conn->JPEGQuality = 5;
+	nx_conn->XdmPort = 177;
+
+	nx_conn->RememberPassword = FALSE;
+	nx_conn->DisableNoDelay = FALSE;
+	nx_conn->DisableZLIB = FALSE;
+	nx_conn->EnableSSLOnly = TRUE;
+	nx_conn->VirtualDesktop = FALSE;
+	nx_conn->XAgentEncoding = FALSE;
+	nx_conn->UseTaint = FALSE;
+	nx_conn->FullScreen = TRUE;
+	nx_conn->enableSound = FALSE;
+	return;
+}
+
+/* free up memory associated with an nx connection data structure */
+gint nx_connection_free (struct nx_connection * nx_conn)
+{
+	if (nx_conn->ConnectionName)
+		g_free (nx_conn->ConnectionName);
+	if (nx_conn->ServerHost)
+		g_free (nx_conn->ServerHost);
+	if (nx_conn->User)
+		g_free (nx_conn->User);
+	if (nx_conn->Pass)
+		g_free (nx_conn->Pass);
+	if (nx_conn->Geometry)
+		g_free (nx_conn->Geometry);
+	if (nx_conn->LinkSpeed)
+		g_free (nx_conn->LinkSpeed);
+	if (nx_conn->Desktop)
+		g_free (nx_conn->Desktop);
+	if (nx_conn->CustomUnixDesktop)
+		g_free (nx_conn->CustomUnixDesktop);
+	if (nx_conn->PublicKey)
+		g_free (nx_conn->PublicKey);
+	if (nx_conn->CommandLine)
+		g_free (nx_conn->CommandLine);
+	if (nx_conn->XdmMode)
+		g_free (nx_conn->XdmMode);
+	if (nx_conn->XdmHost)
+		g_free (nx_conn->XdmHost);
+	if (nx_conn->agentServer)
+		g_free (nx_conn->agentServer);
+	if (nx_conn->agentUser)
+		g_free (nx_conn->agentUser);
+	if (nx_conn->agentPass)
+		g_free (nx_conn->agentPass);
+
+	if (nx_conn != NULL)
+		g_free (nx_conn);
+	
+	return 0;
+}
+
+
+
+
+void setup_nx_popup (struct nx_connection * nx_conn)
+{
+	GtkWidget * widget;
+	GtkTextBuffer * buffer;
+
+	/* First set the page of the notebook so it always comes up the same way */
+	widget = glade_xml_get_widget (xml_glob, "notebook_nx");
+	gtk_notebook_set_current_page (GTK_NOTEBOOK (widget), 0);
+
+	widget = glade_xml_get_widget (xml_glob, "entry_nx_connection_name");
+	gtk_entry_set_text (GTK_ENTRY (widget), nx_conn->ConnectionName);
+
+	widget = glade_xml_get_widget (xml_glob, "entry_nx_user");
+	gtk_entry_set_text (GTK_ENTRY (widget), nx_conn->User);
+
+	widget = glade_xml_get_widget (xml_glob, "entry_nx_server");
+	gtk_entry_set_text (GTK_ENTRY (widget), nx_conn->ServerHost);
+
+	widget = glade_xml_get_widget (xml_glob, "spinbutton_nx_port");
+	gtk_spin_button_set_value (GTK_SPIN_BUTTON (widget), nx_conn->ServerPort);
+
+	widget = glade_xml_get_widget (xml_glob, "checkbutton_nx_save_password");
+	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON (widget), 
+				     nx_conn->RememberPassword ? TRUE : FALSE);
+
+	widget = glade_xml_get_widget (xml_glob, "checkbutton_nx_disable_no_delay");
+	gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widget), 
+				      nx_conn->DisableNoDelay ? TRUE : FALSE); 
+
+	widget = glade_xml_get_widget (xml_glob, "checkbutton_nx_disable_zlib");
+	gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widget), 
+				      nx_conn->DisableZLIB ? TRUE : FALSE); 
+
+	widget = glade_xml_get_widget (xml_glob, "checkbutton_nx_enable_ssl_for_all");
+	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON (widget), 
+				     nx_conn->EnableSSLOnly ? TRUE : FALSE); 
+
+	widget = glade_xml_get_widget (xml_glob, "hscale_nx_connection_capacity");
+	if (!strncmp (nx_conn->LinkSpeed, "modem", NX_FIELDLEN)) {
+		gtk_range_set_value (GTK_RANGE (widget), 1);
+	} else if (!strncmp (nx_conn->LinkSpeed, "isdn", NX_FIELDLEN)) {
+		gtk_range_set_value (GTK_RANGE (widget), 2);
+	} else if (!strncmp (nx_conn->LinkSpeed, "adsl", NX_FIELDLEN)) {
+		gtk_range_set_value (GTK_RANGE (widget), 3);
+	} else if (!strncmp (nx_conn->LinkSpeed, "wan", NX_FIELDLEN)) {
+		gtk_range_set_value (GTK_RANGE (widget), 4);
+	} else if (!strncmp (nx_conn->LinkSpeed, "lan", NX_FIELDLEN)) {
+		gtk_range_set_value (GTK_RANGE (widget), 5);
+	} else {
+		gtk_range_set_value (GTK_RANGE (widget), 3);
+	}
+
+
+	widget = glade_xml_get_widget (xml_glob, "combobox_nx_desktop_session");
+
+	if (!strncmp (nx_conn->Desktop, "kde", NX_FIELDLEN)) {
+		set_combobox (widget, "KDE");
+
+	} else 	if (!strncmp (nx_conn->Desktop, "gnome", NX_FIELDLEN)) {
+		set_combobox (widget, "GNOME");
+
+	} else 	if (!strncmp (nx_conn->Desktop, "cde", NX_FIELDLEN)) {
+		set_combobox (widget, "CDE");
+
+	} else 	if (!strncmp (nx_conn->Desktop, "xdm", NX_FIELDLEN)) {
+		set_combobox (widget, "XDM");
+
+	} else 	if (!strncmp (nx_conn->Desktop, "console", NX_FIELDLEN)) {
+
+		if (!strncmp (nx_conn->CustomUnixDesktop, "console", NX_FIELDLEN)) {
+
+			set_combobox (widget, _("Console"));
+
+		} else if (!strncmp (nx_conn->CustomUnixDesktop, "default", NX_FIELDLEN)) {
+
+			set_combobox (widget, _("Default X client script on server"));
+
+		} else if (!strncmp (nx_conn->CustomUnixDesktop, "application", NX_FIELDLEN)) {
+
+			set_combobox (widget, _("Custom command"));
+		} else {
+			set_combobox (widget, _("Console"));
+		}
+
+	} else {
+		set_combobox (widget, "KDE");
+	}
+
+	widget = glade_xml_get_widget (xml_glob, "entry_nx_custom_command");
+	gtk_entry_set_text (GTK_ENTRY (widget), nx_conn->CommandLine);
+
+	widget = glade_xml_get_widget (xml_glob, "radiobutton_nx_new_virtual_desktop");
+	gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widget), nx_conn->VirtualDesktop);
+
+	widget = glade_xml_get_widget (xml_glob, "radiobutton_nx_floating_window");
+	gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widget), !nx_conn->VirtualDesktop);
+
+	widget = glade_xml_get_widget (xml_glob, "checkbutton_nx_disable_x_agent");
+	gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widget), !nx_conn->XAgentEncoding);
+
+	widget = glade_xml_get_widget (xml_glob, "checkbutton_nx_disable_x_replies");
+	gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widget), !nx_conn->UseTaint);
+
+	widget = glade_xml_get_widget (xml_glob, "combobox_nx_xdm_mode");
+	if (!strncmp (nx_conn->XdmMode, "server decide", NX_FIELDLEN)) {
+		set_combobox (widget, "Let NX server decide");
+
+	} else if (!strncmp (nx_conn->XdmMode, "query", NX_FIELDLEN)) {
+		set_combobox (widget, "Send an XDM query to a host");
+
+	} else if (!strncmp (nx_conn->XdmMode, "broadcast", NX_FIELDLEN)) {
+		set_combobox (widget, "Broadcast an XDM query");
+
+	} else if (!strncmp (nx_conn->XdmMode, "list", NX_FIELDLEN)) {
+		set_combobox (widget, "Get a list of available X display managers");
+
+	} else {
+		printerr ("deflt, nx_conn->XdmMode = %s\n", nx_conn->XdmMode);
+		set_combobox (widget, "Let NX server decide");
+	}
+
+	widget = glade_xml_get_widget (xml_glob, "entry_nx_xdm_host");
+	gtk_entry_set_text (GTK_ENTRY (widget), nx_conn->XdmHost);
+
+	widget = glade_xml_get_widget (xml_glob, "spinbutton_nx_xdm_port");
+	gtk_spin_button_set_value (GTK_SPIN_BUTTON (widget), nx_conn->XdmPort);
+
+	widget = glade_xml_get_widget (xml_glob, "combobox_nx_window_size");
+	if (nx_conn->FullScreen) {
+		set_combobox (widget, "Full Screen");	
+	} else {
+
+		if (nx_conn->ResolutionWidth == 640 
+		    && nx_conn->ResolutionHeight == 480) {
+			set_combobox (widget, "640 x 480");	
+		} else if (nx_conn->ResolutionWidth == 800
+		    && nx_conn->ResolutionHeight == 600) {
+			set_combobox (widget, "800 x 600");
+		} else if (nx_conn->ResolutionWidth == 1024
+		    && nx_conn->ResolutionHeight == 768) {
+			set_combobox (widget, "1024 x 768");
+		} else if (nx_conn->ResolutionWidth == 1280
+		    && nx_conn->ResolutionHeight == 1024) {
+			set_combobox (widget, "1280 x 1024");
+		} else {
+			set_combobox (widget, "Custom");
+		}
+	}
+
+	widget = glade_xml_get_widget (xml_glob, "spinbutton_nx_width");
+	gtk_spin_button_set_value (GTK_SPIN_BUTTON (widget), nx_conn->ResolutionWidth);
+
+	widget = glade_xml_get_widget (xml_glob, "spinbutton_nx_height");
+	gtk_spin_button_set_value (GTK_SPIN_BUTTON (widget), nx_conn->ResolutionHeight);
+
+	widget = glade_xml_get_widget (xml_glob, "combobox_nx_image_encoding");
+	switch (nx_conn->ImageEncoding) {
+	case 1:
+		set_combobox (widget, "PNG");
+		break;
+	case 2:
+		set_combobox (widget, "JPEG");
+		break;
+	case 3:
+		set_combobox (widget, "X Bitmap");
+		break;
+	default:
+		set_combobox (widget, "Default");
+		break;
+	}
+
+	widget = glade_xml_get_widget (xml_glob, "spinbutton_nx_jpeg_quality");
+	gtk_spin_button_set_value (GTK_SPIN_BUTTON (widget), nx_conn->JPEGQuality);
+
+	/* SSL key */
+	widget = glade_xml_get_widget (xml_glob, "textview_nx_key");
+	buffer = gtk_text_view_get_buffer (GTK_TEXT_VIEW (widget));
+	gtk_text_buffer_set_text (buffer, nx_conn->PublicKey, -1);
+
+	/* Enable sound */
+	widget = glade_xml_get_widget (xml_glob, "checkbutton_nx_enable_sound");
+	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON (widget), 
+				     nx_conn->enableSound ? TRUE : FALSE); 
+	return;
+}
+
+
+/*!
+ * Pass the name of the NX connection then read from suitable config
+ * file into an nx_connection data structure and use this to set the
+ * fields in the pop up window.
+ *
+ */
+void setup_new_nx_popup (const gchar * name)
+{
+	struct nx_connection * nx_conn;
+	nx_conn = nx_connection_malloc ();
+	read_nx_connection (nx_conn, name);
+	setup_nx_popup (nx_conn);
+	nx_connection_free (nx_conn);
+	return;
+}
+
+/*!
+ * This function re-sets the NX popup to have
+ * zero or default values.
+ */
+void zero_new_nx_popup (void)
+{
+	struct nx_connection * nx_conn;
+	nx_conn = nx_connection_malloc ();
+	nx_connection_zero (nx_conn);
+	setup_nx_popup (nx_conn);
+	nx_connection_free (nx_conn);
+	return;
+}
+
+/*!
+ * This function sets up name, server, user and fullscreen with data
+ * taken from the submitted form data in conn_new_nx dialog. This is
+ * not required in nxlaunch, but is used by another program which
+ * links to callbacks_nx.c
+ *
+ * It also sets up the data in nx_conn (which will be written to the
+ * config files) with values taken from the conn_new_nx dialog. This
+ * is the really important action as far as nxlaunch is concerned. You
+ * can just malloc some fields NX_FIELDLEN in size and pass the
+ * pointers to this function in nxlaunch and similar programs.
+ *
+ * \param name Filled with the name for the connection.
+ *
+ * \param server Filled with the server ip or address
+ *
+ * \param uname Filled with the username for the connection
+ *
+ * \param fullscreen Set >0 if the connection is fullscreen
+ *
+ * \param nx_conn Filled with all the details of the connection (name,
+ * server, username and fullscreen are all in here)
+ */
+void read_nx_popup (gchar * name, gchar * server, gchar * uname, int * fullscreen,
+		    struct nx_connection * nx_conn)
+{
+	GtkWidget * widget;
+	GtkTextBuffer * buffer;
+	GtkTextIter start, end;
+	GtkTreeIter iter;
+	GtkListStore * nxList;
+	gchar * str;
+
+	/* Used to get the connection capacity hscale value */
+	gdouble speed;
+	guint speed_as_int;
+
+	str = g_malloc0 (512 * sizeof (gchar));
+
+	/*
+	 * The Network Tab.
+	 */
+
+	widget = glade_xml_get_widget(xml_glob, "entry_nx_connection_name");
+	strncpy (name, gtk_entry_get_text (GTK_ENTRY (widget)), NX_FIELDLEN);
+	strncpy (nx_conn->ConnectionName, 
+		 gtk_entry_get_text (GTK_ENTRY (widget)), NX_FIELDLEN);
+
+
+	widget = glade_xml_get_widget(xml_glob, "entry_nx_server");
+	strncpy (server, gtk_entry_get_text (GTK_ENTRY (widget)), NX_FIELDLEN);
+	strncpy (nx_conn->ServerHost,
+		 gtk_entry_get_text (GTK_ENTRY (widget)), NX_FIELDLEN);
+
+
+	widget = glade_xml_get_widget (xml_glob, "spinbutton_nx_port");
+	nx_conn->ServerPort = gtk_spin_button_get_value_as_int (GTK_SPIN_BUTTON (widget));
+
+	widget = glade_xml_get_widget(xml_glob, "entry_nx_user");
+	strncpy (nx_conn->User, 
+		 gtk_entry_get_text (GTK_ENTRY (widget)), NX_FIELDLEN);
+	strncpy (uname, gtk_entry_get_text (GTK_ENTRY (widget)), NX_FIELDLEN);
+
+	widget = glade_xml_get_widget(xml_glob, "checkbutton_nx_save_password");
+	if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON (widget))) {
+		nx_conn->RememberPassword = TRUE;
+	} else {
+		nx_conn->RememberPassword = FALSE;
+	}
+
+	widget = glade_xml_get_widget(xml_glob, "checkbutton_nx_disable_no_delay");
+	if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON (widget))) {
+		nx_conn->DisableNoDelay = TRUE;
+	} else {
+		nx_conn->DisableNoDelay = FALSE;
+	}
+
+	widget = glade_xml_get_widget(xml_glob, "checkbutton_nx_disable_zlib");
+	if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON (widget))) {
+		nx_conn->DisableZLIB = TRUE;
+	} else {
+		nx_conn->DisableZLIB = FALSE;
+	}
+
+	widget = glade_xml_get_widget(xml_glob, "checkbutton_nx_enable_ssl_for_all");
+	if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON (widget))) {
+		nx_conn->EnableSSLOnly = TRUE;
+	} else {
+		nx_conn->EnableSSLOnly = FALSE;
+	}
+
+	widget = glade_xml_get_widget(xml_glob, "hscale_nx_connection_capacity");
+	speed = gtk_range_get_value (GTK_RANGE (widget));
+	if (speed > 5 || speed < 0) {
+		/* error set to default of adsl (middle of the range) */
+		strncpy (nx_conn->LinkSpeed, "adsl", NX_FIELDLEN);
+	} else {
+		speed_as_int = (guint)speed;
+		switch (speed_as_int) {
+		case 1:
+			strncpy (nx_conn->LinkSpeed, "modem", NX_FIELDLEN);
+			break;
+		case 2:
+			strncpy (nx_conn->LinkSpeed, "isdn", NX_FIELDLEN);
+			break;
+		case 3:
+			strncpy (nx_conn->LinkSpeed, "adsl", NX_FIELDLEN);
+			break;
+		case 4:
+			strncpy (nx_conn->LinkSpeed, "wan", NX_FIELDLEN);
+			break;
+		case 5:
+			strncpy (nx_conn->LinkSpeed, "lan", NX_FIELDLEN);
+			break;
+		default:
+			strncpy (nx_conn->LinkSpeed, "adsl", NX_FIELDLEN);
+			break;
+		}
+	}
+
+
+	/*
+	 * The Desktop Tab 
+	 */
+
+	widget = glade_xml_get_widget (xml_glob, "combobox_nx_desktop_session");
+	nxList = GTK_LIST_STORE (gtk_combo_box_get_model (GTK_COMBO_BOX (widget)));
+	printerr ("Getting active iter for desktop session list..\n");
+	gtk_combo_box_get_active_iter (GTK_COMBO_BOX (widget), &iter);
+	gtk_tree_model_get (GTK_TREE_MODEL (nxList), &iter, PROGRAM, &str, -1);
+
+	if (strstr (str, _("KDE"))) {
+		strncpy (nx_conn->Desktop, "kde", NX_FIELDLEN);
+		strncpy (nx_conn->CustomUnixDesktop, "console", NX_FIELDLEN);
+
+	} else if (strstr (str, _("GNOME"))) {
+		strncpy (nx_conn->Desktop, "gnome", NX_FIELDLEN);
+		strncpy (nx_conn->CustomUnixDesktop, "console", NX_FIELDLEN);
+
+	} else if (strstr (str, _("CDE"))) {
+		strncpy (nx_conn->Desktop, "cde", NX_FIELDLEN);
+		strncpy (nx_conn->CustomUnixDesktop, "console", NX_FIELDLEN);
+
+	} else if (strstr (str, _("XDM"))) {
+		strncpy (nx_conn->Desktop, "xdm", NX_FIELDLEN);
+		strncpy (nx_conn->CustomUnixDesktop, "console", NX_FIELDLEN);
+
+	} else if (strstr (str, _("Console"))) {
+		strncpy (nx_conn->Desktop, "console", NX_FIELDLEN);
+		strncpy (nx_conn->CustomUnixDesktop, "console", NX_FIELDLEN);
+
+	} else if (strstr (str, _("Default X client script on server"))) {
+		strncpy (nx_conn->Desktop, "console", NX_FIELDLEN);
+		strncpy (nx_conn->CustomUnixDesktop, "default", NX_FIELDLEN);
+
+	} else if (strstr (str, _("Custom command"))) {
+		strncpy (nx_conn->Desktop, "console", NX_FIELDLEN);
+		strncpy (nx_conn->CustomUnixDesktop, "application", NX_FIELDLEN);
+
+	} else {
+		strncpy (nx_conn->Desktop, "kde", NX_FIELDLEN);
+		strncpy (nx_conn->CustomUnixDesktop, "console", NX_FIELDLEN);
+	}
+
+	widget = glade_xml_get_widget(xml_glob, "entry_nx_custom_command");
+	strncpy (nx_conn->CommandLine, gtk_entry_get_text (GTK_ENTRY (widget)), CMDLINELEN);
+
+	widget = glade_xml_get_widget(xml_glob, "radiobutton_nx_new_virtual_desktop");
+	if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON (widget))) {
+		nx_conn->VirtualDesktop = TRUE;
+	} else {
+		nx_conn->VirtualDesktop = FALSE;
+	}
+
+	widget = glade_xml_get_widget(xml_glob, "checkbutton_nx_disable_x_agent");
+	if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON (widget))) {
+		nx_conn->XAgentEncoding = FALSE;
+	} else {
+		nx_conn->XAgentEncoding = TRUE;
+	}
+
+	widget = glade_xml_get_widget(xml_glob, "checkbutton_nx_disable_x_replies");
+	if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON (widget))) {
+		nx_conn->UseTaint = FALSE;
+	} else {
+		nx_conn->UseTaint = TRUE;
+	}
+	
+	widget = glade_xml_get_widget (xml_glob, "combobox_nx_xdm_mode");
+	nxList = GTK_LIST_STORE (gtk_combo_box_get_model (GTK_COMBO_BOX (widget)));
+	printerr ("Getting active iter for xdm mode..\n");
+	gtk_combo_box_get_active_iter (GTK_COMBO_BOX (widget), &iter);
+	gtk_tree_model_get (GTK_TREE_MODEL (nxList), &iter, PROGRAM, &str, -1);
+
+	if (strstr (str, _("Let NX server decide"))) {
+		strncpy (nx_conn->XdmMode, "server decide", NX_FIELDLEN);
+
+	} else if (strstr (str, _("Send an XDM query to a host"))) {
+		strncpy (nx_conn->XdmMode, "query", NX_FIELDLEN);
+
+	} else if (strstr (str, _("Broadcast an XDM query"))) {
+		strncpy (nx_conn->XdmMode, "broadcast", NX_FIELDLEN);
+
+	} else if (strstr (str, _("Get a list of available X display managers"))) {
+		strncpy (nx_conn->XdmMode, "list", NX_FIELDLEN);
+
+	} else {
+		strncpy (nx_conn->XdmMode, "server decide", NX_FIELDLEN);
+	}
+
+	widget = glade_xml_get_widget(xml_glob, "entry_nx_xdm_host");
+	strncpy (nx_conn->XdmHost, gtk_entry_get_text (GTK_ENTRY (widget)), NX_FIELDLEN);
+
+	widget = glade_xml_get_widget (xml_glob, "spinbutton_nx_xdm_port");
+	nx_conn->XdmPort = gtk_spin_button_get_value_as_int (GTK_SPIN_BUTTON (widget));
+
+	widget = glade_xml_get_widget (xml_glob, "combobox_nx_window_size");
+	nxList = GTK_LIST_STORE (gtk_combo_box_get_model (GTK_COMBO_BOX (widget)));
+	printerr ("Getting active iter for nx window size..\n");
+	gtk_combo_box_get_active_iter (GTK_COMBO_BOX (widget), &iter);
+	gtk_tree_model_get (GTK_TREE_MODEL (nxList), &iter, PROGRAM, &str, -1);
+
+	if (strstr (str, "640 x 480")) {
+		nx_conn->FullScreen = FALSE;
+		*fullscreen = 0;
+		nx_conn->ResolutionWidth = 640;
+		nx_conn->ResolutionHeight = 480;
+
+	} else if (strstr (str, "800 x 600")) {
+		nx_conn->FullScreen = FALSE;
+		*fullscreen = 0;
+		nx_conn->ResolutionWidth = 800;
+		nx_conn->ResolutionHeight = 600;
+
+	} else if (strstr (str, "1024 x 768")) {
+		nx_conn->FullScreen = FALSE;
+		*fullscreen = 0;
+		nx_conn->ResolutionWidth = 1024;
+		nx_conn->ResolutionHeight = 768;
+
+	} else if (strstr (str, "1280 x 1024")) {
+		nx_conn->FullScreen = FALSE;
+		*fullscreen = 0;
+		nx_conn->ResolutionWidth = 1280;
+		nx_conn->ResolutionHeight = 1024;
+
+	} else if (strstr (str, _("Custom"))) {
+		nx_conn->FullScreen = FALSE;
+		*fullscreen = 0;
+		/* Set from widgets */
+		widget = glade_xml_get_widget (xml_glob, "spinbutton_nx_width");
+		nx_conn->ResolutionWidth = gtk_spin_button_get_value_as_int (GTK_SPIN_BUTTON (widget));
+		widget = glade_xml_get_widget (xml_glob, "spinbutton_nx_height");
+		nx_conn->ResolutionHeight = gtk_spin_button_get_value_as_int (GTK_SPIN_BUTTON (widget));
+
+	} else if (strstr (str, _("Full Screen"))) {
+		nx_conn->FullScreen = TRUE;
+		*fullscreen = 1;
+		nx_conn->ResolutionWidth = 800;
+		nx_conn->ResolutionHeight = 600;
+
+	} else {
+		nx_conn->FullScreen = TRUE;
+		*fullscreen = 1;
+		nx_conn->ResolutionWidth = 800;
+		nx_conn->ResolutionHeight = 600;
+	}
+
+	widget = glade_xml_get_widget (xml_glob, "combobox_nx_image_encoding");
+	nxList = GTK_LIST_STORE (gtk_combo_box_get_model (GTK_COMBO_BOX (widget)));
+	printerr ("Getting active iter for image encoding..\n");
+	gtk_combo_box_get_active_iter (GTK_COMBO_BOX (widget), &iter);
+	gtk_tree_model_get (GTK_TREE_MODEL (nxList), &iter, PROGRAM, &str, -1);
+
+	if (strstr (str, _("Default"))) {
+		nx_conn->ImageEncoding = 0;
+	} else if (strstr (str, _("PNG"))) {
+		nx_conn->ImageEncoding = 1;
+	} else if (strstr (str, _("JPEG"))) {
+		nx_conn->ImageEncoding = 2;
+	} else if (strstr (str, _("X Bitmap"))) {
+		nx_conn->ImageEncoding = 3;
+	} else {
+		nx_conn->ImageEncoding = 0;
+	}
+
+	widget = glade_xml_get_widget (xml_glob, "spinbutton_nx_jpeg_quality");
+	nx_conn->JPEGQuality = gtk_spin_button_get_value_as_int (GTK_SPIN_BUTTON (widget));
+
+	g_free (str);
+
+	/*
+	 * The SSH Public Key
+	 *
+	 * We'll read this from the relevant window, which should default to the 
+	 * standard NX public key.
+	 */
+	widget = glade_xml_get_widget (xml_glob, "textview_nx_key");
+	buffer = gtk_text_view_get_buffer (GTK_TEXT_VIEW (widget));
+	printerr ("gtk_text_buffer_get_start_iter (buffer, &start);\n");
+	gtk_text_buffer_get_start_iter (buffer, &start);
+	printerr ("gtk_text_buffer_get_end_iter (buffer, &end);\n");
+	gtk_text_buffer_get_end_iter (buffer, &end);
+
+	str = NULL;
+	printerr ("gtk_text_buffer_get_text (buffer, &start, &end, FALSE);\n");
+	str = gtk_text_buffer_get_text (buffer, &start, &end, FALSE);
+	if (str != NULL) {
+		strncpy (nx_conn->PublicKey,
+			 str,
+			 SSLKEYLEN-1);
+	} else {
+		strncpy (nx_conn->PublicKey, NXDefaultKey, SSLKEYLEN-1);
+	}
+
+	/* Enable Sound Checkbutton */
+	widget = glade_xml_get_widget(xml_glob, "checkbutton_nx_enable_sound");
+	if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON (widget))) {
+		nx_conn->enableSound = TRUE;
+	} else {
+		nx_conn->enableSound = FALSE;
+	}
+
+	return;
+}
+
+
+/**
+ * check that we have ~/.nx/config and ~/.nx/config/nxclient.conf 
+ * 
+ * This function gets called when hcconnect boots.
+ */
+void nx_check_config (void)
+{
+	struct stat * buf;
+	buf = g_malloc0 (sizeof (struct stat));
+	gchar tmp[1024];
+	char* homepath;
+
+	homepath = getenv("HOME");
+
+	/* Check we have the required config files */
+	snprintf (tmp, 1023, "%s/.nx/config", homepath);
+	stat (tmp, buf);
+	if (!S_ISDIR (buf->st_mode)) {
+		snprintf (tmp, 1023, "mkdir -p %s/.nx/config", homepath);
+		system (tmp);
+		nx_writeout_nxclient_conf ();
+	} else {
+		snprintf (tmp, 1023, "%s/.nx/config/nxclient.conf", homepath);
+		stat (tmp, buf);
+		if (!S_ISREG (buf->st_mode)) {
+			nx_writeout_nxclient_conf ();
+		}
+	}
+
+	g_free (buf);
+
+	return;
+}
+
+
+/**
+ * Just writes out the nxclient.conf file
+ */
+gint nx_writeout_nxclient_conf (void)
+{
+	FILE * fp;
+	char* homepath;
+	gchar path[1024];
+
+	homepath = getenv("HOME");
+	snprintf (path, 1023, "%s/.nx/nxclient.conf", homepath);
+	fp = fopen (path, "w");
+	if (fp) {
+		fwrite (nxclient_conf, sizeof (gchar), strlen (nxclient_conf),  fp); 
+		fclose (fp);
+		return 0;
+	}
+
+	return -1;
+}
+
+
+/*
+ * Next functions are callbacks to handle the correct greying out
+ * of controls, for example, greying out the extra settings, when a
+ * GNOME desktop session is chosen.
+ */
+
+
+void set_custom_settings_sensitivity (void)
+{
+	GtkWidget * widget;
+	GtkTreeIter iter;
+	GtkListStore * nxList;
+	gchar * str;
+	gboolean rtn;
+
+	widget = glade_xml_get_widget (xml_glob, "combobox_nx_desktop_session");
+	nxList = GTK_LIST_STORE (gtk_combo_box_get_model (GTK_COMBO_BOX (widget)));
+	rtn = gtk_combo_box_get_active_iter (GTK_COMBO_BOX (widget), &iter);
+	if (!rtn) {
+		return;
+	}
+	gtk_tree_model_get (GTK_TREE_MODEL (nxList), &iter, PROGRAM, &str, -1);
+
+	if (strstr (str, _("KDE"))) {
+		grey_all_custom_settings ();
+
+	} else if (strstr (str, _("GNOME"))) {
+		grey_all_custom_settings ();
+
+	} else if (strstr (str, _("CDE"))) {
+		grey_all_custom_settings ();
+
+	} else if (strstr (str, _("Console"))) {
+		/* ungrey options, grey command box */
+		ungrey_custom_options ();
+		widget = glade_xml_get_widget (xml_glob, "entry_nx_custom_command");
+		gtk_widget_set_sensitive (widget, FALSE);
+		widget = glade_xml_get_widget (xml_glob, "label_nx_custom_command");
+		gtk_widget_set_sensitive (widget, FALSE);
+
+	} else if (strstr (str, _("Default X client script on server"))) {
+		/* ungrey options, grey command box */
+		ungrey_custom_options ();
+		widget = glade_xml_get_widget (xml_glob, "entry_nx_custom_command");
+		gtk_widget_set_sensitive (widget, FALSE);
+		widget = glade_xml_get_widget (xml_glob, "label_nx_custom_command");
+		gtk_widget_set_sensitive (widget, FALSE);
+
+	} else if (strstr (str, _("Custom command"))) {
+		/* ungrey all custom settings */
+		ungrey_custom_options ();
+		widget = glade_xml_get_widget (xml_glob, "entry_nx_custom_command");
+		gtk_widget_set_sensitive (widget, TRUE);
+		widget = glade_xml_get_widget (xml_glob, "label_nx_custom_command");
+		gtk_widget_set_sensitive (widget, TRUE);
+
+
+	} else {
+		grey_all_custom_settings ();
+	}
+
+	return;
+}
+
+void grey_all_custom_settings (void)
+{
+	GtkWidget * widget;
+
+	widget = glade_xml_get_widget (xml_glob, "radiobutton_nx_floating_window");
+	gtk_widget_set_sensitive (widget, FALSE);
+	widget = glade_xml_get_widget (xml_glob, "radiobutton_nx_new_virtual_desktop");
+	gtk_widget_set_sensitive (widget, FALSE);
+	widget = glade_xml_get_widget (xml_glob, "checkbutton_nx_disable_x_agent");
+	gtk_widget_set_sensitive (widget, FALSE);
+	widget = glade_xml_get_widget (xml_glob, "checkbutton_nx_disable_x_replies");
+	gtk_widget_set_sensitive (widget, FALSE);
+	widget = glade_xml_get_widget (xml_glob, "frame_nx_custom_settings");
+	gtk_widget_set_sensitive (widget, FALSE);
+
+	return;
+}
+
+void ungrey_custom_options (void) 
+{
+	GtkWidget * widget;
+
+	widget = glade_xml_get_widget (xml_glob, "frame_nx_custom_settings");
+	gtk_widget_set_sensitive (widget, TRUE);
+	widget = glade_xml_get_widget (xml_glob, "label_nx_custom_settings");
+	gtk_widget_set_sensitive (widget, TRUE);
+	widget = glade_xml_get_widget (xml_glob, "radiobutton_nx_floating_window");
+	gtk_widget_set_sensitive (widget, TRUE);
+	widget = glade_xml_get_widget (xml_glob, "radiobutton_nx_new_virtual_desktop");
+	gtk_widget_set_sensitive (widget, TRUE);
+
+	if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widget))) {
+		/* desensitise checkbutton_nx_disable_x_agent 
+		   and checkbutton_nx_disable_x_replies */
+		widget = glade_xml_get_widget (xml_glob, "checkbutton_nx_disable_x_agent");
+		gtk_widget_set_sensitive (widget, FALSE);
+		widget = glade_xml_get_widget (xml_glob, "checkbutton_nx_disable_x_replies");
+		gtk_widget_set_sensitive (widget, FALSE);
+	} else {
+		widget = glade_xml_get_widget (xml_glob, "checkbutton_nx_disable_x_agent");
+		gtk_widget_set_sensitive (widget, TRUE);
+		if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widget))) {
+			widget = glade_xml_get_widget (xml_glob, "checkbutton_nx_disable_x_replies");
+			gtk_widget_set_sensitive (widget, TRUE);
+		}
+	}	
+}
+
+void set_xdm_settings (void)
+{
+	GtkWidget * widget;
+	GtkTreeIter iter1;
+	GtkListStore * nxList1;
+	gchar * str1;
+	gboolean rtn = FALSE;
+
+	widget = glade_xml_get_widget (xml_glob, "frame_nx_xdm");
+	gtk_widget_set_sensitive (widget, TRUE);
+	widget = glade_xml_get_widget (xml_glob, "label_nx_xdm");
+	gtk_widget_set_sensitive (widget, TRUE);
+
+	widget = glade_xml_get_widget (xml_glob, "combobox_nx_xdm_mode");
+	gtk_widget_set_sensitive (widget, TRUE);
+	nxList1 = GTK_LIST_STORE (gtk_combo_box_get_model (GTK_COMBO_BOX (widget)));
+	rtn = gtk_combo_box_get_active_iter (GTK_COMBO_BOX (widget), &iter1);
+	if (!rtn) {
+		return;
+	} 
+
+	gtk_tree_model_get (GTK_TREE_MODEL (nxList1), &iter1, PROGRAM, &str1, -1);
+
+	if (strstr (str1, _("Let NX server decide"))) {
+		widget = glade_xml_get_widget (xml_glob, "entry_nx_xdm_host");
+		gtk_widget_set_sensitive (widget, FALSE);
+		widget = glade_xml_get_widget (xml_glob, "spinbutton_nx_xdm_port");
+		gtk_widget_set_sensitive (widget, FALSE);
+		widget = glade_xml_get_widget (xml_glob, "label_nx_xdm_host");
+		gtk_widget_set_sensitive (widget, FALSE);
+		widget = glade_xml_get_widget (xml_glob, "label_nx_xdm_port");
+		gtk_widget_set_sensitive (widget, FALSE);
+
+	} else if (strstr (str1, _("Send an XDM query to a host"))) {
+		widget = glade_xml_get_widget (xml_glob, "entry_nx_xdm_host");
+		gtk_widget_set_sensitive (widget, TRUE);
+		widget = glade_xml_get_widget (xml_glob, "spinbutton_nx_xdm_port");
+		gtk_widget_set_sensitive (widget, TRUE);
+		widget = glade_xml_get_widget (xml_glob, "label_nx_xdm_host");
+		gtk_widget_set_sensitive (widget, TRUE);
+		widget = glade_xml_get_widget (xml_glob, "label_nx_xdm_port");
+		gtk_widget_set_sensitive (widget, TRUE);
+
+	} else if (strstr (str1, _("Broadcast an XDM query"))) {
+		widget = glade_xml_get_widget (xml_glob, "entry_nx_xdm_host");
+		gtk_widget_set_sensitive (widget, FALSE);
+		widget = glade_xml_get_widget (xml_glob, "spinbutton_nx_xdm_port");
+		gtk_widget_set_sensitive (widget, TRUE);
+		widget = glade_xml_get_widget (xml_glob, "label_nx_xdm_host");
+		gtk_widget_set_sensitive (widget, FALSE);
+		widget = glade_xml_get_widget (xml_glob, "label_nx_xdm_port");
+		gtk_widget_set_sensitive (widget, TRUE);
+
+	} else if (strstr (str1, _("Get a list of available X display managers"))) {
+		widget = glade_xml_get_widget (xml_glob, "entry_nx_xdm_host");
+		gtk_widget_set_sensitive (widget, TRUE);
+		widget = glade_xml_get_widget (xml_glob, "spinbutton_nx_xdm_port");
+		gtk_widget_set_sensitive (widget, TRUE);
+		widget = glade_xml_get_widget (xml_glob, "label_nx_xdm_host");
+		gtk_widget_set_sensitive (widget, TRUE);
+		widget = glade_xml_get_widget (xml_glob, "label_nx_xdm_port");
+		gtk_widget_set_sensitive (widget, TRUE);
+
+	} else {
+		widget = glade_xml_get_widget (xml_glob, "entry_nx_xdm_host");
+		gtk_widget_set_sensitive (widget, FALSE);
+		widget = glade_xml_get_widget (xml_glob, "spinbutton_nx_xdm_port");
+		gtk_widget_set_sensitive (widget, FALSE);
+		widget = glade_xml_get_widget (xml_glob, "label_nx_xdm_host");
+		gtk_widget_set_sensitive (widget, FALSE);
+		widget = glade_xml_get_widget (xml_glob, "label_nx_xdm_port");
+		gtk_widget_set_sensitive (widget, FALSE);
+	}
+
+	return;
+}
+
+
+int set_xdm_settings_sensitivity_do_work (void)
+{
+	GtkWidget * widget;
+	GtkTreeIter iter;
+	GtkListStore * nxList;
+	gchar * str;
+	gint rtn = 0;
+	
+	widget = glade_xml_get_widget (xml_glob, "combobox_nx_desktop_session");
+	nxList = GTK_LIST_STORE (gtk_combo_box_get_model (GTK_COMBO_BOX (widget)));
+	gtk_combo_box_get_active_iter (GTK_COMBO_BOX (widget), &iter);
+	gtk_tree_model_get (GTK_TREE_MODEL (nxList), &iter, PROGRAM, &str, -1);
+
+	if (strstr (str, _("KDE"))) {
+		grey_all_xdm_settings ();
+
+	} else if (strstr (str, _("GNOME"))) {
+		grey_all_xdm_settings ();
+
+	} else if (strstr (str, _("CDE"))) {
+		grey_all_xdm_settings ();
+
+	} else if (strstr (str, _("XDM"))) {
+		rtn = 10;
+
+	} else if (strstr (str, _("Console"))) {
+		grey_all_xdm_settings ();
+
+	} else if (strstr (str, _("Default X client script on server"))) {
+		grey_all_xdm_settings ();
+
+	} else if (strstr (str, _("Custom command"))) {
+		grey_all_xdm_settings ();
+	} else {
+		grey_all_xdm_settings ();
+	}
+
+	return rtn;
+}
+
+void set_xdm_settings_sensitivity (void)
+{
+	if (set_xdm_settings_sensitivity_do_work () == 10) {
+		set_xdm_settings ();
+	}
+	return;
+}
+
+
+void grey_all_xdm_settings (void)
+{
+	GtkWidget * widget;
+
+	widget = glade_xml_get_widget (xml_glob, "combobox_nx_xdm_mode");
+	gtk_widget_set_sensitive (widget, FALSE);
+	widget = glade_xml_get_widget (xml_glob, "entry_nx_xdm_host");
+	gtk_widget_set_sensitive (widget, FALSE);
+	widget = glade_xml_get_widget (xml_glob, "spinbutton_nx_xdm_port");
+	gtk_widget_set_sensitive (widget, FALSE);
+	widget = glade_xml_get_widget (xml_glob, "label_nx_xdm_host");
+	gtk_widget_set_sensitive (widget, FALSE);
+	widget = glade_xml_get_widget (xml_glob, "label_nx_xdm_port");
+	gtk_widget_set_sensitive (widget, FALSE);
+	widget = glade_xml_get_widget (xml_glob, "frame_nx_xdm");
+	gtk_widget_set_sensitive (widget, FALSE);
+
+	return;
+}
+
+void on_combobox_nx_desktop_session_changed (GtkComboBox * box)
+{
+	set_xdm_settings_sensitivity ();
+	set_custom_settings_sensitivity ();
+	return;
+}
+
+void on_combobox_nx_xdm_mode_changed (GtkComboBox * box)
+{
+	set_xdm_settings_sensitivity ();
+}
+
+void on_radiobutton_nx_new_virtual_desktop_toggled (GtkToggleButton * button)
+{
+	set_custom_settings_sensitivity ();
+}
+
+void on_checkbutton_nx_disable_x_agent_toggled (GtkToggleButton * button)
+{
+	GtkWidget * widget;
+
+	widget = glade_xml_get_widget(xml_glob, "checkbutton_nx_disable_x_agent");
+	gtk_widget_set_sensitive (widget, TRUE);
+	if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON (widget))) {
+		widget = glade_xml_get_widget(xml_glob, "checkbutton_nx_disable_x_replies");
+		gtk_widget_set_sensitive (widget, TRUE);
+	} else {
+		widget = glade_xml_get_widget(xml_glob, "checkbutton_nx_disable_x_replies");
+		gtk_widget_set_sensitive (widget, FALSE);
+	}
+}
+
+void on_combobox_nx_window_size_changed (GtkComboBox * box)
+{
+	GtkWidget * widget;
+	GtkTreeIter iter;
+	GtkListStore * nxList;
+	gchar * str;
+
+	str = g_malloc0 (512 * sizeof (gchar));
+
+	nxList = GTK_LIST_STORE (gtk_combo_box_get_model (box));
+	gtk_combo_box_get_active_iter (box, &iter);
+	gtk_tree_model_get (GTK_TREE_MODEL (nxList), &iter, PROGRAM, &str, -1);
+
+	if (strstr (str, "640 x 480")) {
+		widget =  glade_xml_get_widget (xml_glob, "spinbutton_nx_width");
+		gtk_widget_set_sensitive (widget, FALSE);
+		gtk_spin_button_set_value (GTK_SPIN_BUTTON (widget), (gdouble)640);
+		widget =  glade_xml_get_widget (xml_glob, "spinbutton_nx_height");
+		gtk_widget_set_sensitive (widget, FALSE);
+		gtk_spin_button_set_value (GTK_SPIN_BUTTON (widget), (gdouble)480);
+
+	} else if (strstr (str, "800 x 600")) {
+		widget =  glade_xml_get_widget (xml_glob, "spinbutton_nx_width");
+		gtk_widget_set_sensitive (widget, FALSE);
+		gtk_spin_button_set_value (GTK_SPIN_BUTTON (widget), (gdouble)800);
+		widget =  glade_xml_get_widget (xml_glob, "spinbutton_nx_height");
+		gtk_widget_set_sensitive (widget, FALSE);
+		gtk_spin_button_set_value (GTK_SPIN_BUTTON (widget), (gdouble)600);
+
+	} else if (strstr (str, "1024 x 768")) {
+		widget =  glade_xml_get_widget (xml_glob, "spinbutton_nx_width");
+		gtk_widget_set_sensitive (widget, FALSE);
+		gtk_spin_button_set_value (GTK_SPIN_BUTTON (widget), (gdouble)1024);
+		widget =  glade_xml_get_widget (xml_glob, "spinbutton_nx_height");
+		gtk_widget_set_sensitive (widget, FALSE);
+		gtk_spin_button_set_value (GTK_SPIN_BUTTON (widget), (gdouble)768);
+
+	} else if (strstr (str, "1280 x 1024")) {
+		widget =  glade_xml_get_widget (xml_glob, "spinbutton_nx_width");
+		gtk_widget_set_sensitive (widget, FALSE);
+		gtk_spin_button_set_value (GTK_SPIN_BUTTON (widget), (gdouble)1280);
+		widget =  glade_xml_get_widget (xml_glob, "spinbutton_nx_height");
+		gtk_widget_set_sensitive (widget, FALSE);
+		gtk_spin_button_set_value (GTK_SPIN_BUTTON (widget), (gdouble)1024);
+
+	} else if (strstr (str, _("Custom"))) {
+		widget =  glade_xml_get_widget (xml_glob, "spinbutton_nx_width");
+		gtk_widget_set_sensitive (widget, TRUE);
+		widget =  glade_xml_get_widget (xml_glob, "spinbutton_nx_height");
+		gtk_widget_set_sensitive (widget, TRUE);
+
+	} else if (strstr (str, _("Full Screen"))) {
+		widget =  glade_xml_get_widget (xml_glob, "spinbutton_nx_width");
+		gtk_widget_set_sensitive (widget, FALSE);
+		widget =  glade_xml_get_widget (xml_glob, "spinbutton_nx_height");
+		gtk_widget_set_sensitive (widget, FALSE);
+
+	} else {
+
+	}
+
+	g_free (str);
+
+	return;
+}
+
+
+void on_combobox_nx_image_encoding_changed (GtkComboBox * box)
+{
+	GtkWidget * widget;
+	GtkTreeIter iter;
+	GtkListStore * nxList;
+	gchar * str;
+
+	str = g_malloc0 (512 * sizeof (gchar));
+
+	nxList = GTK_LIST_STORE (gtk_combo_box_get_model (box));
+	gtk_combo_box_get_active_iter (box, &iter);
+	gtk_tree_model_get (GTK_TREE_MODEL (nxList), &iter, PROGRAM, &str, -1);
+
+	if (strstr (str, "JPEG")) {
+		widget =  glade_xml_get_widget (xml_glob, "spinbutton_nx_jpeg_quality");
+		gtk_widget_set_sensitive (widget, TRUE);
+		widget =  glade_xml_get_widget (xml_glob, "label_nx_jpeg_quality");
+		gtk_widget_set_sensitive (widget, TRUE);
+
+	} else {
+		widget =  glade_xml_get_widget (xml_glob, "spinbutton_nx_jpeg_quality");
+		gtk_widget_set_sensitive (widget, FALSE);
+		widget =  glade_xml_get_widget (xml_glob, "label_nx_jpeg_quality");
+		gtk_widget_set_sensitive (widget, FALSE);
+
+	}
+}
+
+
+void on_hscale_nx_connection_capacity_value_changed (GtkWidget * w)
+{
+	GtkWidget * label;
+	gdouble speed;
+	guint speed_as_int;
+
+	speed = gtk_range_get_value (GTK_RANGE (w));
+	label = glade_xml_get_widget(xml_glob, "label_nx_connection_capacity");
+
+	if (speed > 5 || speed < 0) {
+		/* error set to default of adsl (middle of the range) */
+		gtk_label_set_text (GTK_LABEL (label), _("Connection capacity: ADSL"));
+	} else {
+		speed_as_int = (guint)speed;
+		switch (speed_as_int) {
+		case 1:
+			gtk_label_set_text (GTK_LABEL (label), _("Connection capacity: Modem"));
+			break;
+		case 2:
+			gtk_label_set_text (GTK_LABEL (label), _("Connection capacity: ISDN"));
+			break;
+		case 3:
+			gtk_label_set_text (GTK_LABEL (label), _("Connection capacity: ADSL"));
+			break;
+		case 4:
+			gtk_label_set_text (GTK_LABEL (label), _("Connection capacity: WAN"));
+			break;
+		case 5:
+			gtk_label_set_text (GTK_LABEL (label), _("Connection capacity: LAN"));
+			break;
+		default:
+			gtk_label_set_text (GTK_LABEL (label), _("Connection capacity: ADSL"));
+			break;
+		}
+	}	
+}
+
+void on_button_nx_revert_ssl_key_clicked (GtkButton * button)
+{
+	GtkWidget * widget;
+	GtkTextBuffer * buffer;
+	GtkTextIter start, end;
+
+	widget = glade_xml_get_widget (xml_glob, "textview_nx_key");
+	buffer = gtk_text_view_get_buffer (GTK_TEXT_VIEW (widget));
+
+	/* Delete the text first*/
+	gtk_text_buffer_get_start_iter (buffer, &start);
+	gtk_text_buffer_get_end_iter (buffer, &end);
+	gtk_text_buffer_delete (buffer, &start, &end);
+
+	gtk_text_buffer_set_text (buffer, NXDefaultKey, -1);
+	return;
+}
+
+void on_nx_key_file_chosen (GtkButton * button)
+{
+	GtkWidget * widget, * fdlg;
+	GtkTextBuffer * buffer;
+	GtkTextIter start, end;
+	FILE * fp;
+	gchar * key;
+	size_t count;
+
+	fdlg = glade_xml_get_widget (xml_glob, "filechooserdialog_nx_key");	
+
+	/* open the file, copy contents to window, close filechooserdialog */
+	fp = fopen (gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (fdlg)), "r");
+	if (!fp) {
+		/* Couldn't open the file */
+		nx_general_error ("Couldn't open file", "File Error");
+		return;
+	}
+	
+	key = g_malloc0 (SSLKEYLEN * sizeof (gchar));
+
+	count = fread (key, 1, SSLKEYLEN-1, fp);
+	/* debug */
+	printerr ("read %d chars\n", count);
+
+	if (ferror (fp) != 0) {
+		nx_general_error ("File input/output error", "File Error");	
+		fclose (fp);
+		return;
+	}
+
+	fclose (fp);
+
+	widget = glade_xml_get_widget (xml_glob, "textview_nx_key");
+	buffer = gtk_text_view_get_buffer (GTK_TEXT_VIEW (widget));
+
+	/* set new key */
+	gtk_text_buffer_get_start_iter (buffer, &start);
+	gtk_text_buffer_get_end_iter (buffer, &end);
+	gtk_text_buffer_delete (buffer, &start, &end);
+	gtk_text_buffer_set_text (buffer, key, -1);
+
+	g_free (key);
+
+	gtk_widget_hide (fdlg);
+
+	return;
+}
+
+
+
+

Added: nxlaunch/lib/callbacks_nx.h
===================================================================
--- nxlaunch/lib/callbacks_nx.h	2007-09-16 20:16:05 UTC (rev 380)
+++ nxlaunch/lib/callbacks_nx.h	2007-09-17 12:30:56 UTC (rev 381)
@@ -0,0 +1,275 @@
+/***************************************************************************
+                   nxlaunch: A GTK NX Client based on nxcl
+                   ---------------------------------------
+    begin                : September 2007
+    copyright            : (C) 2007 Embedded Software Foundry Ltd. (U.K.)
+                         :     Author: Sebastian James
+    email                : seb at esfnet.co.uk
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+/*! \file callbacks_nx.h
+ *
+ * Functions to do with the configuration of NoMachine NX connections.
+ * Contains both the callback functions relating to the NX
+ * configuration pop-up and also functions which deal with adding
+ * and removing connections from the NX config files (~/.nx/config/nxclient.conf 
+ * and ~/.nx/config/perConnection.nxs)
+ *
+ */
+
+
+#ifndef __CALLBACKS_NX__
+#define __CALLBACKS_NX__
+#include "../src/i18n.h"
+
+#ifdef DEBUG
+# if DEBUG==0
+# undef DEBUG
+# endif
+#endif
+
+#ifndef PRINTERR_DEFINED
+# define PRINTERR_DEFINED 1
+# ifdef DEBUG
+#  define printerr(args...)	fprintf(stderr, ## args);
+# else
+#  define printerr(args...)
+# endif
+#endif
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <glib.h>
+
+#include <gtk/gtk.h>
+#include <sys/stat.h>
+
+#include <libxml/xmlmemory.h>
+#include <libxml/parser.h>
+
+/*!
+ * struct to hold data on nx connection. The names of
+ * the elements of this structure are the same as the 
+ * names they have in the connection config files
+ *
+ * With NX_FIELDLEN = 255, and the two extra size fields
+ * this structure will take up about 7 kB of memory. 
+ *
+ * contents of [] brackets are the descriptions of the controls
+ * in the GUI.
+ *
+ * This structure is related to NXConfigData in nxcl/nxcl, but not
+ * quite the same. The NXConfigData equivalents are indicated in
+ * comments.
+ */
+struct nx_connection {
+
+	/* The name of the session, this gives the filename of the nx config file */
+	gchar * ConnectionName;         // NXCL:sessionName
+
+	/* Configurable variables in the network page */
+	gchar * ServerHost;             // NXCL:serverHost
+	guint ServerPort;               // NXCL:serverPort
+	gchar * User;                   // NXCL:sessionUser
+	gchar * Pass;                   // NXCL:sessionPass
+	gboolean RememberPassword;      // NXCL:?
+	gboolean DisableNoDelay;        // NXCL:?
+	gboolean DisableZLIB;           // NXCL:?
+	gboolean EnableSSLOnly;         // NXCL:encryption == EnableSSLOnly
+	gchar * LinkSpeed;              // NXCL:linkType
+	gchar * PublicKey; /* Needs more than 255 chars */ // NXCL:key
+
+	/* Configurable variables in the desktop page */
+	gchar * Desktop;                // NXCL:sessionType
+	gchar * CustomUnixDesktop;      // NXCL:in customCommand
+	gchar * CommandLine;            // NXCL:customeCommand and sessionType?
+	gboolean VirtualDesktop; /* if false, then "Floating Window" is true */ // NXCL:
+	gboolean XAgentEncoding;        // NXCL:?
+	gboolean UseTaint;              // NXCL:?
+	gchar * XdmMode;                // NXCL:?
+	gchar * XdmHost;                // NXCL:?agentServer?
+	guint XdmPort;                  // NXCL:?
+	gboolean FullScreen;            // NXCL:fullscreen
+	guint ResolutionWidth;          // NXCL:in string geometry
+	guint ResolutionHeight;         // NXCL:in string geometry
+	gchar * Geometry;               // NXCL:geometry
+	guint ImageEncoding;	/* nx_conn->ImageEncoding: 0:Default
+	                           1:PNG
+	                           2:JPEG
+                                   3:XBM   */ // NXCL:imageCompressionMethod
+	guint JPEGQuality;                    // NXCL:imageCompressionLevel
+
+	/* Services */
+	gboolean enableSound;   /* If true, nxesd will be started */ // NXCL:media
+	guint IPPPort;         // NXCL:?
+	gboolean IPPPrinting;  // NXCL:?cups?
+	gboolean Shares;       // NXCL:?
+	gchar * agentServer;
+	gchar * agentUser;
+	gchar * agentPass;
+};
+/* We allow up to NX_FIELDLEN characters in the strings above, except for SSLKey */
+#define NX_FIELDLEN 255
+#define SSLKEYLEN 4096 /* Guess at large enough value.
+			  Apparently this is about 10 times as big as it needs to be */
+#define CMDLINELEN 1024 /* Allow 1023 char length command lines. */
+
+/* Error return codes used in read_nx_connection and write_nx_connection */
+#define NX_XML_NOT_PARSED -1
+#define NX_XML_EMPTY -2
+#define NX_XML_WRONG_ROOT_NODE -3 /* document of the wrong type, 
+				     root node != NXClientSettings */
+
+/* This enum is used setting up some combo boxes */
+enum { PROGRAM, N_COLS };
+
+/* The text to place in wfclient.ini when there isn't already one existing. */
+static const gchar nxclient_conf[] = 
+"<!DOCTYPE NXClientSettings>\n"
+"<NXClientSettings application=\"nxclient\" version=\"1.3\" >\n"
+"<group name=\"General\" >\n"
+"<option key=\"CUPS Password\" value=\"\" />\n"
+"<option key=\"CUPS Port\" value=\"0\" />\n"
+"<option key=\"Default font\" value=\"Helvetica,10,-1,5,50,0,0,0,0,0\" />\n"
+"<option key=\"Hide Full Screen Info\" value=\"false\" />\n"
+"<option key=\"Last session\" value=\"Nx1\" />\n"
+"<option key=\"Permit Root Login\" value=\"false\" />\n"
+"<option key=\"Personal NX dir\" value=\"/etc/persistent/hc/.nx\" />\n"
+"<option key=\"Remove old sessions\" value=\"true\" />\n"
+"<option key=\"System NX dir\" value=\"/opt/nx\" />\n"
+"</group>\n"
+"</NXClientSettings>\n";
+
+static const gchar NXDefaultKey[] =
+"-----BEGIN DSA PRIVATE KEY-----\n"
+"MIIBuwIBAAKBgQCXv9AzQXjxvXWC1qu3CdEqskX9YomTfyG865gb4D02ZwWuRU/9\n"
+"C3I9/bEWLdaWgJYXIcFJsMCIkmWjjeSZyTmeoypI1iLifTHUxn3b7WNWi8AzKcVF\n"
+"aBsBGiljsop9NiD1mEpA0G+nHHrhvTXz7pUvYrsrXcdMyM6rxqn77nbbnwIVALCi\n"
+"xFdHZADw5KAVZI7r6QatEkqLAoGBAI4L1TQGFkq5xQ/nIIciW8setAAIyrcWdK/z\n"
+"5/ZPeELdq70KDJxoLf81NL/8uIc4PoNyTRJjtT3R4f8Az1TsZWeh2+ReCEJxDWgG\n"
+"fbk2YhRqoQTtXPFsI4qvzBWct42WonWqyyb1bPBHk+JmXFscJu5yFQ+JUVNsENpY\n"
+"+Gkz3HqTAoGANlgcCuA4wrC+3Cic9CFkqiwO/Rn1vk8dvGuEQqFJ6f6LVfPfRTfa\n"
+"QU7TGVLk2CzY4dasrwxJ1f6FsT8DHTNGnxELPKRuLstGrFY/PR7KeafeFZDf+fJ3\n"
+"mbX5nxrld3wi5titTnX+8s4IKv29HJguPvOK/SI7cjzA+SqNfD7qEo8CFDIm1xRf\n"
+"8xAPsSKs6yZ6j1FNklfu\n"
+"-----END DSA PRIVATE KEY-----";
+
+
+/*! Utility functions */
+gboolean set_combobox (GtkWidget * widget, gchar * match_string);
+void nx_general_error (const gchar * msg, const gchar * title);
+
+/* Fn declarations for NX file access */
+gint write_nx_connection (struct nx_connection * nx_conn);
+gint delete_nx_connection (gchar * name);
+gint replace_nx_connection (struct nx_connection * nx_conn, gchar * name);
+
+/*! 
+ * Used in read_nx_connection
+ */
+void parse_general (xmlDocPtr doc, xmlNodePtr cur, 
+		    struct nx_connection * nx_conn);
+
+void parse_advanced (xmlDocPtr doc, xmlNodePtr cur, 
+		     struct nx_connection * nx_conn);
+
+gint read_default_image_encoding (xmlDocPtr doc, xmlNodePtr cur);
+gint find_def_im_enc_in_general (xmlDocPtr doc, xmlNodePtr cur);
+void parse_images (xmlDocPtr doc, xmlNodePtr cur, 
+		   struct nx_connection * nx_conn);
+
+void parse_login (xmlDocPtr doc, xmlNodePtr cur, 
+		  struct nx_connection * nx_conn);
+
+/*!
+ * Read an entry in theConn.nxs, putting details into the nx_connection struct.
+ *
+ * Returns 0 if a match is found and read. -1 on error, -2 for no match.
+ */
+gint read_nx_connection (struct nx_connection * nx_conn, const gchar * name);
+
+
+/* Memory management for nx_connection structures */
+struct nx_connection * nx_connection_malloc (void);
+void nx_connection_zero (struct nx_connection * nx_conn);
+gint nx_connection_free (struct nx_connection * nx_conn);
+
+/*! 
+ * This does the real work for setup_new_nx_popup() and 
+ * zero_new_nx_popup ()
+ */
+void setup_nx_popup (struct nx_connection * nx_conn);
+
+/*!
+ * setup_new_nx_popup () fills in the fields in the NX
+ * connection configuration popup (conn_new_nx in glade)
+ * using the entry in the config file which has the name
+ * conn->name.
+ */
+void setup_new_nx_popup (const gchar * name);
+
+/*!
+ * Resets fields in the NX
+ * connection configuration popup (conn_new_nx in glade)
+ * to zero/defaults.
+ */
+void zero_new_nx_popup (void);
+
+/*!
+ * This function sets up the connection structure with data taken
+ * from the submitted form data in the conn_new_nx dialog.
+ *
+ * It also sets up the data in nx_conn (which will be written to 
+ * the appsrv.ini file) with values taken from the conn_new_nx dialog.
+ */
+void read_nx_popup (gchar * name, gchar * server, gchar * uname, int * fullscreen,
+		    struct nx_connection * nx_conn);
+
+/*!
+ * This checks for the existence of the NX configuration
+ * files (in ~/.nx/config). If not present, it initialises
+ * the files using nx_writeout_nxclient_conf ().
+ */
+void nx_check_config (void);
+gint nx_writeout_nxclient_conf (void);
+
+
+/*!
+ * Callbacks which handle greying/ungreying of fields when the comboboxes
+ * and checkboxes in the NX popup window are manipulated
+ */
+
+/* Desktop Sessions */
+void set_custom_settings_sensitivity (void);
+void grey_all_custom_settings (void);
+void ungrey_custom_options (void);
+
+void set_xdm_settings (void);
+int set_xdm_settings_sensitivity_do_work (void);
+void set_xdm_settings_sensitivity (void);
+void grey_all_xdm_settings (void);
+
+void on_combobox_nx_desktop_session_changed (GtkComboBox * box);
+void on_combobox_nx_xdm_mode_changed (GtkComboBox * box);
+void on_radiobutton_nx_new_virtual_desktop_toggled (GtkToggleButton * button);
+void on_checkbutton_nx_disable_x_agent_toggled (GtkToggleButton * button);
+
+void on_combobox_new_nx_window_size_changed (GtkComboBox * box);
+
+void on_combobox_nx_image_encoding_changed (GtkComboBox * box);
+
+void on_button_nx_revert_ssl_key_clicked (GtkButton * button);
+
+void on_nx_key_file_chosen (GtkButton * button);
+
+#endif

Added: nxlaunch/src/Makefile.am
===================================================================
--- nxlaunch/src/Makefile.am	2007-09-16 20:16:05 UTC (rev 380)
+++ nxlaunch/src/Makefile.am	2007-09-17 12:30:56 UTC (rev 381)
@@ -0,0 +1,9 @@
+# Currently, if prefix is /usr then these files go in /usr/share/ but it would be better to place them in /usr/share/nxlaunch/
+EXTRA_DIST = nxlaunch.gladep nxconfig.gladep kde-nx-session.png gnome-nx-session.png unknown-nx-session.png rdp-nx-session.png vnc-nx-session.png nx-icon.png
+dist_data_DATA = nxlaunch.glade nxconfig.glade
+AM_CFLAGS = @PACKAGE_CFLAGS@ -DPACKAGE_DATA_DIR=\""$(datadir)"\" -DLOCALEDIR=\"$(localedir)\" -DPACKAGE_BIN_DIR=\""$(bindir)"\"
+bin_PROGRAMS = nxlaunch
+nxlaunch_SOURCES =  main.c nxlaunch.c
+nxlaunch_LDADD = @PACKAGE_LIBS@ $(LIBINTL) -L../lib/.libs -lcallbacks_nx
+pkginclude_HEADERS = nxlaunch.h
+nxlaunch_LDFLAGS = -export-dynamic # Required so that glade can autoconnect signals
\ No newline at end of file

Added: nxlaunch/src/i18n.h
===================================================================
--- nxlaunch/src/i18n.h	2007-09-16 20:16:05 UTC (rev 380)
+++ nxlaunch/src/i18n.h	2007-09-17 12:30:56 UTC (rev 381)
@@ -0,0 +1,39 @@
+/***************************************************************************
+                   nxlaunch: A GTK NX Client based on nxcl
+                   ---------------------------------------
+    begin                : September 2007
+    copyright            : (C) 2007 Embedded Software Foundry Ltd. (U.K.)
+                         :     Author: Sebastian James
+    email                : seb at esfnet.co.uk
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef __NXLAUNCH_I18N__
+#  define __NXLAUNCH_I18N__
+#  ifdef HAVE_CONFIG_H
+#    include <config.h>
+#  endif
+#  ifdef ENABLE_NLS
+#    include "../lib/gettext.h"
+#    define _(String) gettext (String)
+#    define gettext_noop(String) String
+#    define N_(String) gettext_noop (String)
+#  else
+#    define _(String) (String)
+#    define N_(String) String
+#    define textdomain(Domain) (Domain)
+#    define gettext(String) (String)
+#    define dgettext(Domain,String) (String)
+#    define dcgettext(Domain,String,Type) (String)
+#    define bindtextdomain(Domain, Directory) (Domain) 
+#    define bind_textdomain_codeset(Domain,Codeset) (Codeset) 
+#  endif /* ENABLE_NLS */
+#endif /* __NXLAUNCH_I18N__ */
+

Added: nxlaunch/src/main.c
===================================================================
--- nxlaunch/src/main.c	2007-09-16 20:16:05 UTC (rev 380)
+++ nxlaunch/src/main.c	2007-09-17 12:30:56 UTC (rev 381)
@@ -0,0 +1,211 @@
+/***************************************************************************
+                   nxlaunch: A GTK NX Client based on nxcl
+                   ---------------------------------------
+    begin                : September 2007
+    copyright            : (C) 2007 Embedded Software Foundry Ltd. (U.K.)
+                         :     Author: Sebastian James
+    email                : seb at esfnet.co.uk
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "i18n.h"
+
+/*! 
+ * config.h is created by the configure script and contains
+ * configure/compile time choices made by the program compiler.
+ */
+#include "../config.h"
+
+#include <glade/glade.h>
+#include <gtk/gtk.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <locale.h>
+
+#include "nxlaunch.h"
+
+/*!
+ * Global Variable Definitions
+ */
+//@{
+
+/* Use globals for the xml tree */
+GladeXML * xml_nxlaunch_glob; /* nxlaunch.glade */
+GladeXML * xml_glob;          /* nxconfig.glade */
+
+/* And globals for the lists of connections/sessions */
+GtkListStore * conn_store;
+GtkTreeIter    conn_iter;
+GtkTreeIter    active_iter_glob;
+guint          next_conn_type;
+GtkListStore * sess_store;
+GtkTreeIter    sess_iter;
+guint          next_sess_type;
+
+/* Use some globals for the dbus interface as these need to be available to our callbacks. */
+gchar * dbusSendInterface;
+gchar * dbusRecvInterface;
+gchar * dbusMatchString;
+int              dbusNum = 0;
+DBusConnection * dbusConn = NULL;
+DBusError        dbusErr;
+
+/* The "mode" in which the program was started: "main", "from name",
+ * "from file", "edit named", "edit file". See nxlaunch.h for
+ * #defines */
+int nxlaunch_mode = 0;
+//@}
+
+/*!
+ * main program entry point
+ */
+gint
+main (gint argc, gchar * argv[])
+{
+	GtkWidget * widget;
+	gchar * our_locale;
+	int n_conn = 0;
+
+	bindtextdomain (PACKAGE, BINDTEXTDOMAIN);
+	bind_textdomain_codeset (PACKAGE, "UTF-8");
+	textdomain (PACKAGE);
+
+	gtk_set_locale ();
+	gtk_init (&argc, &argv);
+
+	our_locale = setlocale (LC_ALL, NULL);
+
+	xml_nxlaunch_glob = glade_xml_new (PACKAGE_DATA_DIR"/nxlaunch.glade", NULL, NULL);
+	if (!xml_nxlaunch_glob) {
+		printerr (_("Failed to load the glade XML file (nxlaunch.glade)\n"));
+		return EXIT_FAILURE;
+	}
+	glade_xml_signal_autoconnect (xml_nxlaunch_glob);
+
+#if BUILT_IN_CONFIGURATION==1
+	xml_glob = glade_xml_new (PACKAGE_DATA_DIR"/nxconfig.glade", NULL, NULL);
+	if (!xml_glob) {
+		printerr (_("Failed to load the glade XML file (nxconfig.glade)\n"));
+		return EXIT_FAILURE;
+	}
+	glade_xml_signal_autoconnect (xml_glob);
+#endif
+
+	dbusNum = obtainDbusConnection();
+
+	/*
+	 * See nxlaunch.h for the enums which relate to these list stores.
+	 */
+	conn_store = gtk_list_store_new (N_CONN_COLUMNS,		 
+					 G_TYPE_STRING,
+					 G_TYPE_STRING,
+					 G_TYPE_UINT,
+					 G_TYPE_STRING,
+					 G_TYPE_STRING,
+					 G_TYPE_BOOLEAN,
+					 G_TYPE_BOOLEAN,
+					 G_TYPE_BOOLEAN,
+					 G_TYPE_BOOLEAN,
+					 G_TYPE_STRING,
+					 G_TYPE_STRING,
+					 G_TYPE_STRING,
+					 G_TYPE_STRING,
+					 G_TYPE_STRING,
+					 G_TYPE_BOOLEAN,
+					 G_TYPE_BOOLEAN,
+					 G_TYPE_BOOLEAN,
+					 G_TYPE_STRING,
+					 G_TYPE_STRING,
+					 G_TYPE_UINT,
+					 G_TYPE_BOOLEAN,
+					 G_TYPE_UINT,
+					 G_TYPE_UINT,
+					 G_TYPE_STRING,
+					 G_TYPE_UINT,
+					 G_TYPE_UINT,
+					 G_TYPE_BOOLEAN,
+					 G_TYPE_UINT,
+					 G_TYPE_BOOLEAN,
+					 G_TYPE_BOOLEAN,
+					 G_TYPE_STRING,
+					 G_TYPE_STRING,
+					 G_TYPE_STRING);
+
+	sess_store = gtk_list_store_new (N_SESS_COLUMNS,
+					 G_TYPE_INT,
+					 G_TYPE_INT,
+					 G_TYPE_STRING,
+					 GDK_TYPE_PIXBUF,
+					 G_TYPE_STRING,
+					 G_TYPE_STRING,
+					 G_TYPE_INT,
+					 G_TYPE_STRING,
+					 G_TYPE_STRING,
+					 G_TYPE_STRING);
+
+	/* Create the columns */
+	nxlaunch_create_nxconnection_list ();
+	nxlaunch_create_nxsession_list ();
+
+	/* fill the models (and hence the lists) from the config file */
+	n_conn = nxconnection_buildlist();
+	printerr (_("Found %d connections in config directory.\n"), n_conn);
+
+	/* initialise active_iter_glob and conn_iter */
+	gtk_tree_model_get_iter_first (GTK_TREE_MODEL (conn_store), &active_iter_glob);
+	gtk_tree_model_get_iter_first (GTK_TREE_MODEL (conn_store), &conn_iter);
+
+	gtk_tree_model_get_iter_first (GTK_TREE_MODEL (sess_store), &sess_iter);
+
+	/*
+	 * The following needs to be more sophisticated, with libpopt
+	 * being used. We'll then set modes from the options. Going to
+	 * have these options: --edit|-e --username|-u --file|-f Could
+	 * also have options to mod the chosen connection, like
+	 * --fullscreen etc.
+	 */
+	gboolean have_named = FALSE;
+	if (argc == 2) {
+		/* If we have an argument, we want to launch a connection based on name */
+		nxlaunch_mode = MODE_NAMED;
+		have_named = launch_named_connection (argv[1]);
+	} else {
+		nxlaunch_mode = MODE_MAIN;
+	}
+
+	/*
+	 * If we have a connection named on the cmd line, we just want
+	 * to show the password dialog - that means we need to avoid
+	 * showing the nxlauncher window, BUT we do need to "realise"
+	 * it, so that the tree model containing the connections is
+	 * accessible.
+	 */
+
+	if (!have_named) {
+		/* Unmask the main window */
+		widget = glade_xml_get_widget (xml_nxlaunch_glob, "nxlauncher");
+		gtk_widget_show_all (widget);
+
+		/*
+		 * FIXME: Now we should highlight the first connection
+		 * in the list.
+		 */
+
+	} else {
+		widget = glade_xml_get_widget (xml_nxlaunch_glob, "treeview_nxconnection");
+		gtk_widget_realize (widget);
+	}
+
+	gtk_main();
+	return EXIT_SUCCESS;
+}

Added: nxlaunch/src/nxconfig.glade
===================================================================
--- nxlaunch/src/nxconfig.glade	2007-09-16 20:16:05 UTC (rev 380)
+++ nxlaunch/src/nxconfig.glade	2007-09-17 12:30:56 UTC (rev 381)
@@ -0,0 +1,1960 @@
+<?xml version="1.0" standalone="no"?> <!--*- mode: xml -*-->
+<!DOCTYPE glade-interface SYSTEM "http://glade.gnome.org/glade-2.0.dtd">
+
+<glade-interface>
+<requires lib="gnome"/>
+
+<widget class="GtkDialog" id="conn_new_nx">
+  <property name="title" translatable="yes">NoMachine NX Connection Details</property>
+  <property name="type">GTK_WINDOW_TOPLEVEL</property>
+  <property name="window_position">GTK_WIN_POS_CENTER_ON_PARENT</property>
+  <property name="modal">True</property>
+  <property name="resizable">True</property>
+  <property name="destroy_with_parent">False</property>
+  <property name="icon">nx-desktop.png</property>
+  <property name="decorated">True</property>
+  <property name="skip_taskbar_hint">False</property>
+  <property name="skip_pager_hint">False</property>
+  <property name="type_hint">GDK_WINDOW_TYPE_HINT_DIALOG</property>
+  <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
+  <property name="has_separator">True</property>
+  <signal name="delete_event" handler="gtk_widget_hide" object="conn_new_nx" last_modification_time="Fri, 14 Oct 2005 14:18:27 GMT"/>
+
+  <child internal-child="vbox">
+    <widget class="GtkVBox" id="vbox40">
+      <property name="visible">True</property>
+      <property name="homogeneous">False</property>
+      <property name="spacing">0</property>
+
+      <child internal-child="action_area">
+	<widget class="GtkHButtonBox" id="hbuttonbox15">
+	  <property name="visible">True</property>
+	  <property name="layout_style">GTK_BUTTONBOX_END</property>
+
+	  <child>
+	    <widget class="GtkButton" id="button21">
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-cancel</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <property name="response_id">-6</property>
+	      <signal name="clicked" handler="gtk_widget_hide" object="conn_new_nx" last_modification_time="Mon, 22 Nov 2004 16:04:57 GMT"/>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkButton" id="button22">
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="has_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-ok</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <property name="response_id">-5</property>
+	      <signal name="clicked" handler="on_conn_new_ok_clicked" last_modification_time="Tue, 15 Mar 2005 12:07:14 GMT"/>
+	      <signal name="clicked" handler="gtk_widget_hide" object="conn_new_nx" last_modification_time="Mon, 17 Sep 2007 12:04:08 GMT"/>
+	    </widget>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">True</property>
+	  <property name="pack_type">GTK_PACK_END</property>
+	</packing>
+      </child>
+
+      <child>
+	<widget class="GtkNotebook" id="notebook_nx">
+	  <property name="visible">True</property>
+	  <property name="can_focus">True</property>
+	  <property name="show_tabs">True</property>
+	  <property name="show_border">True</property>
+	  <property name="tab_pos">GTK_POS_TOP</property>
+	  <property name="scrollable">False</property>
+	  <property name="enable_popup">False</property>
+
+	  <child>
+	    <widget class="GtkVBox" id="vbox52">
+	      <property name="visible">True</property>
+	      <property name="homogeneous">False</property>
+	      <property name="spacing">0</property>
+
+	      <child>
+		<widget class="GtkFrame" id="frame9">
+		  <property name="border_width">5</property>
+		  <property name="visible">True</property>
+		  <property name="label_xalign">0</property>
+		  <property name="label_yalign">0.5</property>
+		  <property name="shadow_type">GTK_SHADOW_OUT</property>
+
+		  <child>
+		    <widget class="GtkAlignment" id="alignment23">
+		      <property name="visible">True</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xscale">1</property>
+		      <property name="yscale">1</property>
+		      <property name="top_padding">2</property>
+		      <property name="bottom_padding">5</property>
+		      <property name="left_padding">12</property>
+		      <property name="right_padding">2</property>
+
+		      <child>
+			<widget class="GtkVBox" id="vbox53">
+			  <property name="visible">True</property>
+			  <property name="homogeneous">False</property>
+			  <property name="spacing">0</property>
+
+			  <child>
+			    <widget class="GtkHBox" id="hbox60">
+			      <property name="visible">True</property>
+			      <property name="homogeneous">False</property>
+			      <property name="spacing">0</property>
+
+			      <child>
+				<widget class="GtkEntry" id="entry_nx_connection_name">
+				  <property name="width_request">160</property>
+				  <property name="visible">True</property>
+				  <property name="tooltip" translatable="yes">Mandatory: Enter a unique name for the connection.</property>
+				  <property name="can_focus">True</property>
+				  <property name="editable">True</property>
+				  <property name="visibility">True</property>
+				  <property name="max_length">254</property>
+				  <property name="text" translatable="yes"></property>
+				  <property name="has_frame">True</property>
+				  <property name="invisible_char">*</property>
+				  <property name="activates_default">False</property>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">False</property>
+				  <property name="fill">False</property>
+				</packing>
+			      </child>
+
+			      <child>
+				<placeholder/>
+			      </child>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="label181">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">&lt;i&gt;Connection Name&lt;/i&gt;</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">True</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		    </widget>
+		    <packing>
+		      <property name="type">label_item</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkFrame" id="frame10">
+		  <property name="border_width">5</property>
+		  <property name="visible">True</property>
+		  <property name="label_xalign">0</property>
+		  <property name="label_yalign">0.5</property>
+		  <property name="shadow_type">GTK_SHADOW_OUT</property>
+
+		  <child>
+		    <widget class="GtkAlignment" id="alignment24">
+		      <property name="visible">True</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xscale">1</property>
+		      <property name="yscale">1</property>
+		      <property name="top_padding">2</property>
+		      <property name="bottom_padding">5</property>
+		      <property name="left_padding">12</property>
+		      <property name="right_padding">2</property>
+
+		      <child>
+			<widget class="GtkVBox" id="vbox54">
+			  <property name="visible">True</property>
+			  <property name="homogeneous">False</property>
+			  <property name="spacing">0</property>
+
+			  <child>
+			    <widget class="GtkTable" id="table15">
+			      <property name="visible">True</property>
+			      <property name="n_rows">2</property>
+			      <property name="n_columns">2</property>
+			      <property name="homogeneous">False</property>
+			      <property name="row_spacing">0</property>
+			      <property name="column_spacing">0</property>
+
+			      <child>
+				<widget class="GtkLabel" id="label182">
+				  <property name="visible">True</property>
+				  <property name="label" translatable="yes">Address: </property>
+				  <property name="use_underline">False</property>
+				  <property name="use_markup">False</property>
+				  <property name="justify">GTK_JUSTIFY_LEFT</property>
+				  <property name="wrap">False</property>
+				  <property name="selectable">False</property>
+				  <property name="xalign">0.5</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xpad">0</property>
+				  <property name="ypad">0</property>
+				</widget>
+				<packing>
+				  <property name="left_attach">0</property>
+				  <property name="right_attach">1</property>
+				  <property name="top_attach">0</property>
+				  <property name="bottom_attach">1</property>
+				  <property name="x_options">fill</property>
+				  <property name="y_options"></property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkHBox" id="hbox61">
+				  <property name="visible">True</property>
+				  <property name="homogeneous">False</property>
+				  <property name="spacing">0</property>
+
+				  <child>
+				    <widget class="GtkEntry" id="entry_nx_server">
+				      <property name="visible">True</property>
+				      <property name="tooltip" translatable="yes">Mandatory. Enter an internet address or IP number.</property>
+				      <property name="can_focus">True</property>
+				      <property name="editable">True</property>
+				      <property name="visibility">True</property>
+				      <property name="max_length">254</property>
+				      <property name="text" translatable="yes"></property>
+				      <property name="has_frame">True</property>
+				      <property name="invisible_char">*</property>
+				      <property name="activates_default">False</property>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">False</property>
+				      <property name="fill">False</property>
+				    </packing>
+				  </child>
+
+				  <child>
+				    <widget class="GtkLabel" id="label183">
+				      <property name="visible">True</property>
+				      <property name="label" translatable="yes">:</property>
+				      <property name="use_underline">False</property>
+				      <property name="use_markup">False</property>
+				      <property name="justify">GTK_JUSTIFY_LEFT</property>
+				      <property name="wrap">False</property>
+				      <property name="selectable">False</property>
+				      <property name="xalign">0.5</property>
+				      <property name="yalign">0.5</property>
+				      <property name="xpad">0</property>
+				      <property name="ypad">0</property>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">False</property>
+				      <property name="fill">False</property>
+				    </packing>
+				  </child>
+
+				  <child>
+				    <widget class="GtkSpinButton" id="spinbutton_nx_port">
+				      <property name="visible">True</property>
+				      <property name="tooltip" translatable="yes">Mandatory. The port to connect to on the NX server.</property>
+				      <property name="can_focus">True</property>
+				      <property name="climb_rate">1</property>
+				      <property name="digits">0</property>
+				      <property name="numeric">False</property>
+				      <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+				      <property name="snap_to_ticks">False</property>
+				      <property name="wrap">False</property>
+				      <property name="adjustment">22 1 32767 1 10 10</property>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">False</property>
+				      <property name="fill">False</property>
+				    </packing>
+				  </child>
+				</widget>
+				<packing>
+				  <property name="left_attach">1</property>
+				  <property name="right_attach">2</property>
+				  <property name="top_attach">0</property>
+				  <property name="bottom_attach">1</property>
+				  <property name="y_options">fill</property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkLabel" id="label184">
+				  <property name="visible">True</property>
+				  <property name="label" translatable="yes">Username: </property>
+				  <property name="use_underline">False</property>
+				  <property name="use_markup">False</property>
+				  <property name="justify">GTK_JUSTIFY_LEFT</property>
+				  <property name="wrap">False</property>
+				  <property name="selectable">False</property>
+				  <property name="xalign">0.5</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xpad">0</property>
+				  <property name="ypad">0</property>
+				</widget>
+				<packing>
+				  <property name="left_attach">0</property>
+				  <property name="right_attach">1</property>
+				  <property name="top_attach">1</property>
+				  <property name="bottom_attach">2</property>
+				  <property name="x_options">fill</property>
+				  <property name="y_options"></property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkHBox" id="hbox62">
+				  <property name="visible">True</property>
+				  <property name="homogeneous">False</property>
+				  <property name="spacing">0</property>
+
+				  <child>
+				    <widget class="GtkEntry" id="entry_nx_user">
+				      <property name="width_request">160</property>
+				      <property name="visible">True</property>
+				      <property name="tooltip" translatable="yes">Mandatory: Enter a user name for the connection.</property>
+				      <property name="can_focus">True</property>
+				      <property name="editable">True</property>
+				      <property name="visibility">True</property>
+				      <property name="max_length">254</property>
+				      <property name="text" translatable="yes"></property>
+				      <property name="has_frame">True</property>
+				      <property name="invisible_char">*</property>
+				      <property name="activates_default">False</property>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">True</property>
+				      <property name="fill">True</property>
+				    </packing>
+				  </child>
+
+				  <child>
+				    <placeholder/>
+				  </child>
+				</widget>
+				<packing>
+				  <property name="left_attach">1</property>
+				  <property name="right_attach">2</property>
+				  <property name="top_attach">1</property>
+				  <property name="bottom_attach">2</property>
+				  <property name="x_options">shrink|fill</property>
+				  <property name="y_options">fill</property>
+				</packing>
+			      </child>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkHBox" id="hbox63">
+			      <property name="visible">True</property>
+			      <property name="homogeneous">False</property>
+			      <property name="spacing">0</property>
+
+			      <child>
+				<widget class="GtkCheckButton" id="checkbutton_nx_save_password">
+				  <property name="visible">True</property>
+				  <property name="tooltip" translatable="yes">Whether your password is saved locally in an encrypted form on the thin client.</property>
+				  <property name="can_focus">True</property>
+				  <property name="label" translatable="yes">Save Password</property>
+				  <property name="use_underline">True</property>
+				  <property name="relief">GTK_RELIEF_NORMAL</property>
+				  <property name="focus_on_click">True</property>
+				  <property name="active">False</property>
+				  <property name="inconsistent">False</property>
+				  <property name="draw_indicator">True</property>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">False</property>
+				  <property name="fill">False</property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkLabel" id="label185">
+				  <property name="visible">True</property>
+				  <property name="label" translatable="yes"> </property>
+				  <property name="use_underline">False</property>
+				  <property name="use_markup">False</property>
+				  <property name="justify">GTK_JUSTIFY_LEFT</property>
+				  <property name="wrap">False</property>
+				  <property name="selectable">False</property>
+				  <property name="xalign">0.5</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xpad">0</property>
+				  <property name="ypad">0</property>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">True</property>
+				  <property name="fill">False</property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkButton" id="button_nx_manage_key">
+				  <property name="visible">True</property>
+				  <property name="tooltip" translatable="yes">Manage the SSL public key which will be used to connect to your NX server.</property>
+				  <property name="can_focus">True</property>
+				  <property name="relief">GTK_RELIEF_NORMAL</property>
+				  <property name="focus_on_click">True</property>
+				  <signal name="clicked" handler="gtk_widget_show" object="manage_nx_key" last_modification_time="Tue, 18 Apr 2006 14:58:06 GMT"/>
+
+				  <child>
+				    <widget class="GtkAlignment" id="alignment25">
+				      <property name="visible">True</property>
+				      <property name="xalign">0.5</property>
+				      <property name="yalign">0.5</property>
+				      <property name="xscale">0</property>
+				      <property name="yscale">0</property>
+				      <property name="top_padding">0</property>
+				      <property name="bottom_padding">0</property>
+				      <property name="left_padding">0</property>
+				      <property name="right_padding">0</property>
+
+				      <child>
+					<widget class="GtkHBox" id="hbox64">
+					  <property name="visible">True</property>
+					  <property name="homogeneous">False</property>
+					  <property name="spacing">2</property>
+
+					  <child>
+					    <widget class="GtkImage" id="image19">
+					      <property name="visible">True</property>
+					      <property name="stock">gtk-network</property>
+					      <property name="icon_size">4</property>
+					      <property name="xalign">0.5</property>
+					      <property name="yalign">0.5</property>
+					      <property name="xpad">0</property>
+					      <property name="ypad">0</property>
+					    </widget>
+					    <packing>
+					      <property name="padding">0</property>
+					      <property name="expand">False</property>
+					      <property name="fill">False</property>
+					    </packing>
+					  </child>
+
+					  <child>
+					    <widget class="GtkLabel" id="label186">
+					      <property name="visible">True</property>
+					      <property name="label" translatable="yes">Manage Key</property>
+					      <property name="use_underline">True</property>
+					      <property name="use_markup">False</property>
+					      <property name="justify">GTK_JUSTIFY_LEFT</property>
+					      <property name="wrap">False</property>
+					      <property name="selectable">False</property>
+					      <property name="xalign">0.5</property>
+					      <property name="yalign">0.5</property>
+					      <property name="xpad">0</property>
+					      <property name="ypad">0</property>
+					    </widget>
+					    <packing>
+					      <property name="padding">0</property>
+					      <property name="expand">False</property>
+					      <property name="fill">False</property>
+					    </packing>
+					  </child>
+					</widget>
+				      </child>
+				    </widget>
+				  </child>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">False</property>
+				  <property name="fill">False</property>
+				</packing>
+			      </child>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="label187">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">&lt;i&gt;Connection Details&lt;/i&gt;</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">True</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		    </widget>
+		    <packing>
+		      <property name="type">label_item</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkFrame" id="frame11">
+		  <property name="border_width">5</property>
+		  <property name="visible">True</property>
+		  <property name="label_xalign">0</property>
+		  <property name="label_yalign">0.5</property>
+		  <property name="shadow_type">GTK_SHADOW_OUT</property>
+
+		  <child>
+		    <widget class="GtkAlignment" id="alignment26">
+		      <property name="visible">True</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xscale">1</property>
+		      <property name="yscale">1</property>
+		      <property name="top_padding">2</property>
+		      <property name="bottom_padding">5</property>
+		      <property name="left_padding">12</property>
+		      <property name="right_padding">2</property>
+
+		      <child>
+			<widget class="GtkVBox" id="vbox55">
+			  <property name="visible">True</property>
+			  <property name="homogeneous">False</property>
+			  <property name="spacing">0</property>
+
+			  <child>
+			    <widget class="GtkCheckButton" id="checkbutton_nx_disable_no_delay">
+			      <property name="visible">True</property>
+			      <property name="tooltip" translatable="yes">Disable TCP no-delay for the connection.</property>
+			      <property name="can_focus">True</property>
+			      <property name="label" translatable="yes">Disable No-delay</property>
+			      <property name="use_underline">True</property>
+			      <property name="relief">GTK_RELIEF_NORMAL</property>
+			      <property name="focus_on_click">True</property>
+			      <property name="active">False</property>
+			      <property name="inconsistent">False</property>
+			      <property name="draw_indicator">True</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkCheckButton" id="checkbutton_nx_disable_zlib">
+			      <property name="visible">True</property>
+			      <property name="tooltip" translatable="yes">Disable compression of the data stream (use less cpu on high capacity networks).</property>
+			      <property name="can_focus">True</property>
+			      <property name="label" translatable="yes">Disable ZLIB stream compression</property>
+			      <property name="use_underline">True</property>
+			      <property name="relief">GTK_RELIEF_NORMAL</property>
+			      <property name="focus_on_click">True</property>
+			      <property name="active">False</property>
+			      <property name="inconsistent">False</property>
+			      <property name="draw_indicator">True</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkCheckButton" id="checkbutton_nx_enable_ssl_for_all">
+			      <property name="visible">True</property>
+			      <property name="tooltip" translatable="yes">Pass all data through a SSL tunnel (more secure).</property>
+			      <property name="can_focus">True</property>
+			      <property name="label" translatable="yes">Enable SSL encryption of all traffic</property>
+			      <property name="use_underline">True</property>
+			      <property name="relief">GTK_RELIEF_NORMAL</property>
+			      <property name="focus_on_click">True</property>
+			      <property name="active">True</property>
+			      <property name="inconsistent">False</property>
+			      <property name="draw_indicator">True</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkHScale" id="hscale_nx_connection_capacity">
+			      <property name="visible">True</property>
+			      <property name="can_focus">True</property>
+			      <property name="draw_value">True</property>
+			      <property name="value_pos">GTK_POS_TOP</property>
+			      <property name="digits">0</property>
+			      <property name="update_policy">GTK_UPDATE_CONTINUOUS</property>
+			      <property name="inverted">False</property>
+			      <property name="adjustment">3 1 5 1 0 0</property>
+			      <signal name="value_changed" handler="on_hscale_nx_connection_capacity_value_changed" last_modification_time="Tue, 18 Apr 2006 13:51:14 GMT"/>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkLabel" id="label_nx_connection_capacity">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">Connection capacity: ADSL</property>
+			      <property name="use_underline">False</property>
+			      <property name="use_markup">False</property>
+			      <property name="justify">GTK_JUSTIFY_LEFT</property>
+			      <property name="wrap">False</property>
+			      <property name="selectable">False</property>
+			      <property name="xalign">0.5</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="label189">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">&lt;i&gt;Network options&lt;/i&gt;</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">True</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		    </widget>
+		    <packing>
+		      <property name="type">label_item</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="tab_expand">False</property>
+	      <property name="tab_fill">True</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="label190">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Network</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	    </widget>
+	    <packing>
+	      <property name="type">tab</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkVBox" id="vbox56">
+	      <property name="visible">True</property>
+	      <property name="homogeneous">False</property>
+	      <property name="spacing">0</property>
+
+	      <child>
+		<widget class="GtkFrame" id="frame12">
+		  <property name="border_width">5</property>
+		  <property name="visible">True</property>
+		  <property name="label_xalign">0</property>
+		  <property name="label_yalign">0.5</property>
+		  <property name="shadow_type">GTK_SHADOW_OUT</property>
+
+		  <child>
+		    <widget class="GtkAlignment" id="alignment27">
+		      <property name="visible">True</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xscale">1</property>
+		      <property name="yscale">1</property>
+		      <property name="top_padding">2</property>
+		      <property name="bottom_padding">5</property>
+		      <property name="left_padding">12</property>
+		      <property name="right_padding">2</property>
+
+		      <child>
+			<widget class="GtkVBox" id="vbox57">
+			  <property name="visible">True</property>
+			  <property name="homogeneous">False</property>
+			  <property name="spacing">0</property>
+
+			  <child>
+			    <widget class="GtkComboBox" id="combobox_nx_desktop_session">
+			      <property name="visible">True</property>
+			      <property name="items" translatable="yes">KDE
+GNOME
+CDE
+XDM
+Console
+Default X client script on server
+Custom command</property>
+			      <signal name="changed" handler="on_combobox_nx_desktop_session_changed" last_modification_time="Thu, 13 Apr 2006 12:26:55 GMT"/>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">True</property>
+			      <property name="fill">True</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkFrame" id="frame_nx_custom_settings">
+			      <property name="border_width">5</property>
+			      <property name="visible">True</property>
+			      <property name="label_xalign">0</property>
+			      <property name="label_yalign">0.5</property>
+			      <property name="shadow_type">GTK_SHADOW_OUT</property>
+
+			      <child>
+				<widget class="GtkAlignment" id="alignment28">
+				  <property name="visible">True</property>
+				  <property name="xalign">0.5</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xscale">1</property>
+				  <property name="yscale">1</property>
+				  <property name="top_padding">2</property>
+				  <property name="bottom_padding">5</property>
+				  <property name="left_padding">12</property>
+				  <property name="right_padding">2</property>
+
+				  <child>
+				    <widget class="GtkVBox" id="vbox58">
+				      <property name="visible">True</property>
+				      <property name="homogeneous">False</property>
+				      <property name="spacing">0</property>
+
+				      <child>
+					<widget class="GtkHBox" id="hbox65">
+					  <property name="visible">True</property>
+					  <property name="homogeneous">False</property>
+					  <property name="spacing">0</property>
+
+					  <child>
+					    <widget class="GtkLabel" id="label_nx_custom_command">
+					      <property name="visible">True</property>
+					      <property name="label" translatable="yes">Command to run: </property>
+					      <property name="use_underline">False</property>
+					      <property name="use_markup">False</property>
+					      <property name="justify">GTK_JUSTIFY_LEFT</property>
+					      <property name="wrap">False</property>
+					      <property name="selectable">False</property>
+					      <property name="xalign">0.5</property>
+					      <property name="yalign">0.5</property>
+					      <property name="xpad">0</property>
+					      <property name="ypad">0</property>
+					    </widget>
+					    <packing>
+					      <property name="padding">0</property>
+					      <property name="expand">False</property>
+					      <property name="fill">False</property>
+					    </packing>
+					  </child>
+
+					  <child>
+					    <widget class="GtkEntry" id="entry_nx_custom_command">
+					      <property name="visible">True</property>
+					      <property name="tooltip" translatable="yes">Command to run on the NX server. 1023 characters max.</property>
+					      <property name="can_focus">True</property>
+					      <property name="editable">True</property>
+					      <property name="visibility">True</property>
+					      <property name="max_length">1023</property>
+					      <property name="text" translatable="yes"></property>
+					      <property name="has_frame">True</property>
+					      <property name="invisible_char">*</property>
+					      <property name="activates_default">False</property>
+					    </widget>
+					    <packing>
+					      <property name="padding">0</property>
+					      <property name="expand">True</property>
+					      <property name="fill">True</property>
+					    </packing>
+					  </child>
+					</widget>
+					<packing>
+					  <property name="padding">0</property>
+					  <property name="expand">False</property>
+					  <property name="fill">False</property>
+					</packing>
+				      </child>
+
+				      <child>
+					<widget class="GtkRadioButton" id="radiobutton_nx_new_virtual_desktop">
+					  <property name="visible">True</property>
+					  <property name="sensitive">False</property>
+					  <property name="can_focus">True</property>
+					  <property name="label" translatable="yes">New virtual desktop</property>
+					  <property name="use_underline">True</property>
+					  <property name="relief">GTK_RELIEF_NORMAL</property>
+					  <property name="focus_on_click">True</property>
+					  <property name="active">False</property>
+					  <property name="inconsistent">False</property>
+					  <property name="draw_indicator">True</property>
+					  <signal name="toggled" handler="on_radiobutton_nx_new_virtual_desktop_toggled" last_modification_time="Thu, 13 Apr 2006 12:38:51 GMT"/>
+					</widget>
+					<packing>
+					  <property name="padding">0</property>
+					  <property name="expand">False</property>
+					  <property name="fill">False</property>
+					</packing>
+				      </child>
+
+				      <child>
+					<widget class="GtkVBox" id="vbox59">
+					  <property name="visible">True</property>
+					  <property name="homogeneous">False</property>
+					  <property name="spacing">0</property>
+
+					  <child>
+					    <widget class="GtkRadioButton" id="radiobutton_nx_floating_window">
+					      <property name="visible">True</property>
+					      <property name="can_focus">True</property>
+					      <property name="label" translatable="yes">Floating Window</property>
+					      <property name="use_underline">True</property>
+					      <property name="relief">GTK_RELIEF_NORMAL</property>
+					      <property name="focus_on_click">True</property>
+					      <property name="active">False</property>
+					      <property name="inconsistent">False</property>
+					      <property name="draw_indicator">True</property>
+					      <property name="group">radiobutton_nx_new_virtual_desktop</property>
+					      <signal name="toggled" handler="on_radiobutton_nx_new_virtual_desktop_toggled" last_modification_time="Thu, 13 Apr 2006 12:38:51 GMT"/>
+					    </widget>
+					    <packing>
+					      <property name="padding">0</property>
+					      <property name="expand">False</property>
+					      <property name="fill">False</property>
+					    </packing>
+					  </child>
+
+					  <child>
+					    <widget class="GtkCheckButton" id="checkbutton_nx_disable_x_agent">
+					      <property name="visible">True</property>
+					      <property name="sensitive">False</property>
+					      <property name="can_focus">True</property>
+					      <property name="label" translatable="yes">Disable X agent encoding</property>
+					      <property name="use_underline">True</property>
+					      <property name="relief">GTK_RELIEF_NORMAL</property>
+					      <property name="focus_on_click">True</property>
+					      <property name="active">False</property>
+					      <property name="inconsistent">False</property>
+					      <property name="draw_indicator">True</property>
+					      <signal name="toggled" handler="on_checkbutton_nx_disable_x_agent_toggled" last_modification_time="Thu, 13 Apr 2006 12:40:39 GMT"/>
+					    </widget>
+					    <packing>
+					      <property name="padding">0</property>
+					      <property name="expand">False</property>
+					      <property name="fill">False</property>
+					    </packing>
+					  </child>
+
+					  <child>
+					    <widget class="GtkCheckButton" id="checkbutton_nx_disable_x_replies">
+					      <property name="visible">True</property>
+					      <property name="sensitive">False</property>
+					      <property name="can_focus">True</property>
+					      <property name="label" translatable="yes">Disable taint of X replies</property>
+					      <property name="use_underline">True</property>
+					      <property name="relief">GTK_RELIEF_NORMAL</property>
+					      <property name="focus_on_click">True</property>
+					      <property name="active">False</property>
+					      <property name="inconsistent">False</property>
+					      <property name="draw_indicator">True</property>
+					    </widget>
+					    <packing>
+					      <property name="padding">0</property>
+					      <property name="expand">False</property>
+					      <property name="fill">False</property>
+					    </packing>
+					  </child>
+					</widget>
+					<packing>
+					  <property name="padding">0</property>
+					  <property name="expand">False</property>
+					  <property name="fill">False</property>
+					</packing>
+				      </child>
+				    </widget>
+				  </child>
+				</widget>
+			      </child>
+
+			      <child>
+				<widget class="GtkLabel" id="label_nx_custom_settings">
+				  <property name="visible">True</property>
+				  <property name="sensitive">False</property>
+				  <property name="label" translatable="yes">&lt;i&gt;Custom Settings&lt;/i&gt;</property>
+				  <property name="use_underline">False</property>
+				  <property name="use_markup">True</property>
+				  <property name="justify">GTK_JUSTIFY_LEFT</property>
+				  <property name="wrap">False</property>
+				  <property name="selectable">False</property>
+				  <property name="xalign">0.5</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xpad">0</property>
+				  <property name="ypad">0</property>
+				</widget>
+				<packing>
+				  <property name="type">label_item</property>
+				</packing>
+			      </child>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">True</property>
+			      <property name="fill">True</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkFrame" id="frame_nx_xdm">
+			      <property name="border_width">5</property>
+			      <property name="visible">True</property>
+			      <property name="label_xalign">0</property>
+			      <property name="label_yalign">0.5</property>
+			      <property name="shadow_type">GTK_SHADOW_OUT</property>
+
+			      <child>
+				<widget class="GtkAlignment" id="alignment31">
+				  <property name="visible">True</property>
+				  <property name="xalign">0.5</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xscale">1</property>
+				  <property name="yscale">1</property>
+				  <property name="top_padding">2</property>
+				  <property name="bottom_padding">5</property>
+				  <property name="left_padding">12</property>
+				  <property name="right_padding">2</property>
+
+				  <child>
+				    <widget class="GtkVBox" id="vbox61">
+				      <property name="visible">True</property>
+				      <property name="homogeneous">False</property>
+				      <property name="spacing">0</property>
+
+				      <child>
+					<widget class="GtkComboBox" id="combobox_nx_xdm_mode">
+					  <property name="visible">True</property>
+					  <property name="items" translatable="yes">Let NX server decide
+Send an XDM query to a host
+Broadcast an XDM query
+Get a list of available X display managers
+</property>
+					  <signal name="changed" handler="on_combobox_nx_xdm_mode_changed" last_modification_time="Thu, 13 Apr 2006 12:58:45 GMT"/>
+					</widget>
+					<packing>
+					  <property name="padding">0</property>
+					  <property name="expand">True</property>
+					  <property name="fill">True</property>
+					</packing>
+				      </child>
+
+				      <child>
+					<widget class="GtkHBox" id="hbox69">
+					  <property name="visible">True</property>
+					  <property name="homogeneous">False</property>
+					  <property name="spacing">0</property>
+
+					  <child>
+					    <widget class="GtkLabel" id="label_nx_xdm_host">
+					      <property name="visible">True</property>
+					      <property name="label" translatable="yes">Host: </property>
+					      <property name="use_underline">False</property>
+					      <property name="use_markup">False</property>
+					      <property name="justify">GTK_JUSTIFY_LEFT</property>
+					      <property name="wrap">False</property>
+					      <property name="selectable">False</property>
+					      <property name="xalign">0.5</property>
+					      <property name="yalign">0.5</property>
+					      <property name="xpad">0</property>
+					      <property name="ypad">0</property>
+					    </widget>
+					    <packing>
+					      <property name="padding">0</property>
+					      <property name="expand">False</property>
+					      <property name="fill">False</property>
+					    </packing>
+					  </child>
+
+					  <child>
+					    <widget class="GtkEntry" id="entry_nx_xdm_host">
+					      <property name="visible">True</property>
+					      <property name="tooltip" translatable="yes">The computer running the X display manager.</property>
+					      <property name="can_focus">True</property>
+					      <property name="editable">True</property>
+					      <property name="visibility">True</property>
+					      <property name="max_length">0</property>
+					      <property name="text" translatable="yes"></property>
+					      <property name="has_frame">True</property>
+					      <property name="invisible_char">*</property>
+					      <property name="activates_default">False</property>
+					    </widget>
+					    <packing>
+					      <property name="padding">0</property>
+					      <property name="expand">True</property>
+					      <property name="fill">True</property>
+					    </packing>
+					  </child>
+
+					  <child>
+					    <widget class="GtkLabel" id="label_nx_xdm_port">
+					      <property name="visible">True</property>
+					      <property name="label" translatable="yes">Port: </property>
+					      <property name="use_underline">False</property>
+					      <property name="use_markup">False</property>
+					      <property name="justify">GTK_JUSTIFY_LEFT</property>
+					      <property name="wrap">False</property>
+					      <property name="selectable">False</property>
+					      <property name="xalign">0.5</property>
+					      <property name="yalign">0.5</property>
+					      <property name="xpad">0</property>
+					      <property name="ypad">0</property>
+					    </widget>
+					    <packing>
+					      <property name="padding">0</property>
+					      <property name="expand">False</property>
+					      <property name="fill">False</property>
+					    </packing>
+					  </child>
+
+					  <child>
+					    <widget class="GtkSpinButton" id="spinbutton_nx_xdm_port">
+					      <property name="visible">True</property>
+					      <property name="tooltip" translatable="yes">The port for the XDM connection. Usually 177.</property>
+					      <property name="can_focus">True</property>
+					      <property name="climb_rate">1</property>
+					      <property name="digits">0</property>
+					      <property name="numeric">False</property>
+					      <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+					      <property name="snap_to_ticks">False</property>
+					      <property name="wrap">False</property>
+					      <property name="adjustment">177 1 32767 1 10 10</property>
+					    </widget>
+					    <packing>
+					      <property name="padding">0</property>
+					      <property name="expand">True</property>
+					      <property name="fill">True</property>
+					    </packing>
+					  </child>
+					</widget>
+					<packing>
+					  <property name="padding">0</property>
+					  <property name="expand">True</property>
+					  <property name="fill">True</property>
+					</packing>
+				      </child>
+				    </widget>
+				  </child>
+				</widget>
+			      </child>
+
+			      <child>
+				<widget class="GtkLabel" id="label_nx_xdm">
+				  <property name="visible">True</property>
+				  <property name="sensitive">False</property>
+				  <property name="label" translatable="yes">&lt;i&gt;XDM Settings&lt;/i&gt;</property>
+				  <property name="use_underline">False</property>
+				  <property name="use_markup">True</property>
+				  <property name="justify">GTK_JUSTIFY_LEFT</property>
+				  <property name="wrap">False</property>
+				  <property name="selectable">False</property>
+				  <property name="xalign">0.5</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xpad">0</property>
+				  <property name="ypad">0</property>
+				</widget>
+				<packing>
+				  <property name="type">label_item</property>
+				</packing>
+			      </child>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">True</property>
+			      <property name="fill">True</property>
+			    </packing>
+			  </child>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="label193">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">&lt;i&gt;Desktop Session&lt;/i&gt;</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">True</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		    </widget>
+		    <packing>
+		      <property name="type">label_item</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkFrame" id="frame14">
+		  <property name="border_width">5</property>
+		  <property name="visible">True</property>
+		  <property name="label_xalign">0</property>
+		  <property name="label_yalign">0.5</property>
+		  <property name="shadow_type">GTK_SHADOW_OUT</property>
+
+		  <child>
+		    <widget class="GtkAlignment" id="alignment29">
+		      <property name="visible">True</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xscale">1</property>
+		      <property name="yscale">1</property>
+		      <property name="top_padding">2</property>
+		      <property name="bottom_padding">5</property>
+		      <property name="left_padding">12</property>
+		      <property name="right_padding">2</property>
+
+		      <child>
+			<widget class="GtkVBox" id="vbox60">
+			  <property name="visible">True</property>
+			  <property name="homogeneous">False</property>
+			  <property name="spacing">0</property>
+
+			  <child>
+			    <widget class="GtkHBox" id="hbox66">
+			      <property name="visible">True</property>
+			      <property name="homogeneous">False</property>
+			      <property name="spacing">0</property>
+
+			      <child>
+				<widget class="GtkLabel" id="label194">
+				  <property name="width_request">170</property>
+				  <property name="visible">True</property>
+				  <property name="label" translatable="yes">Window Size</property>
+				  <property name="use_underline">False</property>
+				  <property name="use_markup">False</property>
+				  <property name="justify">GTK_JUSTIFY_LEFT</property>
+				  <property name="wrap">False</property>
+				  <property name="selectable">False</property>
+				  <property name="xalign">0.5</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xpad">0</property>
+				  <property name="ypad">0</property>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">False</property>
+				  <property name="fill">False</property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkComboBox" id="combobox_nx_window_size">
+				  <property name="visible">True</property>
+				  <property name="items" translatable="yes">640 x 480
+800 x 600
+1024 x 768
+1280 x 1024
+Custom
+Full Screen</property>
+				  <signal name="changed" handler="on_combobox_nx_window_size_changed" last_modification_time="Thu, 13 Apr 2006 12:28:43 GMT"/>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">True</property>
+				  <property name="fill">True</property>
+				</packing>
+			      </child>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkHBox" id="hbox67">
+			      <property name="visible">True</property>
+			      <property name="homogeneous">False</property>
+			      <property name="spacing">0</property>
+
+			      <child>
+				<widget class="GtkLabel" id="label195">
+				  <property name="width_request">90</property>
+				  <property name="visible">True</property>
+				  <property name="label" translatable="yes">Width</property>
+				  <property name="use_underline">False</property>
+				  <property name="use_markup">False</property>
+				  <property name="justify">GTK_JUSTIFY_LEFT</property>
+				  <property name="wrap">False</property>
+				  <property name="selectable">False</property>
+				  <property name="xalign">0.5</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xpad">0</property>
+				  <property name="ypad">0</property>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">False</property>
+				  <property name="fill">False</property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkSpinButton" id="spinbutton_nx_width">
+				  <property name="visible">True</property>
+				  <property name="can_focus">True</property>
+				  <property name="climb_rate">1</property>
+				  <property name="digits">0</property>
+				  <property name="numeric">False</property>
+				  <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+				  <property name="snap_to_ticks">False</property>
+				  <property name="wrap">False</property>
+				  <property name="adjustment">640 100 100000 10 100 100</property>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">True</property>
+				  <property name="fill">True</property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkLabel" id="label196">
+				  <property name="width_request">90</property>
+				  <property name="visible">True</property>
+				  <property name="label" translatable="yes">Height</property>
+				  <property name="use_underline">False</property>
+				  <property name="use_markup">False</property>
+				  <property name="justify">GTK_JUSTIFY_LEFT</property>
+				  <property name="wrap">False</property>
+				  <property name="selectable">False</property>
+				  <property name="xalign">0.5</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xpad">0</property>
+				  <property name="ypad">0</property>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">False</property>
+				  <property name="fill">False</property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkSpinButton" id="spinbutton_nx_height">
+				  <property name="visible">True</property>
+				  <property name="can_focus">True</property>
+				  <property name="climb_rate">1</property>
+				  <property name="digits">0</property>
+				  <property name="numeric">False</property>
+				  <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+				  <property name="snap_to_ticks">False</property>
+				  <property name="wrap">False</property>
+				  <property name="adjustment">480 60 10000 10 100 100</property>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">True</property>
+				  <property name="fill">True</property>
+				</packing>
+			      </child>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="label197">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">&lt;i&gt;Window Size&lt;/i&gt;</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">True</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		    </widget>
+		    <packing>
+		      <property name="type">label_item</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkFrame" id="frame15">
+		  <property name="border_width">5</property>
+		  <property name="visible">True</property>
+		  <property name="label_xalign">0</property>
+		  <property name="label_yalign">0.5</property>
+		  <property name="shadow_type">GTK_SHADOW_OUT</property>
+
+		  <child>
+		    <widget class="GtkAlignment" id="alignment30">
+		      <property name="visible">True</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xscale">1</property>
+		      <property name="yscale">1</property>
+		      <property name="top_padding">2</property>
+		      <property name="bottom_padding">5</property>
+		      <property name="left_padding">12</property>
+		      <property name="right_padding">2</property>
+
+		      <child>
+			<widget class="GtkHBox" id="hbox68">
+			  <property name="visible">True</property>
+			  <property name="homogeneous">False</property>
+			  <property name="spacing">0</property>
+
+			  <child>
+			    <widget class="GtkComboBox" id="combobox_nx_image_encoding">
+			      <property name="visible">True</property>
+			      <property name="items" translatable="yes">Default
+PNG
+JPEG
+X Bitmap</property>
+			      <signal name="changed" handler="on_combobox_nx_image_encoding_changed" last_modification_time="Tue, 18 Apr 2006 12:29:08 GMT"/>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">True</property>
+			      <property name="fill">True</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkLabel" id="label_nx_jpeg_quality">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">Quality: </property>
+			      <property name="use_underline">False</property>
+			      <property name="use_markup">False</property>
+			      <property name="justify">GTK_JUSTIFY_LEFT</property>
+			      <property name="wrap">False</property>
+			      <property name="selectable">False</property>
+			      <property name="xalign">0.5</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkSpinButton" id="spinbutton_nx_jpeg_quality">
+			      <property name="visible">True</property>
+			      <property name="tooltip" translatable="yes">Lower JPEG quality is equivalent to greater image compression and is good for low capacity links (modem, ISDN and ADSL).</property>
+			      <property name="can_focus">True</property>
+			      <property name="climb_rate">1</property>
+			      <property name="digits">0</property>
+			      <property name="numeric">False</property>
+			      <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+			      <property name="snap_to_ticks">False</property>
+			      <property name="wrap">True</property>
+			      <property name="adjustment">9 0 9 1 3 3</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">True</property>
+			      <property name="fill">True</property>
+			    </packing>
+			  </child>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="label199">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">&lt;i&gt;Image Encoding&lt;/i&gt;</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">True</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		    </widget>
+		    <packing>
+		      <property name="type">label_item</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkFrame" id="frame16">
+		  <property name="border_width">5</property>
+		  <property name="visible">True</property>
+		  <property name="label_xalign">0</property>
+		  <property name="label_yalign">0.5</property>
+		  <property name="shadow_type">GTK_SHADOW_OUT</property>
+
+		  <child>
+		    <widget class="GtkAlignment" id="alignment41">
+		      <property name="visible">True</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xscale">1</property>
+		      <property name="yscale">1</property>
+		      <property name="top_padding">2</property>
+		      <property name="bottom_padding">5</property>
+		      <property name="left_padding">12</property>
+		      <property name="right_padding">2</property>
+
+		      <child>
+			<widget class="GtkCheckButton" id="checkbutton_nx_enable_sound">
+			  <property name="visible">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="label" translatable="yes">Enable sound support</property>
+			  <property name="use_underline">True</property>
+			  <property name="relief">GTK_RELIEF_NORMAL</property>
+			  <property name="focus_on_click">True</property>
+			  <property name="active">False</property>
+			  <property name="inconsistent">False</property>
+			  <property name="draw_indicator">True</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="label222">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">&lt;i&gt;Services&lt;/i&gt;</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">True</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		    </widget>
+		    <packing>
+		      <property name="type">label_item</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">True</property>
+		  <property name="fill">True</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="tab_expand">False</property>
+	      <property name="tab_fill">True</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="label200">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Desktop</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	    </widget>
+	    <packing>
+	      <property name="type">tab</property>
+	    </packing>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">True</property>
+	  <property name="fill">True</property>
+	</packing>
+      </child>
+    </widget>
+  </child>
+</widget>
+
+<widget class="GtkWindow" id="manage_nx_key">
+  <property name="title" translatable="yes">Public SSL Key</property>
+  <property name="type">GTK_WINDOW_TOPLEVEL</property>
+  <property name="window_position">GTK_WIN_POS_CENTER_ON_PARENT</property>
+  <property name="modal">True</property>
+  <property name="default_width">600</property>
+  <property name="default_height">300</property>
+  <property name="resizable">True</property>
+  <property name="destroy_with_parent">False</property>
+  <property name="icon">nx-icon.png</property>
+  <property name="decorated">True</property>
+  <property name="skip_taskbar_hint">False</property>
+  <property name="skip_pager_hint">False</property>
+  <property name="type_hint">GDK_WINDOW_TYPE_HINT_DIALOG</property>
+  <property name="gravity">GDK_GRAVITY_CENTER</property>
+
+  <child>
+    <widget class="GtkVBox" id="vbox62">
+      <property name="visible">True</property>
+      <property name="homogeneous">False</property>
+      <property name="spacing">0</property>
+
+      <child>
+	<widget class="GtkScrolledWindow" id="scrolledwindow_nx_key">
+	  <property name="border_width">1</property>
+	  <property name="visible">True</property>
+	  <property name="can_focus">True</property>
+	  <property name="hscrollbar_policy">GTK_POLICY_ALWAYS</property>
+	  <property name="vscrollbar_policy">GTK_POLICY_ALWAYS</property>
+	  <property name="shadow_type">GTK_SHADOW_IN</property>
+	  <property name="window_placement">GTK_CORNER_TOP_LEFT</property>
+
+	  <child>
+	    <widget class="GtkTextView" id="textview_nx_key">
+	      <property name="visible">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="editable">False</property>
+	      <property name="overwrite">False</property>
+	      <property name="accepts_tab">True</property>
+	      <property name="justification">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap_mode">GTK_WRAP_NONE</property>
+	      <property name="cursor_visible">False</property>
+	      <property name="pixels_above_lines">1</property>
+	      <property name="pixels_below_lines">0</property>
+	      <property name="pixels_inside_wrap">0</property>
+	      <property name="left_margin">0</property>
+	      <property name="right_margin">0</property>
+	      <property name="indent">0</property>
+	      <property name="text" translatable="yes">SSL Key goes here...</property>
+	    </widget>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">True</property>
+	  <property name="fill">True</property>
+	</packing>
+      </child>
+
+      <child>
+	<widget class="GtkHButtonBox" id="hbuttonbox16">
+	  <property name="visible">True</property>
+	  <property name="layout_style">GTK_BUTTONBOX_END</property>
+	  <property name="spacing">0</property>
+
+	  <child>
+	    <widget class="GtkButton" id="button_change_ssl_key">
+	      <property name="visible">True</property>
+	      <property name="tooltip" translatable="yes">Choose a new key from a usb key drive or a downloaded file.</property>
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <signal name="clicked" handler="gtk_widget_show" object="filechooserdialog_nx_key" last_modification_time="Tue, 18 Apr 2006 15:00:23 GMT"/>
+
+	      <child>
+		<widget class="GtkAlignment" id="alignment32">
+		  <property name="visible">True</property>
+		  <property name="xalign">0.5</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xscale">0</property>
+		  <property name="yscale">0</property>
+		  <property name="top_padding">0</property>
+		  <property name="bottom_padding">0</property>
+		  <property name="left_padding">0</property>
+		  <property name="right_padding">0</property>
+
+		  <child>
+		    <widget class="GtkHBox" id="hbox70">
+		      <property name="visible">True</property>
+		      <property name="homogeneous">False</property>
+		      <property name="spacing">2</property>
+
+		      <child>
+			<widget class="GtkImage" id="image20">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-open</property>
+			  <property name="icon_size">4</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+			<packing>
+			  <property name="padding">0</property>
+			  <property name="expand">False</property>
+			  <property name="fill">False</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkLabel" id="label203">
+			  <property name="visible">True</property>
+			  <property name="label" translatable="yes">C_hange Key</property>
+			  <property name="use_underline">True</property>
+			  <property name="use_markup">False</property>
+			  <property name="justify">GTK_JUSTIFY_LEFT</property>
+			  <property name="wrap">False</property>
+			  <property name="selectable">False</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+			<packing>
+			  <property name="padding">0</property>
+			  <property name="expand">False</property>
+			  <property name="fill">False</property>
+			</packing>
+		      </child>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkButton" id="button_nx_revert_ssl_key">
+	      <property name="visible">True</property>
+	      <property name="tooltip" translatable="yes">Revert to the default NX server public SSL key.</property>
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <signal name="clicked" handler="on_button_nx_revert_ssl_key_clicked" last_modification_time="Thu, 20 Apr 2006 09:22:08 GMT"/>
+
+	      <child>
+		<widget class="GtkAlignment" id="alignment33">
+		  <property name="visible">True</property>
+		  <property name="xalign">0.5</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xscale">0</property>
+		  <property name="yscale">0</property>
+		  <property name="top_padding">0</property>
+		  <property name="bottom_padding">0</property>
+		  <property name="left_padding">0</property>
+		  <property name="right_padding">0</property>
+
+		  <child>
+		    <widget class="GtkHBox" id="hbox71">
+		      <property name="visible">True</property>
+		      <property name="homogeneous">False</property>
+		      <property name="spacing">2</property>
+
+		      <child>
+			<widget class="GtkImage" id="image21">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-revert-to-saved</property>
+			  <property name="icon_size">4</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+			<packing>
+			  <property name="padding">0</property>
+			  <property name="expand">False</property>
+			  <property name="fill">False</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkLabel" id="label204">
+			  <property name="visible">True</property>
+			  <property name="label">Revert to _Default</property>
+			  <property name="use_underline">True</property>
+			  <property name="use_markup">False</property>
+			  <property name="justify">GTK_JUSTIFY_LEFT</property>
+			  <property name="wrap">False</property>
+			  <property name="selectable">False</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+			<packing>
+			  <property name="padding">0</property>
+			  <property name="expand">False</property>
+			  <property name="fill">False</property>
+			</packing>
+		      </child>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkButton" id="button27">
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <signal name="clicked" handler="gtk_widget_hide" object="manage_nx_key" last_modification_time="Thu, 20 Apr 2006 08:16:48 GMT"/>
+
+	      <child>
+		<widget class="GtkAlignment" id="alignment34">
+		  <property name="visible">True</property>
+		  <property name="xalign">0.5</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xscale">0</property>
+		  <property name="yscale">0</property>
+		  <property name="top_padding">0</property>
+		  <property name="bottom_padding">0</property>
+		  <property name="left_padding">0</property>
+		  <property name="right_padding">0</property>
+
+		  <child>
+		    <widget class="GtkHBox" id="hbox72">
+		      <property name="visible">True</property>
+		      <property name="homogeneous">False</property>
+		      <property name="spacing">2</property>
+
+		      <child>
+			<widget class="GtkImage" id="image22">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-close</property>
+			  <property name="icon_size">4</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+			<packing>
+			  <property name="padding">0</property>
+			  <property name="expand">False</property>
+			  <property name="fill">False</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkLabel" id="label205">
+			  <property name="visible">True</property>
+			  <property name="label" translatable="yes">_Close Window</property>
+			  <property name="use_underline">True</property>
+			  <property name="use_markup">False</property>
+			  <property name="justify">GTK_JUSTIFY_LEFT</property>
+			  <property name="wrap">False</property>
+			  <property name="selectable">False</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+			<packing>
+			  <property name="padding">0</property>
+			  <property name="expand">False</property>
+			  <property name="fill">False</property>
+			</packing>
+		      </child>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">False</property>
+	</packing>
+      </child>
+    </widget>
+  </child>
+</widget>
+
+<widget class="GtkFileChooserDialog" id="filechooserdialog_nx_key">
+  <property name="action">GTK_FILE_CHOOSER_ACTION_OPEN</property>
+  <property name="local_only">False</property>
+  <property name="select_multiple">False</property>
+  <property name="show_hidden">True</property>
+  <property name="title" translatable="yes">Locate SSL Public Key text file</property>
+  <property name="type">GTK_WINDOW_TOPLEVEL</property>
+  <property name="window_position">GTK_WIN_POS_CENTER_ON_PARENT</property>
+  <property name="modal">True</property>
+  <property name="resizable">True</property>
+  <property name="destroy_with_parent">False</property>
+  <property name="icon">nx-icon.png</property>
+  <property name="decorated">True</property>
+  <property name="skip_taskbar_hint">False</property>
+  <property name="skip_pager_hint">False</property>
+  <property name="type_hint">GDK_WINDOW_TYPE_HINT_DIALOG</property>
+  <property name="gravity">GDK_GRAVITY_CENTER</property>
+
+  <child internal-child="vbox">
+    <widget class="GtkVBox" id="dialog-vbox7">
+      <property name="visible">True</property>
+      <property name="homogeneous">False</property>
+      <property name="spacing">24</property>
+
+      <child internal-child="action_area">
+	<widget class="GtkHButtonBox" id="dialog-action_area7">
+	  <property name="visible">True</property>
+	  <property name="layout_style">GTK_BUTTONBOX_END</property>
+
+	  <child>
+	    <widget class="GtkButton" id="button23">
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-cancel</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <property name="response_id">-6</property>
+	      <signal name="clicked" handler="gtk_widget_hide" object="filechooserdialog_nx_key" last_modification_time="Tue, 18 Apr 2006 15:01:06 GMT"/>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkButton" id="button24">
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="has_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-open</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <property name="response_id">-5</property>
+	      <signal name="clicked" handler="on_nx_key_file_chosen" last_modification_time="Tue, 18 Apr 2006 15:01:42 GMT"/>
+	    </widget>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">True</property>
+	  <property name="pack_type">GTK_PACK_END</property>
+	</packing>
+      </child>
+    </widget>
+  </child>
+</widget>
+
+</glade-interface>

Added: nxlaunch/src/nxlaunch.c
===================================================================
--- nxlaunch/src/nxlaunch.c	2007-09-16 20:16:05 UTC (rev 380)
+++ nxlaunch/src/nxlaunch.c	2007-09-17 12:30:56 UTC (rev 381)
@@ -0,0 +1,1697 @@
+/***************************************************************************
+                   nxlaunch: A GTK NX Client based on nxcl
+                   ---------------------------------------
+    begin                : September 2007
+    copyright            : (C) 2007 Embedded Software Foundry Ltd. (U.K.)
+                         :     Author: Sebastian James
+    email                : seb at esfnet.co.uk
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "i18n.h"
+
+/*! 
+ * config.h is created by the configure script and contains
+ * configure/compile time choices made by the program compiler.
+ */
+#include "../config.h"
+
+#include <glade/glade.h>
+#include <gtk/gtk.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <locale.h>
+#include <dirent.h>
+#include <string.h>
+#include <unistd.h>
+#define DBUS_API_SUBJECT_TO_CHANGE 1
+#include <dbus/dbus.h>
+
+#include "nxlaunch.h"
+#include "../lib/callbacks_nx.h"
+
+/* Use a global for the xml tree */
+extern GladeXML * xml_nxlaunch_glob;
+#if BUILT_IN_CONFIGURATION==1
+extern GladeXML * xml_glob;
+#endif
+
+extern GtkListStore * conn_store;
+extern GtkTreeIter    conn_iter;
+extern GtkTreeIter    active_iter_glob;
+extern guint          next_conn_type;
+extern GtkListStore * sess_store;
+extern GtkTreeIter    sess_iter;
+extern guint          next_sess_type;
+
+/*!
+ * Lazily use some globals for the send/receive dbus interfaces.
+ */
+extern gchar * dbusSendInterface;
+extern gchar * dbusRecvInterface;
+extern gchar * dbusMatchString;
+extern int              dbusNum;
+extern DBusConnection * dbusConn;
+extern DBusError        dbusErr;
+
+/*!
+ * The modus operandi. See main.c and nxlaunch.h
+ */
+extern int nxlaunch_mode;
+
+/*!
+ * Oh, look, another global! This one is used to hold connection
+ * information pulled out of the gtk_tree_model of connections when
+ * the user launches nxlaunch with a connection name argument. This
+ * one is local to nxlaunch.o
+ *
+ * WARNING: This is a possible source of a hanging pointer!
+ */
+struct nx_connection * nx_conn_glob = NULL;
+
+/*!
+ * Callback Functions are first in nxlaunch.c
+ */
+//@{
+
+/*!
+ * Callback for the delete-event signal 
+ */
+gboolean on_main_win_delete_event (GtkWidget * widget, 
+				   GdkEvent * event,
+				   gpointer user_data)
+{
+	return FALSE;
+}
+
+/*!
+ * There's a password entry on the main window and then a standalone
+ * password entry box. 
+ *
+ * If we are launching from the main window, then we use the
+ * password entry box on the main window, which is filled in from the
+ * configuration file if applicable.
+ *
+ * If the user presses launch without entering a password, then we
+ * either prompt him to enter on on the main window or we throw up
+ * the dedicated password window for him to enter the password there.
+ *
+ * If we are launching a connection from a name supplied on the cmd
+ * line then we don't show the main window, instead we give the user
+ * the dedicated password window.
+ *
+ * If we are launching a connection from a file given on the cmd line,
+ * then we do as for a name given on the cmd line.
+ *
+ * This implies we start up in different modes; something like:
+ * MODE_MAIN - no switches given
+ * MODE_NAMED - just a name given
+ * MODE_FILE - a file switch given
+ * MODE_EDIT_NAMED - name and --edit switch given
+ * MODE_EDIT_FILE - file and --edit switch given
+ *
+ * Do we want a global to hold the mode?
+ */
+void on_button_nxlaunch_launch_clicked (GtkButton * button)
+{
+	GtkWidget * widget;
+	struct nx_connection * nx_conn = NULL;	
+
+	int flags = checkActiveConnectionPassword();
+
+	/* Malloc and get active connection if state is correct */
+	if ((flags & STORED_PASSWORD) || 
+	    (nxlaunch_mode == MODE_MAIN && (flags & ENTERED_PASSWORD)) ) {
+		printerr ("Have entered or stored password\n");
+
+		/* Get the currently activated connection */
+		nx_conn = g_malloc0 (sizeof(struct nx_connection));
+		getActiveConnection (nx_conn);
+
+		/* Grey out the main window */
+		widget = glade_xml_get_widget (xml_nxlaunch_glob, "nxlauncher");
+		gtk_widget_set_sensitive (widget, FALSE);
+		while (gtk_events_pending()) gtk_main_iteration();
+	}
+
+
+	if (flags & STORED_PASSWORD) {
+
+		printerr ("There's a stored password, just launch connection\n");
+		launch_connection (nx_conn);
+
+	} else if (nxlaunch_mode == MODE_MAIN && (flags & ENTERED_PASSWORD)) {
+
+		printerr ("User entered password; get password into nx_conn then launch.\n");
+		/* Read the password into nx_conn->Pass, mallocing if necessary */
+		widget = glade_xml_get_widget (xml_nxlaunch_glob, "entry_nxlaunch_password");
+		if (!(nx_conn->Pass = g_try_realloc (nx_conn->Pass, 
+						     NX_FIELDLEN * sizeof(gchar)))) {
+			printerr ("NXLAUNCH> Failed g_try_realloc in %s\n", __FUNCTION__);
+		}
+		strncpy (nx_conn->Pass, gtk_entry_get_text (GTK_ENTRY(widget)), NX_FIELDLEN);
+		gtk_entry_set_text (GTK_ENTRY(widget), "");
+
+		launch_connection (nx_conn);
+
+	} else {
+		/* In this case, nx_conn should not have been
+		   g_malloc0ed */
+		if (nx_conn != NULL) {
+			g_error ("We seem to have allocated memory when we shouldn't have\n");
+			_exit(-1);
+		}
+		
+		/* Prompt user to enter password in the password box */
+		widget = glade_xml_get_widget (xml_nxlaunch_glob, "dialog_password");
+		gtk_widget_show_all (widget);
+		while (gtk_events_pending()) gtk_main_iteration();
+		widget = glade_xml_get_widget (xml_nxlaunch_glob, "nxlauncher");
+		gtk_widget_set_sensitive (widget, FALSE);
+	}
+	return;
+}
+
+#if BUILT_IN_CONFIGURATION==1
+void on_button_nxlaunch_new_clicked (GtkButton * button)
+{
+	GtkWidget * widget;
+
+	widget = glade_xml_get_widget (xml_glob, "conn_new_nx");
+	gtk_widget_show_all (widget);
+
+	return;
+}
+
+void on_button_nxlaunch_edit_clicked (GtkButton * button)
+{
+	GtkWidget * widget;
+	struct nx_connection * nx_conn;
+
+	widget = glade_xml_get_widget (xml_glob, "conn_new_nx");
+	gtk_widget_show_all (widget);
+
+	// Read in nx_conn for the highlighted entry
+	nx_conn = g_malloc0 (sizeof (struct nx_connection));
+	getActiveConnection (nx_conn);
+	setup_nx_popup (nx_conn);
+	nx_connection_free (nx_conn);
+
+	return;
+}
+
+void on_button_nxlaunch_delete_clicked (GtkButton * button)
+{
+	printerr ("%s\n", __FUNCTION__);
+	return;
+}
+
+void on_conn_new_ok_clicked (GtkButton * button)
+{
+	GtkTreeView * list_tree;
+	GtkTreeSelection * selected;
+	GtkTreeIter iter;
+	GtkTreeModel * tree_model;
+
+	gchar dummy_name[NX_FIELDLEN];
+	gchar dummy_server[NX_FIELDLEN];
+	gchar dummy_uname[NX_FIELDLEN];
+	int dummy_fullscreen = 0;
+	struct nx_connection * nx_conn;
+
+	/*
+	 * read_nx_popup() into nx_conn. Update the connection list
+	 * entry from the data.
+	 */
+	nx_conn = nx_connection_malloc();
+	read_nx_popup (dummy_name, dummy_server, dummy_uname, &dummy_fullscreen, nx_conn);
+
+	/* Get iter for current row and update connection list. */
+	list_tree = GTK_TREE_VIEW (glade_xml_get_widget (xml_nxlaunch_glob, "treeview_nxconnection"));
+	selected = gtk_tree_view_get_selection (list_tree);
+	tree_model = GTK_TREE_MODEL (conn_store);
+	if (gtk_tree_selection_get_selected (selected, &tree_model, &iter)) {
+		gtk_list_store_set (conn_store, &conn_iter,
+				    CONN_CONNECTIONNAME,    nx_conn->ConnectionName,
+				    CONN_SERVERHOST,        nx_conn->ServerHost,
+				    CONN_SERVERPORT,        nx_conn->ServerPort,
+				    CONN_USER,              nx_conn->User,
+				    CONN_PASS,              nx_conn->Pass,
+				    CONN_REMEMBERPASS,      nx_conn->RememberPassword ? TRUE : FALSE,
+				    CONN_DISABLENODELAY,    nx_conn->DisableNoDelay ? TRUE : FALSE,
+				    CONN_DISABLEZLIB,       nx_conn->DisableZLIB ? TRUE : FALSE,
+				    CONN_ENABLESSLONLY,     nx_conn->EnableSSLOnly ? TRUE : FALSE,
+				    CONN_LINKSPEED,         nx_conn->LinkSpeed,
+				    CONN_PUBLICKEY,         nx_conn->PublicKey,
+				    CONN_DESKTOP,           nx_conn->Desktop,
+				    CONN_CUSTOMUNIXDESKTOP, nx_conn->CustomUnixDesktop,
+				    CONN_COMMANDLINE,       nx_conn->CommandLine,
+				    CONN_VIRTUALDESKTOP,    nx_conn->VirtualDesktop ? TRUE : FALSE,
+				    CONN_XAGENTENCODING,    nx_conn->XAgentEncoding ? TRUE : FALSE,
+				    CONN_USETAINT,          nx_conn->UseTaint ? TRUE : FALSE,
+				    CONN_XDMMODE,           nx_conn->XdmMode,
+				    CONN_XDMHOST,           nx_conn->XdmHost,
+				    CONN_XDMPORT,           nx_conn->XdmPort,
+				    CONN_FULLSCREEN,        nx_conn->FullScreen ? TRUE : FALSE,	    
+				    CONN_RESOLUTIONWIDTH,   nx_conn->ResolutionWidth,
+				    CONN_RESOLUTIONHEIGHT,  nx_conn->ResolutionHeight,
+				    CONN_GEOMETRY,          nx_conn->Geometry,
+				    CONN_IMAGEENCODING,     nx_conn->ImageEncoding,
+				    CONN_JPEGQUALITY,       nx_conn->JPEGQuality,
+				    CONN_ENABLESOUND,       nx_conn->enableSound ? TRUE : FALSE,
+				    CONN_IPPPORT,           nx_conn->IPPPort,
+				    CONN_IPPPRINTING,       nx_conn->IPPPrinting ? TRUE : FALSE,
+				    CONN_SHARES,            nx_conn->Shares ? TRUE : FALSE,
+				    CONN_AGENTSERVER,       nx_conn->agentServer,
+				    CONN_AGENTUSER,         nx_conn->agentUser,
+				    CONN_AGENTPASS,         nx_conn->agentPass,
+				    -1);
+	}
+
+	nx_connection_free (nx_conn);
+	return;
+}
+#endif	
+
+void on_button_nxlaunch_quit_clicked (GtkButton * button)
+{
+	gtk_main_quit();
+	return;
+}
+
+/*!
+ * Connect to the highlighted connection
+ */
+void on_button_nxsession_connect_clicked (GtkButton * button)
+{
+	GtkTreeView * list_tree;
+	GtkTreeSelection * selected;
+	GtkTreeIter iter;
+	GtkTreeModel * tree_model;
+	int sessionNum = -1;
+
+	printerr ("%s() called\n", __FUNCTION__);
+
+	/* Get the highlighted row in the nxsession list window */
+	list_tree = GTK_TREE_VIEW (glade_xml_get_widget (xml_nxlaunch_glob, "treeview_nxsession"));
+	selected = gtk_tree_view_get_selection (list_tree);
+	tree_model = GTK_TREE_MODEL (conn_store);
+	if (gtk_tree_selection_get_selected (selected, &tree_model, &iter)) {
+		/* Get the sessionNum out. */
+		gtk_tree_model_get (tree_model, &iter, SESS_INDEX, &sessionNum, -1);
+	}
+
+	/* Call the "session connect dbus message" fn */
+	if (sessionNum > -1) {
+		sendReply (dbusConn, sessionNum);
+	} else {
+		printerr ("NXLAUNCH> %s(): Failed to set sessionNum from the session list gtk tree model\n",
+			  __FUNCTION__);
+	}
+
+	nxlaunch_display_progress();
+}
+
+/*!
+ * Send a launch message, saying "launch new"
+ */
+void on_button_nxsession_launch_clicked (GtkButton * button)
+{
+	sendReply (dbusConn, -1);
+	nxlaunch_display_progress();
+}
+
+void on_button_nxsession_terminate_clicked (GtkButton * button)
+{
+	GtkTreeView * list_tree;
+	GtkTreeSelection * selected;
+	GtkTreeIter iter;
+	GtkTreeModel * tree_model;
+	int sessionNum = -1;
+
+	printerr ("%s() called\n", __FUNCTION__);
+
+	/* Get the highlighted row in the nxsession list window */
+	list_tree = GTK_TREE_VIEW (glade_xml_get_widget (xml_nxlaunch_glob, "treeview_nxsession"));
+	selected = gtk_tree_view_get_selection (list_tree);
+	tree_model = GTK_TREE_MODEL (conn_store);
+	if (gtk_tree_selection_get_selected (selected, &tree_model, &iter)) {
+		/* Get the sessionNum out. */
+		gtk_tree_model_get (tree_model, &iter, SESS_INDEX, &sessionNum, -1);
+	}
+
+	if (sessionNum > -1) {
+		terminateSession (dbusConn, sessionNum);
+	} else {
+		printerr ("NXLAUNCH> %s(): Failed to set sessionNum from the session list gtk tree model\n",
+			  __FUNCTION__);
+	}
+	
+	return;
+}
+
+void on_button_nxsession_cancel_clicked (GtkButton * button)
+{
+	GtkWidget * widget;
+
+	widget = glade_xml_get_widget (xml_nxlaunch_glob, "session_list");
+	gtk_widget_hide (widget);
+	widget = glade_xml_get_widget (xml_nxlaunch_glob, "nxlauncher");
+	gtk_widget_set_sensitive (widget, TRUE);
+	gtk_widget_show (widget);
+
+	return;
+}
+
+void on_treeview_connection_cursor_changed (GtkWidget * widget)
+{
+	/* We get passed the treeview_nxconnection object here */
+	GtkTreeSelection * selected;
+	GtkTreeIter iter;
+	GtkTreeModel * tree_model;
+	gchar * the_user, * the_pass;
+	GtkWidget * entrybox;
+
+	/* We get passed the gtktreeview */
+	selected = gtk_tree_view_get_selection (GTK_TREE_VIEW (widget));
+	tree_model = GTK_TREE_MODEL (conn_store);
+	if (gtk_tree_selection_get_selected (selected, &tree_model, &iter)) {
+
+		/* Get all the information out of the row */
+		gtk_tree_model_get (tree_model, &iter,
+				    CONN_USER, &the_user, 
+				    CONN_PASS, &the_pass,
+				    -1);
+	}	
+
+	/*
+	 * Now place the user in entry_nxlaunch_user
+	 */
+	entrybox = glade_xml_get_widget (xml_nxlaunch_glob, "entry_nxlaunch_user");
+	if (strlen (the_user) < 1) {
+		the_user = g_realloc (the_user, sizeof(gchar)<<3); // 8 gchars
+		snprintf (the_user, 6, "%s", "noone");
+	}
+	gtk_entry_set_text (GTK_ENTRY(entrybox), the_user);
+
+	/*
+	 * Fill in the password if it has been set in the
+	 * configuration file
+	 */
+	entrybox = glade_xml_get_widget (xml_nxlaunch_glob, "entry_nxlaunch_password");
+	if (strlen (the_pass) > 0) {
+		gtk_entry_set_text (GTK_ENTRY(entrybox), the_pass);
+	}
+	
+	g_free (the_user);
+	g_free (the_pass);
+
+	// Place the focus on the password entry box
+	//gtk_widget_grab_focus (entrybox);
+	
+	return;
+}
+
+//@} Callbacks
+
+
+int nxconnection_buildlist (void)
+{
+	DIR *dp;
+	struct dirent *ep;
+	int nlen = 0, rtn = 0;
+	gchar config[1024];
+
+	snprintf (config, 1023, "%s/.nx/config", getenv("HOME"));
+
+	dp = opendir (config);
+	if (dp == NULL) {
+		printerr ("Couldn't opendir...\n");
+		return 0;
+	}
+
+	while ((ep = readdir (dp))) {
+
+		/* If d_name ends in .nxs, it should be an NX config file. */
+		nlen = strlen (ep->d_name);
+		if ( ep->d_name[--nlen] == 's'
+		     && ep->d_name[--nlen] == 'x'
+		     && ep->d_name[--nlen] == 'n'
+		     && ep->d_name[--nlen] == '.' ) {
+			
+			gchar nxname[128];
+			snprintf (nxname, ++nlen, ep->d_name);
+			struct nx_connection * nx_conn;
+			nx_conn = nx_connection_malloc();
+			/* Read in the connection using the callbacks_nx library fn */
+			if (0 == read_nx_connection (nx_conn, nxname)) {
+				/* Now place it in the connection store list */
+				gtk_list_store_append (conn_store, &conn_iter);
+				gtk_list_store_set (conn_store, &conn_iter,
+						    CONN_CONNECTIONNAME,    nx_conn->ConnectionName,
+						    CONN_SERVERHOST,        nx_conn->ServerHost,
+						    CONN_SERVERPORT,        nx_conn->ServerPort,
+						    CONN_USER,              nx_conn->User,
+						    CONN_PASS,              nx_conn->Pass,
+						    CONN_REMEMBERPASS,      nx_conn->RememberPassword ? TRUE : FALSE,
+						    CONN_DISABLENODELAY,    nx_conn->DisableNoDelay ? TRUE : FALSE,
+						    CONN_DISABLEZLIB,       nx_conn->DisableZLIB ? TRUE : FALSE,
+						    CONN_ENABLESSLONLY,     nx_conn->EnableSSLOnly ? TRUE : FALSE,
+						    CONN_LINKSPEED,         nx_conn->LinkSpeed,
+						    CONN_PUBLICKEY,         nx_conn->PublicKey,
+						    CONN_DESKTOP,           nx_conn->Desktop,
+						    CONN_CUSTOMUNIXDESKTOP, nx_conn->CustomUnixDesktop,
+						    CONN_COMMANDLINE,       nx_conn->CommandLine,
+						    CONN_VIRTUALDESKTOP,    nx_conn->VirtualDesktop ? TRUE : FALSE,
+						    CONN_XAGENTENCODING,    nx_conn->XAgentEncoding ? TRUE : FALSE,
+						    CONN_USETAINT,          nx_conn->UseTaint ? TRUE : FALSE,
+						    CONN_XDMMODE,           nx_conn->XdmMode,
+						    CONN_XDMHOST,           nx_conn->XdmHost,
+						    CONN_XDMPORT,           nx_conn->XdmPort,
+						    CONN_FULLSCREEN,        nx_conn->FullScreen ? TRUE : FALSE,	    
+						    CONN_RESOLUTIONWIDTH,   nx_conn->ResolutionWidth,
+						    CONN_RESOLUTIONHEIGHT,  nx_conn->ResolutionHeight,
+						    CONN_GEOMETRY,          nx_conn->Geometry,
+						    CONN_IMAGEENCODING,     nx_conn->ImageEncoding,
+						    CONN_JPEGQUALITY,       nx_conn->JPEGQuality,
+						    CONN_ENABLESOUND,       nx_conn->enableSound ? TRUE : FALSE,
+						    CONN_IPPPORT,           nx_conn->IPPPort,
+						    CONN_IPPPRINTING,       nx_conn->IPPPrinting ? TRUE : FALSE,
+						    CONN_SHARES,            nx_conn->Shares ? TRUE : FALSE,
+						    CONN_AGENTSERVER,       nx_conn->agentServer,
+						    CONN_AGENTUSER,         nx_conn->agentUser,
+						    CONN_AGENTPASS,         nx_conn->agentPass,
+						    -1);
+				rtn++;
+			}
+			nx_connection_free (nx_conn);
+		}
+	}
+	closedir (dp);
+
+	if (rtn > 0) {
+		GtkTreeIter treeIter;
+		GtkTreeView * list_tree;
+		GtkTreeSelection * select;
+
+		list_tree = GTK_TREE_VIEW (glade_xml_get_widget (xml_nxlaunch_glob,
+								 "treeview_nxconnection"));
+
+		/* Get the first iter */
+		gtk_tree_model_get_iter_first (GTK_TREE_MODEL (conn_store), &treeIter);
+		/* Now set it as the selected row somehow */
+		select = gtk_tree_view_get_selection (list_tree);
+		gtk_tree_selection_select_iter (select, &treeIter);
+		
+		on_treeview_connection_cursor_changed (GTK_WIDGET(list_tree));
+	}
+
+	return rtn;
+}
+
+void nxlaunch_create_nxconnection_list (void)
+{
+	GtkTreeViewColumn * column;
+	GtkCellRenderer * renderer;
+	GtkTreeView * list_tree;
+
+	list_tree = GTK_TREE_VIEW (glade_xml_get_widget (xml_nxlaunch_glob, "treeview_nxconnection"));
+	gtk_tree_view_set_model (list_tree, GTK_TREE_MODEL (conn_store));
+
+	/* Connection Name Column */
+	renderer = gtk_cell_renderer_text_new ();
+	column = gtk_tree_view_column_new_with_attributes (_("Name"), renderer,
+							   "text", CONN_CONNECTIONNAME,
+							   NULL);
+	gtk_tree_view_column_set_resizable (column, TRUE);
+	g_object_set (renderer, "width", 200, NULL);
+	gtk_tree_view_append_column (list_tree, column);
+
+
+	/* Server column */
+	renderer = gtk_cell_renderer_text_new ();
+	column = gtk_tree_view_column_new_with_attributes (_("Server"), renderer,
+							   "text", CONN_SERVERHOST,
+							   NULL);
+	g_object_set (renderer, "width", 100, NULL);
+	gtk_tree_view_append_column (list_tree, column);
+
+	/* User column */
+	renderer = gtk_cell_renderer_text_new ();
+	column = gtk_tree_view_column_new_with_attributes (_("Username"), renderer,
+							   "text", CONN_USER,
+							   NULL);
+	g_object_set (renderer, "width", 60, NULL);
+	gtk_tree_view_append_column (list_tree, column);
+
+	/* Type column */
+	renderer = gtk_cell_renderer_text_new ();
+	column = gtk_tree_view_column_new_with_attributes (_("Session Type"), renderer,
+							   "text", CONN_DESKTOP,
+							   NULL);
+	g_object_set (renderer, "width", 60, NULL);
+	gtk_tree_view_append_column (list_tree, column);
+
+	/* Geometry column */
+	renderer = gtk_cell_renderer_text_new ();
+	column = gtk_tree_view_column_new_with_attributes (_("Geometry"), renderer,
+							   "text", CONN_GEOMETRY,
+							   NULL);
+	g_object_set (renderer, "width", 100, NULL);
+	gtk_tree_view_append_column (list_tree, column);
+
+	return;
+}
+
+void nxlaunch_create_nxsession_list (void)
+{
+	GtkTreeViewColumn * column;
+	GtkCellRenderer * renderer;
+	GtkTreeView * list_tree;
+
+	list_tree = GTK_TREE_VIEW (glade_xml_get_widget (xml_nxlaunch_glob, "treeview_nxsession"));
+	gtk_tree_view_set_model (list_tree, GTK_TREE_MODEL (sess_store));
+
+	/* Name Column */
+	renderer = gtk_cell_renderer_text_new ();
+	column = gtk_tree_view_column_new_with_attributes (_("Name"), renderer,
+							   "text", SESS_SESSIONNAME,
+							   NULL);
+	gtk_tree_view_column_set_resizable (column, TRUE);
+        g_object_set (renderer, "width", 200, NULL);
+	gtk_tree_view_append_column (list_tree, column);
+
+	/* Icon column (icon representing type) with type as text */
+	column = gtk_tree_view_column_new();
+	gtk_tree_view_column_set_title (column, _("Type"));
+
+	renderer = gtk_cell_renderer_pixbuf_new();
+	gtk_tree_view_column_pack_start (column, renderer, FALSE);
+	gtk_tree_view_column_set_attributes (column, renderer, "pixbuf", SESS_TYPEICON, NULL);
+	g_object_set (renderer, "width", 32, NULL);
+
+	renderer = gtk_cell_renderer_text_new();
+	gtk_tree_view_column_pack_start (column, renderer, TRUE);
+	gtk_tree_view_column_set_attributes (column, renderer, "text", SESS_SESSIONTYPE, NULL);
+	g_object_set (renderer, "width", 100, NULL);
+
+	gtk_tree_view_append_column (list_tree, column);
+
+	/* Status column (add icon later, as above.) */
+	renderer = gtk_cell_renderer_text_new ();
+	column = gtk_tree_view_column_new_with_attributes (_("Status"), renderer,
+							   "text", SESS_AVAILABLE,
+							   NULL);
+	g_object_set (renderer, "width", 100, NULL);
+	gtk_tree_view_append_column (list_tree, column);
+
+	/* Display column */
+	renderer = gtk_cell_renderer_text_new ();
+	column = gtk_tree_view_column_new_with_attributes (_("Display"), renderer,
+							   "text", SESS_DISPLAY,
+							   NULL);
+	g_object_set (renderer, "width", 100, NULL);
+	gtk_tree_view_append_column (list_tree, column);
+
+	return;
+}
+
+int sendSettings (DBusConnection *bus, struct nx_connection * nx_conn)
+{
+	DBusMessage *message;
+
+	/* Create a new setting signal on the "org.freenx.nxcl.client"
+	 * interface, from the object "/org/freenx/nxcl/dbus/settingSignal". */
+	message = dbus_message_new_signal ("/org/freenx/nxcl/dbus/settingSignal",
+					   dbusSendInterface, 
+					   "sessionConfig");
+	if (NULL == message) {
+		printerr ("NXLAUNCH> Message Null\n");
+		return -1;
+	}
+
+	int media=0, enc=0, fs=0, cups=0;
+	if (nx_conn->enableSound == TRUE) { media = 1; }
+	if (nx_conn->EnableSSLOnly == TRUE) { enc = 1; }
+	if (nx_conn->FullScreen == TRUE) { fs = 1; }
+	if (nx_conn->IPPPrinting == TRUE) { cups = 1; }
+	int cache = 8, images = 24, render = 1;
+	const char * backingstore = "when_requested";
+	/* FIXME: Would like to store these in the .nxs file */
+	const char * keyboard = "";
+	const char * kbtype = "";
+	printerr ("Sending settings for connection %s, to Server %s\n",
+		  nx_conn->ConnectionName, nx_conn->ServerHost);
+	dbus_message_append_args 
+		(message,
+		 DBUS_TYPE_STRING, &nx_conn->ServerHost,     //0
+		 DBUS_TYPE_INT32,  &nx_conn->ServerPort,
+		 DBUS_TYPE_STRING, &nx_conn->User,           //2
+		 DBUS_TYPE_STRING, &nx_conn->Pass,
+		 DBUS_TYPE_STRING, &nx_conn->ConnectionName, //4
+		 DBUS_TYPE_STRING, &nx_conn->Desktop,        // FIXME - but not exactly.. If Desktop == gnome, sessionType == unix-gnome.
+		 DBUS_TYPE_INT32,  &cache,                //6
+		 DBUS_TYPE_INT32,  &images,
+		 DBUS_TYPE_STRING, &nx_conn->LinkSpeed,      //8
+		 DBUS_TYPE_INT32,  &render, 
+		 DBUS_TYPE_STRING, &backingstore,         //10
+		 DBUS_TYPE_INT32,  &nx_conn->ImageEncoding,
+		 DBUS_TYPE_INT32,  &nx_conn->JPEGQuality,    //12
+		 DBUS_TYPE_STRING, &nx_conn->Geometry,
+		 DBUS_TYPE_STRING, &keyboard,             //14
+		 DBUS_TYPE_STRING, &kbtype,
+		 DBUS_TYPE_INT32,  &media,                //16
+		 DBUS_TYPE_STRING, &nx_conn->agentServer,
+		 DBUS_TYPE_STRING, &nx_conn->agentUser,      //18
+		 DBUS_TYPE_STRING, &nx_conn->agentPass,
+		 DBUS_TYPE_INT32,  &cups,                 //20
+		 DBUS_TYPE_STRING, &nx_conn->PublicKey,
+		 DBUS_TYPE_INT32,  &enc,                  //22
+		 DBUS_TYPE_INT32,  &fs,
+		 DBUS_TYPE_STRING, &nx_conn->CommandLine,    //24
+		 DBUS_TYPE_INVALID);
+	printerr ("Sent settings to server\n");
+	/* Send the signal */
+	if (!dbus_connection_send (bus, message, NULL)) {
+		printerr ("NXLAUNCH> Out Of Memory!\n");
+		_exit(1);
+	}
+
+	/* Clean up */
+	dbus_message_unref (message);
+	dbus_connection_flush (bus);
+	printerr ("Returning\n");
+	return 1;
+}
+
+int sendReply (DBusConnection *bus, int sessionNum)
+{
+	DBusMessage *message;
+	DBusMessageIter args;
+
+	/* Create a new session choice signal on the "org.freenx.nxcl.client"
+	 * interface, from the object "/org/freenx/nxcl/dbus/sessionChoice". */
+	message = dbus_message_new_signal ("/org/freenx/nxcl/dbus/sessionChoice",
+					   dbusSendInterface,
+					   "sessionChoice");
+	if (NULL == message) {
+		printerr ("NXLAUNCH> Message Null\n");
+		return -1;
+	}
+
+	dbus_message_iter_init_append (message, &args);
+	if (!dbus_message_iter_append_basic (&args,
+					     DBUS_TYPE_INT32,
+					     (const void*)&sessionNum)) {
+		printerr ("NXLAUNCH> Out Of Memory!\n");
+		_exit(1);
+	}
+
+	/* Send the signal */
+	if (!dbus_connection_send (bus, message, NULL)) {
+		printerr ("NXLAUNCH> Out Of Memory!\n");
+		_exit(1);	  
+	}
+
+	/* Clean up */
+	dbus_message_unref (message);
+	dbus_connection_flush (bus);
+
+	return 1;
+}
+
+
+int terminateSession (DBusConnection *bus, int sessionNum)
+{
+	DBusMessage *message;
+	DBusMessageIter args;
+
+	/* Create a new session choice signal on the "org.freenx.nxcl.client"
+	 * interface, from the object "/org/freenx/nxcl/dbus/sessionChoice". */
+	message = dbus_message_new_signal ("/org/freenx/nxcl/dbus/sessionChoice",
+					   dbusSendInterface,
+					   "terminateSession");
+	if (NULL == message) { 
+		printerr ("NXLAUNCH> Message Null\n");
+		return -1;
+	}
+
+	dbus_message_iter_init_append (message, &args);
+	if (!dbus_message_iter_append_basic (&args,
+					     DBUS_TYPE_INT32,
+					     (const void*)&sessionNum)) {
+		printerr ("NXLAUNCH> Out Of Memory!\n");
+		_exit(1);
+	}
+
+	/* Send the signal */
+	if (!dbus_connection_send (bus, message, NULL)) {
+		printerr ("NXLAUNCH> Out Of Memory!\n");
+		_exit(1);	  
+	}
+
+	/* Clean up */
+	dbus_message_unref (message);
+	dbus_connection_flush (bus);
+
+	/* Now we terminated, we listen to nxcl to receive an updated
+	 * list of sessions, or for notification that we are now
+	 * starting a new session. */
+	callReceiveSession (TRUE);
+
+	return 1;
+}
+
+void callReceiveSession (gboolean relist_call)
+{
+	int ret = 0;
+
+	if (REPLY_REQUIRED == (ret = receiveSession (dbusConn))) {
+		/* Session window should have been populated
+		 * by receiveSession, so we now return and
+		 * wait for a button press event (the choice
+		 * of session) */
+
+	} else if (SERVER_CAPACITY == ret) {
+		/* Have run out of capacity (licences) on the server. */
+		nxlaunch_error_requiring_quit (_("Out of licences on server."));
+
+		/* Ok. The above call will lead to quitting the
+		 * program. Ideally we should show a list of sessions
+		 * so user can terminate one if possible.
+		 *
+		 * But how to get a list of sessions to terminate?
+		 * Does NX actually return that information? I think
+		 * it just returns the "out of capacity" message, and
+		 * that's that.
+		 */
+
+	} else {
+
+		printerr ("NXLAUNCH> receiveSession() returned %d\n", ret);
+
+		/*
+		 * Now, in this case, if we have called
+		 * callReceiveSession from terminate session, we don't
+		 * just want to launch a new session, unless the user
+		 * actually presses the new connection button. The
+		 * sequence here is: 1) Enter user/pass for the
+		 * session. 2) Get back list of 1 suspended session 3)
+		 * Terminate it 4) get presented with empty session
+		 * window in which you can either click "cancel" to go
+		 * back to the connection list, or "new" to create a
+		 * new session.
+		 */
+
+		if (!relist_call) {
+			nxlaunch_display_progress();
+		}
+	}
+
+	return;
+}
+
+/*
+ * Wait for and receive a message with available sessions, or a
+ * message saying there are no available sessions
+ */
+#define RECEIVE_TIMEOUT_SECONDS 30
+int receiveSession (DBusConnection* conn)
+{
+	GtkWidget * widget;
+	GdkPixbuf * icon;
+	GError * gerror = NULL;
+	DBusMessage * message;
+	DBusMessageIter args;
+	DBusError error;
+	char * parameter = NULL;
+	dbus_int32_t iparam = 0, t = 0;
+	int count = 0;
+	int timeout = 0;
+	gboolean sessions_obtained = FALSE;
+	int rtn = 0;
+
+	printerr (_("NXLAUNCH> Waiting to receive session information\n"));
+
+	// Clear the list store we're about to populate.
+	gtk_list_store_clear (sess_store);
+
+	dbus_error_init (&error);
+
+	int sessionNum = 0;
+
+	// loop listening for signals being emitted
+	while ((sessions_obtained == FALSE) && (++timeout < RECEIVE_TIMEOUT_SECONDS)) {
+		
+		if (dbus_error_is_set(&error)) { 
+			printerr ("NXLAUNCH> Name Error (%s)\n", error.message); 
+			dbus_error_free(&error); 
+		}
+
+		count = 0;
+
+		// non blocking read of the next available message
+		dbus_connection_read_write (conn, 0);
+		message = dbus_connection_pop_message (conn);
+
+		// loop again if we haven't read a message
+		if (NULL == message) {
+			usleep (1000000);
+			continue;
+		}
+
+		// Is the message the one we're interested in?
+		if (dbus_message_is_signal (message, dbusRecvInterface, "AvailableSession")) {
+
+			if (!dbus_message_iter_init (message, &args)) {
+				printerr ("NXLAUNCH> Message has no arguments!\n");
+				dbus_connection_flush (conn);
+				dbus_message_unref (message);
+				continue;
+			}
+
+			/* Now we have a message containing an
+			 * available session, append an entry to the
+			 * gtk_list_store of available connections. */
+			gtk_list_store_append (sess_store, &sess_iter);
+
+			/* Read the parameters of the message into the sess_store gtk_list_store.
+			 * The order of session parameters passed in the dbus message is:
+			 * [0]Display(i) | [1]Type(s)   | [2]Session ID(s) | [3]Options(s)
+			 * [4]Depth(i)   | [5]Screen(s) | [6]Status(s)     | [7]Session Name(s)
+			 */
+
+			gtk_list_store_set (sess_store, &sess_iter, SESS_INDEX, sessionNum, -1);
+			printerr ("N-%2d: ", sessionNum++);
+			do {
+				if (DBUS_TYPE_STRING == (t = dbus_message_iter_get_arg_type(&args))) {
+					dbus_message_iter_get_basic(&args, &parameter);
+					printerr (" '%s'", parameter);
+					switch (count) {
+					case 1: // Type
+						gtk_list_store_set (sess_store, &sess_iter, SESS_SESSIONTYPE, parameter, -1);
+						if (!strcmp ("unix-gnome", parameter)) {
+							icon = gdk_pixbuf_new_from_file(PACKAGE_DATA_DIR"/gnome-nx-session.png", &gerror);
+							gtk_list_store_set (sess_store, &sess_iter, SESS_TYPEICON, icon, -1);
+						} else if (!strcmp ("unix-kde", parameter)) {
+							icon = gdk_pixbuf_new_from_file(PACKAGE_DATA_DIR"/kde-nx-session.png", &gerror);
+							gtk_list_store_set (sess_store, &sess_iter, SESS_TYPEICON, icon, -1);
+						} else {
+							icon = gdk_pixbuf_new_from_file(PACKAGE_DATA_DIR"/unknown-nx-session.png", &gerror);
+							gtk_list_store_set (sess_store, &sess_iter, SESS_TYPEICON, icon, -1);
+						}
+						break;
+					case 2: // Session ID
+						gtk_list_store_set (sess_store, &sess_iter, SESS_SESSIONID, parameter, -1);
+						break;
+					case 3: // Options
+						gtk_list_store_set (sess_store, &sess_iter, SESS_OPTIONS, parameter, -1);
+						break;
+					case 5: // Screen
+						gtk_list_store_set (sess_store, &sess_iter, SESS_SCREEN, parameter, -1);
+						break;
+					case 6: // Status
+						gtk_list_store_set (sess_store, &sess_iter, SESS_AVAILABLE, parameter, -1);
+						break;
+					case 7: // Session Name
+						gtk_list_store_set (sess_store, &sess_iter, SESS_SESSIONNAME, parameter, -1);
+						break;
+					default:
+						break;
+					}
+					count++;
+
+				} else if (t == DBUS_TYPE_INT32) {
+					dbus_message_iter_get_basic (&args, &iparam);
+					printerr (" d%d", iparam);
+					//snprintf (parameter, 16, "%d", iparam);
+					switch (count) {
+					case 0:
+						gtk_list_store_set (sess_store, &sess_iter, SESS_DISPLAY, iparam, -1);
+						break;
+					case 4: // Depth
+						gtk_list_store_set (sess_store, &sess_iter, SESS_DEPTH, iparam, -1);
+						break;
+					default:
+						break;
+					}
+					count++;
+
+				} else {
+					printerr ("NXLAUNCH> Error, parameter is not string or int.\n");
+				}
+
+			} while (dbus_message_iter_next (&args));
+
+			printerr ("\n");
+		
+			/*
+			 * The session box should now have been populated, so just reveal it
+			 */
+			widget = glade_xml_get_widget (xml_nxlaunch_glob, "session_list");
+			gtk_widget_show (widget);
+			while (gtk_events_pending()) gtk_main_iteration();
+			rtn = REPLY_REQUIRED;
+
+		} else if (dbus_message_is_signal (message,
+						   dbusRecvInterface,
+						   "NoMoreAvailable")) {
+			printerr ("NXLAUNCH> Server says \"NoMoreAvailable\"\n");
+			sessions_obtained = TRUE;
+			rtn = REPLY_REQUIRED;
+
+		} else if (dbus_message_is_signal (message,
+						   dbusRecvInterface,
+						   "Connecting")) {
+			printerr ("NXLAUNCH> Server says \"Connection\"\n");
+			sessions_obtained = TRUE;
+			rtn = NEW_CONNECTION;
+
+		} else if (dbus_message_is_signal (message,
+						   dbusRecvInterface,
+						   "ServerCapacityReached")) {
+			printerr ("NXLAUNCH> Server says \"ServerCapacityReached\"\n");
+			sessions_obtained = TRUE;
+			rtn = SERVER_CAPACITY;
+
+		} else {
+			/* Nothing */
+		}	
+
+		dbus_connection_flush (conn);
+		dbus_message_unref (message);
+
+	} // while()
+
+	return rtn;
+}
+
+
+/*!
+ * This populates global variables
+ */
+int obtainDbusConnection (void)
+{
+	gboolean gotName = FALSE;
+	gboolean gotSendName = FALSE;
+	gboolean gotRecvName = FALSE;
+	int i = 0, ret = 0;
+	
+	dbusSendInterface = g_malloc0 (64*sizeof (gchar));
+	dbusRecvInterface = g_malloc0 (64*sizeof (gchar));
+	dbusMatchString   = g_malloc0 (128*sizeof (gchar));
+
+	/* Get a connection to the session bus */
+	dbus_error_init (&dbusErr);
+	dbusConn = dbus_bus_get (DBUS_BUS_SESSION, &dbusErr);
+	if (!dbusConn) {
+		printerr ("Failed to connect to the D-BUS daemon: %s\n", dbusErr.message);
+		dbus_error_free (&dbusErr);
+		return -1;
+	}
+
+	/*
+	 * Here, we try to get the interface org.freenx.nxcl.client0
+	 * in case any other clients are running. We also try to get
+	 * the interface org.freenx.nxcl.nxcl0, in case any other nxcl
+	 * daemons are running, but we have to release that name, one
+	 * we established that it is available.
+	 */
+	while (gotName == FALSE) {
+
+		snprintf (dbusSendInterface, 63, "org.freenx.nxcl.client%d", i);
+		snprintf (dbusRecvInterface, 63, "org.freenx.nxcl.nxcl%d", i);
+		snprintf (dbusMatchString, 127, "type='signal',interface='org.freenx.nxcl.nxcl%d'", i);
+
+		// We request a name on the bus which is the same string as the send interface.
+		ret = dbus_bus_request_name (dbusConn, dbusSendInterface,
+					     DBUS_NAME_FLAG_REPLACE_EXISTING, 
+					     &dbusErr);
+
+		if (dbus_error_is_set (&dbusErr)) { 
+			printerr ("NXLAUNCH> Name Error (%s)\n", dbusErr.message); 
+			dbus_error_free(&dbusErr);
+		}
+
+		if (DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER != ret) {
+			printerr ("NXLAUNCH> Couldn't get the send name this iteration\n");
+		} else {
+			printerr ("NXLAUNCH> Got the send name '%s' on the dbus\n", dbusSendInterface);
+			gotSendName = TRUE;
+		}
+
+		ret = dbus_bus_request_name (dbusConn, dbusRecvInterface,
+					     DBUS_NAME_FLAG_REPLACE_EXISTING, 
+					     &dbusErr);
+
+		if (dbus_error_is_set (&dbusErr)) { 
+			printerr ("NXLAUNCH> Name Error (%s)\n", dbusErr.message); 
+			dbus_error_free(&dbusErr);
+		}
+
+		if (DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER != ret) {
+			printerr ("NXLAUNCH> Couldn't get the receive name in this iteration\n");
+		} else {
+			printerr ("NXLAUNCH> Got the recv name '%s' on the dbus\n", dbusRecvInterface);
+			gotRecvName = TRUE;
+			dbus_bus_release_name (dbusConn, dbusRecvInterface, &dbusErr);
+		}
+
+		if (gotSendName && gotRecvName) {
+			gotName = TRUE;
+		} else {
+			gotSendName = FALSE;
+			gotRecvName = FALSE;
+			i++;
+		}
+	}
+
+	printerr ("NXLAUNCH> obtainDbusConnection() returning %d\n", i);
+	return i;
+}
+
+void execNxcl (void)
+{
+	pid_t pid = 0;
+	char argStr[8];
+	char progLocn[128];
+	char prog[32];
+	int theError = 0;
+
+	snprintf (argStr, 7, "%d", dbusNum);
+	snprintf (progLocn, 127, PACKAGE_BIN_DIR"/nxcl");
+	snprintf (prog, 31, "nxcl");
+
+	printerr ("NXLAUNCH> About to exec '%s %s'\n", prog, argStr);
+
+	/* fork and exec the nxcl */
+	pid = fork();
+	switch (pid) {
+	case -1:
+		printerr ("Can't fork()!\n");
+		_exit(1);
+	case 0:
+		// This is the CHILD process
+		// Allocate memory for the program arguments
+		// 1+ to allow space for NULL terminating pointer
+		
+
+		// FIXME: This isn't passing the argument correctly to nxcl.
+		execl (progLocn, prog, argStr, (char*)NULL);
+		// If process returns, error occurred
+		theError = errno;
+		// This'll get picked up by parseResponse
+		printerr ("NXLAUNCH> Process error: %d crashed. errno:%d\n", pid, theError);
+		// Child should exit now.
+		_exit(1);
+
+	default:
+		// This is the PARENT process
+		printerr ("NXLAUNCH> forked the nxcl process; continuing.\n");
+		break;
+	}
+}
+
+
+void sendNxclSettings (struct nx_connection * nx_conn)
+{
+	/* Prepare interface - add a rule for which messages we want
+	   to see - those that are sent to us from the nxcl
+	   connection. */
+	dbus_bus_add_match (dbusConn, dbusMatchString, &dbusErr);
+	dbus_connection_flush (dbusConn);
+	if (dbus_error_is_set(&dbusErr)) { 
+		printerr ("NXLAUNCH> Match Error (%s)\n", dbusErr.message);
+		_exit(1);
+	} else {
+		printerr ("NXLAUNCH> Added match '%s'\n", dbusMatchString);
+	}
+
+	if (waitForAlive() == FALSE) {
+		printerr ("NXLAUNCH> nxcl didn't start!");
+		_exit (-1);		
+	}
+
+	// ...and then send it on dbus.
+	sendSettings (dbusConn, nx_conn);
+	printerr ("NXLAUNCH> sent settings\n");
+	
+	return;
+}
+
+/*!
+ * This is a callback, but is better placed here in the code near
+ * getActiveConnection.
+ */
+void on_button_password_ok_clicked (GtkButton * button)
+{
+	struct nx_connection * nx_conn = NULL;
+	GtkWidget * widget;
+
+	printerr ("NXLAUNCH> %s() called\n", __FUNCTION__);
+
+	if (nx_conn_glob == NULL) {
+		printerr ("NXLAUNCH> Reading the active connection from the tree model\n");
+		nx_conn = g_malloc0 (sizeof (struct nx_connection));
+		getActiveConnection (nx_conn);
+	} else { /* we already populated nx_conn in launch_named_connection() */
+		printerr ("NXLAUNCH> Using global nx_conn pointer, which is 0x%x\n", 
+			  (unsigned int)nx_conn_glob);
+		nx_conn = nx_conn_glob;
+		nx_conn_glob = NULL;
+		printerr ("NXLAUNCH> nx_conn is still 0x%x\n", (int)nx_conn);
+	}
+
+	/* Read the password into nx_conn->Pass, mallocing if necessary */
+	widget = glade_xml_get_widget (xml_nxlaunch_glob, "entry_password_dialog");
+	if (!(nx_conn->Pass = g_try_realloc (nx_conn->Pass, NX_FIELDLEN * sizeof(gchar)))) {
+		printerr ("NXLAUNCH> Failed g_try_realloc\n");
+	}
+	strncpy (nx_conn->Pass, gtk_entry_get_text (GTK_ENTRY (widget)),  NX_FIELDLEN);
+
+	/* Hide the password window (this may not happen until this
+	 * callback returns, which is not what we want, really) */
+	widget = glade_xml_get_widget (xml_nxlaunch_glob, "dialog_password");
+	gtk_widget_hide_all (widget);
+	while (gtk_events_pending()) gtk_main_iteration();
+	/* We still have an un-redrawn patch on the greyed out nxlauncher main window... */
+	widget = glade_xml_get_widget (xml_nxlaunch_glob, "nxlauncher");
+	gtk_widget_show_all (widget);
+	while (gtk_events_pending()) gtk_main_iteration();
+	launch_connection (nx_conn);
+	return;
+}
+
+void on_button_password_cancel_clicked (GtkButton * button)
+{
+	GtkWidget * widget;
+	widget = glade_xml_get_widget (xml_nxlaunch_glob, "nxlauncher");
+	gtk_widget_set_sensitive (widget, TRUE);
+	gtk_widget_show (widget);
+	return;
+}
+
+void getActiveConnection (struct nx_connection * nx_conn)
+{
+	GtkTreeView * list_tree;
+	GtkTreeSelection * selected;
+	GtkTreeIter iter;
+	GtkTreeModel * tree_model;
+
+	printerr ("%s() called\n", __FUNCTION__);
+
+	list_tree = GTK_TREE_VIEW (glade_xml_get_widget (xml_nxlaunch_glob, "treeview_nxconnection"));
+	selected = gtk_tree_view_get_selection (list_tree);
+	tree_model = GTK_TREE_MODEL (conn_store);
+
+	if (gtk_tree_selection_get_selected (selected, &tree_model, &iter)) {
+
+		/* Get all the information out of the row */
+		gtk_tree_model_get (tree_model, &iter,
+				    CONN_CONNECTIONNAME,    &nx_conn->ConnectionName,//
+				    CONN_SERVERHOST,        &nx_conn->ServerHost,//
+				    CONN_SERVERPORT,        &nx_conn->ServerPort,
+				    CONN_USER,              &nx_conn->User,//
+				    CONN_PASS,              &nx_conn->Pass,//
+				    CONN_REMEMBERPASS,      &nx_conn->RememberPassword,
+				    CONN_DISABLENODELAY,    &nx_conn->DisableNoDelay,
+				    CONN_DISABLEZLIB,       &nx_conn->DisableZLIB,
+				    CONN_ENABLESSLONLY,     &nx_conn->EnableSSLOnly,
+				    CONN_LINKSPEED,         &nx_conn->LinkSpeed,//
+				    CONN_PUBLICKEY,         &nx_conn->PublicKey,//
+				    CONN_DESKTOP,           &nx_conn->Desktop,//
+				    CONN_CUSTOMUNIXDESKTOP, &nx_conn->CustomUnixDesktop,//
+				    CONN_COMMANDLINE,       &nx_conn->CommandLine,//
+				    CONN_VIRTUALDESKTOP,    &nx_conn->VirtualDesktop,
+				    CONN_XAGENTENCODING,    &nx_conn->XAgentEncoding,
+				    CONN_USETAINT,          &nx_conn->UseTaint,
+				    CONN_XDMMODE,           &nx_conn->XdmMode,//
+				    CONN_XDMHOST,           &nx_conn->XdmHost,//
+				    CONN_XDMPORT,           &nx_conn->XdmPort,
+				    CONN_FULLSCREEN,        &nx_conn->FullScreen,	    
+				    CONN_RESOLUTIONWIDTH,   &nx_conn->ResolutionWidth,
+				    CONN_RESOLUTIONHEIGHT,  &nx_conn->ResolutionHeight,
+				    CONN_GEOMETRY,          &nx_conn->Geometry,//
+				    CONN_IMAGEENCODING,     &nx_conn->ImageEncoding,
+				    CONN_JPEGQUALITY,       &nx_conn->JPEGQuality,
+				    CONN_ENABLESOUND,       &nx_conn->enableSound,
+				    CONN_IPPPORT,           &nx_conn->IPPPort,
+				    CONN_IPPPRINTING,       &nx_conn->IPPPrinting,
+				    CONN_SHARES,            &nx_conn->Shares,
+				    CONN_AGENTSERVER,       &nx_conn->agentServer,//
+				    CONN_AGENTUSER,         &nx_conn->agentUser,//
+				    CONN_AGENTPASS,         &nx_conn->agentPass,//
+				    -1);
+
+		/* Put this iter in the global iter */
+		conn_iter = iter;
+	}
+}
+
+/*!
+ * Returns true if we have a named connection, but we are waiting for
+ * user to input a password.
+ */
+gboolean launch_named_connection (gchar * connection_name)
+{
+	/* Set the iter to point to the named connection, and if we
+	 * have a match, called on_button_nxlaunch_launch_clicked */
+	GtkWidget * widget;
+	GtkWidget * tree;
+	GtkTreeIter iter;
+	gchar * str_data;
+	gboolean valid;
+	gboolean got_connection = FALSE;
+	struct nx_connection * nx_conn;
+
+	nx_conn = g_malloc0 (sizeof (struct nx_connection));
+
+	/* Need to get the associated treemodel */
+	tree = glade_xml_get_widget (xml_nxlaunch_glob, "treeview_nxconnection");
+	valid = gtk_tree_model_get_iter_first (GTK_TREE_MODEL (conn_store), &iter);
+	while (valid) {
+		gtk_tree_model_get (GTK_TREE_MODEL (conn_store), &iter, 
+				    CONN_CONNECTIONNAME, &str_data,
+				    -1);
+		printerr ("Got connection named '%s'\n", str_data);
+		if (!strcmp (connection_name, str_data)) {
+			printerr ("This is the connection to activate\n");
+			got_connection = TRUE;
+
+			/* NB: This function mallocs the data for the strings */
+			gtk_tree_model_get (GTK_TREE_MODEL(conn_store), &iter,
+					    CONN_CONNECTIONNAME,    &nx_conn->ConnectionName,
+					    CONN_SERVERHOST,        &nx_conn->ServerHost,
+					    CONN_SERVERPORT,        &nx_conn->ServerPort,
+					    CONN_USER,              &nx_conn->User,
+					    CONN_PASS,              &nx_conn->Pass,
+					    CONN_REMEMBERPASS,      &nx_conn->RememberPassword,
+					    CONN_DISABLENODELAY,    &nx_conn->DisableNoDelay,
+					    CONN_DISABLEZLIB,       &nx_conn->DisableZLIB,
+					    CONN_ENABLESSLONLY,     &nx_conn->EnableSSLOnly,
+					    CONN_LINKSPEED,         &nx_conn->LinkSpeed,
+					    CONN_PUBLICKEY,         &nx_conn->PublicKey,
+					    CONN_DESKTOP,           &nx_conn->Desktop,
+					    CONN_CUSTOMUNIXDESKTOP, &nx_conn->CustomUnixDesktop,
+					    CONN_COMMANDLINE,       &nx_conn->CommandLine,
+					    CONN_VIRTUALDESKTOP,    &nx_conn->VirtualDesktop,
+					    CONN_XAGENTENCODING,    &nx_conn->XAgentEncoding,
+					    CONN_USETAINT,          &nx_conn->UseTaint,
+					    CONN_XDMMODE,           &nx_conn->XdmMode,
+					    CONN_XDMHOST,           &nx_conn->XdmHost,
+					    CONN_XDMPORT,           &nx_conn->XdmPort,
+					    CONN_FULLSCREEN,        &nx_conn->FullScreen,	    
+					    CONN_RESOLUTIONWIDTH,   &nx_conn->ResolutionWidth,
+					    CONN_RESOLUTIONHEIGHT,  &nx_conn->ResolutionHeight,
+					    CONN_GEOMETRY,          &nx_conn->Geometry,
+					    CONN_IMAGEENCODING,     &nx_conn->ImageEncoding,
+					    CONN_JPEGQUALITY,       &nx_conn->JPEGQuality,
+					    CONN_ENABLESOUND,       &nx_conn->enableSound,
+					    CONN_IPPPORT,           &nx_conn->IPPPort,
+					    CONN_IPPPRINTING,       &nx_conn->IPPPrinting,
+					    CONN_SHARES,            &nx_conn->Shares,
+					    CONN_AGENTSERVER,       &nx_conn->agentServer,
+					    CONN_AGENTUSER,         &nx_conn->agentUser,
+					    CONN_AGENTPASS,         &nx_conn->agentPass,
+					    -1);
+			printerr ("nx_conn->ServerHost: %s\n", nx_conn->ServerHost);
+			g_free (str_data);
+			break;
+		}
+		g_free (str_data);
+		valid = gtk_tree_model_iter_next (GTK_TREE_MODEL (conn_store), &iter);
+	}
+	
+	if (!got_connection) {
+		printerr ("NXLAUNCH> Couldn't find the connection '%s'\n", connection_name);
+		return FALSE;
+	}
+
+	if (nx_conn->RememberPassword == FALSE) {
+		/* Show the window to enter the password */
+		/* Set the global pointer to point to the memory we
+		 * just malloced. */
+		nx_conn_glob = nx_conn;
+		widget = glade_xml_get_widget (xml_nxlaunch_glob, "dialog_password");
+		gtk_widget_show_all (widget);
+		return TRUE;
+
+	} else {
+		launch_connection (nx_conn);
+		nx_connection_free (nx_conn);
+		return FALSE;
+	}
+}
+
+/*!
+ * nx_conn should be malloced already when passed to this fn.
+ * This function will then free that memory, and exit the program.
+ */
+void launch_connection (struct nx_connection * nx_conn)
+{
+	GtkWidget * widget;
+	gchar temp[32];
+
+	printerr ("%s() called\n", __FUNCTION__);
+
+	/* FIXME
+	 * Not quite sure what to do with nx_conn->Desktop
+	 * here. Mostly, gnome goes to unix-gnome, kde to unix-kde and
+	 * so on, but not sure what sessionType should be for console,
+	 * custom and RDP/VNC sessions.
+	 * For now, apply this hack:
+	 */
+	snprintf (temp, 31, "unix-%s", nx_conn->Desktop);
+	snprintf (nx_conn->Desktop, 255, "%s", temp);
+
+	execNxcl();
+	sendNxclSettings (nx_conn);
+	callReceiveSession (FALSE);
+	printerr ("NXLAUNCH> Received session\n");
+
+	if (!(nx_conn->Pass = g_try_realloc (nx_conn->Pass, NX_FIELDLEN * sizeof(gchar)))) {
+		printerr ("NXLAUNCH> Failed g_try_realloc in %s()\n", __FUNCTION__);
+	}
+	memset (nx_conn->Pass, 0, NX_FIELDLEN);
+
+	/* Clear the password GTK entry here where necessary */
+	widget = glade_xml_get_widget (xml_nxlaunch_glob, "entry_nxlaunch_password");
+	gtk_entry_set_text (GTK_ENTRY(widget), "");
+	widget = glade_xml_get_widget (xml_nxlaunch_glob, "entry_password_dialog");
+	gtk_entry_set_text (GTK_ENTRY(widget), "");
+
+	nx_connection_free (nx_conn);
+	return;
+}
+
+void nxlauncher_hide (void)
+{
+	GtkWidget * widget;
+	widget = glade_xml_get_widget (xml_nxlaunch_glob, "nxlauncher");
+	printerr ("NXLAUNCH> Hide all\n");
+	gtk_widget_hide_all (widget);
+	return;
+}
+
+void nxlauncher_show (void)
+{
+	GtkWidget * widget;
+	widget = glade_xml_get_widget (xml_nxlaunch_glob, "nxlauncher");
+	printerr ("NXLAUNCH> Show all\n");
+	gtk_widget_show_all (widget);
+	return;
+}
+
+int checkActiveConnectionPassword (void)
+{
+	GtkWidget * widget;
+	GtkTreeView * list_tree;
+	GtkTreeSelection * selected;
+	GtkTreeIter iter;
+	GtkTreeModel * tree_model;
+	gchar * str;
+	int flags = 0;
+
+	/* Check active row in treeview */
+	list_tree = GTK_TREE_VIEW (glade_xml_get_widget (xml_nxlaunch_glob, "treeview_nxconnection"));
+	selected = gtk_tree_view_get_selection (list_tree);
+	tree_model = GTK_TREE_MODEL (conn_store);
+	if (gtk_tree_selection_get_selected (selected, &tree_model, &iter)) {
+		gtk_tree_model_get (tree_model, &iter, CONN_PASS, &str, -1);		
+		if (strlen (str) > 0) {
+			flags |= STORED_PASSWORD;
+		}
+		g_free (str);
+	}
+
+	widget = glade_xml_get_widget (xml_nxlaunch_glob, "entry_nxlaunch_password");
+	str = g_malloc0 (NX_FIELDLEN * sizeof (gchar));
+	strncpy (str, gtk_entry_get_text (GTK_ENTRY(widget)), NX_FIELDLEN);
+	if (strlen (str) > 0) {
+		flags |= ENTERED_PASSWORD;
+	}
+	g_free (str);
+	return flags;
+}
+
+/*
+ * Likely to become obsolete.
+ */
+void nxlaunch_quit_with_window (void)
+{
+	printerr ("%s called\n", __FUNCTION__);
+	GtkWidget * widget;
+	printerr ("NXLAUNCH> Quitting in 8 seconds...\n");
+	widget = glade_xml_get_widget (xml_nxlaunch_glob, "dialog_quitting");
+	gtk_widget_show_all (widget);
+	while (gtk_events_pending()) gtk_main_iteration();
+	widget = glade_xml_get_widget (xml_nxlaunch_glob, "label_reason_for_exit");
+	gtk_widget_show (widget);
+	while (gtk_events_pending()) gtk_main_iteration();
+	printerr ("About to sleep.. it would be better to pass control back to the main loop for a few seconds before quitting here.\n");
+	usleep (8000000);
+	printerr ("Slept, now quit..\n");
+	while (gtk_events_pending()) gtk_main_iteration();
+	gtk_main_quit();
+}
+
+void nxlaunch_display_progress (void)
+{
+	GtkWidget * widget;
+	widget = glade_xml_get_widget (xml_nxlaunch_glob, "nxlaunch_progress");
+	gtk_widget_show (widget);
+	while (gtk_events_pending()) gtk_main_iteration();
+	widget = glade_xml_get_widget (xml_nxlaunch_glob, "label_progress");
+	gtk_widget_show (widget);
+	/* Add a status message listener - this will update the status
+	   message in the nxlaunch_progress window, and the messages will
+	   be used to set the progress bar, too. */
+	g_timeout_add (500, &nxlaunch_status_listener, NULL);
+	return;
+}
+
+gboolean nxlaunch_status_listener (gpointer data)
+{
+	GtkWidget * widget;
+	DBusMessage * message;
+	DBusMessageIter args;
+	DBusError error;
+	char * parameter = NULL;
+	dbus_int32_t iparam = 0, t = 0;
+
+	//printerr (_("NXLAUNCH> Listening for status information\n"));
+
+	dbus_error_init (&error);
+
+	if (dbus_error_is_set(&error)) { 
+		printerr ("NXLAUNCH> Name Error (%s)\n", error.message); 
+		dbus_error_free(&error); 
+	}
+
+	// non blocking read of the next available message
+	dbus_connection_read_write(dbusConn, 0);
+	message = dbus_connection_pop_message(dbusConn);
+
+	// return if no message
+	if (NULL == message) { return TRUE; }
+
+	if (dbus_message_is_signal (message, dbusRecvInterface, "InfoMessage")) {
+
+		if (!dbus_message_iter_init (message, &args)) {
+			printerr ("NXLAUNCH> That message had no arguments.\n");
+			dbus_connection_flush (dbusConn);
+			dbus_message_unref (message);
+			return TRUE;
+		}
+		printerr ("(NXCL)> Info: ");
+		do {
+			if (DBUS_TYPE_STRING == (t = dbus_message_iter_get_arg_type(&args))) {
+				dbus_message_iter_get_basic(&args, &parameter);
+				printerr (" '%s'", parameter);
+				widget = glade_xml_get_widget (xml_nxlaunch_glob, "label_progress");
+				gtk_label_set_text (GTK_LABEL (widget), parameter);
+			} else if (t == DBUS_TYPE_INT32) {
+		 			dbus_message_iter_get_basic (&args, &iparam);
+					printerr (" d%d", iparam);
+					/* We used the integer passed with these progress signals to set the progress bar */
+					widget = glade_xml_get_widget (xml_nxlaunch_glob, "progressbar");
+					switch (iparam) {
+					case 700: /* 'Got a session ID' */
+						gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (widget), 0.125);
+						break;
+					case 702: /* 'Got a proxy IP' or 'All data will be SSL tunnelled' */
+						if (gtk_progress_bar_get_fraction (GTK_PROGRESS_BAR (widget)) < 0.300) {
+							gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (widget), 0.250);
+						} else {
+							gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (widget), 0.500);
+						}
+						break;
+					case 706: /* 'Got an agent cookie' */
+						gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (widget), 0.375);
+						break;
+					case 710: /* 'Session status is "running"' */
+						gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (widget), 0.625);
+						break;
+					case 1000007: /* 'Starting NX session' */
+						gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (widget), 0.750);
+						break;
+					case 1000001: /* 'nxproxy process started' */
+						gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (widget), 0.825);
+						break;
+					case 287: /* 'The session has been started successfully' */
+						gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (widget), 1.000);
+						while (gtk_events_pending()) gtk_main_iteration();
+						usleep (2000000);
+						gtk_main_quit();
+						break;
+					default:
+						break;
+					}
+			} else {
+				printerr ("NXLAUNCH> Error, parameter is not string or int.\n");
+			}
+
+		} while (dbus_message_iter_next (&args));
+		printerr ("\n");
+
+	} else if (dbus_message_is_signal (message, dbusRecvInterface, "ErrorMessage")) {
+
+		if (!dbus_message_iter_init (message, &args)) {
+			printerr ("NXLAUNCH> That message had no arguments.\n");
+			dbus_connection_flush (dbusConn);
+			dbus_message_unref (message);
+			return TRUE;
+		}
+
+		printerr ("(NXCL)> Error: ");
+		do {
+			if (DBUS_TYPE_STRING == (t = dbus_message_iter_get_arg_type(&args))) {
+				dbus_message_iter_get_basic(&args, &parameter);
+				printerr (" '%s'", parameter);
+				widget = glade_xml_get_widget (xml_nxlaunch_glob, "label_progress");
+				gtk_label_set_text (GTK_LABEL (widget), parameter);
+
+			} else if (t == DBUS_TYPE_INT32) {
+					dbus_message_iter_get_basic (&args, &iparam);
+					printerr (" d%d", iparam);
+			} else {
+				printerr ("NXLAUNCH> Error, parameter is not string or int.\n");
+			}
+
+		} while (dbus_message_iter_next (&args));
+		printerr ("\n");
+
+	} else {
+		/* Nothing */
+	}	
+	
+	dbus_connection_flush (dbusConn);
+	dbus_message_unref (message);
+
+	return TRUE;
+}
+
+gboolean waitForAlive (void)
+{
+	DBusMessage * message = NULL;
+	DBusMessageIter args;
+	DBusError error;
+	char * parameter = NULL;
+	dbus_int32_t iparam = 0, t = 0;
+	gboolean nxclAlive = FALSE;
+	int i = 0;
+
+	dbus_error_init (&error);
+
+	while (nxclAlive == FALSE && i<60) {
+
+		i++;
+
+		if (dbus_error_is_set(&error)) { 
+			printerr ("NXLAUNCH> Name Error (%s)\n", error.message); 
+			dbus_error_free(&error); 
+		}
+
+		// non blocking read of the next available message
+		dbus_connection_read_write(dbusConn, 0);
+		message = dbus_connection_pop_message(dbusConn);
+
+		// return if no message
+		if (NULL == message) {
+			usleep (1000000);
+			continue;
+		}
+
+		if (dbus_message_is_signal (message, dbusRecvInterface, "InfoMessage")) {
+
+			if (!dbus_message_iter_init (message, &args)) {
+				printerr ("NXLAUNCH> That message had no arguments.\n");
+				dbus_connection_flush (dbusConn);
+				dbus_message_unref (message);
+				continue;
+			}
+
+			do {
+				if (DBUS_TYPE_STRING == (t = dbus_message_iter_get_arg_type(&args))) {
+					dbus_message_iter_get_basic(&args, &parameter);
+				} else if (t == DBUS_TYPE_INT32) {
+		 			dbus_message_iter_get_basic (&args, &iparam);
+					if (iparam == NXCL_ALIVE) {
+						/* Set global variable to say we're alive */
+						nxclAlive = TRUE;
+					}
+				} else {
+					printerr ("NXLAUNCH> Error, parameter is not string or int.\n");
+				}
+
+			} while (dbus_message_iter_next (&args));
+
+		} else {
+			/* Nothing */
+		}	
+	}
+	dbus_connection_flush (dbusConn);
+	dbus_message_unref (message);
+
+	if (i<60 && nxclAlive == TRUE) {
+		return TRUE;
+	} else {
+		return FALSE;
+	}
+}
+
+void nxlaunch_error_requiring_quit (const char * message)
+{
+	GtkWidget * widget;
+	
+	/* Grey out all the other windows */
+	widget = glade_xml_get_widget (xml_nxlaunch_glob, "nxlauncher");
+	gtk_widget_set_sensitive (widget, FALSE);
+	widget = glade_xml_get_widget (xml_nxlaunch_glob, "session_list");
+	gtk_widget_set_sensitive (widget, FALSE);
+	widget = glade_xml_get_widget (xml_nxlaunch_glob, "nxlaunch_progress");
+	gtk_widget_set_sensitive (widget, FALSE);
+	widget = glade_xml_get_widget (xml_nxlaunch_glob, "dialog_password");
+	gtk_widget_set_sensitive (widget, FALSE);
+	while (gtk_events_pending()) gtk_main_iteration();
+
+	/* Bring up the general error window, with quit button */
+	widget = glade_xml_get_widget (xml_nxlaunch_glob, "unrecoverable_error_message");
+	gtk_label_set_text (GTK_LABEL(widget), message);
+	widget = glade_xml_get_widget (xml_nxlaunch_glob, "unrecoverable_error");
+	gtk_widget_set_sensitive (widget, TRUE);
+	gtk_widget_show_all (widget);
+
+	return;
+}

Added: nxlaunch/src/nxlaunch.glade
===================================================================
--- nxlaunch/src/nxlaunch.glade	2007-09-16 20:16:05 UTC (rev 380)
+++ nxlaunch/src/nxlaunch.glade	2007-09-17 12:30:56 UTC (rev 381)
@@ -0,0 +1,1144 @@
+<?xml version="1.0" standalone="no"?> <!--*- mode: xml -*-->
+<!DOCTYPE glade-interface SYSTEM "http://glade.gnome.org/glade-2.0.dtd">
+
+<glade-interface>
+
+<widget class="GtkWindow" id="nxlauncher">
+  <property name="title" translatable="yes">NXLaunch</property>
+  <property name="type">GTK_WINDOW_TOPLEVEL</property>
+  <property name="window_position">GTK_WIN_POS_CENTER</property>
+  <property name="modal">False</property>
+  <property name="default_width">690</property>
+  <property name="default_height">200</property>
+  <property name="resizable">True</property>
+  <property name="destroy_with_parent">False</property>
+  <property name="icon">nx-icon.png</property>
+  <property name="decorated">True</property>
+  <property name="skip_taskbar_hint">False</property>
+  <property name="skip_pager_hint">False</property>
+  <property name="type_hint">GDK_WINDOW_TYPE_HINT_NORMAL</property>
+  <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
+  <signal name="destroy" handler="gtk_main_quit" last_modification_time="Thu, 02 Sep 2004 09:22:11 GMT"/>
+  <signal name="delete-event" handler="on_main_win_delete_event" last_modification_time="Thu, 02 Sep 2004 09:22:26 GMT"/>
+
+  <child>
+    <widget class="GtkHBox" id="hbox_nxlaunch1">
+      <property name="visible">True</property>
+      <property name="homogeneous">False</property>
+      <property name="spacing">0</property>
+
+      <child>
+	<widget class="GtkVBox" id="vbox_nxlaunch1">
+	  <property name="visible">True</property>
+	  <property name="homogeneous">False</property>
+	  <property name="spacing">0</property>
+
+	  <child>
+	    <widget class="GtkHBox" id="hbox87">
+	      <property name="visible">True</property>
+	      <property name="homogeneous">False</property>
+	      <property name="spacing">0</property>
+
+	      <child>
+		<widget class="GtkScrolledWindow" id="scrolledwindow_nxlaunch">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="hscrollbar_policy">GTK_POLICY_ALWAYS</property>
+		  <property name="vscrollbar_policy">GTK_POLICY_ALWAYS</property>
+		  <property name="shadow_type">GTK_SHADOW_NONE</property>
+		  <property name="window_placement">GTK_CORNER_TOP_LEFT</property>
+
+		  <child>
+		    <widget class="GtkViewport" id="viewport_nxlaunch">
+		      <property name="visible">True</property>
+		      <property name="shadow_type">GTK_SHADOW_IN</property>
+
+		      <child>
+			<widget class="GtkTreeView" id="treeview_nxconnection">
+			  <property name="visible">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="headers_visible">True</property>
+			  <property name="rules_hint">True</property>
+			  <property name="reorderable">False</property>
+			  <property name="enable_search">True</property>
+			  <signal name="row_activated" handler="on_button_nxlaunch_launch_clicked" last_modification_time="Tue, 21 Aug 2007 14:02:34 GMT"/>
+			  <signal name="cursor_changed" handler="on_treeview_connection_cursor_changed" last_modification_time="Wed, 12 Sep 2007 12:45:25 GMT"/>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">True</property>
+		  <property name="fill">True</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkVButtonBox" id="vbuttonbox1">
+		  <property name="visible">True</property>
+		  <property name="layout_style">GTK_BUTTONBOX_START</property>
+		  <property name="spacing">0</property>
+
+		  <child>
+		    <widget class="GtkButton" id="button_nxlaunch_new">
+		      <property name="tooltip" translatable="yes">Configure a new NX connection</property>
+		      <property name="can_default">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="label">gtk-new</property>
+		      <property name="use_stock">True</property>
+		      <property name="relief">GTK_RELIEF_NORMAL</property>
+		      <property name="focus_on_click">True</property>
+		      <signal name="clicked" handler="on_button_nxlaunch_new_clicked" last_modification_time="Mon, 20 Aug 2007 15:10:34 GMT"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="button_nxlaunch_edit">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Edit the selected NX connection</property>
+		      <property name="can_default">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="label">gtk-edit</property>
+		      <property name="use_stock">True</property>
+		      <property name="relief">GTK_RELIEF_NORMAL</property>
+		      <property name="focus_on_click">True</property>
+		      <signal name="clicked" handler="on_button_nxlaunch_edit_clicked" last_modification_time="Mon, 20 Aug 2007 15:10:27 GMT"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="button_nxlaunch_delete">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Delete the selected NX connection</property>
+		      <property name="can_default">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="label">gtk-delete</property>
+		      <property name="use_stock">True</property>
+		      <property name="relief">GTK_RELIEF_NORMAL</property>
+		      <property name="focus_on_click">True</property>
+		      <signal name="clicked" handler="on_button_nxlaunch_delete_clicked" last_modification_time="Mon, 20 Aug 2007 15:10:19 GMT"/>
+		    </widget>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="padding">0</property>
+	      <property name="expand">True</property>
+	      <property name="fill">True</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkHBox" id="hbox86">
+	      <property name="visible">True</property>
+	      <property name="homogeneous">False</property>
+	      <property name="spacing">0</property>
+
+	      <child>
+		<widget class="GtkLabel" id="label223">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Username:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0.5</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">5</property>
+		  <property name="ypad">0</property>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkEntry" id="entry_nxlaunch_user">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="editable">True</property>
+		  <property name="visibility">True</property>
+		  <property name="max_length">0</property>
+		  <property name="text" translatable="yes"></property>
+		  <property name="has_frame">True</property>
+		  <property name="invisible_char">*</property>
+		  <property name="activates_default">False</property>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkLabel" id="label224">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Password:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0.5</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">5</property>
+		  <property name="ypad">0</property>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkEntry" id="entry_nxlaunch_password">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="has_focus">True</property>
+		  <property name="editable">True</property>
+		  <property name="visibility">False</property>
+		  <property name="max_length">0</property>
+		  <property name="text" translatable="yes"></property>
+		  <property name="has_frame">True</property>
+		  <property name="invisible_char">*</property>
+		  <property name="activates_default">True</property>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkHButtonBox" id="hbuttonbox1">
+		  <property name="visible">True</property>
+		  <property name="layout_style">GTK_BUTTONBOX_EDGE</property>
+		  <property name="spacing">20</property>
+
+		  <child>
+		    <widget class="GtkButton" id="button_nxlaunch_launch">
+		      <property name="visible">True</property>
+		      <property name="can_default">True</property>
+		      <property name="has_default">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="relief">GTK_RELIEF_NORMAL</property>
+		      <property name="focus_on_click">True</property>
+		      <signal name="clicked" handler="on_button_nxlaunch_launch_clicked" last_modification_time="Tue, 11 Sep 2007 15:54:42 GMT"/>
+
+		      <child>
+			<widget class="GtkAlignment" id="alignment46">
+			  <property name="visible">True</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xscale">0</property>
+			  <property name="yscale">0</property>
+			  <property name="top_padding">0</property>
+			  <property name="bottom_padding">0</property>
+			  <property name="left_padding">0</property>
+			  <property name="right_padding">0</property>
+
+			  <child>
+			    <widget class="GtkHBox" id="hbox88">
+			      <property name="visible">True</property>
+			      <property name="homogeneous">False</property>
+			      <property name="spacing">2</property>
+
+			      <child>
+				<widget class="GtkImage" id="image37">
+				  <property name="visible">True</property>
+				  <property name="stock">gtk-network</property>
+				  <property name="icon_size">4</property>
+				  <property name="xalign">0.5</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xpad">0</property>
+				  <property name="ypad">0</property>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">False</property>
+				  <property name="fill">False</property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkLabel" id="label225">
+				  <property name="visible">True</property>
+				  <property name="label" translatable="yes">_Launch</property>
+				  <property name="use_underline">True</property>
+				  <property name="use_markup">False</property>
+				  <property name="justify">GTK_JUSTIFY_LEFT</property>
+				  <property name="wrap">False</property>
+				  <property name="selectable">False</property>
+				  <property name="xalign">0.5</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xpad">0</property>
+				  <property name="ypad">0</property>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">False</property>
+				  <property name="fill">False</property>
+				</packing>
+			      </child>
+			    </widget>
+			  </child>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="button_nxlaunch_quit">
+		      <property name="visible">True</property>
+		      <property name="can_default">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="label">gtk-quit</property>
+		      <property name="use_stock">True</property>
+		      <property name="relief">GTK_RELIEF_NORMAL</property>
+		      <property name="focus_on_click">True</property>
+		      <signal name="clicked" handler="on_button_nxlaunch_quit_clicked" last_modification_time="Tue, 11 Sep 2007 15:54:36 GMT"/>
+		    </widget>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">True</property>
+		  <property name="fill">True</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="padding">0</property>
+	      <property name="expand">False</property>
+	      <property name="fill">False</property>
+	    </packing>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">True</property>
+	  <property name="fill">True</property>
+	</packing>
+      </child>
+    </widget>
+  </child>
+</widget>
+
+<widget class="GtkWindow" id="session_list">
+  <property name="title" translatable="yes">Available Sessions</property>
+  <property name="type">GTK_WINDOW_TOPLEVEL</property>
+  <property name="window_position">GTK_WIN_POS_CENTER_ON_PARENT</property>
+  <property name="modal">False</property>
+  <property name="default_width">600</property>
+  <property name="default_height">220</property>
+  <property name="resizable">True</property>
+  <property name="destroy_with_parent">False</property>
+  <property name="icon">nx-icon.png</property>
+  <property name="decorated">True</property>
+  <property name="skip_taskbar_hint">False</property>
+  <property name="skip_pager_hint">False</property>
+  <property name="type_hint">GDK_WINDOW_TYPE_HINT_NORMAL</property>
+  <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
+
+  <child>
+    <widget class="GtkVBox" id="vbox_nxsession1">
+      <property name="visible">True</property>
+      <property name="homogeneous">False</property>
+      <property name="spacing">0</property>
+
+      <child>
+	<widget class="GtkScrolledWindow" id="scrolledwindow_nxsession">
+	  <property name="visible">True</property>
+	  <property name="can_focus">True</property>
+	  <property name="hscrollbar_policy">GTK_POLICY_ALWAYS</property>
+	  <property name="vscrollbar_policy">GTK_POLICY_ALWAYS</property>
+	  <property name="shadow_type">GTK_SHADOW_NONE</property>
+	  <property name="window_placement">GTK_CORNER_TOP_LEFT</property>
+
+	  <child>
+	    <widget class="GtkViewport" id="viewport_nxsession">
+	      <property name="visible">True</property>
+	      <property name="shadow_type">GTK_SHADOW_IN</property>
+
+	      <child>
+		<widget class="GtkTreeView" id="treeview_nxsession">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="headers_visible">True</property>
+		  <property name="rules_hint">True</property>
+		  <property name="reorderable">False</property>
+		  <property name="enable_search">True</property>
+		  <signal name="row_activated" handler="on_button_nxsession_connect_clicked" last_modification_time="Mon, 20 Aug 2007 15:45:22 GMT"/>
+		  <signal name="toggle_cursor_row" handler="on_nxsession_toggle_cursor_row" last_modification_time="Fri, 07 Sep 2007 13:22:11 GMT"/>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">True</property>
+	  <property name="fill">True</property>
+	</packing>
+      </child>
+
+      <child>
+	<widget class="GtkHBox" id="hbox_nxsession1">
+	  <property name="visible">True</property>
+	  <property name="homogeneous">False</property>
+	  <property name="spacing">0</property>
+
+	  <child>
+	    <widget class="GtkHButtonBox" id="hbuttonbox_nxsession_l">
+	      <property name="visible">True</property>
+	      <property name="layout_style">GTK_BUTTONBOX_START</property>
+	      <property name="spacing">0</property>
+
+	      <child>
+		<widget class="GtkButton" id="button_nxsession_connect">
+		  <property name="visible">True</property>
+		  <property name="tooltip" translatable="yes">Connect to the selected NX session</property>
+		  <property name="can_default">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="relief">GTK_RELIEF_NORMAL</property>
+		  <property name="focus_on_click">True</property>
+		  <signal name="clicked" handler="on_button_nxsession_connect_clicked" last_modification_time="Mon, 20 Aug 2007 15:12:07 GMT"/>
+		  <signal name="clicked" handler="gtk_widget_hide" after="yes" object="session_list" last_modification_time="Fri, 07 Sep 2007 15:02:26 GMT"/>
+
+		  <child>
+		    <widget class="GtkAlignment" id="alignment44">
+		      <property name="visible">True</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xscale">0</property>
+		      <property name="yscale">0</property>
+		      <property name="top_padding">0</property>
+		      <property name="bottom_padding">0</property>
+		      <property name="left_padding">0</property>
+		      <property name="right_padding">0</property>
+
+		      <child>
+			<widget class="GtkHBox" id="hbox84">
+			  <property name="visible">True</property>
+			  <property name="homogeneous">False</property>
+			  <property name="spacing">2</property>
+
+			  <child>
+			    <widget class="GtkImage" id="image35">
+			      <property name="visible">True</property>
+			      <property name="stock">gtk-ok</property>
+			      <property name="icon_size">4</property>
+			      <property name="xalign">0.5</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkLabel" id="label221">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">_Connect</property>
+			      <property name="use_underline">True</property>
+			      <property name="use_markup">False</property>
+			      <property name="justify">GTK_JUSTIFY_LEFT</property>
+			      <property name="wrap">False</property>
+			      <property name="selectable">False</property>
+			      <property name="xalign">0.5</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+
+	      <child>
+		<widget class="GtkButton" id="button_nxsession_launch">
+		  <property name="visible">True</property>
+		  <property name="tooltip" translatable="yes">Start a new NX session</property>
+		  <property name="can_default">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="relief">GTK_RELIEF_NORMAL</property>
+		  <property name="focus_on_click">True</property>
+		  <signal name="clicked" handler="on_button_nxsession_launch_clicked" after="yes" last_modification_time="Mon, 20 Aug 2007 15:12:19 GMT"/>
+		  <signal name="clicked" handler="gtk_widget_hide" after="yes" object="session_list" last_modification_time="Fri, 07 Sep 2007 15:02:10 GMT"/>
+
+		  <child>
+		    <widget class="GtkAlignment" id="alignment43">
+		      <property name="visible">True</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xscale">0</property>
+		      <property name="yscale">0</property>
+		      <property name="top_padding">0</property>
+		      <property name="bottom_padding">0</property>
+		      <property name="left_padding">0</property>
+		      <property name="right_padding">0</property>
+
+		      <child>
+			<widget class="GtkHBox" id="hbox83">
+			  <property name="visible">True</property>
+			  <property name="homogeneous">False</property>
+			  <property name="spacing">2</property>
+
+			  <child>
+			    <widget class="GtkImage" id="image34">
+			      <property name="visible">True</property>
+			      <property name="stock">gtk-network</property>
+			      <property name="icon_size">4</property>
+			      <property name="xalign">0.5</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkLabel" id="label220">
+			      <property name="visible">True</property>
+			      <property name="label">_Launch New</property>
+			      <property name="use_underline">True</property>
+			      <property name="use_markup">False</property>
+			      <property name="justify">GTK_JUSTIFY_LEFT</property>
+			      <property name="wrap">False</property>
+			      <property name="selectable">False</property>
+			      <property name="xalign">0.5</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+
+	      <child>
+		<widget class="GtkButton" id="button_nxsession_terminate">
+		  <property name="visible">True</property>
+		  <property name="tooltip" translatable="yes">Terminate the selected NX session</property>
+		  <property name="can_default">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="relief">GTK_RELIEF_NORMAL</property>
+		  <property name="focus_on_click">True</property>
+		  <signal name="clicked" handler="on_button_nxsession_terminate_clicked" last_modification_time="Mon, 20 Aug 2007 15:12:35 GMT"/>
+
+		  <child>
+		    <widget class="GtkAlignment" id="alignment42">
+		      <property name="visible">True</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xscale">0</property>
+		      <property name="yscale">0</property>
+		      <property name="top_padding">0</property>
+		      <property name="bottom_padding">0</property>
+		      <property name="left_padding">0</property>
+		      <property name="right_padding">0</property>
+
+		      <child>
+			<widget class="GtkHBox" id="hbox82">
+			  <property name="visible">True</property>
+			  <property name="homogeneous">False</property>
+			  <property name="spacing">2</property>
+
+			  <child>
+			    <widget class="GtkImage" id="image33">
+			      <property name="visible">True</property>
+			      <property name="stock">gtk-delete</property>
+			      <property name="icon_size">4</property>
+			      <property name="xalign">0.5</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkLabel" id="label219">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">Terminate</property>
+			      <property name="use_underline">True</property>
+			      <property name="use_markup">False</property>
+			      <property name="justify">GTK_JUSTIFY_LEFT</property>
+			      <property name="wrap">False</property>
+			      <property name="selectable">False</property>
+			      <property name="xalign">0.5</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="padding">0</property>
+	      <property name="expand">False</property>
+	      <property name="fill">False</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkHButtonBox" id="hbuttonbox_nxsession_r">
+	      <property name="visible">True</property>
+	      <property name="layout_style">GTK_BUTTONBOX_END</property>
+	      <property name="spacing">0</property>
+
+	      <child>
+		<widget class="GtkButton" id="button_nxsession_cancel">
+		  <property name="visible">True</property>
+		  <property name="tooltip" translatable="yes">Return to the main NXLaunch window</property>
+		  <property name="can_default">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="label">gtk-cancel</property>
+		  <property name="use_stock">True</property>
+		  <property name="relief">GTK_RELIEF_NORMAL</property>
+		  <property name="focus_on_click">True</property>
+		  <signal name="clicked" handler="on_button_nxsession_cancel_clicked" last_modification_time="Mon, 20 Aug 2007 15:12:41 GMT"/>
+		</widget>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="padding">0</property>
+	      <property name="expand">True</property>
+	      <property name="fill">True</property>
+	    </packing>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">False</property>
+	</packing>
+      </child>
+    </widget>
+  </child>
+</widget>
+
+<widget class="GtkDialog" id="dialog_password">
+  <property name="title" translatable="yes">Password</property>
+  <property name="type">GTK_WINDOW_TOPLEVEL</property>
+  <property name="window_position">GTK_WIN_POS_CENTER_ON_PARENT</property>
+  <property name="modal">False</property>
+  <property name="resizable">True</property>
+  <property name="destroy_with_parent">False</property>
+  <property name="icon">nx-icon.png</property>
+  <property name="decorated">True</property>
+  <property name="skip_taskbar_hint">False</property>
+  <property name="skip_pager_hint">False</property>
+  <property name="type_hint">GDK_WINDOW_TYPE_HINT_DIALOG</property>
+  <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
+  <property name="has_separator">True</property>
+
+  <child internal-child="vbox">
+    <widget class="GtkVBox" id="dialog-vbox1">
+      <property name="visible">True</property>
+      <property name="homogeneous">False</property>
+      <property name="spacing">0</property>
+
+      <child internal-child="action_area">
+	<widget class="GtkHButtonBox" id="dialog-action_area1">
+	  <property name="visible">True</property>
+	  <property name="layout_style">GTK_BUTTONBOX_END</property>
+
+	  <child>
+	    <widget class="GtkButton" id="cancelbutton1">
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-cancel</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <property name="response_id">-6</property>
+	      <signal name="clicked" handler="on_button_password_cancel_clicked" last_modification_time="Fri, 07 Sep 2007 15:49:16 GMT"/>
+	      <signal name="clicked" handler="gtk_widget_hide" after="yes" object="dialog_password" last_modification_time="Fri, 07 Sep 2007 15:49:33 GMT"/>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkButton" id="okbutton1">
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="has_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-ok</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <property name="response_id">-5</property>
+	      <signal name="clicked" handler="on_button_password_ok_clicked" after="yes" last_modification_time="Sun, 02 Sep 2007 09:44:23 GMT"/>
+	    </widget>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">True</property>
+	  <property name="pack_type">GTK_PACK_END</property>
+	</packing>
+      </child>
+
+      <child>
+	<widget class="GtkFrame" id="frame1">
+	  <property name="visible">True</property>
+	  <property name="label_xalign">0</property>
+	  <property name="label_yalign">0.5</property>
+	  <property name="shadow_type">GTK_SHADOW_NONE</property>
+
+	  <child>
+	    <widget class="GtkAlignment" id="alignment45">
+	      <property name="visible">True</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xscale">1</property>
+	      <property name="yscale">1</property>
+	      <property name="top_padding">0</property>
+	      <property name="bottom_padding">0</property>
+	      <property name="left_padding">0</property>
+	      <property name="right_padding">0</property>
+
+	      <child>
+		<widget class="GtkEntry" id="entry_password_dialog">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="has_focus">True</property>
+		  <property name="editable">True</property>
+		  <property name="visibility">False</property>
+		  <property name="max_length">255</property>
+		  <property name="text" translatable="yes"></property>
+		  <property name="has_frame">True</property>
+		  <property name="invisible_char">*</property>
+		  <property name="activates_default">True</property>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="label222">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">&lt;i&gt;Enter the session password:&lt;/i&gt;</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">True</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	    </widget>
+	    <packing>
+	      <property name="type">label_item</property>
+	    </packing>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">True</property>
+	  <property name="fill">True</property>
+	</packing>
+      </child>
+    </widget>
+  </child>
+</widget>
+
+<widget class="GtkDialog" id="nxlaunch_progress">
+  <property name="title" translatable="yes">Launch Status</property>
+  <property name="type">GTK_WINDOW_TOPLEVEL</property>
+  <property name="window_position">GTK_WIN_POS_CENTER_ON_PARENT</property>
+  <property name="modal">False</property>
+  <property name="default_width">350</property>
+  <property name="resizable">True</property>
+  <property name="destroy_with_parent">False</property>
+  <property name="icon">nx-icon.png</property>
+  <property name="decorated">True</property>
+  <property name="skip_taskbar_hint">False</property>
+  <property name="skip_pager_hint">False</property>
+  <property name="type_hint">GDK_WINDOW_TYPE_HINT_DIALOG</property>
+  <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
+  <property name="has_separator">True</property>
+
+  <child internal-child="vbox">
+    <widget class="GtkVBox" id="dialog-vbox3">
+      <property name="visible">True</property>
+      <property name="homogeneous">False</property>
+      <property name="spacing">0</property>
+
+      <child internal-child="action_area">
+	<widget class="GtkHButtonBox" id="dialog-action_area3">
+	  <property name="visible">True</property>
+	  <property name="layout_style">GTK_BUTTONBOX_END</property>
+
+	  <child>
+	    <widget class="GtkButton" id="button1">
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-cancel</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <property name="response_id">-6</property>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkButton" id="button_progress_quit">
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-quit</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <property name="response_id">0</property>
+	    </widget>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">True</property>
+	  <property name="pack_type">GTK_PACK_END</property>
+	</packing>
+      </child>
+
+      <child>
+	<widget class="GtkVBox" id="vbox1">
+	  <property name="visible">True</property>
+	  <property name="homogeneous">False</property>
+	  <property name="spacing">0</property>
+
+	  <child>
+	    <widget class="GtkAlignment" id="alignment47">
+	      <property name="visible">True</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xscale">1</property>
+	      <property name="yscale">1</property>
+	      <property name="top_padding">8</property>
+	      <property name="bottom_padding">8</property>
+	      <property name="left_padding">8</property>
+	      <property name="right_padding">8</property>
+
+	      <child>
+		<widget class="GtkProgressBar" id="progressbar">
+		  <property name="visible">True</property>
+		  <property name="orientation">GTK_PROGRESS_LEFT_TO_RIGHT</property>
+		  <property name="fraction">0</property>
+		  <property name="pulse_step">0.10000000149</property>
+		</widget>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="padding">0</property>
+	      <property name="expand">False</property>
+	      <property name="fill">False</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkHSeparator" id="hseparator1">
+	      <property name="visible">True</property>
+	    </widget>
+	    <packing>
+	      <property name="padding">0</property>
+	      <property name="expand">False</property>
+	      <property name="fill">False</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkHBox" id="hbox89">
+	      <property name="visible">True</property>
+	      <property name="homogeneous">False</property>
+	      <property name="spacing">0</property>
+
+	      <child>
+		<widget class="GtkImage" id="image38">
+		  <property name="visible">True</property>
+		  <property name="pixbuf">nx-icon.png</property>
+		  <property name="xalign">0.5</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">9</property>
+		  <property name="ypad">0</property>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkLabel" id="label_progress">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Launching session...</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">True</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">7</property>
+		  <property name="ypad">10</property>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="padding">0</property>
+	      <property name="expand">False</property>
+	      <property name="fill">True</property>
+	    </packing>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">True</property>
+	  <property name="fill">True</property>
+	</packing>
+      </child>
+    </widget>
+  </child>
+</widget>
+
+<widget class="GtkDialog" id="unrecoverable_error">
+  <property name="title" translatable="yes">Error</property>
+  <property name="type">GTK_WINDOW_TOPLEVEL</property>
+  <property name="window_position">GTK_WIN_POS_CENTER_ON_PARENT</property>
+  <property name="modal">False</property>
+  <property name="resizable">True</property>
+  <property name="destroy_with_parent">False</property>
+  <property name="decorated">True</property>
+  <property name="skip_taskbar_hint">False</property>
+  <property name="skip_pager_hint">False</property>
+  <property name="type_hint">GDK_WINDOW_TYPE_HINT_DIALOG</property>
+  <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
+  <property name="has_separator">True</property>
+
+  <child internal-child="vbox">
+    <widget class="GtkVBox" id="dialog-vbox4">
+      <property name="visible">True</property>
+      <property name="homogeneous">False</property>
+      <property name="spacing">0</property>
+
+      <child internal-child="action_area">
+	<widget class="GtkHButtonBox" id="dialog-action_area4">
+	  <property name="visible">True</property>
+	  <property name="layout_style">GTK_BUTTONBOX_END</property>
+
+	  <child>
+	    <widget class="GtkButton" id="button2">
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-quit</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <property name="response_id">0</property>
+	      <signal name="clicked" handler="gtk_main_quit" last_modification_time="Sat, 15 Sep 2007 21:00:52 GMT"/>
+	    </widget>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">True</property>
+	  <property name="pack_type">GTK_PACK_END</property>
+	</packing>
+      </child>
+
+      <child>
+	<widget class="GtkHBox" id="hbox90">
+	  <property name="visible">True</property>
+	  <property name="homogeneous">False</property>
+	  <property name="spacing">0</property>
+
+	  <child>
+	    <widget class="GtkImage" id="image39">
+	      <property name="width_request">32</property>
+	      <property name="height_request">32</property>
+	      <property name="visible">True</property>
+	      <property name="pixbuf">nx-icon.png</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	    </widget>
+	    <packing>
+	      <property name="padding">0</property>
+	      <property name="expand">False</property>
+	      <property name="fill">False</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="unrecoverable_error_message">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Error...</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	    </widget>
+	    <packing>
+	      <property name="padding">0</property>
+	      <property name="expand">False</property>
+	      <property name="fill">False</property>
+	    </packing>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">True</property>
+	</packing>
+      </child>
+    </widget>
+  </child>
+</widget>
+
+<widget class="GtkDialog" id="dialog_general_error">
+  <property name="title" translatable="yes">Error</property>
+  <property name="type">GTK_WINDOW_TOPLEVEL</property>
+  <property name="window_position">GTK_WIN_POS_CENTER_ON_PARENT</property>
+  <property name="modal">True</property>
+  <property name="default_width">400</property>
+  <property name="default_height">200</property>
+  <property name="resizable">True</property>
+  <property name="destroy_with_parent">False</property>
+  <property name="icon">nx-icon.png</property>
+  <property name="decorated">True</property>
+  <property name="skip_taskbar_hint">False</property>
+  <property name="skip_pager_hint">False</property>
+  <property name="type_hint">GDK_WINDOW_TYPE_HINT_DIALOG</property>
+  <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
+  <property name="has_separator">True</property>
+  <signal name="delete_event" handler="gtk_widget_hide" object="dialog_failed_download" last_modification_time="Fri, 14 Oct 2005 14:06:55 GMT"/>
+
+  <child internal-child="vbox">
+    <widget class="GtkVBox" id="vbox63">
+      <property name="visible">True</property>
+      <property name="homogeneous">False</property>
+      <property name="spacing">0</property>
+
+      <child internal-child="action_area">
+	<widget class="GtkHButtonBox" id="hbuttonbox17">
+	  <property name="visible">True</property>
+	  <property name="layout_style">GTK_BUTTONBOX_END</property>
+
+	  <child>
+	    <widget class="GtkButton" id="button_general_error_ok">
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-ok</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <property name="response_id">-5</property>
+	      <signal name="clicked" handler="gtk_widget_hide" object="dialog_general_error" last_modification_time="Thu, 29 Sep 2005 20:59:53 GMT"/>
+	    </widget>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">True</property>
+	  <property name="pack_type">GTK_PACK_END</property>
+	</packing>
+      </child>
+
+      <child>
+	<widget class="GtkLabel" id="label_general_error">
+	  <property name="visible">True</property>
+	  <property name="label" translatable="yes">Error</property>
+	  <property name="use_underline">False</property>
+	  <property name="use_markup">False</property>
+	  <property name="justify">GTK_JUSTIFY_CENTER</property>
+	  <property name="wrap">True</property>
+	  <property name="selectable">False</property>
+	  <property name="xalign">0.469999998808</property>
+	  <property name="yalign">0.509999990463</property>
+	  <property name="xpad">0</property>
+	  <property name="ypad">0</property>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">True</property>
+	  <property name="fill">False</property>
+	</packing>
+      </child>
+    </widget>
+  </child>
+</widget>
+
+</glade-interface>

Added: nxlaunch/src/nxlaunch.h
===================================================================
--- nxlaunch/src/nxlaunch.h	2007-09-16 20:16:05 UTC (rev 380)
+++ nxlaunch/src/nxlaunch.h	2007-09-17 12:30:56 UTC (rev 381)
@@ -0,0 +1,356 @@
+/***************************************************************************
+                   nxlaunch: A GTK NX Client based on nxcl
+                   ---------------------------------------
+    begin                : September 2007
+    copyright            : (C) 2007 Embedded Software Foundry Ltd. (U.K.)
+                         :     Author: Sebastian James
+    email                : seb at esfnet.co.uk
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef _NXLAUNCH_H_
+#define _NXLAUNCH_H_ 1
+
+#define DBUS_API_SUBJECT_TO_CHANGE 1
+#include <dbus/dbus.h>
+#include "../lib/callbacks_nx.h"
+
+#ifdef DEBUG
+# if DEBUG==0
+# undef DEBUG
+# endif
+#endif
+
+#ifndef PRINTERR_DEFINED
+# define PRINTERR_DEFINED 1
+# ifdef DEBUG
+#  define printerr(args...)	fprintf(stderr, ## args);
+#  define printdbg(args...)	fprintf(stdout, ## args);
+# else
+#  define printerr(args...)
+#  define printdbg(args...)
+# endif
+#endif
+
+/*!
+ * Some definitions of numbers that we can send over to the frontend
+ * client to tell it how we're getting along with the connection...
+ * These should be the same as those found in nxcl/lib/nxdata.h.
+ */
+#define NXCL_PROCESS_STARTED        1000001
+#define NXCL_PROCESS_EXITED         1000002
+#define NXCL_AUTH_FAILED            1000003
+#define NXCL_AUTHENTICATING         1000004
+#define NXCL_LOGIN_FAILED           1000005
+#define NXCL_HOST_KEY_VERIFAILED    1000006
+#define NXCL_INVOKE_PROXY           1000007
+#define NXCL_STARTING               1000008
+#define NXCL_FINISHED               1000009
+#define NXCL_ALIVE                  1000010
+
+/*
+ * Column ids for NX Connection List - the list of configured NX connections 
+ * This mirrors nx_connection in callbacks_nx.h
+ */
+enum
+{
+	CONN_CONNECTIONNAME,
+	CONN_SERVERHOST,
+	CONN_SERVERPORT,
+	CONN_USER,
+	CONN_PASS,
+	CONN_REMEMBERPASS,
+	CONN_DISABLENODELAY,
+	CONN_DISABLEZLIB,
+	CONN_ENABLESSLONLY,
+	CONN_LINKSPEED,
+	CONN_PUBLICKEY,
+	CONN_DESKTOP,
+	CONN_CUSTOMUNIXDESKTOP,
+	CONN_COMMANDLINE,
+	CONN_VIRTUALDESKTOP,
+	CONN_XAGENTENCODING,
+	CONN_USETAINT,
+	CONN_XDMMODE,
+	CONN_XDMHOST,
+	CONN_XDMPORT,
+	CONN_FULLSCREEN,
+	CONN_RESOLUTIONWIDTH,
+	CONN_RESOLUTIONHEIGHT,
+	CONN_GEOMETRY,
+	CONN_IMAGEENCODING,
+	CONN_JPEGQUALITY,
+	CONN_ENABLESOUND,
+	CONN_IPPPORT,
+	CONN_IPPPRINTING,
+	CONN_SHARES,
+	CONN_AGENTSERVER,
+	CONN_AGENTUSER,
+	CONN_AGENTPASS,
+	N_CONN_COLUMNS        /* the number of entries here */
+};
+
+/*! Similar to NXResumeData in nxcl, but with gchar* instead of string*/
+struct NXResumeData {
+	int display;
+	gchar * sessionType;
+	gchar * sessionID;
+	gchar * options;
+	int depth;
+	gchar * screen;
+	gchar * available;
+	gchar * sessionName;
+};
+
+/*!
+ * Column ids for NX Session resume list. This appears when you
+ * connect to a server on which there are some running and suspended
+ * sessions that you could connect to.
+ * This mirrors NXResumeData above.
+ */
+enum
+{
+	SESS_INDEX,
+	SESS_DISPLAY,
+	SESS_SESSIONTYPE,
+	SESS_TYPEICON,
+	SESS_SESSIONID,
+	SESS_OPTIONS,
+	SESS_DEPTH,
+	SESS_SCREEN,
+	SESS_AVAILABLE,
+	SESS_SESSIONNAME,
+	N_SESS_COLUMNS        /* the number of entries here */
+};
+
+/*!
+ * Modes in which nxlaunch can be started
+ *
+ * MODE_MAIN - no switches given
+ * MODE_NAMED - just a name given
+ * MODE_FILE - a file switch given
+ * MODE_EDIT_NAMED - name and --edit switch given
+ * MODE_EDIT_FILE - file and --edit switch given
+ */
+enum
+{
+	MODE_MAIN,
+	MODE_NAMED,
+	MODE_FILE,
+	MODE_EDIT_NAMED,
+	MODE_EDIT_FILE,
+	N_MODES
+};
+
+/*!
+ * Function Declarations
+ */
+//@{
+
+/*!
+ * Callbacks for User Interface
+ */
+//@{
+void on_button_nxlaunch_launch_clicked (GtkButton * button);
+#if BUILT_IN_CONFIGURATION==1
+void on_button_nxlaunch_new_clicked (GtkButton * button);
+void on_button_nxlaunch_edit_clicked (GtkButton * button);
+void on_button_nxlaunch_delete_clicked (GtkButton * button);
+/*!
+ * Called when the OK button is clicked in the config window. On this
+ * callback we need to read the data from the window into an nx_conn
+ * structure then read that data into the relevant field in the
+ * connection list.
+ */
+void on_conn_new_ok_clicked (GtkButton * button);
+#endif
+void on_button_nxlaunch_quit_clicked (GtkButton * button);
+void on_button_nxsession_connect_clicked (GtkButton * button);
+void on_button_nxsession_launch_clicked (GtkButton * button);
+void on_button_nxsession_terminate_clicked (GtkButton * button);
+void on_button_nxsession_cancel_clicked (GtkButton * button);
+/*!
+ * \brief Set the password in nx_conn and launch the connection.
+ *
+ * This callback will check if there is an nx_connection structure in
+ * memory, pointed to by the global pointer nx_conn_glob. If there
+ * _is_ one, it will launch that connection using launch connection,
+ * after setting the password from the password dialogue box. If there
+ * is no nx_connection pointed to by the global pointer, it will
+ * malloc space for nx_conn, read in the active row from the
+ * tree_model in the main window, and then launch that connection.
+ */
+void on_button_password_ok_clicked (GtkButton * button);
+void on_button_password_cancel_clicked (GtkButton * button);
+/*!
+ * Called when you single click a row in the connection list. This
+ * function will update the user in the username entry box on the
+ * nxlauncher window.
+ */
+void on_treeview_connection_cursor_changed (GtkWidget * widget);
+
+//@}
+
+/*!
+ * Look in ~/.nx, and build a list of connections based on the number
+ * of .nxs files in there.
+ *
+ * Return number of connections.
+ */
+int nxconnection_buildlist (void);
+
+/*!
+ * Create the memory structure for the treelist of connections
+ */
+void nxlaunch_create_nxconnection_list (void);
+
+/*!
+ * Create the memory structure for the treelist of available sessions
+ */
+void nxlaunch_create_nxsession_list (void);
+
+/*!
+ * Send all the settings in a single dbus signal.
+ */
+int sendSettings (DBusConnection *bus, struct nx_connection * nx_conn);
+
+/*!
+ * Calls receiveSession and interprets the output.
+ *
+ * \param relist_call Set this to TRUE if this is a call to
+ * receiveSession to re-list the sessions in the session list, after
+ * terminating a session.
+ */
+void callReceiveSession (gboolean relist_call);
+
+/*!
+ * Used in receiveSession as the return value
+ */
+#define REPLY_REQUIRED  1
+#define NEW_CONNECTION  2
+#define SERVER_CAPACITY 3
+/*!
+ * Listen to the dbus, waiting for a signal to say either that
+ * connection is in progress, or giving us a list of possible sessions
+ * we could connect to. Return true if nxcld requires a reply such
+ * as "please resume session 1".
+ */
+int receiveSession (DBusConnection* conn);
+
+/*!
+ * Send a signal containing the identifier for the NX session that the
+ * user would like to start.
+ */
+int sendReply (DBusConnection *bus, int sessionNum);
+
+/*!
+ * Send a signal containing the identifier for the NX session that the
+ * user would like to terminate.
+ */
+int terminateSession (DBusConnection *bus, int sessionNum);
+
+/*!
+ * Set up DBUS.
+ *
+ * Uses global variables dbusConn and dbusErr which need to be set up
+ * in the main.c file.
+ *
+ * Returns the suffix of the dbus naming - e.g. 0 if dbusSendInterface
+ * is org.freenx.nxcl.client0 etc.
+ *
+ * Returns -1 on error.
+ */
+int obtainDbusConnection (void);
+
+
+/*!
+ * Fork and exec the nxcl process.
+ */
+void execNxcl (void);
+
+/*!
+ * Prepare DBUS for sending/receiving and then send the settings
+ */
+void sendNxclSettings (struct nx_connection * nx_conn);
+
+/*!
+ * Populate nx_conn from the treeview list.
+ */
+void getActiveConnection (struct nx_connection * nx_conn);
+
+/*!
+ * If there is a configured connection with the name connection_name,
+ * launch it by calling launch_connection.
+ */
+gboolean launch_named_connection (gchar * connection_name);
+
+/*!
+ * Launch the connection by calling nxcl, then communicating with it
+ * via dbus.
+ */
+void launch_connection (struct nx_connection * nx_conn);
+
+/*!
+ * Hide the main nxlaunch window
+ */
+void nxlauncher_hide (void);
+
+/*!
+ * Show the main nxlaunch window
+ */
+void nxlauncher_show (void);
+
+/*!
+ * Get the password field stored in the active (highlighted)
+ * connection. If there is a password, return TRUE, if the length of
+ * the password is 0, return FALSE.
+ */
+#define STORED_PASSWORD  0x1
+#define ENTERED_PASSWORD 0x2
+int checkActiveConnectionPassword (void);
+
+/*!
+ * Display a window saying "We're done", then exit after 5 seconds.
+ * This is so that the program doesn't appear to exit before the NX
+ * session window appears.
+ */
+void nxlaunch_quit_with_window (void);
+
+/*!
+ * Display a progress window, which could have a progress bar on it,
+ * and should have some text output to the user.
+ */
+void nxlaunch_display_progress (void);
+
+/*!
+ * A listener for dbus status messages. We use the contents of these
+ * messages to update the progress bar for user feedback on connection
+ * progress.
+ */
+gboolean nxlaunch_status_listener (gpointer data);
+
+/*!
+ * Wait for an alive message from nxcl. This function blocks until the
+ * message is received or a timeout has occurred.
+ */
+gboolean waitForAlive (void);
+
+/*!
+ * A non-recoverable error occurred. Show the user a dialog explaining
+ * the error, with a quit button as the only available option. Grey
+ * out all other windows.
+ *
+ * \param message The error message to display
+ */
+void nxlaunch_error_requiring_quit (const char * message);
+
+//@} Fn Declarations
+
+#endif /* _NXLAUNCH_H_ */

Added: nxlaunch/src/pixmaps/gnome-nx-session.png
===================================================================
(Binary files differ)


Property changes on: nxlaunch/src/pixmaps/gnome-nx-session.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: nxlaunch/src/pixmaps/kde-nx-session.png
===================================================================
(Binary files differ)


Property changes on: nxlaunch/src/pixmaps/kde-nx-session.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: nxlaunch/src/pixmaps/nx-icon.png
===================================================================
(Binary files differ)


Property changes on: nxlaunch/src/pixmaps/nx-icon.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: nxlaunch/src/pixmaps/nx-icon.xcf
===================================================================
(Binary files differ)


Property changes on: nxlaunch/src/pixmaps/nx-icon.xcf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: nxlaunch/src/pixmaps/nxclient-icon.png
===================================================================
(Binary files differ)


Property changes on: nxlaunch/src/pixmaps/nxclient-icon.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: nxlaunch/src/pixmaps/rdp-nx-session.png
===================================================================
(Binary files differ)


Property changes on: nxlaunch/src/pixmaps/rdp-nx-session.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: nxlaunch/src/pixmaps/unknown-nx-session.png
===================================================================
(Binary files differ)


Property changes on: nxlaunch/src/pixmaps/unknown-nx-session.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: nxlaunch/src/pixmaps/vnc-nx-session.png
===================================================================
(Binary files differ)


Property changes on: nxlaunch/src/pixmaps/vnc-nx-session.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



