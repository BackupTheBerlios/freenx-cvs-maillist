From gwright at mail.berlios.de  Wed Jan  2 13:39:06 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Wed, 2 Jan 2008 13:39:06 +0100
Subject: [Freenx-cvs] r428 - nxcl
Message-ID: <200801021239.m02Cd6RZ019486@sheep.berlios.de>

Author: gwright
Date: 2008-01-02 13:39:06 +0100 (Wed, 02 Jan 2008)
New Revision: 428

Added:
   nxcl/nxcl.pc.in
Modified:
   nxcl/Makefile.am
   nxcl/configure.ac
Log:
Add pkgconfig support to nxcl


Modified: nxcl/Makefile.am
===================================================================
--- nxcl/Makefile.am	2007-12-18 20:47:23 UTC (rev 427)
+++ nxcl/Makefile.am	2008-01-02 12:39:06 UTC (rev 428)
@@ -8,3 +8,8 @@
 MAINTAINERCLEANFILES = aclocal.m4 nxcl-*.tar.gz nxcl-*.tar.bz2 nxcl-*.diff
 
 INCLUDES = -I./lib
+
+pkgconfigdir = $(libdir)/pkgconfig
+pkgconfig_DATA = nxcl.pc
+
+EXTRA_DIST = nxcl.pc.in

Modified: nxcl/configure.ac
===================================================================
--- nxcl/configure.ac	2007-12-18 20:47:23 UTC (rev 427)
+++ nxcl/configure.ac	2008-01-02 12:39:06 UTC (rev 428)
@@ -71,6 +71,6 @@
 fi
 
 dnl Add in doc/Makefile to this:
-AC_CONFIG_FILES([Makefile lib/Makefile nxcl/Makefile test/Makefile doc/Makefile])
+AC_CONFIG_FILES([Makefile lib/Makefile nxcl/Makefile test/Makefile doc/Makefile nxcl.pc])
 
 AC_OUTPUT

Added: nxcl/nxcl.pc.in
===================================================================
--- nxcl/nxcl.pc.in	2007-12-18 20:47:23 UTC (rev 427)
+++ nxcl/nxcl.pc.in	2008-01-02 12:39:06 UTC (rev 428)
@@ -0,0 +1,14 @@
+# nxcl pkg-config source file
+
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@/nxcl
+
+Name: nxcl
+Description: NX client library
+Version: @VERSION@
+Requires: x11
+Conflicts:
+Libs: -L${libdir} -lnxcl
+Cflags: -I${includedir}



From gwright at mail.berlios.de  Thu Jan  3 13:25:34 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Thu, 3 Jan 2008 13:25:34 +0100
Subject: [Freenx-cvs] r429 - nxcl/lib
Message-ID: <200801031225.m03CPYxK023381@sheep.berlios.de>

Author: gwright
Date: 2008-01-03 13:25:34 +0100 (Thu, 03 Jan 2008)
New Revision: 429

Modified:
   nxcl/lib/nxclientlib.cpp
   nxcl/lib/nxclientlib.h
   nxcl/lib/nxsession.cpp
   nxcl/lib/nxsession.h
Log:
Changes to allow suspending/resuming using the old API (with slight modifications)


Modified: nxcl/lib/nxclientlib.cpp
===================================================================
--- nxcl/lib/nxclientlib.cpp	2008-01-02 12:39:06 UTC (rev 428)
+++ nxcl/lib/nxclientlib.cpp	2008-01-03 12:25:34 UTC (rev 429)
@@ -454,6 +454,16 @@
 	}
 }
 
+void NXClientLib::runSession ()
+{
+	session.runSession();
+	string a = "NX> 105";
+	string d = session.parseSSH(a);
+	if (d.size()>0) {
+		this->write(d);
+	}
+}
+
 string NXClientLib::parseSSH (string message)
 {
 	string rMessage;

Modified: nxcl/lib/nxclientlib.h
===================================================================
--- nxcl/lib/nxclientlib.h	2008-01-02 12:39:06 UTC (rev 428)
+++ nxcl/lib/nxclientlib.h	2008-01-03 12:25:34 UTC (rev 429)
@@ -222,8 +222,10 @@
 		 * \return true if the nth session is terminatable, false
 		 * if not, or if there is no nth session.
 		 */
-		bool terminateSession (int n); 
+		bool terminateSession (int n);
 
+    void runSession (void);
+
 		// public slots:
 		//@{
 		void doneAuth (void);

Modified: nxcl/lib/nxsession.cpp
===================================================================
--- nxcl/lib/nxsession.cpp	2008-01-02 12:39:06 UTC (rev 428)
+++ nxcl/lib/nxsession.cpp	2008-01-03 12:25:34 UTC (rev 429)
@@ -362,7 +362,6 @@
 void NXSession::setSessionData (NXSessionData *sd)
 {
 	this->sessionData = sd;
-	this->sessionDataSet = true;
 }
 
 int NXSession::parseResponse(string message)

Modified: nxcl/lib/nxsession.h
===================================================================
--- nxcl/lib/nxsession.h	2008-01-02 12:39:06 UTC (rev 428)
+++ nxcl/lib/nxsession.h	2008-01-03 12:25:34 UTC (rev 429)
@@ -69,6 +69,7 @@
 		bool chooseResumable (int n);
 		bool terminateSession (int n);
 		string generateCookie (void);
+    void runSession (void) { sessionDataSet = true; }
 
 		/*!
 		 * Accessors



From gwright at mail.berlios.de  Fri Jan  4 20:07:21 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Fri, 4 Jan 2008 20:07:21 +0100
Subject: [Freenx-cvs] r431 - qtnx
Message-ID: <200801041907.m04J7LKl009708@sheep.berlios.de>

Author: gwright
Date: 2008-01-04 20:07:20 +0100 (Fri, 04 Jan 2008)
New Revision: 431

Modified:
   qtnx/nxwritexml.cpp
Log:
Fix QString->std::string stuff


Modified: qtnx/nxwritexml.cpp
===================================================================
--- qtnx/nxwritexml.cpp	2008-01-03 12:52:12 UTC (rev 430)
+++ qtnx/nxwritexml.cpp	2008-01-04 19:07:20 UTC (rev 431)
@@ -70,20 +70,20 @@
         "\"></option>\n";
 
     if (sessionData.render == true)
-        xml << "<option key=\"Use Render Extension\" value=\"True\">" +
+        xml << "<option key=\"Use Render Extension\" value=\"True\">" <<
             "</option>\n";
     else
-        xml << "<option key=\"Use Render Extension\" value=\"False\">" +
+        xml << "<option key=\"Use Render Extension\" value=\"False\">" <<
             "</option>\n";
 
     if (sessionData.imageCompressionMethod == -1)
-        xml << "<option key=\"Image Compression Method\" value=\"JPEG\">" +
+        xml << "<option key=\"Image Compression Method\" value=\"JPEG\">" <<
             "</option>\n";
     else if (sessionData.imageCompressionMethod == 2)
-        xml << "<option key=\"Image Compression Method\" value=\"PNG\">" +
+        xml << "<option key=\"Image Compression Method\" value=\"PNG\">" <<
             "</option>\n";
     else if (sessionData.imageCompressionMethod == 0)
-        xml << "<option key=\"Image Compression Method\" value=\"Raw X11\">" +
+        xml << "<option key=\"Image Compression Method\" value=\"Raw X11\">" <<
             "</option>\n";
 
     xml << "<option key=\"JPEG Compression Level\" value=\"" <<
@@ -124,17 +124,17 @@
         "\"></option>\n";
 
     if (sessionData.encryption == true)
-        xml << "<option key=\"Use SSL Tunnelling\" value=\"True\">" +
+        xml << "<option key=\"Use SSL Tunnelling\" value=\"True\">" <<
             "</option>\n";
     else
-        xml << "<option key=\"Use SSL Tunnelling\" value=\"False\">" +
+        xml << "<option key=\"Use SSL Tunnelling\" value=\"False\">" <<
             "</option>\n";
 
     if (sessionData.fullscreen == true)
-        xml << "<option key=\"Enable Fullscreen Desktop\" value=\"True\">" +
+        xml << "<option key=\"Enable Fullscreen Desktop\" value=\"True\">" <<
             "</option>\n";
     else
-        xml << "<option key=\"Enable Fullscreen Desktop\" value=\"False\">" +
+        xml << "<option key=\"Enable Fullscreen Desktop\" value=\"False\">" <<
             "</option>\n";
 
     xml << "</NXClientLibSettings>\n";



From gwright at mail.berlios.de  Mon Jan  7 10:44:38 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Mon, 7 Jan 2008 10:44:38 +0100
Subject: [Freenx-cvs] r432 - qtnx
Message-ID: <200801070944.m079icS9023703@sheep.berlios.de>

Author: gwright
Date: 2008-01-07 10:44:37 +0100 (Mon, 07 Jan 2008)
New Revision: 432

Modified:
   qtnx/README
Log:
Workaround for a bug in nxcl


Modified: qtnx/README
===================================================================
--- qtnx/README	2008-01-04 19:07:20 UTC (rev 431)
+++ qtnx/README	2008-01-07 09:44:37 UTC (rev 432)
@@ -27,5 +27,14 @@
 qmake
 make
 
+There is currently a bug in nxcl which means that qtnx (or any other
+application linking directly) won't compile properly; simply remove
+the line
+
+#include "../config.h"
+
+from notQt.h in $PREFIX/include/nxcl (normally /usr/local/include/nxcl)
+to allow it to compile cleanly.
+
 This will generate a qtnx binary in that directory; install it to /usr/bin
 or anywhere you want.



From gwright at mail.berlios.de  Mon Jan  7 13:26:53 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Mon, 7 Jan 2008 13:26:53 +0100
Subject: [Freenx-cvs] r434 - qtnx
Message-ID: <200801071226.m07CQrqe021631@sheep.berlios.de>

Author: gwright
Date: 2008-01-07 13:26:52 +0100 (Mon, 07 Jan 2008)
New Revision: 434

Modified:
   qtnx/qtnxwindow.cpp
Log:
Fix connecting to servers again...


Modified: qtnx/qtnxwindow.cpp
===================================================================
--- qtnx/qtnxwindow.cpp	2008-01-07 12:10:22 UTC (rev 433)
+++ qtnx/qtnxwindow.cpp	2008-01-07 12:26:52 UTC (rev 434)
@@ -122,7 +122,7 @@
             updateStatusBar("Invalid authentication key");
             break;
         case NXCL_AUTHENTICATING:
-            updateStatusBar("Authentication client");
+            updateStatusBar("Authenticating client");
             break;
         case NXCL_LOGIN_FAILED:
             updateStatusBar("Invalid username or password");
@@ -217,6 +217,7 @@
     session.fullscreen = config.fullscreen;
     session.encryption = true;
     session.virtualDesktop = false;
+    session.terminate = false;
 
     if (!config.key.empty()) {
         key = config.key;



From gwright at mail.berlios.de  Tue Jan  8 08:10:06 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Tue, 8 Jan 2008 08:10:06 +0100
Subject: [Freenx-cvs] r435 - qtnx
Message-ID: <200801080710.m087A6jq031295@sheep.berlios.de>

Author: gwright
Date: 2008-01-08 08:10:05 +0100 (Tue, 08 Jan 2008)
New Revision: 435

Modified:
   qtnx/qtnxwindow.cpp
   qtnx/qtnxwindow.h
Log:
Code cleanups - split large code blocks into functions


Modified: qtnx/qtnxwindow.cpp
===================================================================
--- qtnx/qtnxwindow.cpp	2008-01-07 12:26:52 UTC (rev 434)
+++ qtnx/qtnxwindow.cpp	2008-01-08 07:10:05 UTC (rev 435)
@@ -28,14 +28,43 @@
 using namespace nxcl;
 using namespace std;
 
-QtNXWindow::QtNXWindow() : QMainWindow()
+QtNXWindow::QtNXWindow() : 
+    QMainWindow(),
+    processProbe(new QTimer()),
+    sessionsDialog(NULL)
 {
     nxClient.setExternalCallbacks(&callback);
 
-    processProbe = new QTimer();
+    setupUI();
 
-    sessionsDialog = 0;
+    QDir dir(QDir::homePath()+"/.qtnx","*.nxml");
 
+    for (unsigned int i=0;i<dir.count();i++) {
+        QString conn=dir[i];
+        ui_lg.session->addItem(conn.left(conn.length()-5));
+    }
+
+    ui_lg.session->addItem(tr("Create new session"));
+
+    connect(ui_lg.connectButton, SIGNAL(pressed()), this, SLOT(startConnect()));
+    connect(ui_lg.configureButton, SIGNAL(pressed()), this, SLOT(configure()));
+    connect(processProbe, SIGNAL(timeout()), this, SLOT(processProbeTimeout()));
+    connect(&callback, SIGNAL(logging(QString)), this, SLOT(logStd(QString)));
+    connect(&callback, SIGNAL(status(QString)), this, 
+            SLOT(updateStatusBar(QString)));
+    connect(&callback, SIGNAL(suspendedSessions(QList<NXResumeData>)), this,
+            SLOT(loadResumeDialog(QList<NXResumeData>)));
+    connect(&callback, SIGNAL(noSessions()), this, SLOT(noSessions()));
+    connect(&callback, SIGNAL(progress(int, QString)), this, 
+            SLOT(handleProgress(int, QString)));
+}
+
+QtNXWindow::~QtNXWindow()
+{
+}
+
+void QtNXWindow::setupUI()
+{
     logWindow = new QDialog(0);
     ui_lw.setupUi(logWindow);
 
@@ -73,34 +102,8 @@
     connectionMenu->addAction(tr("Connect..."),
             this,
             SLOT(startConnect()));
-
-    QDir dir(QDir::homePath()+"/.qtnx","*.nxml");
-
-    for (unsigned int i=0;i<dir.count();i++) {
-        QString conn=dir[i];
-        ui_lg.session->addItem(conn.left(conn.length()-5));
-    }
-
-    ui_lg.session->addItem(tr("Create new session"));
-
-
-    connect(ui_lg.connectButton, SIGNAL(pressed()), this, SLOT(startConnect()));
-    connect(ui_lg.configureButton, SIGNAL(pressed()), this, SLOT(configure()));
-    connect(processProbe, SIGNAL(timeout()), this, SLOT(processProbeTimeout()));
-    connect(&callback, SIGNAL(logging(QString)), this, SLOT(logStd(QString)));
-    connect(&callback, SIGNAL(status(QString)), this, 
-            SLOT(updateStatusBar(QString)));
-    connect(&callback, SIGNAL(suspendedSessions(QList<NXResumeData>)), this,
-            SLOT(loadResumeDialog(QList<NXResumeData>)));
-    connect(&callback, SIGNAL(noSessions()), this, SLOT(noSessions()));
-    connect(&callback, SIGNAL(progress(int, QString)), this, 
-            SLOT(handleProgress(int, QString)));
 }
 
-QtNXWindow::~QtNXWindow()
-{
-}
-
 void QtNXWindow::showLogWindow()
 {
     if (logWindow->isHidden())
@@ -181,8 +184,6 @@
 void QtNXWindow::startConnect()
 {
     string key = "";
-    QDesktopWidget dw;
-    QX11Info info;
 
     NXParseXML handler;
     handler.setData(&config);
@@ -197,6 +198,36 @@
     reader.setErrorHandler(&handler);
     reader.parse(inputSource);
 
+    setDefaultData();
+
+    if (!config.key.empty()) {
+        key = config.key;
+        session.key = "supplied";
+    } else
+        session.key = "default";
+
+    if (config.sessionType == "unix-application")
+        session.customCommand = config.customCommand;
+
+    nxClient.setSessionData(&session);
+
+    nxClient.invokeNXSSH("id.key", config.serverHost, config.encryption, "",
+            config.serverPort);
+    processProbe->start(30);
+
+    string username = ui_lg.username->text().toStdString();
+    string password = ui_lg.password->text().toStdString();
+
+    nxClient.setUsername(username);
+    nxClient.setPassword(password);
+    nxClient.setResolution(getWidth(), getHeight());
+
+    nxClient.setDepth(getDepth());
+}
+
+void QtNXWindow::setDefaultData()
+{
+    // These seem to be a fairly sane set of defaults for session data
     session.sessionName = config.sessionName;
     session.sessionType = config.sessionType;
     session.cache = config.cache;
@@ -218,31 +249,25 @@
     session.encryption = true;
     session.virtualDesktop = false;
     session.terminate = false;
+}
 
-    if (!config.key.empty()) {
-        key = config.key;
-        session.key = "supplied";
-    } else
-        session.key = "default";
+// This should be the only function that needs porting to other platforms
+int QtNXWindow::getDepth()
+{
+    QX11Info info;
+    return info.depth();
+}
 
-    if (config.sessionType == "unix-application")
-        session.customCommand = config.customCommand;
+int QtNXWindow::getWidth()
+{
+    QDesktopWidget dw;
+    return dw.screenGeometry(this).width();
+}
 
-    nxClient.setSessionData(&session);
-
-    nxClient.invokeNXSSH("id.key", config.serverHost, config.encryption, "",
-            config.serverPort);
-    processProbe->start(30);
-
-    string username = ui_lg.username->text().toStdString();
-    string password = ui_lg.password->text().toStdString();
-
-    nxClient.setUsername(username);
-    nxClient.setPassword(password);
-    nxClient.setResolution(dw.screenGeometry(this).width(),
-            dw.screenGeometry(this).height());
-
-    nxClient.setDepth(info.depth());
+int QtNXWindow::getHeight()
+{
+    QDesktopWidget dw;
+    return dw.screenGeometry(this).height();
 }
 
 void QtNXWindow::updateStatusBar(QString message)

Modified: qtnx/qtnxwindow.h
===================================================================
--- qtnx/qtnxwindow.h	2008-01-07 12:26:52 UTC (rev 434)
+++ qtnx/qtnxwindow.h	2008-01-08 07:10:05 UTC (rev 435)
@@ -112,6 +112,14 @@
         void processProbeTimeout();
         void handleProgress(int, QString);
     private:
+
+        // Decided to split up the code
+        void setupUI();
+        void setDefaultData();
+        int getWidth();
+        int getHeight();
+        int getDepth();
+
         Ui::LoginDialog ui_lg;
         Ui::LogWindow ui_lw;
 



From gwright at mail.berlios.de  Tue Jan  8 12:02:07 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Tue, 8 Jan 2008 12:02:07 +0100
Subject: [Freenx-cvs] r436 - nxcl/lib
Message-ID: <200801081102.m08B27QL011101@sheep.berlios.de>

Author: gwright
Date: 2008-01-08 12:02:07 +0100 (Tue, 08 Jan 2008)
New Revision: 436

Modified:
   nxcl/lib/notQt.cpp
   nxcl/lib/notQt.h
Log:
This should be in .cpp not .h


Modified: nxcl/lib/notQt.cpp
===================================================================
--- nxcl/lib/notQt.cpp	2008-01-08 07:10:05 UTC (rev 435)
+++ nxcl/lib/notQt.cpp	2008-01-08 11:02:07 UTC (rev 436)
@@ -28,6 +28,8 @@
 #include <sys/poll.h>	
 #include <signal.h>
 }
+
+#include "../config.h"
 #include "notQt.h"
 
 using namespace std;

Modified: nxcl/lib/notQt.h
===================================================================
--- nxcl/lib/notQt.h	2008-01-08 07:10:05 UTC (rev 435)
+++ nxcl/lib/notQt.h	2008-01-08 11:02:07 UTC (rev 436)
@@ -28,8 +28,6 @@
 #ifndef _NOTQT_H_
 #define _NOTQT_H_
 
-#include "../config.h"
-
 #include <list>
 #include <vector>
 #include <string>



From gwright at mail.berlios.de  Sun Jan 27 03:09:57 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Sun, 27 Jan 2008 03:09:57 +0100
Subject: [Freenx-cvs] r437 - qtnx
Message-ID: <200801270209.m0R29vvm008303@sheep.berlios.de>

Author: gwright
Date: 2008-01-27 03:09:57 +0100 (Sun, 27 Jan 2008)
New Revision: 437

Modified:
   qtnx/qtnxwindow.cpp
Log:
Cross platform depth detection


Modified: qtnx/qtnxwindow.cpp
===================================================================
--- qtnx/qtnxwindow.cpp	2008-01-08 11:02:07 UTC (rev 436)
+++ qtnx/qtnxwindow.cpp	2008-01-27 02:09:57 UTC (rev 437)
@@ -23,7 +23,6 @@
 #include <QDir>
 #include <QFile>
 #include <QMessageBox>
-#include <QX11Info>
 
 using namespace nxcl;
 using namespace std;
@@ -209,20 +208,20 @@
     if (config.sessionType == "unix-application")
         session.customCommand = config.customCommand;
 
-    nxClient.setSessionData(&session);
-
-    nxClient.invokeNXSSH("id.key", config.serverHost, config.encryption, "",
-            config.serverPort);
-    processProbe->start(30);
-
     string username = ui_lg.username->text().toStdString();
     string password = ui_lg.password->text().toStdString();
 
+    nxClient.setSessionData(&session);
+
     nxClient.setUsername(username);
     nxClient.setPassword(password);
     nxClient.setResolution(getWidth(), getHeight());
 
     nxClient.setDepth(getDepth());
+
+    nxClient.invokeNXSSH("id.key", config.serverHost, config.encryption, "",
+            config.serverPort);
+    processProbe->start(30);
 }
 
 void QtNXWindow::setDefaultData()
@@ -251,23 +250,19 @@
     session.terminate = false;
 }
 
-// This should be the only function that needs porting to other platforms
 int QtNXWindow::getDepth()
 {
-    QX11Info info;
-    return info.depth();
+    return qApp->desktop()->depth();
 }
 
 int QtNXWindow::getWidth()
 {
-    QDesktopWidget dw;
-    return dw.screenGeometry(this).width();
+    return qApp->desktop()->screenGeometry(this).width();
 }
 
 int QtNXWindow::getHeight()
 {
-    QDesktopWidget dw;
-    return dw.screenGeometry(this).height();
+    return qApp->desktop()->screenGeometry(this).height();
 }
 
 void QtNXWindow::updateStatusBar(QString message)



From gwright at mail.berlios.de  Sun Jan 27 03:15:24 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Sun, 27 Jan 2008 03:15:24 +0100
Subject: [Freenx-cvs] r438 - nxcl/lib
Message-ID: <200801270215.m0R2FOdc008721@sheep.berlios.de>

Author: gwright
Date: 2008-01-27 03:15:24 +0100 (Sun, 27 Jan 2008)
New Revision: 438

Modified:
   nxcl/lib/nxsession.h
Log:
These conditionals are not needed


Modified: nxcl/lib/nxsession.h
===================================================================
--- nxcl/lib/nxsession.h	2008-01-27 02:09:57 UTC (rev 437)
+++ nxcl/lib/nxsession.h	2008-01-27 02:15:24 UTC (rev 438)
@@ -80,17 +80,13 @@
             void setPassword (string& pass) { nxPassword = pass; }
             void setResolution (int x, int y) 
             {
-                if (this->sessionDataSet) {
-                    this->sessionData->xRes = x;
-                    this->sessionData->yRes = y;
-                }
+                this->sessionData->xRes = x;
+                this->sessionData->yRes = y;
             }
 
             void setDepth (int d) 
             {
-                if (this->sessionDataSet) {
-                    this->sessionData->depth = d;
-                }
+                this->sessionData->depth = d;
             }
 
             void setRender (bool isRender)



From gwright at mail.berlios.de  Tue Jan 29 01:12:35 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Tue, 29 Jan 2008 01:12:35 +0100
Subject: [Freenx-cvs] r439 - in nxcl: . nxcl test
Message-ID: <200801290012.m0T0CZVT019557@sheep.berlios.de>

Author: gwright
Date: 2008-01-29 01:12:34 +0100 (Tue, 29 Jan 2008)
New Revision: 439

Modified:
   nxcl/Makefile.am
   nxcl/configure.ac
   nxcl/nxcl/Makefile.am
   nxcl/test/Makefile.am
Log:
Add a --with(out)-nxcmd option to disable compilation of D-Bus stuff


Modified: nxcl/Makefile.am
===================================================================
--- nxcl/Makefile.am	2008-01-27 02:15:24 UTC (rev 438)
+++ nxcl/Makefile.am	2008-01-29 00:12:34 UTC (rev 439)
@@ -1,8 +1,15 @@
 
 AUTOMAKE_OPTIONS = check-news dist-bzip2
 
-SUBDIRS = lib nxcl test doc
+ALWAYS_SUBDIRS = lib test doc
 
+
+SUBDIRS = $(ALWAYS_SUBDIRS)
+
+if WITH_NXCMD
+  SUBDIRS +=  nxcl
+endif
+
 CLEANFILES = *~
 
 MAINTAINERCLEANFILES = aclocal.m4 nxcl-*.tar.gz nxcl-*.tar.bz2 nxcl-*.diff
@@ -13,3 +20,4 @@
 pkgconfig_DATA = nxcl.pc
 
 EXTRA_DIST = nxcl.pc.in
+

Modified: nxcl/configure.ac
===================================================================
--- nxcl/configure.ac	2008-01-27 02:15:24 UTC (rev 438)
+++ nxcl/configure.ac	2008-01-29 00:12:34 UTC (rev 439)
@@ -1,11 +1,11 @@
 dnl Process this file with autoconf to produce a configure script.
-AC_PREREQ(2.59)
+AC_PREREQ(2.59c)
 AC_INIT([nxcl], [1.0], [seb at esfnet.co.uk])
 AC_CONFIG_SRCDIR(nxcl/nxcl.cpp)
 AC_REVISION([$Revision: 1.3 $])
 AC_PREFIX_DEFAULT(/usr/local)
 
-AM_INIT_AUTOMAKE([1.9 foreign])
+AM_INIT_AUTOMAKE([1.10 foreign])
 
 AM_CONFIG_HEADER(config.h)
 AM_MAINTAINER_MODE
@@ -17,6 +17,7 @@
 AC_PROG_CC
 AC_PROG_INSTALL
 AC_PROG_LIBTOOL
+
 AC_CHECK_PROG(DOXYGEN, doxygen, doxygen, /bin/echo)
 
 dnl check for boost library
@@ -24,8 +25,27 @@
 dnl AC_CHECK_LIB(boost_signals, LIB_BOOST_SIGNALS="-lboost_signals")
 dnl AC_SUBST(LIB_BOOST_SIGNALS)
 
-PKG_CHECK_MODULES(PACKAGE, dbus-1)
+AC_ARG_WITH(nxcmd, 
+        AC_HELP_STRING([--with-nxcmd], [build nxcmd]),
+        [with_nxcmd=${withval}],
+        [with_nxcmd=auto])
 
+AS_IF([test "$with_nxcmd" != no], [
+        PKG_CHECK_MODULES(DBUS, [
+                dbus-1
+                ],
+                [with_nxcmd=yes],
+                [
+                AS_IF([test "$with_nxcmd" = yes], [
+                        AC_MSG_ERROR([nxcmd support was requested but D-Bus libraries are not available])
+               ])
+
+               with_nxcmd=no
+               ])
+])
+
+AM_CONDITIONAL(WITH_NXCMD, test "$with_nxcmd" = yes)
+
 dnl Checks for library functions.
 AC_HEADER_STDC
 AC_HEADER_TIME

Modified: nxcl/nxcl/Makefile.am
===================================================================
--- nxcl/nxcl/Makefile.am	2008-01-27 02:15:24 UTC (rev 438)
+++ nxcl/nxcl/Makefile.am	2008-01-29 00:12:34 UTC (rev 439)
@@ -1,8 +1,9 @@
-AM_CPPFLAGS = @PACKAGE_CFLAGS@ -DPACKAGE_DATA_DIR=\""$(datadir)"\" -DLOCALEDIR=\"$(localedir)\" -DPACKAGE_BIN_DIR=\""$(bindir)"\"
+AM_CPPFLAGS = @PACKAGE_CFLAGS@ -DPACKAGE_DATA_DIR=\""$(datadir)"\" -DLOCALEDIR=\"$(localedir)\" -DPACKAGE_BIN_DIR=\""$(bindir)"\" $(DBUS_CFLAGS)
+
 INCLUDES = -I../lib
 bin_PROGRAMS = nxcl
 nxcl_SOURCES = main.cpp nxcl.cpp
 # This links to X11 so that nxcl can obtain the X server's actual screen size
-nxcl_LDADD = @PACKAGE_LIBS@ $(LIBINTL) -L../lib -lnxcl -lX11
+nxcl_LDADD = @PACKAGE_LIBS@ $(LIBINTL) $(DBUS_LIBS) -L../lib -lnxcl -lX11
 pkginclude_HEADERS = nxcl.h
 

Modified: nxcl/test/Makefile.am
===================================================================
--- nxcl/test/Makefile.am	2008-01-27 02:15:24 UTC (rev 438)
+++ nxcl/test/Makefile.am	2008-01-29 00:12:34 UTC (rev 439)
@@ -1,11 +1,16 @@
-AM_CPPFLAGS = @PACKAGE_CFLAGS@ -DPACKAGE_DATA_DIR=\""$(datadir)"\" -DLOCALEDIR=\"$(localedir)\" -DPACKAGE_BIN_DIR=\""$(bindir)"\"
+AM_CPPFLAGS = @PACKAGE_CFLAGS@ -DPACKAGE_DATA_DIR=\""$(datadir)"\" -DLOCALEDIR=\"$(localedir)\" -DPACKAGE_BIN_DIR=\""$(bindir)"\" $(DBUS_CFLAGS)
 INCLUDES = -I../lib
-bin_PROGRAMS = libtest nxcmd notQttest
+bin_PROGRAMS = libtest notQttest
+
+if WITH_NXCMD
+  bin_PROGRAMS += nxcmd
+endif
+
 libtest_SOURCES = libtest.cpp
 libtest_LDADD = @PACKAGE_LIBS@ $(LIBINTL) -L../lib -lnxcl
 notQttest_SOURCES = notQttest.cpp
 notQttest_LDADD = @PACKAGE_LIBS@ $(LIBINTL) -L../lib -lnxcl
 nxcmd_SOURCES = nxcmd.cpp
-nxcmd_LDADD = @PACKAGE_LIBS@ $(LIBINTL)
+nxcmd_LDADD = @PACKAGE_LIBS@ $(LIBINTL) $(DBUS_LIBS)
 #pkginclude_HEADERS = header.h
 



From gwright at mail.berlios.de  Tue Jan 29 01:28:37 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Tue, 29 Jan 2008 01:28:37 +0100
Subject: [Freenx-cvs] r440 - nxcl
Message-ID: <200801290028.m0T0Sb5M024963@sheep.berlios.de>

Author: gwright
Date: 2008-01-29 01:28:37 +0100 (Tue, 29 Jan 2008)
New Revision: 440

Modified:
   nxcl/Makefile.am
   nxcl/configure.ac
Log:
Add --with(out)-doxygen


Modified: nxcl/Makefile.am
===================================================================
--- nxcl/Makefile.am	2008-01-29 00:12:34 UTC (rev 439)
+++ nxcl/Makefile.am	2008-01-29 00:28:37 UTC (rev 440)
@@ -1,15 +1,18 @@
 
 AUTOMAKE_OPTIONS = check-news dist-bzip2
 
-ALWAYS_SUBDIRS = lib test doc
+ALWAYS_SUBDIRS = lib test
 
-
 SUBDIRS = $(ALWAYS_SUBDIRS)
 
 if WITH_NXCMD
-  SUBDIRS +=  nxcl
+  SUBDIRS += nxcl
 endif
 
+if WITH_DOXYGEN
+  SUBDIRS += doc
+endif
+
 CLEANFILES = *~
 
 MAINTAINERCLEANFILES = aclocal.m4 nxcl-*.tar.gz nxcl-*.tar.bz2 nxcl-*.diff

Modified: nxcl/configure.ac
===================================================================
--- nxcl/configure.ac	2008-01-29 00:12:34 UTC (rev 439)
+++ nxcl/configure.ac	2008-01-29 00:28:37 UTC (rev 440)
@@ -18,8 +18,6 @@
 AC_PROG_INSTALL
 AC_PROG_LIBTOOL
 
-AC_CHECK_PROG(DOXYGEN, doxygen, doxygen, /bin/echo)
-
 dnl check for boost library
 dnl I would prefer to include boost code and compile in place and statically link.
 dnl AC_CHECK_LIB(boost_signals, LIB_BOOST_SIGNALS="-lboost_signals")
@@ -46,6 +44,17 @@
 
 AM_CONDITIONAL(WITH_NXCMD, test "$with_nxcmd" = yes)
 
+AC_ARG_WITH(doxygen,
+            AC_HELP_STRING([--with-doxygen], [build doxygen API documentation]),
+        [with_doxygen=${withval}],
+        [with_doxygen=yes])
+
+if test "$with_doxygen" = yes; then
+  AC_CHECK_PROG(DOXYGEN, doxygen, doxygen, /bin/echo)
+fi
+
+AM_CONDITIONAL(WITH_DOXYGEN, test "$with_doxygen" = yes)
+
 dnl Checks for library functions.
 AC_HEADER_STDC
 AC_HEADER_TIME



From gwright at mail.berlios.de  Tue Jan 29 01:35:36 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Tue, 29 Jan 2008 01:35:36 +0100
Subject: [Freenx-cvs] r441 - nxcl
Message-ID: <200801290035.m0T0ZaGD026630@sheep.berlios.de>

Author: gwright
Date: 2008-01-29 01:35:36 +0100 (Tue, 29 Jan 2008)
New Revision: 441

Modified:
   nxcl/configure.ac
Log:
Defines for cygwin/darwin


Modified: nxcl/configure.ac
===================================================================
--- nxcl/configure.ac	2008-01-29 00:28:37 UTC (rev 440)
+++ nxcl/configure.ac	2008-01-29 00:35:36 UTC (rev 441)
@@ -99,6 +99,22 @@
   AC_DEFINE(DEBUG, 0, Define if debugging output should be enabled)
 fi
 
+dnl Do some platform checking for cygwin
+
+if test "$(uname -o)" = Cygwin; then
+  AC_DEFINE(NXCL_CYGWIN, 1, Define if compiling on Cygwin)
+else
+  AC_DEFINE(NXCL_CYGWIN, 0, Define if compiling on Cygwin)
+fi
+
+dnl Do some platform checking for OS X
+
+if test "$(uname)" = Darwin; then
+  AC_DEFINE(NXCL_DARWIN, 1, Define if compiling on Darwin)
+else
+  AC_DEFINE(NXCL_DARWIN, 0, Define if compiling on Darwin)
+fi
+
 dnl Add in doc/Makefile to this:
 AC_CONFIG_FILES([Makefile lib/Makefile nxcl/Makefile test/Makefile doc/Makefile nxcl.pc])
 



From gwright at mail.berlios.de  Tue Jan 29 01:44:28 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Tue, 29 Jan 2008 01:44:28 +0100
Subject: [Freenx-cvs] r442 - nxcl
Message-ID: <200801290044.m0T0iS7V027506@sheep.berlios.de>

Author: gwright
Date: 2008-01-29 01:44:28 +0100 (Tue, 29 Jan 2008)
New Revision: 442

Modified:
   nxcl/README
Log:
Update docs


Modified: nxcl/README
===================================================================
--- nxcl/README	2008-01-29 00:35:36 UTC (rev 441)
+++ nxcl/README	2008-01-29 00:44:28 UTC (rev 442)
@@ -51,9 +51,13 @@
 daemon to be running to use the nxcl standalone binary, but NOT if you link
 your client directly to libnxcl.so*
 
+The D-Bus client can be disabled with the --without-nxcmd flag to configure.
+
 If you have doxygen on your system, (imperfect) documentation will be
 generated from the source header files.
 
+Documentation can be disabled with the --without-doxygen flag to configure.
+
 Compile and install libXcomp, nxssh and nxproxy following the instructions
 in the readme file for each package. You can install the nxssh and nxproxy
 in any of the following locations:



From gwright at mail.berlios.de  Tue Jan 29 01:54:39 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Tue, 29 Jan 2008 01:54:39 +0100
Subject: [Freenx-cvs] r443 - qtnx
Message-ID: <200801290054.m0T0sd2L028057@sheep.berlios.de>

Author: gwright
Date: 2008-01-29 01:54:38 +0100 (Tue, 29 Jan 2008)
New Revision: 443

Modified:
   qtnx/README
Log:
Add Win32 build documentation


Modified: qtnx/README
===================================================================
--- qtnx/README	2008-01-29 00:44:28 UTC (rev 442)
+++ qtnx/README	2008-01-29 00:54:38 UTC (rev 443)
@@ -20,21 +20,38 @@
 (These three NX components all should be from the 3.x.x series. You can
 obtain them from NoMachine's servers at http://www.nomachine.com/sources.php)
 
-Read the nxcl README for details of the first three packages.
+Read the nxcl README for details of the first three packages. You will not need
+to build the nxcmd daemon nor the doxygen API documentation.
 
 To build QtNX you will need Qt 4.x. You need to run the following commands:
 
-qmake
-make
+$ qmake
+$ make
 
-There is currently a bug in nxcl which means that qtnx (or any other
-application linking directly) won't compile properly; simply remove
-the line
+This will generate a qtnx binary in that directory; install it to /usr/bin
+or anywhere you want.
 
-#include "../config.h"
+Win32 Builds
+------------
 
-from notQt.h in $PREFIX/include/nxcl (normally /usr/local/include/nxcl)
-to allow it to compile cleanly.
+In order to build on Win32, you will need a full Cygwin setup. Ensure you have
+pkg-config installed in cygwin.
 
-This will generate a qtnx binary in that directory; install it to /usr/bin
-or anywhere you want.
+Build Qt 4.3.3 as per the instructions on http://wiki.lyx.org/LyX/LyXOnCygwin;
+you will, however, need to patch Qt. Line 528 in src/corelib/codecs/qtextcodec.cpp
+should also contain an extra conditional:
+
+&& !defined(Q_CYGWIN_WIN)
+
+You can then build Qt without any trouble by following those instructions. 
+
+Afterwards, set QTDIR to point to wherever you installed Qt to, and set the
+PATH to point to QTDIR/bin as well:
+
+$ export QTDIR=/usr/local/src/qtwin-4.3.3
+$ export PATH=$QTDIR/bin:$PATH
+
+You can then build qtnx normally with the standard steps:
+
+$ qmake
+$ make



From gwright at mail.berlios.de  Tue Jan 29 12:15:27 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Tue, 29 Jan 2008 12:15:27 +0100
Subject: [Freenx-cvs] r444 - nxcl/lib
Message-ID: <200801291115.m0TBFRm9029569@sheep.berlios.de>

Author: gwright
Date: 2008-01-29 12:15:27 +0100 (Tue, 29 Jan 2008)
New Revision: 444

Modified:
   nxcl/lib/nxclientlib.cpp
Log:
Initial code fragments to start X11 on Windows


Modified: nxcl/lib/nxclientlib.cpp
===================================================================
--- nxcl/lib/nxclientlib.cpp	2008-01-29 00:54:38 UTC (rev 443)
+++ nxcl/lib/nxclientlib.cpp	2008-01-29 11:15:27 UTC (rev 444)
@@ -681,6 +681,54 @@
     }
 }
 
+#ifdef NXCL_CYGWIN
+int NXClientLib::startX11 (int xResolution, int yResolution, string name)
+{
+    // Invoke NXWin.exe on Windows machines
+
+    // See if XAUTHORITY path is set
+
+    stringstream xauthority = getenv("XAUTHORITY");
+
+    if (xauthority.empty()) {
+        // We hardcode XAUTHORITY to $HOME/.Xauthority
+        xauthority = getenv("HOME") << "/.Xauthority";
+    }
+
+    // Now we add a cookie to this auth file
+
+    char hostname[256];
+
+    gethostname(hostname, 256);
+
+    string cookie = NXSession::generateCookie();
+    stringstream domain = getenv("HOME") << ":0.0";
+
+    list<string> arguments;
+
+    // These arguments taken from the 2X GPL client
+    // We're going to assume that nxauth is in PATH
+    arguments.push_back("nxauth");
+    arguments.push_back("-i");
+    arguments.push_back("-f");
+    arguments.push_back(xauthority.str());
+    arguments.push_back("add");
+    arguments.push_back(domain.str());
+    arguments.push_back("MIT-MAGIC-COOKIE-1");
+    arguments.push_back(cookie);
+
+    notQProcess nxauthProcess;
+
+    nxauthProcess.start("nxauth", arguments);
+
+    if (this->nxauthProcess.waitForStarted() == false) {
+        this->externalCallbacks->write
+            (NXCL_PROCESS_ERROR, _("Error starting nxauth!"));
+        this->isFinished = true;
+    }
+}
+#endif
+
 bool NXClientLib::chooseResumable (int n)
 {
     return (this->session.chooseResumable(n));



From gwright at mail.berlios.de  Tue Jan 29 12:27:35 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Tue, 29 Jan 2008 12:27:35 +0100
Subject: [Freenx-cvs] r445 - nxcl/lib
Message-ID: <200801291127.m0TBRZKC030603@sheep.berlios.de>

Author: gwright
Date: 2008-01-29 12:27:34 +0100 (Tue, 29 Jan 2008)
New Revision: 445

Modified:
   nxcl/lib/nxclientlib.cpp
   nxcl/lib/nxclientlib.h
Log:
Woops, didn't compile... Code updates


Modified: nxcl/lib/nxclientlib.cpp
===================================================================
--- nxcl/lib/nxclientlib.cpp	2008-01-29 11:15:27 UTC (rev 444)
+++ nxcl/lib/nxclientlib.cpp	2008-01-29 11:27:34 UTC (rev 445)
@@ -24,6 +24,8 @@
 #include "nxclientlib.h"
 #include "nxdata.h"
 
+#include "../config.h"
+
 #include <fstream>
 
 extern "C" {
@@ -681,18 +683,20 @@
     }
 }
 
-#ifdef NXCL_CYGWIN
 int NXClientLib::startX11 (int xResolution, int yResolution, string name)
 {
+#ifdef NXCL_CYGWIN
     // Invoke NXWin.exe on Windows machines
 
     // See if XAUTHORITY path is set
 
-    stringstream xauthority = getenv("XAUTHORITY");
+    stringstream xauthority;
 
-    if (xauthority.empty()) {
+    xauthority << getenv("XAUTHORITY");
+
+    if (xauthority.str().empty()) {
         // We hardcode XAUTHORITY to $HOME/.Xauthority
-        xauthority = getenv("HOME") << "/.Xauthority";
+        xauthority << getenv("HOME") << "/.Xauthority";
     }
 
     // Now we add a cookie to this auth file
@@ -701,9 +705,11 @@
 
     gethostname(hostname, 256);
 
-    string cookie = NXSession::generateCookie();
-    stringstream domain = getenv("HOME") << ":0.0";
+    string cookie = getSession()->generateCookie();
+    stringstream domain;
 
+    domain << getenv("HOME") << ":0.0";
+
     list<string> arguments;
 
     // These arguments taken from the 2X GPL client
@@ -721,13 +727,13 @@
 
     nxauthProcess.start("nxauth", arguments);
 
-    if (this->nxauthProcess.waitForStarted() == false) {
+    if (nxauthProcess.waitForStarted() == false) {
         this->externalCallbacks->write
             (NXCL_PROCESS_ERROR, _("Error starting nxauth!"));
         this->isFinished = true;
     }
+#endif
 }
-#endif
 
 bool NXClientLib::chooseResumable (int n)
 {

Modified: nxcl/lib/nxclientlib.h
===================================================================
--- nxcl/lib/nxclientlib.h	2008-01-29 11:15:27 UTC (rev 444)
+++ nxcl/lib/nxclientlib.h	2008-01-29 11:27:34 UTC (rev 445)
@@ -232,6 +232,8 @@
 
             void runSession (void);
 
+	    int startX11(int xResolution, int yResolution, string name);
+
             // public slots:
             //@{
             void doneAuth (void);



From gwright at mail.berlios.de  Tue Jan 29 15:38:41 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Tue, 29 Jan 2008 15:38:41 +0100
Subject: [Freenx-cvs] r446 - nxcl/lib
Message-ID: <200801291438.m0TEcfRD006535@sheep.berlios.de>

Author: gwright
Date: 2008-01-29 15:38:40 +0100 (Tue, 29 Jan 2008)
New Revision: 446

Modified:
   nxcl/lib/nxclientlib.cpp
   nxcl/lib/nxclientlib.h
Log:
Add code to launch NXWin on Win32


Modified: nxcl/lib/nxclientlib.cpp
===================================================================
--- nxcl/lib/nxclientlib.cpp	2008-01-29 11:27:34 UTC (rev 445)
+++ nxcl/lib/nxclientlib.cpp	2008-01-29 14:38:40 UTC (rev 446)
@@ -153,6 +153,7 @@
 
     this->pNxsshProcess = &this->nxsshProcess;
     this->pNxproxyProcess = &this->nxproxyProcess;
+    this->pNxwinProcess = &this->nxwinProcess;
 
     /* Set up callback pointers */
     this->nxsshProcess.setCallbacks (&callbacks);
@@ -683,13 +684,12 @@
     }
 }
 
-int NXClientLib::startX11 (int xResolution, int yResolution, string name)
+int NXClientLib::startX11 (string resolution, string name)
 {
 #ifdef NXCL_CYGWIN
     // Invoke NXWin.exe on Windows machines
 
     // See if XAUTHORITY path is set
-
     stringstream xauthority;
 
     xauthority << getenv("XAUTHORITY");
@@ -710,28 +710,86 @@
 
     domain << getenv("HOME") << ":0.0";
 
-    list<string> arguments;
+    list<string> nxauthArguments;
 
     // These arguments taken from the 2X GPL client
     // We're going to assume that nxauth is in PATH
-    arguments.push_back("nxauth");
-    arguments.push_back("-i");
-    arguments.push_back("-f");
-    arguments.push_back(xauthority.str());
-    arguments.push_back("add");
-    arguments.push_back(domain.str());
-    arguments.push_back("MIT-MAGIC-COOKIE-1");
-    arguments.push_back(cookie);
+    nxauthArguments.push_back("nxauth");
+    nxauthArguments.push_back("-i");
+    nxauthArguments.push_back("-f");
+    nxauthArguments.push_back(xauthority.str());
+    nxauthArguments.push_back("add");
+    nxauthArguments.push_back(domain.str());
+    nxauthArguments.push_back("MIT-MAGIC-COOKIE-1");
+    nxauthArguments.push_back(cookie);
 
     notQProcess nxauthProcess;
 
-    nxauthProcess.start("nxauth", arguments);
+    nxauthProcess.start("nxauth", nxauthArguments);
 
     if (nxauthProcess.waitForStarted() == false) {
         this->externalCallbacks->write
             (NXCL_PROCESS_ERROR, _("Error starting nxauth!"));
         this->isFinished = true;
     }
+
+    // Now we actually start NXWin.exe
+
+    list<string> nxwinArguments;
+
+    // Arguments taken from 2X
+    nxwinArguments.push_back("NXWin");
+    nxwinArguments.push_back("-auth");
+
+    stringstream xauthPath;
+    xauthPath << "'" << xauthority.str() << "'";
+
+    nxwinArguments.push_back(xauthPath.str());
+    nxwinArguments.push_back("-nowinkill");
+    nxwinArguments.push_back("-clipboard");
+    nxwinArguments.push_back("-noloadxkb");
+
+    // TODO: If rootless, append "-multiwindow" and "-hide" but only
+    // hide if not restoring
+
+    // Now we set up the font paths. By default this is $PWD/usr/X11R6/...
+
+    stringstream fontPath;
+
+    fontPath << "\"" << "usr/X11R6/lib/X11/fonts/TTF" << "\","
+        << "\"" << "usr/X11R6/lib/X11/fonts/misc" << "\","
+        << "\"" << "usr/X11R6/lib/X11/fonts/Speedo" << "\","
+        << "\"" << "usr/X11R6/lib/X11/fonts/Type1" << "\","
+        << "\"" << "usr/X11R6/lib/X11/fonts/75dpi" << "\","
+        << "\"" << "usr/X11R6/lib/X11/fonts/100dpi" << "\"";
+
+    nxwinArguments.push_back("-fp");
+    nxwinArguments.push_back(fontPath.str());
+    nxwinArguments.push_back("-agent");
+    nxwinArguments.push_back("-emulate3buttons");
+    nxwinArguments.push_back("-hide");
+    nxwinArguments.push_back("-noreset");
+    nxwinArguments.push_back("-name");
+    nxwinArguments.push_back("NXWin");
+    nxwinArguments.push_back("0");
+
+    nxwinArguments.push_back("-screen");
+    nxwinArguments.push_back("0");
+
+    char* dimensions = strtok(resolution.c_str(), "x");
+
+    while (dimensions != NULL) {
+        nxwinArguments.push_back(dimensions);
+        dimensions = strtok(NULL, "x");
+    }
+
+    this->nxwinProcess->start("nxwin", nxwinArguments);
+
+    if (this->nxwinProcess->waitForStarted() == false) {
+        this->externalCallbacks->write
+            (NXCL_PROCESS_ERROR, _("Error starting nxwin!"));
+        this->isFinished = true;
+    }
 #endif
 }
 

Modified: nxcl/lib/nxclientlib.h
===================================================================
--- nxcl/lib/nxclientlib.h	2008-01-29 11:27:34 UTC (rev 445)
+++ nxcl/lib/nxclientlib.h	2008-01-29 14:38:40 UTC (rev 446)
@@ -391,6 +391,11 @@
             notQProcess nxproxyProcess;
             notQProcess* pNxproxyProcess;
             /*!
+             * The nxwin process object
+             */
+            notQProcess nxwinProcess;
+            notQProcess* pNxwinProcess;
+            /*!
              * A callbacks object. This holds the various callback
              * methods. The callback methods are defined here, but
              * are callable from notQProcess etc.



From gwright at mail.berlios.de  Tue Jan 29 15:44:15 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Tue, 29 Jan 2008 15:44:15 +0100
Subject: [Freenx-cvs] r447 - nxcl/lib
Message-ID: <200801291444.m0TEiFCt006988@sheep.berlios.de>

Author: gwright
Date: 2008-01-29 15:44:15 +0100 (Tue, 29 Jan 2008)
New Revision: 447

Modified:
   nxcl/lib/nxclientlib.cpp
   nxcl/lib/nxclientlib.h
Log:
Fix compile errors..


Modified: nxcl/lib/nxclientlib.cpp
===================================================================
--- nxcl/lib/nxclientlib.cpp	2008-01-29 14:38:40 UTC (rev 446)
+++ nxcl/lib/nxclientlib.cpp	2008-01-29 14:44:15 UTC (rev 447)
@@ -684,7 +684,7 @@
     }
 }
 
-int NXClientLib::startX11 (string resolution, string name)
+void NXClientLib::startX11 (string resolution, string name)
 {
 #ifdef NXCL_CYGWIN
     // Invoke NXWin.exe on Windows machines
@@ -776,16 +776,16 @@
     nxwinArguments.push_back("-screen");
     nxwinArguments.push_back("0");
 
-    char* dimensions = strtok(resolution.c_str(), "x");
+    char* dimensions = strtok(const_cast<char*>(resolution.c_str()), "x");
 
     while (dimensions != NULL) {
         nxwinArguments.push_back(dimensions);
         dimensions = strtok(NULL, "x");
     }
 
-    this->nxwinProcess->start("nxwin", nxwinArguments);
+    this->nxwinProcess.start("nxwin", nxwinArguments);
 
-    if (this->nxwinProcess->waitForStarted() == false) {
+    if (this->nxwinProcess.waitForStarted() == false) {
         this->externalCallbacks->write
             (NXCL_PROCESS_ERROR, _("Error starting nxwin!"));
         this->isFinished = true;

Modified: nxcl/lib/nxclientlib.h
===================================================================
--- nxcl/lib/nxclientlib.h	2008-01-29 14:38:40 UTC (rev 446)
+++ nxcl/lib/nxclientlib.h	2008-01-29 14:44:15 UTC (rev 447)
@@ -232,7 +232,7 @@
 
             void runSession (void);
 
-	    int startX11(int xResolution, int yResolution, string name);
+	    void startX11(string resolution, string name);
 
             // public slots:
             //@{



From gwright at mail.berlios.de  Tue Jan 29 15:56:59 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Tue, 29 Jan 2008 15:56:59 +0100
Subject: [Freenx-cvs] r448 - nxcl/lib
Message-ID: <200801291456.m0TEux1G008895@sheep.berlios.de>

Author: gwright
Date: 2008-01-29 15:56:58 +0100 (Tue, 29 Jan 2008)
New Revision: 448

Modified:
   nxcl/lib/nxclientlib.cpp
   nxcl/lib/nxsession.h
Log:
Invoke NXWin itself


Modified: nxcl/lib/nxclientlib.cpp
===================================================================
--- nxcl/lib/nxclientlib.cpp	2008-01-29 14:44:15 UTC (rev 447)
+++ nxcl/lib/nxclientlib.cpp	2008-01-29 14:56:58 UTC (rev 448)
@@ -600,6 +600,13 @@
     this->externalCallbacks->write
         (NXCL_INVOKE_PROXY, _("Starting NX session"));
 
+#ifdef NXCL_CYGWIN
+    NXSessionData* sessionData = getSession()->getSessionData();
+    stringstream resolution;
+    resolution << itoa(sessionData->xRes) << "x" << itoa(sessionData->yRes);
+    startX11(resolution, "");
+#endif
+
     int e;
     char * home;
 

Modified: nxcl/lib/nxsession.h
===================================================================
--- nxcl/lib/nxsession.h	2008-01-29 14:44:15 UTC (rev 447)
+++ nxcl/lib/nxsession.h	2008-01-29 14:56:58 UTC (rev 448)
@@ -110,6 +110,11 @@
 
             void setSessionData (NXSessionData*);
 
+            NXSessionData* getSessionData()
+            {
+                return this->sessionData;
+            }
+
             bool getSessionDataSet (void)
             {
                 return this->sessionDataSet;



From gwright at mail.berlios.de  Tue Jan 29 16:09:55 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Tue, 29 Jan 2008 16:09:55 +0100
Subject: [Freenx-cvs] r449 - nxcl/lib
Message-ID: <200801291509.m0TF9tjo010058@sheep.berlios.de>

Author: gwright
Date: 2008-01-29 16:09:55 +0100 (Tue, 29 Jan 2008)
New Revision: 449

Modified:
   nxcl/lib/nxclientlib.cpp
Log:
Apparently itoa() isn't standard


Modified: nxcl/lib/nxclientlib.cpp
===================================================================
--- nxcl/lib/nxclientlib.cpp	2008-01-29 14:56:58 UTC (rev 448)
+++ nxcl/lib/nxclientlib.cpp	2008-01-29 15:09:55 UTC (rev 449)
@@ -602,9 +602,15 @@
 
 #ifdef NXCL_CYGWIN
     NXSessionData* sessionData = getSession()->getSessionData();
+
     stringstream resolution;
-    resolution << itoa(sessionData->xRes) << "x" << itoa(sessionData->yRes);
-    startX11(resolution, "");
+
+    ostringstream dimensionX, dimensionY;
+    dimensionX << sessionData->xRes;
+    dimensionY << sessionData->yRes;
+
+    resolution << dimensionX.str() << "x" << dimensionY.str();
+    startX11(resolution.str(), "");
 #endif
 
     int e;



From gwright at mail.berlios.de  Tue Jan 29 16:26:20 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Tue, 29 Jan 2008 16:26:20 +0100
Subject: [Freenx-cvs] r450 - nxcl/lib
Message-ID: <200801291526.m0TFQK29011709@sheep.berlios.de>

Author: gwright
Date: 2008-01-29 16:26:19 +0100 (Tue, 29 Jan 2008)
New Revision: 450

Modified:
   nxcl/lib/nxclientlib.cpp
   nxcl/lib/nxclientlib.h
Log:
Make nxauthProcess class-wide


Modified: nxcl/lib/nxclientlib.cpp
===================================================================
--- nxcl/lib/nxclientlib.cpp	2008-01-29 15:09:55 UTC (rev 449)
+++ nxcl/lib/nxclientlib.cpp	2008-01-29 15:26:19 UTC (rev 450)
@@ -154,10 +154,13 @@
     this->pNxsshProcess = &this->nxsshProcess;
     this->pNxproxyProcess = &this->nxproxyProcess;
     this->pNxwinProcess = &this->nxwinProcess;
+    this->pNxauthProcess = &this->nxauthProcess;
 
     /* Set up callback pointers */
     this->nxsshProcess.setCallbacks (&callbacks);
     this->nxproxyProcess.setCallbacks (&callbacks);
+    this->nxwinProcess.setCallbacks (&callbacks);
+    this->nxauthProcess.setCallbacks (&callbacks);
     this->session.setCallbacks (&callbacks);
     this->callbacks.setParent (this);
 
@@ -736,11 +739,11 @@
     nxauthArguments.push_back("MIT-MAGIC-COOKIE-1");
     nxauthArguments.push_back(cookie);
 
-    notQProcess nxauthProcess;
+    this->nxauthProcess.setCallbacks (&callbacks);
 
-    nxauthProcess.start("nxauth", nxauthArguments);
+    this->nxauthProcess.start("nxauth", nxauthArguments);
 
-    if (nxauthProcess.waitForStarted() == false) {
+    if (this->nxauthProcess.waitForStarted() == false) {
         this->externalCallbacks->write
             (NXCL_PROCESS_ERROR, _("Error starting nxauth!"));
         this->isFinished = true;

Modified: nxcl/lib/nxclientlib.h
===================================================================
--- nxcl/lib/nxclientlib.h	2008-01-29 15:09:55 UTC (rev 449)
+++ nxcl/lib/nxclientlib.h	2008-01-29 15:26:19 UTC (rev 450)
@@ -308,6 +308,16 @@
                 return this->pNxproxyProcess;
             }
 
+	    notQProcess* getNXWinProcess (void)
+	    {
+                return this->pNxwinProcess;
+            }
+
+            notQProcess* getNXAuthProcess (void)
+            {
+                return this->pNxauthProcess;
+            }
+
             bool getIsFinished (void)
             {
                 return this->isFinished;
@@ -396,6 +406,11 @@
             notQProcess nxwinProcess;
             notQProcess* pNxwinProcess;
             /*!
+             * The nxauth process object
+             */
+            notQProcess nxauthProcess;
+            notQProcess* pNxauthProcess;
+            /*!
              * A callbacks object. This holds the various callback
              * methods. The callback methods are defined here, but
              * are callable from notQProcess etc.



From gwright at mail.berlios.de  Tue Jan 29 20:09:41 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Tue, 29 Jan 2008 20:09:41 +0100
Subject: [Freenx-cvs] r451 - nxcl/lib
Message-ID: <200801291909.m0TJ9f0C030379@sheep.berlios.de>

Author: gwright
Date: 2008-01-29 20:09:40 +0100 (Tue, 29 Jan 2008)
New Revision: 451

Modified:
   nxcl/lib/nxclientlib.cpp
Log:
OS X uses open-x11


Modified: nxcl/lib/nxclientlib.cpp
===================================================================
--- nxcl/lib/nxclientlib.cpp	2008-01-29 15:26:19 UTC (rev 450)
+++ nxcl/lib/nxclientlib.cpp	2008-01-29 19:09:40 UTC (rev 451)
@@ -245,6 +245,11 @@
 
     // Find a path for the nxssh process using getPath()
     string nxsshPath = this->getPath ("nxssh");
+
+#ifdef NXCL_DARWIN
+    nxsshPath = "open-x11";
+#endif
+
     this->nxsshProcess.start(nxsshPath, arguments);
 
     if (this->nxsshProcess.waitForStarted() == false) {
@@ -682,6 +687,9 @@
 
     // Build arguments for the call to the nxproxy command
     list<string> arguments;
+#ifdef NXCL_DARWIN
+    arguments.push_back("open-x11"); // We open X11 apps on OS X with this script
+#endif
     arguments.push_back("nxproxy"); // argv[0] has to be the program name
     arguments.push_back("-S");
     ss.str("");



From gwright at mail.berlios.de  Wed Jan 30 06:01:35 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Wed, 30 Jan 2008 06:01:35 +0100
Subject: [Freenx-cvs] r452 - qtnx
Message-ID: <200801300501.m0U51Zd9024937@sheep.berlios.de>

Author: gwright
Date: 2008-01-30 06:01:33 +0100 (Wed, 30 Jan 2008)
New Revision: 452

Modified:
   qtnx/README
   qtnx/qtnx.pro
   qtnx/qtnxwindow.cpp
Log:
OS X builds


Modified: qtnx/README
===================================================================
--- qtnx/README	2008-01-29 19:09:40 UTC (rev 451)
+++ qtnx/README	2008-01-30 05:01:33 UTC (rev 452)
@@ -43,7 +43,8 @@
 
 && !defined(Q_CYGWIN_WIN)
 
-You can then build Qt without any trouble by following those instructions. 
+You can then build Qt without any trouble by following those instructions. Ensure
+you also build the XML module and install qmake and mkspecs.
 
 Afterwards, set QTDIR to point to wherever you installed Qt to, and set the
 PATH to point to QTDIR/bin as well:
@@ -55,3 +56,16 @@
 
 $ qmake
 $ make
+
+Mac OS X Builds
+---------------
+
+Ensure that you have a build of Qt 4 on OS X, then run qmake from $QTDIR/bin.
+
+Standard procedure then follows:
+
+$ qmake
+$ make
+
+You can then put statically linked versions of nxssh and nxproxy and id.key in
+qtnx.app/Contents/MacOS - it should then all just work.

Modified: qtnx/qtnx.pro
===================================================================
--- qtnx/qtnx.pro	2008-01-29 19:09:40 UTC (rev 451)
+++ qtnx/qtnx.pro	2008-01-30 05:01:33 UTC (rev 452)
@@ -1,6 +1,6 @@
 TEMPLATE	= app
 
-CONFIG		+= qt warn_on debug
+CONFIG		+= static qt warn_on release
 
 FORMS = settingsdialog.ui logindialog.ui sessionsdialog.ui keydialog.ui logwindow.ui
 
@@ -10,11 +10,19 @@
 
 INCLUDEPATH	+= $(QTDIR)/include
 
-QMAKE_CXXFLAGS += $$system(pkg-config --cflags nxcl)
+!macx {
+    QMAKE_CXXFLAGS += $$system(pkg-config --cflags nxcl)
 
+    LIBS += $$system(pkg-config --libs nxcl)
+}
+
+macx {
+    QMAKE_CXXFLAGS += -I/usr/local/include/nxcl
+    LIBS += -lnxcl
+}
+
 DEPENDPATH	+= $(QTDIR)/include
 
-LIBS += $$system(pkg-config --libs nxcl)
 
 QT += ui xml
 

Modified: qtnx/qtnxwindow.cpp
===================================================================
--- qtnx/qtnxwindow.cpp	2008-01-29 19:09:40 UTC (rev 451)
+++ qtnx/qtnxwindow.cpp	2008-01-30 05:01:33 UTC (rev 452)
@@ -24,6 +24,10 @@
 #include <QFile>
 #include <QMessageBox>
 
+#ifdef Q_WS_MAC
+    #include <CoreFoundation/CFBundle.h>
+#endif
+
 using namespace nxcl;
 using namespace std;
 
@@ -36,6 +40,25 @@
 
     setupUI();
 
+#ifdef Q_WS_MAC
+    // We ship nxproxy and nxssh in qtnx.app/Contents/MacOS
+    CFURLRef appUrlRef = CFBundleCopyBundleURL(CFBundleGetMainBundle());
+    CFStringRef macPath = CFURLCopyFileSystemPath(appUrlRef,
+            kCFURLPOSIXPathStyle);
+
+    const char *pathPtr = CFStringGetCStringPtr(macPath,
+            CFStringGetSystemEncoding());
+
+    CFRelease(appUrlRef);
+    CFRelease(macPath);
+
+    stringstream binaryPath;
+    binaryPath << pathPtr << "/Contents/MacOS";
+    cout << binaryPath.str() << endl;
+
+    nxClient.setCustomPath(binaryPath.str());
+#endif
+
     QDir dir(QDir::homePath()+"/.qtnx","*.nxml");
 
     for (unsigned int i=0;i<dir.count();i++) {
@@ -113,40 +136,43 @@
 
 void QtNXWindow::handleProgress(int id, QString message)
 {
+    if (!message.isEmpty())
+        message = ": " + message;
+
     switch (id) {
         case NXCL_PROCESS_STARTED:
-            updateStatusBar("Process started");
+            updateStatusBar(tr("Process started"));
             break;
         case NXCL_PROCESS_EXITED:
-            updateStatusBar("Process exited");
+            updateStatusBar(tr("Process exited"));
             break;
         case NXCL_AUTH_FAILED:
-            updateStatusBar("Invalid authentication key");
+            updateStatusBar(tr("Invalid authentication key"));
             break;
         case NXCL_AUTHENTICATING:
-            updateStatusBar("Authenticating client");
+            updateStatusBar(tr("Authenticating client"));
             break;
         case NXCL_LOGIN_FAILED:
-            updateStatusBar("Invalid username or password");
+            updateStatusBar(tr("Invalid username or password"));
             failedLogin();
             break;
         case NXCL_HOST_KEY_VERIFAILED:
-            updateStatusBar("Host key verification failed");
+            updateStatusBar(tr("Host key verification failed"));
             break;
         case NXCL_INVOKE_PROXY:
-            updateStatusBar("Starting NX proxy");
+            updateStatusBar(tr("Starting NX proxy"));
             break;
         case NXCL_STARTING:
-            updateStatusBar("Starting session");
+            updateStatusBar(tr("Starting session"));
             break;
         case NXCL_FINISHED:
-            updateStatusBar("Finished connecting");
+            updateStatusBar(tr("Finished connecting"));
             break;
         case NXCL_ALIVE:
-            updateStatusBar("NX session active");
+            updateStatusBar(tr("NX session active"));
             break;
         case NXCL_PROCESS_ERROR:
-            updateStatusBar("Process error");
+            updateStatusBar(tr("Process error"));
             break;
         default:
             break;



From gwright at mail.berlios.de  Wed Jan 30 07:45:12 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Wed, 30 Jan 2008 07:45:12 +0100
Subject: [Freenx-cvs] r453 - qtnx
Message-ID: <200801300645.m0U6jCE5016309@sheep.berlios.de>

Author: gwright
Date: 2008-01-30 07:45:12 +0100 (Wed, 30 Jan 2008)
New Revision: 453

Modified:
   qtnx/qtnxwindow.cpp
   qtnx/qtnxwindow.h
Log:
More miscellaneous Mac OS X stuff


Modified: qtnx/qtnxwindow.cpp
===================================================================
--- qtnx/qtnxwindow.cpp	2008-01-30 05:01:33 UTC (rev 452)
+++ qtnx/qtnxwindow.cpp	2008-01-30 06:45:12 UTC (rev 453)
@@ -52,11 +52,12 @@
     CFRelease(appUrlRef);
     CFRelease(macPath);
 
-    stringstream binaryPath;
-    binaryPath << pathPtr << "/Contents/MacOS";
-    cout << binaryPath.str() << endl;
+    binaryPath = pathPtr;
+    binaryPath.append("/Contents/MacOS");
 
-    nxClient.setCustomPath(binaryPath.str());
+    nxClient.setCustomPath(binaryPath.toStdString());
+
+    setenv("NX_SYSTEM", binaryPath.toStdString().c_str(), 1);
 #endif
 
     QDir dir(QDir::homePath()+"/.qtnx","*.nxml");
@@ -245,7 +246,13 @@
 
     nxClient.setDepth(getDepth());
 
-    nxClient.invokeNXSSH("id.key", config.serverHost, config.encryption, "",
+    QString keyPath = "id.key";
+
+#ifdef Q_WS_MAC
+    keyPath = binaryPath + "/id.key";
+#endif
+
+    nxClient.invokeNXSSH(keyPath.toStdString(), config.serverHost, config.encryption, "",
             config.serverPort);
     processProbe->start(30);
 }
@@ -303,6 +310,10 @@
     if ((nxClient.getIsFinished()) == false) {
         if (nxClient.getReadyForProxy() == false) {
             p->probeProcess();
+        } else if (nxClient.needX11Probe()) {
+            p->probeProcess();
+            p = nxClient.getX11Process();
+            p->probeProcess();
         } else {
             p->probeProcess();
             p = nxClient.getNXProxyProcess();

Modified: qtnx/qtnxwindow.h
===================================================================
--- qtnx/qtnxwindow.h	2008-01-30 05:01:33 UTC (rev 452)
+++ qtnx/qtnxwindow.h	2008-01-30 06:45:12 UTC (rev 453)
@@ -141,5 +141,7 @@
         QWidget *loginDialog;
 
         QtNXCallback callback;
+
+        QString binaryPath;
 };
 #endif



From gwright at mail.berlios.de  Wed Jan 30 07:45:39 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Wed, 30 Jan 2008 07:45:39 +0100
Subject: [Freenx-cvs] r454 - nxcl/lib
Message-ID: <200801300645.m0U6jdTV016343@sheep.berlios.de>

Author: gwright
Date: 2008-01-30 07:45:39 +0100 (Wed, 30 Jan 2008)
New Revision: 454

Modified:
   nxcl/lib/nxclientlib.cpp
   nxcl/lib/nxclientlib.h
Log:
Fix X11 loading on OS X


Modified: nxcl/lib/nxclientlib.cpp
===================================================================
--- nxcl/lib/nxclientlib.cpp	2008-01-30 06:45:12 UTC (rev 453)
+++ nxcl/lib/nxclientlib.cpp	2008-01-30 06:45:39 UTC (rev 454)
@@ -153,13 +153,13 @@
 
     this->pNxsshProcess = &this->nxsshProcess;
     this->pNxproxyProcess = &this->nxproxyProcess;
-    this->pNxwinProcess = &this->nxwinProcess;
+    this->pX11Process = &this->x11Process;
     this->pNxauthProcess = &this->nxauthProcess;
 
     /* Set up callback pointers */
     this->nxsshProcess.setCallbacks (&callbacks);
     this->nxproxyProcess.setCallbacks (&callbacks);
-    this->nxwinProcess.setCallbacks (&callbacks);
+    this->x11Process.setCallbacks (&callbacks);
     this->nxauthProcess.setCallbacks (&callbacks);
     this->session.setCallbacks (&callbacks);
     this->callbacks.setParent (this);
@@ -246,10 +246,6 @@
     // Find a path for the nxssh process using getPath()
     string nxsshPath = this->getPath ("nxssh");
 
-#ifdef NXCL_DARWIN
-    nxsshPath = "open-x11";
-#endif
-
     this->nxsshProcess.start(nxsshPath, arguments);
 
     if (this->nxsshProcess.waitForStarted() == false) {
@@ -608,7 +604,7 @@
     this->externalCallbacks->write
         (NXCL_INVOKE_PROXY, _("Starting NX session"));
 
-#ifdef NXCL_CYGWIN
+#if NXCL_CYGWIN
     NXSessionData* sessionData = getSession()->getSessionData();
 
     stringstream resolution;
@@ -621,6 +617,32 @@
     startX11(resolution.str(), "");
 #endif
 
+#if NXCL_DARWIN
+    // Let's run open -a X11 to fire up X
+    list<string> x11Arguments;
+
+    x11Arguments.push_back("open");
+    x11Arguments.push_back("-a");
+    x11Arguments.push_back("X11");
+
+    string openPath = this->getPath("open");
+    
+    this->x11Process.start(openPath, x11Arguments);
+
+    this->x11Probe = true;
+    
+    if (this->x11Process.waitForStarted() == false) {
+        this->externalCallbacks->write
+            (NXCL_PROCESS_ERROR, _("Error starting X11!"));
+        this->isFinished = true;
+    }
+    
+    this->x11Probe = false;
+
+    // Horrendous hack - must fix
+    for (int i = 0; i < 32768; i++) {};
+#endif
+
     int e;
     char * home;
 
@@ -660,9 +682,16 @@
         }
     }
 
+    string x11Display = "";
+
+#if NXCL_DARWIN
+    x11Display = ",display=:0.0";
+#endif
+
     stringstream data;
+ 
     if (proxyData.encrypted) {
-        data << "nx/nx,session=session,encryption=1,cookie="
+        data << "nx/nx" << x11Display << ",session=session,encryption=1,cookie="
             << proxyData.cookie
             << ",root=" << home << "/.nx"
             << ",id=" << proxyData.id << ",listen=" 
@@ -671,10 +700,11 @@
 
     } else {
         // Not tested yet
-        data << "nx,session=session,cookie=" << proxyData.cookie
+        data << "nx/nx" << x11Display << ",session=session,cookie=" << proxyData.cookie
             << ",root=" << home
             << "/.nx,id=" << proxyData.id
-            << ",connect=" << proxyData.server << ":" << proxyData.display
+            // << ",connect=" << proxyData.server << ":" << proxyData.display
+            << ",listen=" << proxyData.port << ":" << proxyData.display
             << "\n";
     }
 
@@ -687,9 +717,6 @@
 
     // Build arguments for the call to the nxproxy command
     list<string> arguments;
-#ifdef NXCL_DARWIN
-    arguments.push_back("open-x11"); // We open X11 apps on OS X with this script
-#endif
     arguments.push_back("nxproxy"); // argv[0] has to be the program name
     arguments.push_back("-S");
     ss.str("");
@@ -710,7 +737,7 @@
 
 void NXClientLib::startX11 (string resolution, string name)
 {
-#ifdef NXCL_CYGWIN
+#if NXCL_CYGWIN
     // Invoke NXWin.exe on Windows machines
 
     // See if XAUTHORITY path is set
@@ -807,9 +834,9 @@
         dimensions = strtok(NULL, "x");
     }
 
-    this->nxwinProcess.start("nxwin", nxwinArguments);
+    this->x11Process.start("nxwin", nxwinArguments);
 
-    if (this->nxwinProcess.waitForStarted() == false) {
+    if (this->x11Process.waitForStarted() == false) {
         this->externalCallbacks->write
             (NXCL_PROCESS_ERROR, _("Error starting nxwin!"));
         this->isFinished = true;
@@ -839,6 +866,19 @@
         return prog;
     }
 
+    // We'll check the custom search path first
+    stringstream pathTest;
+    pathTest << customPath << "/" << prog;
+
+    memset (buf, 0, sizeof(struct stat));
+    stat (pathTest.str().c_str(), buf);
+
+    if (S_ISREG (buf->st_mode) || S_ISLNK (buf->st_mode)) {
+        // Found in custom path
+        free(buf);
+        return pathTest.str();
+    }
+
     path = PACKAGE_BIN_DIR"/" + prog;
     memset (buf, 0, sizeof(struct stat));
     stat (path.c_str(), buf);

Modified: nxcl/lib/nxclientlib.h
===================================================================
--- nxcl/lib/nxclientlib.h	2008-01-30 06:45:12 UTC (rev 453)
+++ nxcl/lib/nxclientlib.h	2008-01-30 06:45:39 UTC (rev 454)
@@ -186,6 +186,14 @@
             void write (string data);
 
             /*!
+             * Sets a custom binary search path
+             */
+            void setCustomPath(string path)
+            {
+                this->customPath = path;
+            }
+            
+            /*!
              * Passes auth to this->session.setContinue()
              */
             void allowSSHConnect (bool auth);
@@ -232,8 +240,13 @@
 
             void runSession (void);
 
-	    void startX11(string resolution, string name);
+            void startX11 (string resolution, string name);
 
+            bool needX11Probe (void)
+            {
+                return x11Probe;
+            }
+            
             // public slots:
             //@{
             void doneAuth (void);
@@ -308,9 +321,9 @@
                 return this->pNxproxyProcess;
             }
 
-	    notQProcess* getNXWinProcess (void)
-	    {
-                return this->pNxwinProcess;
+            notQProcess* getX11Process (void)
+            {
+                return this->pX11Process;
             }
 
             notQProcess* getNXAuthProcess (void)
@@ -362,6 +375,12 @@
             string getPath (string prog);
 
             /*!
+             * Custom search path
+             */
+            string customPath;
+
+            bool x11Probe;
+            /*!
              * Set true when the program is ready to end, e.g if
              * authentication failed, nxssh failed to start amoung
              * other reasons.
@@ -401,10 +420,10 @@
             notQProcess nxproxyProcess;
             notQProcess* pNxproxyProcess;
             /*!
-             * The nxwin process object
+             * The X11 process object
              */
-            notQProcess nxwinProcess;
-            notQProcess* pNxwinProcess;
+            notQProcess x11Process;
+            notQProcess* pX11Process;
             /*!
              * The nxauth process object
              */



From gwright at mail.berlios.de  Wed Jan 30 07:58:28 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Wed, 30 Jan 2008 07:58:28 +0100
Subject: [Freenx-cvs] r455 - nxcl
Message-ID: <200801300658.m0U6wSae016865@sheep.berlios.de>

Author: gwright
Date: 2008-01-30 07:58:28 +0100 (Wed, 30 Jan 2008)
New Revision: 455

Modified:
   nxcl/nxcl.pc.in
Log:
This is a lie.


Modified: nxcl/nxcl.pc.in
===================================================================
--- nxcl/nxcl.pc.in	2008-01-30 06:45:39 UTC (rev 454)
+++ nxcl/nxcl.pc.in	2008-01-30 06:58:28 UTC (rev 455)
@@ -8,7 +8,7 @@
 Name: nxcl
 Description: NX client library
 Version: @VERSION@
-Requires: x11
+Requires:
 Conflicts:
 Libs: -L${libdir} -lnxcl
 Cflags: -I${includedir}



From gwright at mail.berlios.de  Wed Jan 30 08:57:36 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Wed, 30 Jan 2008 08:57:36 +0100
Subject: [Freenx-cvs] r456 - in nxcl: . lib nxcl test
Message-ID: <200801300757.m0U7vaBT021113@sheep.berlios.de>

Author: gwright
Date: 2008-01-30 08:57:35 +0100 (Wed, 30 Jan 2008)
New Revision: 456

Modified:
   nxcl/configure.ac
   nxcl/lib/Makefile.am
   nxcl/nxcl/Makefile.am
   nxcl/test/Makefile.am
Log:
Fix debug builds


Modified: nxcl/configure.ac
===================================================================
--- nxcl/configure.ac	2008-01-30 06:58:28 UTC (rev 455)
+++ nxcl/configure.ac	2008-01-30 07:57:35 UTC (rev 456)
@@ -99,6 +99,8 @@
   AC_DEFINE(DEBUG, 0, Define if debugging output should be enabled)
 fi
 
+AM_CONDITIONAL(DEBUG, test "$nxcl_debug" = yes)
+
 dnl Do some platform checking for cygwin
 
 if test "$(uname -o)" = Cygwin; then

Modified: nxcl/lib/Makefile.am
===================================================================
--- nxcl/lib/Makefile.am	2008-01-30 06:58:28 UTC (rev 455)
+++ nxcl/lib/Makefile.am	2008-01-30 07:57:35 UTC (rev 456)
@@ -1,5 +1,10 @@
 CLEANFILES = *~
 AM_CPPFLAGS = @PACKAGE_CFLAGS@  -DPACKAGE_BIN_DIR=\""$(bindir)"\"
+
+if DEBUG
+    AM_CPPFLAGS += -DDEBUG
+endif
+
 INCLUDES = -I$(top_srcdir) -I$(top_builddir)
 lib_LTLIBRARIES = libnxcl.la
 libnxcl_la_SOURCES = notQt.cpp nxsession.cpp nxclientlib.cpp

Modified: nxcl/nxcl/Makefile.am
===================================================================
--- nxcl/nxcl/Makefile.am	2008-01-30 06:58:28 UTC (rev 455)
+++ nxcl/nxcl/Makefile.am	2008-01-30 07:57:35 UTC (rev 456)
@@ -1,5 +1,9 @@
 AM_CPPFLAGS = @PACKAGE_CFLAGS@ -DPACKAGE_DATA_DIR=\""$(datadir)"\" -DLOCALEDIR=\"$(localedir)\" -DPACKAGE_BIN_DIR=\""$(bindir)"\" $(DBUS_CFLAGS)
 
+if DEBUG
+    AM_CPPFLAGS += -DDEBUG
+endif
+
 INCLUDES = -I../lib
 bin_PROGRAMS = nxcl
 nxcl_SOURCES = main.cpp nxcl.cpp

Modified: nxcl/test/Makefile.am
===================================================================
--- nxcl/test/Makefile.am	2008-01-30 06:58:28 UTC (rev 455)
+++ nxcl/test/Makefile.am	2008-01-30 07:57:35 UTC (rev 456)
@@ -6,6 +6,10 @@
   bin_PROGRAMS += nxcmd
 endif
 
+if DEBUG
+  AM_CPPFLAGS += -DDEBUG
+endif
+
 libtest_SOURCES = libtest.cpp
 libtest_LDADD = @PACKAGE_LIBS@ $(LIBINTL) -L../lib -lnxcl
 notQttest_SOURCES = notQttest.cpp



From gwright at mail.berlios.de  Wed Jan 30 09:00:54 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Wed, 30 Jan 2008 09:00:54 +0100
Subject: [Freenx-cvs] r457 - nxcl
Message-ID: <200801300800.m0U80sok021576@sheep.berlios.de>

Author: gwright
Date: 2008-01-30 09:00:54 +0100 (Wed, 30 Jan 2008)
New Revision: 457

Modified:
   nxcl/configure.ac
Log:
This is unnecessary


Modified: nxcl/configure.ac
===================================================================
--- nxcl/configure.ac	2008-01-30 07:57:35 UTC (rev 456)
+++ nxcl/configure.ac	2008-01-30 08:00:54 UTC (rev 457)
@@ -93,11 +93,6 @@
   esac], nxcl_debug=no)
 AC_MSG_CHECKING(whether to enable debugging output)
 AC_MSG_RESULT($nxcl_debug)
-if test "$nxcl_debug" = yes; then
-  AC_DEFINE(DEBUG, 1, Define if debugging output should be enabled)
-else
-  AC_DEFINE(DEBUG, 0, Define if debugging output should be enabled)
-fi
 
 AM_CONDITIONAL(DEBUG, test "$nxcl_debug" = yes)
 



From gwright at mail.berlios.de  Thu Jan  3 13:53:35 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Thu, 03 Jan 2008 12:53:35 -0000
Subject: [Freenx-cvs] r430 - / qtnx
Message-ID: <200801031252.m03CqDrA024739@sheep.berlios.de>

Author: gwright
Date: 2008-01-03 13:52:12 +0100 (Thu, 03 Jan 2008)
New Revision: 430

Added:
   qtnx/
   qtnx/README
   qtnx/id.key
   qtnx/keydialog.ui
   qtnx/logindialog.ui
   qtnx/logwindow.ui
   qtnx/main.cpp
   qtnx/nxparsexml.cpp
   qtnx/nxparsexml.h
   qtnx/nxwritexml.cpp
   qtnx/nxwritexml.h
   qtnx/qtnx.pro
   qtnx/qtnxsessions.cpp
   qtnx/qtnxsessions.h
   qtnx/qtnxsettings.cpp
   qtnx/qtnxsettings.h
   qtnx/qtnxwindow.cpp
   qtnx/qtnxwindow.h
   qtnx/sessionsdialog.ui
   qtnx/settingsdialog.ui
Log:
Initial import of the new QtNX client based on nxcl


Added: qtnx/README
===================================================================
--- qtnx/README	2008-01-03 12:25:34 UTC (rev 429)
+++ qtnx/README	2008-01-03 12:52:12 UTC (rev 430)
@@ -0,0 +1,31 @@
+
+  qtnx: A Qt-based NX client linking to nxcl
+
+  George Wright. January 2008. gwright at kde.org
+
+This is an update of the experimental QtNX client which was based on the
+now deprecated NXClientLib backend library. This is an experimental port
+to Seb James' nxcl library.
+
+Building qtnx
+-------------
+
+Prerequisites are:
+
+* libXcomp from NoMachine, provided by the nxcomp package.
+* nxssh from NoMachine
+* nxproxy from NoMachine
+* nxcl from the FreeNX subversion repository
+
+(These three NX components all should be from the 3.x.x series. You can
+obtain them from NoMachine's servers at http://www.nomachine.com/sources.php)
+
+Read the nxcl README for details of the first three packages.
+
+To build QtNX you will need Qt 4.x. You need to run the following commands:
+
+qmake
+make
+
+This will generate a qtnx binary in that directory; install it to /usr/bin
+or anywhere you want.

Added: qtnx/id.key
===================================================================
--- qtnx/id.key	2008-01-03 12:25:34 UTC (rev 429)
+++ qtnx/id.key	2008-01-03 12:52:12 UTC (rev 430)
@@ -0,0 +1,12 @@
+-----BEGIN DSA PRIVATE KEY-----
+MIIBuwIBAAKBgQCXv9AzQXjxvXWC1qu3CdEqskX9YomTfyG865gb4D02ZwWuRU/9
+C3I9/bEWLdaWgJYXIcFJsMCIkmWjjeSZyTmeoypI1iLifTHUxn3b7WNWi8AzKcVF
+aBsBGiljsop9NiD1mEpA0G+nHHrhvTXz7pUvYrsrXcdMyM6rxqn77nbbnwIVALCi
+xFdHZADw5KAVZI7r6QatEkqLAoGBAI4L1TQGFkq5xQ/nIIciW8setAAIyrcWdK/z
+5/ZPeELdq70KDJxoLf81NL/8uIc4PoNyTRJjtT3R4f8Az1TsZWeh2+ReCEJxDWgG
+fbk2YhRqoQTtXPFsI4qvzBWct42WonWqyyb1bPBHk+JmXFscJu5yFQ+JUVNsENpY
++Gkz3HqTAoGANlgcCuA4wrC+3Cic9CFkqiwO/Rn1vk8dvGuEQqFJ6f6LVfPfRTfa
+QU7TGVLk2CzY4dasrwxJ1f6FsT8DHTNGnxELPKRuLstGrFY/PR7KeafeFZDf+fJ3
+mbX5nxrld3wi5titTnX+8s4IKv29HJguPvOK/SI7cjzA+SqNfD7qEo8CFDIm1xRf
+8xAPsSKs6yZ6j1FNklfu
+-----END DSA PRIVATE KEY-----

Added: qtnx/keydialog.ui
===================================================================
--- qtnx/keydialog.ui	2008-01-03 12:25:34 UTC (rev 429)
+++ qtnx/keydialog.ui	2008-01-03 12:52:12 UTC (rev 430)
@@ -0,0 +1,118 @@
+<ui version="4.0" >
+ <author></author>
+ <comment></comment>
+ <exportmacro></exportmacro>
+ <class>KeyDialog</class>
+ <widget class="QDialog" name="KeyDialog" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>400</width>
+    <height>300</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string>Dialog</string>
+  </property>
+  <layout class="QVBoxLayout" >
+   <property name="margin" >
+    <number>9</number>
+   </property>
+   <property name="spacing" >
+    <number>6</number>
+   </property>
+   <item>
+    <widget class="QTextEdit" name="key" >
+     <property name="font" >
+      <font>
+       <family>Courier</family>
+       <pointsize>9</pointsize>
+       <weight>50</weight>
+       <italic>false</italic>
+       <bold>false</bold>
+       <underline>false</underline>
+       <strikeout>false</strikeout>
+      </font>
+     </property>
+     <property name="lineWrapMode" >
+      <enum>QTextEdit::NoWrap</enum>
+     </property>
+    </widget>
+   </item>
+   <item>
+    <layout class="QHBoxLayout" >
+     <property name="margin" >
+      <number>0</number>
+     </property>
+     <property name="spacing" >
+      <number>6</number>
+     </property>
+     <item>
+      <spacer>
+       <property name="orientation" >
+        <enum>Qt::Horizontal</enum>
+       </property>
+       <property name="sizeHint" >
+        <size>
+         <width>131</width>
+         <height>31</height>
+        </size>
+       </property>
+      </spacer>
+     </item>
+     <item>
+      <widget class="QPushButton" name="okButton" >
+       <property name="text" >
+        <string>OK</string>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <widget class="QPushButton" name="cancelButton" >
+       <property name="text" >
+        <string>Cancel</string>
+       </property>
+      </widget>
+     </item>
+    </layout>
+   </item>
+  </layout>
+ </widget>
+ <pixmapfunction></pixmapfunction>
+ <resources/>
+ <connections>
+  <connection>
+   <sender>okButton</sender>
+   <signal>clicked()</signal>
+   <receiver>KeyDialog</receiver>
+   <slot>accept()</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>278</x>
+     <y>253</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>96</x>
+     <y>254</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>cancelButton</sender>
+   <signal>clicked()</signal>
+   <receiver>KeyDialog</receiver>
+   <slot>reject()</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>369</x>
+     <y>253</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>179</x>
+     <y>282</y>
+    </hint>
+   </hints>
+  </connection>
+ </connections>
+</ui>

Added: qtnx/logindialog.ui
===================================================================
--- qtnx/logindialog.ui	2008-01-03 12:25:34 UTC (rev 429)
+++ qtnx/logindialog.ui	2008-01-03 12:52:12 UTC (rev 430)
@@ -0,0 +1,163 @@
+<ui version="4.0" >
+ <author></author>
+ <comment></comment>
+ <exportmacro></exportmacro>
+ <class>LoginDialog</class>
+ <widget class="QWidget" name="LoginDialog" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>396</width>
+    <height>207</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string>Form</string>
+  </property>
+  <layout class="QVBoxLayout" >
+   <property name="margin" >
+    <number>9</number>
+   </property>
+   <property name="spacing" >
+    <number>6</number>
+   </property>
+   <item>
+    <widget class="QLabel" name="logo" >
+     <property name="text" >
+      <string>&lt;html>&lt;head>&lt;meta name="qrichtext" content="1" />&lt;/head>&lt;body style=" white-space: pre-wrap; font-family:Sans Serif; font-size:9pt; font-weight:400; font-style:normal; text-decoration:none;">&lt;p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">&lt;span style=" font-size:21pt; font-weight:600;">QtNX&lt;/span>&lt;/p>&lt;/body>&lt;/html></string>
+     </property>
+     <property name="alignment" >
+      <set>Qt::AlignCenter</set>
+     </property>
+    </widget>
+   </item>
+   <item>
+    <layout class="QHBoxLayout" >
+     <property name="margin" >
+      <number>0</number>
+     </property>
+     <property name="spacing" >
+      <number>6</number>
+     </property>
+     <item>
+      <layout class="QVBoxLayout" >
+       <property name="margin" >
+        <number>0</number>
+       </property>
+       <property name="spacing" >
+        <number>6</number>
+       </property>
+       <item>
+        <widget class="QLabel" name="usernameLabel" >
+         <property name="text" >
+          <string>Username:</string>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <widget class="QLabel" name="passwordLabel" >
+         <property name="text" >
+          <string>Password:</string>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <widget class="QLabel" name="label" >
+         <property name="text" >
+          <string>Session:</string>
+         </property>
+        </widget>
+       </item>
+      </layout>
+     </item>
+     <item>
+      <layout class="QVBoxLayout" >
+       <property name="margin" >
+        <number>0</number>
+       </property>
+       <property name="spacing" >
+        <number>6</number>
+       </property>
+       <item>
+        <widget class="QLineEdit" name="username" >
+         <property name="minimumSize" >
+          <size>
+           <width>300</width>
+           <height>0</height>
+          </size>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <widget class="QLineEdit" name="password" >
+         <property name="minimumSize" >
+          <size>
+           <width>300</width>
+           <height>0</height>
+          </size>
+         </property>
+         <property name="echoMode" >
+          <enum>QLineEdit::Password</enum>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <widget class="QComboBox" name="session" >
+         <property name="sizePolicy" >
+          <sizepolicy>
+           <hsizetype>3</hsizetype>
+           <vsizetype>0</vsizetype>
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+        </widget>
+       </item>
+      </layout>
+     </item>
+    </layout>
+   </item>
+   <item>
+    <layout class="QHBoxLayout" >
+     <property name="margin" >
+      <number>0</number>
+     </property>
+     <property name="spacing" >
+      <number>6</number>
+     </property>
+     <item>
+      <widget class="QPushButton" name="configureButton" >
+       <property name="text" >
+        <string>Confi&amp;gure...</string>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <spacer>
+       <property name="orientation" >
+        <enum>Qt::Horizontal</enum>
+       </property>
+       <property name="sizeHint" >
+        <size>
+         <width>40</width>
+         <height>20</height>
+        </size>
+       </property>
+      </spacer>
+     </item>
+     <item>
+      <widget class="QPushButton" name="connectButton" >
+       <property name="text" >
+        <string>&amp;Connect</string>
+       </property>
+      </widget>
+     </item>
+    </layout>
+   </item>
+  </layout>
+ </widget>
+ <pixmapfunction></pixmapfunction>
+ <resources/>
+ <connections/>
+</ui>

Added: qtnx/logwindow.ui
===================================================================
--- qtnx/logwindow.ui	2008-01-03 12:25:34 UTC (rev 429)
+++ qtnx/logwindow.ui	2008-01-03 12:52:12 UTC (rev 430)
@@ -0,0 +1,51 @@
+<ui version="4.0" >
+ <author></author>
+ <comment></comment>
+ <exportmacro></exportmacro>
+ <class>LogWindow</class>
+ <widget class="QDialog" name="LogWindow" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>400</width>
+    <height>300</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string>Dialog</string>
+  </property>
+  <layout class="QVBoxLayout" >
+   <property name="margin" >
+    <number>9</number>
+   </property>
+   <property name="spacing" >
+    <number>6</number>
+   </property>
+   <item>
+    <widget class="QTextEdit" name="output" >
+     <property name="font" >
+      <font>
+       <family>Courier</family>
+       <pointsize>9</pointsize>
+       <weight>50</weight>
+       <italic>false</italic>
+       <bold>false</bold>
+       <underline>false</underline>
+       <strikeout>false</strikeout>
+      </font>
+     </property>
+     <property name="lineWrapMode" >
+      <enum>QTextEdit::NoWrap</enum>
+     </property>
+     <property name="readOnly" >
+      <bool>true</bool>
+     </property>
+    </widget>
+   </item>
+  </layout>
+ </widget>
+ <pixmapfunction></pixmapfunction>
+ <resources/>
+ <connections/>
+</ui>

Added: qtnx/main.cpp
===================================================================
--- qtnx/main.cpp	2008-01-03 12:25:34 UTC (rev 429)
+++ qtnx/main.cpp	2008-01-03 12:52:12 UTC (rev 430)
@@ -0,0 +1,35 @@
+/***************************************************************************
+                                  main.cpp
+                            -------------------
+        begin                : Thursday August 3rd 2006
+        copyright            : (C) 2006 by George Wright
+                               (C) 2007 Defuturo Ltd
+        email                : gwright at kde.org
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include <QApplication>
+
+#include "qtnxwindow.h"
+
+ofstream debugLogFile;
+
+int main(int argc, char *argv[])
+{
+    debugLogFile.open("/tmp/nxcl.log", ios::out|ios::trunc);
+
+    QApplication app(argc, argv);
+
+    QtNXWindow *mw = new QtNXWindow();
+    mw->show();
+
+    return app.exec();
+}
+

Added: qtnx/nxparsexml.cpp
===================================================================
--- qtnx/nxparsexml.cpp	2008-01-03 12:25:34 UTC (rev 429)
+++ qtnx/nxparsexml.cpp	2008-01-03 12:52:12 UTC (rev 430)
@@ -0,0 +1,142 @@
+/***************************************************************************
+                              nxparsexml.cpp
+                            -------------------
+        begin                : Friday August 4th 2006
+        copyright            : (C) 2006 by George Wright
+                               (C) 2007 Defuturo Ltd
+        email                : gwright at kde.org
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <iostream>
+#include "nxparsexml.h"
+
+using namespace std;
+using namespace nxcl;
+
+NXParseXML::NXParseXML()
+{
+}
+
+NXParseXML::~NXParseXML()
+{
+}
+
+bool NXParseXML::startElement(const QString &namespaceURI, const QString &localName, const QString &qName, const QXmlAttributes &attributes)
+{
+    if (attributes.value("key") == "Connection Name") {
+        sessionData->sessionName = attributes.value("value").toStdString();
+    }
+
+    if (attributes.value("key") == "Server Hostname") {
+        sessionData->serverHost = attributes.value("value").toStdString();
+    }
+
+    if (attributes.value("key") == "Server Port") {
+        sessionData->serverPort = attributes.value("value").toInt();
+    }
+
+    if (attributes.value("key") == "Session Type") {
+        sessionData->sessionType = attributes.value("value").toStdString();
+    }
+
+    if (attributes.value("key") == "Custom Session Command") {
+        sessionData->customCommand = attributes.value("value").toStdString();
+    }
+
+    if (attributes.value("key") == "Disk Cache") {
+        sessionData->cache = attributes.value("value").toInt();
+    }
+
+    if (attributes.value("key") == "Image Cache") {
+        sessionData->images = attributes.value("value").toInt();
+    }
+
+    if (attributes.value("key") == "Link Type") {
+        sessionData->linkType = attributes.value("value").toStdString();
+    }
+
+    if (attributes.value("key") == "Use Render Extension") {
+        if (attributes.value("value") == "True")
+            sessionData->render = true;
+        else
+            sessionData->render = false;
+    }
+
+    if (attributes.value("key") == "Image Compression Method") {
+        if (attributes.value("value") == "JPEG")
+            sessionData->imageCompressionMethod = -1;
+        else if (attributes.value("value") == "PNG")
+            sessionData->imageCompressionMethod = 2;
+        else if (attributes.value("value") == "Raw X11")
+            sessionData->imageCompressionMethod = 0;
+    }
+
+    if (attributes.value("key") == "JPEG Compression Level") {
+        sessionData->imageCompressionLevel = attributes.value("value").toInt();
+    }
+
+    if (attributes.value("key") == "Desktop Geometry") {
+        sessionData->geometry = attributes.value("value").toStdString();
+    }
+
+    if (attributes.value("key") == "Keyboard Layout") {
+        sessionData->keyboard = attributes.value("value").toStdString();
+    }
+
+    if (attributes.value("key") == "Keyboard Type") {
+        sessionData->kbtype = attributes.value("value").toStdString();
+    }
+
+    if (attributes.value("key") == "Media") {
+        if (attributes.value("value") == "True")
+            sessionData->media = true;
+        else
+            sessionData->media = false;
+    }
+
+    if (attributes.value("key") == "Agent Server") {
+        sessionData->agentServer = attributes.value("value").toStdString();
+    }
+
+    if (attributes.value("key") == "Agent User") {
+        sessionData->agentUser = attributes.value("value").toStdString();
+    }
+
+    if (attributes.value("key") == "CUPS Port") {
+        sessionData->cups = attributes.value("value").toInt();
+    }
+
+    if (attributes.value("key") == "Authentication Key") {
+        sessionData->key = attributes.value("value").toStdString();
+    }
+
+    if (attributes.value("key") == "Use SSL Tunnelling") {
+        if (attributes.value("value") == "True")
+            sessionData->encryption = true;
+        else
+            sessionData->encryption = false;
+    }
+
+    if (attributes.value("key") == "Enable Fullscreen Desktop") {
+        if (attributes.value("value") == "True")
+            sessionData->fullscreen = true;
+        else
+            sessionData->fullscreen = false;
+    }
+
+    return true;
+}
+
+bool NXParseXML::endElement(const QString &namespaceURI, const QString &localName, const QString &qName)
+{
+    return true;
+}

Added: qtnx/nxparsexml.h
===================================================================
--- qtnx/nxparsexml.h	2008-01-03 12:25:34 UTC (rev 429)
+++ qtnx/nxparsexml.h	2008-01-03 12:52:12 UTC (rev 430)
@@ -0,0 +1,46 @@
+/***************************************************************************
+                                nxparsexml.h
+                            -------------------
+        begin                : Friday August 4th 2006
+        copyright            : (C) 2006 by George Wright
+                             : (C) 2007 Defuturo Ltd
+        email                : gwright at kde.org
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef _NXPARSEXML_H_
+#define _NXPARSEXML_H_
+
+#include <QXmlDefaultHandler>
+
+#include "nxdata.h"
+#include "nxsession.h"
+
+using namespace nxcl;
+
+class NXParseXML : public QObject, public QXmlDefaultHandler
+{
+    Q_OBJECT
+    public:
+        NXParseXML();
+        ~NXParseXML();
+        bool startElement(const QString &namespaceURI, const QString
+                &localName, const QString &qName, const QXmlAttributes 
+                &attributes);
+        bool endElement(const QString &namespaceURI, const QString
+                &localName, const QString &qName);
+        void setData(NXConfigData *data) { sessionData = data; };
+    private:
+        NXConfigData *sessionData;
+        int group;
+};
+
+#endif

Added: qtnx/nxwritexml.cpp
===================================================================
--- qtnx/nxwritexml.cpp	2008-01-03 12:25:34 UTC (rev 429)
+++ qtnx/nxwritexml.cpp	2008-01-03 12:52:12 UTC (rev 430)
@@ -0,0 +1,152 @@
+/***************************************************************************
+                                nxwritexml.cpp
+                            -------------------
+        begin                : Wednesday August 9th 2006
+        copyright            : (C) 2006 by George Wright
+                               (C) 2007 Defuturo Ltd
+        email                : gwright at kde.org
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "nxwritexml.h"
+
+NXWriteXML::NXWriteXML()
+{
+}
+
+NXWriteXML::~NXWriteXML()
+{
+}
+
+void NXWriteXML::write(QString fileName)
+{
+    QFile file(fileName);
+    file.open(QFile::WriteOnly);
+
+    QTextStream xml(&file);
+    xml.setCodec("UTF-8");
+
+    xml << "<!DOCTYPE NXClientLibSettings>\n";
+    xml << "<NXClientLibSettings>\n";
+
+    xml << "<option key=\"Connection Name\" value=\"" <<
+        escape(QString::fromStdString(sessionData.sessionName)) <<
+        "\"></option>\n";
+
+    xml << "<option key=\"Server Hostname\" value=\"" <<
+        escape(QString::fromStdString(sessionData.serverHost)) <<
+        "\"></option>\n";
+
+    xml << "<option key=\"Server Port\" value=\"" <<
+        escape(QString::number(sessionData.serverPort)) <<
+        "\"></option>\n";
+
+    xml << "<option key=\"Session Type\" value=\"" <<
+        escape(QString::fromStdString(sessionData.sessionType)) <<
+        "\"></option>\n";
+
+    xml << "<option key=\"Custom Session Command\" value=\"" <<
+        escape(QString::fromStdString(sessionData.customCommand)) <<
+        "\"></option>\n";
+
+    xml << "<option key=\"Disk Cache\" value=\"" <<
+        escape(QString::number(sessionData.cache)) <<
+        "\"></option>\n";
+
+    xml << "<option key=\"Image Cache\" value=\"" <<
+        escape(QString::number(sessionData.images)) <<
+        "\"></option>\n";
+
+    xml << "<option key=\"Link Type\" value=\"" <<
+        escape(QString::fromStdString(sessionData.linkType)) <<
+        "\"></option>\n";
+
+    if (sessionData.render == true)
+        xml << "<option key=\"Use Render Extension\" value=\"True\">" +
+            "</option>\n";
+    else
+        xml << "<option key=\"Use Render Extension\" value=\"False\">" +
+            "</option>\n";
+
+    if (sessionData.imageCompressionMethod == -1)
+        xml << "<option key=\"Image Compression Method\" value=\"JPEG\">" +
+            "</option>\n";
+    else if (sessionData.imageCompressionMethod == 2)
+        xml << "<option key=\"Image Compression Method\" value=\"PNG\">" +
+            "</option>\n";
+    else if (sessionData.imageCompressionMethod == 0)
+        xml << "<option key=\"Image Compression Method\" value=\"Raw X11\">" +
+            "</option>\n";
+
+    xml << "<option key=\"JPEG Compression Level\" value=\"" <<
+        escape(QString::number(sessionData.imageCompressionLevel)) <<
+        "\"></option>\n";
+
+    xml << "<option key=\"Desktop Geometry\" value=\"" <<
+        escape(QString::fromStdString(sessionData.geometry)) <<
+        "\"></option>\n";
+
+    xml << "<option key=\"Keyboard Layout\" value=\"" <<
+        escape(QString::fromStdString(sessionData.keyboard)) <<
+        "\"></option>\n";
+
+    xml << "<option key=\"Keyboard Type\" value=\"" <<
+        escape(QString::fromStdString(sessionData.kbtype)) <<
+        "\"></option>\n";
+
+    if (sessionData.media == true)
+        xml << "<option key=\"Media\" value=\"True\"></option>\n";
+    else
+        xml << "<option key=\"Media\" value=\"False\"></option>\n";
+
+    xml << "<option key=\"Agent Server\" value=\"" <<
+        escape(QString::fromStdString(sessionData.agentServer)) <<
+        "\"></option>\n";
+
+    xml << "<option key=\"Agent User\" value=\"" <<
+        escape(QString::fromStdString(sessionData.agentUser)) <<
+        "\"></option>\n";
+
+    xml << "<option key=\"CUPS Port\" value=\"" <<
+        escape(QString::number(sessionData.cups)) <<
+        "\"></option>\n";
+
+    xml << "<option key=\"Authentication Key\" value=\"" <<
+        escape(QString::fromStdString(sessionData.key)) <<
+        "\"></option>\n";
+
+    if (sessionData.encryption == true)
+        xml << "<option key=\"Use SSL Tunnelling\" value=\"True\">" +
+            "</option>\n";
+    else
+        xml << "<option key=\"Use SSL Tunnelling\" value=\"False\">" +
+            "</option>\n";
+
+    if (sessionData.fullscreen == true)
+        xml << "<option key=\"Enable Fullscreen Desktop\" value=\"True\">" +
+            "</option>\n";
+    else
+        xml << "<option key=\"Enable Fullscreen Desktop\" value=\"False\">" +
+            "</option>\n";
+
+    xml << "</NXClientLibSettings>\n";
+
+    file.close();
+}
+
+QString NXWriteXML::escape(QString plain)
+{
+    QString formatted;
+    formatted = plain.replace('<', "&lt;");
+    formatted = plain.replace('>', "&rt;");
+    formatted = plain.replace('&', "&amp;");
+    return formatted;
+}

Added: qtnx/nxwritexml.h
===================================================================
--- qtnx/nxwritexml.h	2008-01-03 12:25:34 UTC (rev 429)
+++ qtnx/nxwritexml.h	2008-01-03 12:52:12 UTC (rev 430)
@@ -0,0 +1,43 @@
+/***************************************************************************
+                                nxwritexml.h
+                            -------------------
+        begin                : Wednesday August 9th 2006
+        copyright            : (C) 2006 by George Wright
+                               (C) 2007 Defuturo Ltd
+        email                : gwright at kde.org
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#ifndef _NXWRITEXML_H_
+#define _NXWRITEXML_H_
+
+#include "nxdata.h"
+
+#include <QString>
+#include <QFile>
+#include <QTextStream>
+
+using namespace nxcl;
+
+class NXWriteXML
+{
+    public:
+        NXWriteXML();
+        ~NXWriteXML();
+        void write(QString);
+        void setSessionData(NXConfigData data) { sessionData = data; };
+        QString escape(QString);
+    private:
+        NXConfigData sessionData;
+};
+
+#endif

Added: qtnx/qtnx.pro
===================================================================
--- qtnx/qtnx.pro	2008-01-03 12:25:34 UTC (rev 429)
+++ qtnx/qtnx.pro	2008-01-03 12:52:12 UTC (rev 430)
@@ -0,0 +1,21 @@
+TEMPLATE	= app
+
+CONFIG		+= qt warn_on debug
+
+FORMS = settingsdialog.ui logindialog.ui sessionsdialog.ui keydialog.ui logwindow.ui
+
+SOURCES = main.cpp qtnxwindow.cpp qtnxsettings.cpp qtnxsessions.cpp nxparsexml.cpp nxwritexml.cpp
+
+HEADERS = qtnxwindow.h qtnxsettings.h qtnxsessions.h nxparsexml.h nxwritexml.h
+
+INCLUDEPATH	+= $(QTDIR)/include
+
+QMAKE_CXXFLAGS += $$system(pkg-config --cflags nxcl)
+
+DEPENDPATH	+= $(QTDIR)/include
+
+LIBS += $$system(pkg-config --libs nxcl)
+
+QT += ui xml
+
+TARGET		= qtnx

Added: qtnx/qtnxsessions.cpp
===================================================================
--- qtnx/qtnxsessions.cpp	2008-01-03 12:25:34 UTC (rev 429)
+++ qtnx/qtnxsessions.cpp	2008-01-03 12:52:12 UTC (rev 430)
@@ -0,0 +1,62 @@
+/***************************************************************************
+                             qtnxsessions.cpp
+                            -------------------
+        begin                : Wednesday August 16th 2006
+        copyright            : (C) 2006 by George Wright
+                               (C) 2007 Defuturo Ltd
+        email                : gwright at kde.org
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "qtnxsessions.h"
+
+using namespace nxcl;
+
+QtNXSessions::QtNXSessions(QList<NXResumeData> sessions)
+{
+    ui_sd.setupUi(this);
+
+    connect(ui_sd.newButton, SIGNAL(pressed()), this, SLOT(pressedNew()));
+    connect(ui_sd.resumeButton, SIGNAL(pressed()), this, 
+            SLOT(pressedResume()));
+
+    for (int i = 0; i < sessions.size(); ++i) {
+        sessionItems.append(new QTreeWidgetItem(ui_sd.sessionsList));
+        sessionItems.last()->setText(0,
+                QString::number(sessions.at(i).display));
+        sessionItems.last()->setText(1,
+                QString::fromStdString(sessions.at(i).sessionType));
+        sessionItems.last()->setText(2,
+                QString::fromStdString(sessions.at(i).sessionID));
+        sessionItems.last()->setText(3,
+                QString::number(sessions.at(i).depth));
+        sessionItems.last()->setText(4,
+                QString::fromStdString(sessions.at(i).screen));
+        sessionItems.last()->setText(5,
+                QString::fromStdString(sessions.at(i).sessionName));
+    }
+}
+
+QtNXSessions::~QtNXSessions()
+{
+}
+
+void QtNXSessions::pressedNew()
+{
+    emit newPressed();
+    close();
+}
+
+void QtNXSessions::pressedResume()
+{
+    emit resumePressed(ui_sd.sessionsList->currentItem()->text(2));
+    close();
+}

Added: qtnx/qtnxsessions.h
===================================================================
--- qtnx/qtnxsessions.h	2008-01-03 12:25:34 UTC (rev 429)
+++ qtnx/qtnxsessions.h	2008-01-03 12:52:12 UTC (rev 430)
@@ -0,0 +1,51 @@
+/***************************************************************************
+                              qtnxsessions.h
+                            -------------------
+        begin                : Wednesday August 16th 2006
+        copyright            : (C) 2006 by George Wright
+                               (C) 2007 Defuturo Ltd
+        email                : gwright at kde.org
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef _QTNXSESSIONS_H_
+#define _QTNXSESSIONS_H_
+
+#include <QList>
+#include <QTreeWidget>
+#include <QTreeWidgetItem>
+
+#include "nxdata.h"
+
+#include "ui_sessionsdialog.h"
+
+using namespace nxcl;
+
+class QtNXSessions : public QDialog
+{
+    Q_OBJECT
+    public:
+        QtNXSessions(QList<NXResumeData>);
+        ~QtNXSessions();
+    public slots:
+            void pressedNew();
+        void pressedResume();
+    signals:
+        void newPressed();
+        void resumePressed(QString);
+    private:
+        void empty();
+
+        Ui_SessionsDialog ui_sd;
+        QList<QTreeWidgetItem*> sessionItems;
+};
+
+#endif

Added: qtnx/qtnxsettings.cpp
===================================================================
--- qtnx/qtnxsettings.cpp	2008-01-03 12:25:34 UTC (rev 429)
+++ qtnx/qtnxsettings.cpp	2008-01-03 12:52:12 UTC (rev 430)
@@ -0,0 +1,292 @@
+/***************************************************************************
+  qtnxsettings.cpp
+  -------------------
+begin                : Saturday August 12th 2006
+copyright            : (C) 2006 by George Wright
+email                : gwright at kde.org
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <QFile>
+#include <QDir>
+
+#include "qtnxsettings.h"
+
+#include "nxdata.h"
+#include "nxparsexml.h"
+#include "nxwritexml.h"
+
+using namespace nxcl;
+
+QtNXSettings::QtNXSettings(QString sessionName) : QDialog()
+{
+    filedesc = sessionName;
+    keyDialog = 0;
+
+    if (!sessionName.isEmpty())
+        fileName = QDir::homePath() + "/.qtnx/" + sessionName + ".nxml";
+    else
+        fileName = "";
+
+    ui_sd.setupUi(this);
+    ui_sd.sessionName->setText(sessionName);
+
+    parseFile();
+
+    connect(ui_sd.resolution, SIGNAL(currentIndexChanged(QString)), this, SLOT(resolutionChanged(QString)));
+    connect(ui_sd.imageCompressionType, SIGNAL(currentIndexChanged(QString)), this, SLOT(compressionChanged(QString)));
+    connect(ui_sd.defaultKey, SIGNAL(stateChanged(int)), this, SLOT(keyChanged(int)));
+    connect(ui_sd.applyButton, SIGNAL(pressed()), this, SLOT(applyPressed()));
+    connect(ui_sd.okButton, SIGNAL(pressed()), this, SLOT(okPressed()));
+    connect(ui_sd.cancelButton, SIGNAL(pressed()), this, SLOT(cancelPressed()));
+    connect(ui_sd.setAuthKeyButton, SIGNAL(pressed()), this, SLOT(authKeyPressed()));
+}
+
+QtNXSettings::~QtNXSettings()
+{
+}
+
+void QtNXSettings::parseFile()
+{
+    if (!fileName.isEmpty()) {
+        NXParseXML handler;
+        handler.setData(&config);
+
+        QFile file(fileName);
+        QXmlInputSource inputSource(&file);
+
+        QXmlSimpleReader reader;
+        reader.setContentHandler(&handler);
+        reader.setErrorHandler(&handler);
+        reader.parse(inputSource);
+
+        ui_sd.hostname->setText(QString::fromStdString(config.serverHost));
+        ui_sd.port->setValue(config.serverPort);
+
+        if (config.key.empty())
+            ui_sd.defaultKey->setChecked(true);
+        else {
+            ui_sd.defaultKey->setChecked(false);
+            ui_sd.setAuthKeyButton->setEnabled(true);
+        }
+
+        if (config.sessionType == "unix-kde") {
+            ui_sd.platform->setCurrentIndex(ui_sd.platform->findText(tr("UNIX")));
+            ui_sd.type->setCurrentIndex(ui_sd.type->findText(tr("KDE")));
+        } else if (config.sessionType == "unix-gnome") {
+            ui_sd.platform->setCurrentIndex(ui_sd.platform->findText(tr("UNIX")));
+            ui_sd.type->setCurrentIndex(ui_sd.type->findText(tr("GNOME")));
+        } else if (config.sessionType == "unix-cde") {
+            ui_sd.platform->setCurrentIndex(ui_sd.platform->findText(tr("UNIX")));
+            ui_sd.type->setCurrentIndex(ui_sd.type->findText(tr("CDE")));
+        } else if (config.sessionType == "unix-application") {
+            ui_sd.platform->setCurrentIndex(ui_sd.platform->findText(tr("UNIX")));
+            ui_sd.type->setCurrentIndex(ui_sd.type->findText(tr("Custom")));
+            ui_sd.desktopSettingButton->setEnabled(true);
+        }
+
+        if (config.linkType == "modem")
+            ui_sd.link->setCurrentIndex(ui_sd.link->findText(tr("Modem")));
+        else if (config.linkType == "isdn")
+            ui_sd.link->setCurrentIndex(ui_sd.link->findText(tr("ISDN")));
+        else if (config.linkType == "adsl")
+            ui_sd.link->setCurrentIndex(ui_sd.link->findText(tr("ADSL")));
+        else if (config.linkType == "wan")
+            ui_sd.link->setCurrentIndex(ui_sd.link->findText(tr("WAN")));
+        else if (config.linkType == "lan")
+            ui_sd.link->setCurrentIndex(ui_sd.link->findText(tr("LAN")));
+
+        if (config.imageCompressionMethod == -1) {
+            ui_sd.imageCompressionType->setCurrentIndex(ui_sd.imageCompressionType->findText(tr("JPEG")));
+            ui_sd.imageQualityLevel->setValue(config.imageCompressionLevel);
+            ui_sd.imageQualityLevel->setEnabled(true);
+        } else if (config.imageCompressionMethod == 2)
+            ui_sd.imageCompressionType->setCurrentIndex(ui_sd.imageCompressionType->findText(tr("PNG")));
+        else if (config.imageCompressionMethod == 0)
+            ui_sd.imageCompressionType->setCurrentIndex(ui_sd.imageCompressionType->findText(tr("Raw X11")));
+
+        if (config.geometry == "640x480+0+0")
+            ui_sd.resolution->setCurrentIndex(ui_sd.resolution->findText("640x480"));
+        else if (config.geometry == "800x600+0+0")
+            ui_sd.resolution->setCurrentIndex(ui_sd.resolution->findText("800x600"));
+        else if (config.geometry == "1024x768+0+0")
+            ui_sd.resolution->setCurrentIndex(ui_sd.resolution->findText("1024x768"));
+        else {
+            if (config.fullscreen) {
+                ui_sd.resolution->setCurrentIndex(ui_sd.resolution->findText(tr("Fullscreen")));
+            } else {
+                ui_sd.resolution->setCurrentIndex(ui_sd.resolution->findText(tr("Custom")));
+
+                QString res;
+                res = QString::fromStdString(config.geometry).left(config.geometry.length() - 4);
+                ui_sd.width->setValue(res.split('x').at(0).toInt());
+                ui_sd.height->setValue(res.split('x').at(1).toInt());
+                ui_sd.width->setEnabled(true);
+                ui_sd.height->setEnabled(true);
+            }
+        }
+
+        ui_sd.encryption->setChecked(config.encryption);
+        ui_sd.memoryCache->setValue(config.cache);
+        ui_sd.diskCache->setValue(config.images);
+
+        ui_sd.render->setChecked(config.render);
+    }
+}
+
+void QtNXSettings::resolutionChanged(QString text)
+{
+    if (text == tr("Custom")) {
+        ui_sd.width->setEnabled(true);
+        ui_sd.height->setEnabled(true);
+    } else {
+        ui_sd.width->setEnabled(false);
+        ui_sd.height->setEnabled(false);
+    }
+}
+
+void QtNXSettings::compressionChanged(QString text)
+{
+    if (text == tr("JPEG")) {
+        ui_sd.imageQualityLevel->setEnabled(true);
+    } else {
+        ui_sd.imageQualityLevel->setEnabled(false);
+    }
+}
+
+void QtNXSettings::platformChanged(QString text)
+{
+}
+
+void QtNXSettings::typeChanged(QString text)
+{
+}
+
+void QtNXSettings::keyChanged(int state)
+{
+    if (state == Qt::Checked) {
+        config.key = "";
+        ui_sd.setAuthKeyButton->setEnabled(false);
+    } else
+        ui_sd.setAuthKeyButton->setEnabled(true);
+}
+
+void QtNXSettings::cancelPressed()
+{
+    close();
+}
+
+void QtNXSettings::okPressed()
+{
+    applyPressed();
+    emit closing();
+    close();
+}
+
+void QtNXSettings::authKeyPressed()
+{
+    keyDialog = 0;
+    delete keyDialog;
+    keyDialog = new QDialog(this);
+    ui_kd.setupUi(keyDialog);
+    keyDialog->show();
+    QTextDocument *doc_key = new QTextDocument(QString::fromStdString(config.key));
+    ui_kd.key->setDocument(doc_key);
+
+    connect(keyDialog, SIGNAL(accepted()), this, SLOT(keyDialogAccept()));
+}
+
+void QtNXSettings::keyDialogAccept()
+{
+
+    config.key = ui_kd.key->document()->toPlainText().toStdString();
+}
+
+void QtNXSettings::keyDialogReject()
+{
+}
+
+void QtNXSettings::applyPressed()
+{
+    // File has been renamed, remove old one
+    if (filedesc != ui_sd.sessionName->text()) {
+        QFile temp(QDir::homePath() + "/.qtnx/" + filedesc + ".nxml");
+        temp.remove();
+    }
+
+    QDir configDir(QDir::homePath() + "/.qtnx/");
+    configDir.mkpath(QDir::homePath() + "/.qtnx/");
+
+    config.sessionName = ui_sd.sessionName->text().toStdString();
+    config.serverHost = ui_sd.hostname->text().toStdString();
+    config.serverPort = ui_sd.port->value();
+
+    // TODO: Add keyboard selection support
+    config.keyboard = "defkeymap";
+    config.kbtype = "pc102/defkeymap";
+
+    if (ui_sd.platform->currentText() == tr("UNIX")) {
+        if (ui_sd.type->currentText() == tr("KDE"))
+            config.sessionType = "unix-kde";
+        else if (ui_sd.type->currentText() == tr("GNOME"))
+            config.sessionType = "unix-gnome";
+        else if (ui_sd.type->currentText() == tr("CDE"))
+            config.sessionType = "unix-cde";
+        else if (ui_sd.type->currentText() == tr("Custom"))
+            config.sessionType = "unix-application";
+    }
+
+    if (ui_sd.link->currentText() == tr("Modem"))
+        config.linkType = "modem";
+    else if (ui_sd.link->currentText() == tr("ISDN"))
+        config.linkType = "isdn";
+    else if (ui_sd.link->currentText() == tr("ADSL"))
+        config.linkType = "adsl";
+    else if (ui_sd.link->currentText() == tr("WAN"))
+        config.linkType = "wan";
+    else if (ui_sd.link->currentText() == tr("LAN"))
+        config.linkType = "lan";
+
+    if (ui_sd.imageCompressionType->currentText() == tr("JPEG")) {
+        config.imageCompressionMethod = -1;
+        config.imageCompressionLevel = ui_sd.imageQualityLevel->value();
+    } else if (ui_sd.imageCompressionType->currentText() == tr("PNG"))
+        config.imageCompressionMethod = 2;
+    else if (ui_sd.imageCompressionType->currentText() == tr("Raw X11"))
+        config.imageCompressionMethod = 0;
+
+    if (ui_sd.resolution->currentText() == tr("Fullscreen"))
+        config.fullscreen = true;
+    else if (ui_sd.resolution->currentText() == tr("Custom")) {
+        config.fullscreen = false;
+        config.geometry = (QString::number(ui_sd.width->value()) + "x" + QString::number(ui_sd.height->value()) + "+0+0").toStdString();
+    } else {
+        config.fullscreen = false;
+        config.geometry = (ui_sd.resolution->currentText() + "+0+0").toStdString();
+    }
+
+    if (ui_sd.encryption->checkState() == Qt::Checked)
+        config.encryption = true;
+    else
+        config.encryption = false;
+
+    config.cache = ui_sd.memoryCache->value();
+    config.images = ui_sd.diskCache->value();
+
+    if (ui_sd.render->checkState() == Qt::Checked)
+        config.render = true;
+    else
+        config.render = false;
+
+    NXWriteXML writeData;
+    writeData.setSessionData(config);
+    writeData.write(QDir::homePath() + "/.qtnx/" + ui_sd.sessionName->text() + ".nxml");
+}

Added: qtnx/qtnxsettings.h
===================================================================
--- qtnx/qtnxsettings.h	2008-01-03 12:25:34 UTC (rev 429)
+++ qtnx/qtnxsettings.h	2008-01-03 12:52:12 UTC (rev 430)
@@ -0,0 +1,62 @@
+/***************************************************************************
+  qtnxsettings.h
+  -------------------
+begin                : Saturday August 12th 2006
+copyright            : (C) 2006 by George Wright
+email                : gwright at kde.org
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef _QTNXSETTINGS_H_
+#define _QTNXSETTINGS_H_
+
+#include <QDialog>
+
+#include "nxdata.h"
+
+#include "ui_settingsdialog.h"
+#include "ui_keydialog.h"
+
+using namespace nxcl;
+
+class QtNXSettings : public QDialog
+{
+    Q_OBJECT
+    public:
+        QtNXSettings(QString);
+        ~QtNXSettings();
+        void parseFile();
+        public slots:
+            void resolutionChanged(QString);
+        void compressionChanged(QString);
+        void platformChanged(QString);
+        void typeChanged(QString);
+        void keyChanged(int);
+        void applyPressed();
+        void cancelPressed();
+        void okPressed();
+        void setData(NXConfigData data) { config = data; };
+        void authKeyPressed();
+        void keyDialogAccept();
+        void keyDialogReject();
+signals:
+        void closing();
+    private:
+        Ui::SettingsDialog ui_sd;
+        Ui::KeyDialog ui_kd;
+        QDialog *keyDialog;
+        NXConfigData config;
+        QString fileName;
+        QString filedesc;
+
+};
+
+#endif

Added: qtnx/qtnxwindow.cpp
===================================================================
--- qtnx/qtnxwindow.cpp	2008-01-03 12:25:34 UTC (rev 429)
+++ qtnx/qtnxwindow.cpp	2008-01-03 12:52:12 UTC (rev 430)
@@ -0,0 +1,341 @@
+/***************************************************************************
+                               qtnxwindow.cpp
+                            -------------------
+        begin                : Thursday August 3rd 2006
+        copyright            : (C) 2006 by George Wright
+                               (C) 2007 Defuturo Ltd
+        email                : gwright at kde.org
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "qtnxwindow.h"
+
+#include <QApplication>
+#include <QDesktopWidget>
+#include <QDir>
+#include <QFile>
+#include <QMessageBox>
+#include <QX11Info>
+
+using namespace nxcl;
+using namespace std;
+
+QtNXWindow::QtNXWindow() : QMainWindow()
+{
+    nxClient.setExternalCallbacks(&callback);
+
+    processProbe = new QTimer();
+
+    sessionsDialog = 0;
+
+    logWindow = new QDialog(0);
+    ui_lw.setupUi(logWindow);
+
+    log = new QTextDocument();
+    ui_lw.output->setDocument(log);
+
+    loginDialog = new QWidget(this);
+    menuBar = new QMenuBar(this);
+    statusBar = new QStatusBar(this);
+
+    fileMenu = new QMenu(tr("&File"));
+    connectionMenu = new QMenu(tr("Conn&ection"));
+
+    ui_lg.setupUi(loginDialog);
+    setCentralWidget(loginDialog);
+    setStatusBar(statusBar);
+    setMenuBar(menuBar);
+
+    statusBar->showMessage(tr("Ready"));
+    statusBar->setSizeGripEnabled(false);
+
+    menuBar->addMenu(fileMenu);
+    menuBar->addMenu(connectionMenu);
+
+    fileMenu->addAction(tr("Quit"),
+            qApp,
+            SLOT(quit()),
+            QKeySequence(tr("CTRL+Q")));
+
+    connectionMenu->addAction(tr("Show log window"),
+            this,
+            SLOT(showLogWindow()),
+            QKeySequence(tr("CTRL+L")));
+
+    connectionMenu->addAction(tr("Connect..."),
+            this,
+            SLOT(startConnect()));
+
+    QDir dir(QDir::homePath()+"/.qtnx","*.nxml");
+
+    for (unsigned int i=0;i<dir.count();i++) {
+        QString conn=dir[i];
+        ui_lg.session->addItem(conn.left(conn.length()-5));
+    }
+
+    ui_lg.session->addItem(tr("Create new session"));
+
+
+    connect(ui_lg.connectButton, SIGNAL(pressed()), this, SLOT(startConnect()));
+    connect(ui_lg.configureButton, SIGNAL(pressed()), this, SLOT(configure()));
+    connect(processProbe, SIGNAL(timeout()), this, SLOT(processProbeTimeout()));
+    connect(&callback, SIGNAL(logging(QString)), this, SLOT(logStd(QString)));
+    connect(&callback, SIGNAL(status(QString)), this, 
+            SLOT(updateStatusBar(QString)));
+    connect(&callback, SIGNAL(suspendedSessions(QList<NXResumeData>)), this,
+            SLOT(loadResumeDialog(QList<NXResumeData>)));
+    connect(&callback, SIGNAL(noSessions()), this, SLOT(noSessions()));
+    connect(&callback, SIGNAL(progress(int, QString)), this, 
+            SLOT(handleProgress(int, QString)));
+}
+
+QtNXWindow::~QtNXWindow()
+{
+}
+
+void QtNXWindow::showLogWindow()
+{
+    if (logWindow->isHidden())
+        logWindow->show();
+    else
+        logWindow->hide();
+}
+
+void QtNXWindow::handleProgress(int id, QString message)
+{
+    switch (id) {
+        case NXCL_PROCESS_STARTED:
+            updateStatusBar("Process started");
+            break;
+        case NXCL_PROCESS_EXITED:
+            updateStatusBar("Process exited");
+            break;
+        case NXCL_AUTH_FAILED:
+            updateStatusBar("Invalid authentication key");
+            break;
+        case NXCL_AUTHENTICATING:
+            updateStatusBar("Authentication client");
+            break;
+        case NXCL_LOGIN_FAILED:
+            updateStatusBar("Invalid username or password");
+            failedLogin();
+            break;
+        case NXCL_HOST_KEY_VERIFAILED:
+            updateStatusBar("Host key verification failed");
+            break;
+        case NXCL_INVOKE_PROXY:
+            updateStatusBar("Starting NX proxy");
+            break;
+        case NXCL_STARTING:
+            updateStatusBar("Starting session");
+            break;
+        case NXCL_FINISHED:
+            updateStatusBar("Finished connecting");
+            break;
+        case NXCL_ALIVE:
+            updateStatusBar("NX session active");
+            break;
+        case NXCL_PROCESS_ERROR:
+            updateStatusBar("Process error");
+            break;
+        default:
+            break;
+    }
+}
+
+void QtNXWindow::failedLogin()
+{
+    QMessageBox::critical(this, tr("Authentication failure"),
+            tr("You have supplied an incorrect username or password for this \
+                NX server."), QMessageBox::Ok, QMessageBox::NoButton,
+            QMessageBox::NoButton);
+
+    statusBar->showMessage(tr("Login failed"));
+}
+void QtNXWindow::sshContinue(QString message)
+{
+    /*TODO: this is not functionally available in nxcl
+
+    int reply = QMessageBox::question(this,
+            tr("SSH Request"),
+            message,
+            QMessageBox::Yes,
+            QMessageBox::No,
+            QMessageBox::NoButton);
+
+    if (reply == QMessageBox::Yes)
+        nxClient.allowSSHConnect(true);
+    else
+        nxClient.allowSSHConnect(false);
+    */
+}
+
+void QtNXWindow::startConnect()
+{
+    string key = "";
+    QDesktopWidget dw;
+    QX11Info info;
+
+    NXParseXML handler;
+    handler.setData(&config);
+
+    QFile file(QDir::homePath() + "/.qtnx/" +
+            ui_lg.session->currentText() + ".nxml");
+
+    QXmlInputSource inputSource(&file);
+
+    QXmlSimpleReader reader;
+    reader.setContentHandler(&handler);
+    reader.setErrorHandler(&handler);
+    reader.parse(inputSource);
+
+    session.sessionName = config.sessionName;
+    session.sessionType = config.sessionType;
+    session.cache = config.cache;
+    session.images = config.images;
+    session.linkType = config.linkType;
+    session.render = config.render;
+    session.backingstore = "when_requested";
+    session.imageCompressionMethod = config.imageCompressionMethod;
+    session.imageCompressionLevel = config.imageCompressionLevel;
+    session.geometry = config.geometry;
+    session.keyboard = "defkeymap";
+    session.kbtype = "pc102/defkeymap";
+    session.media = config.media;
+    session.agentServer = config.agentServer;
+    session.agentUser = config.agentUser;
+    session.agentPass = config.agentPass;
+    session.cups = config.cups;
+    session.fullscreen = config.fullscreen;
+    session.encryption = true;
+    session.virtualDesktop = false;
+
+    if (!config.key.empty()) {
+        key = config.key;
+        session.key = "supplied";
+    } else
+        session.key = "default";
+
+    if (config.sessionType == "unix-application")
+        session.customCommand = config.customCommand;
+
+    nxClient.setSessionData(&session);
+
+    nxClient.invokeNXSSH("id.key", config.serverHost, config.encryption, "",
+            config.serverPort);
+    processProbe->start(30);
+
+    string username = ui_lg.username->text().toStdString();
+    string password = ui_lg.password->text().toStdString();
+
+    nxClient.setUsername(username);
+    nxClient.setPassword(password);
+    nxClient.setResolution(dw.screenGeometry(this).width(),
+            dw.screenGeometry(this).height());
+
+    nxClient.setDepth(info.depth());
+}
+
+void QtNXWindow::updateStatusBar(QString message)
+{
+    statusBar->showMessage(message);
+}
+
+void QtNXWindow::processProbeTimeout()
+{
+    notQProcess* p = nxClient.getNXSSHProcess();
+
+    if ((nxClient.getIsFinished()) == false) {
+        if (nxClient.getReadyForProxy() == false) {
+            p->probeProcess();
+        } else {
+            p->probeProcess();
+            p = nxClient.getNXProxyProcess();
+            p->probeProcess();
+        }
+        if (!nxClient.getSessionRunning())
+            processProbe->start(30);
+        else {
+            processProbe->start(2000);
+        }
+    } else {
+        processProbe->stop();
+    }
+}
+
+void QtNXWindow::configure()
+{
+    if (ui_lg.session->currentText() == tr("Create new session"))
+        settingsDialog = new QtNXSettings("");
+    else
+        settingsDialog = new QtNXSettings(ui_lg.session->currentText());
+
+    connect(settingsDialog, SIGNAL(closing()), this, SLOT(configureClosed()));
+
+    settingsDialog->show();
+}
+
+void QtNXWindow::configureClosed()
+{
+    while (ui_lg.session->count() != 0) {
+        ui_lg.session->removeItem(0);
+    }
+
+    QDir dir(QDir::homePath()+"/.qtnx","*.nxml");
+    for (unsigned int i=0;i<dir.count();i++) {
+        QString conn=dir[i];
+        ui_lg.session->addItem(conn.left(conn.length()-5));
+    }
+    ui_lg.session->addItem(tr("Create new session"));
+}
+
+void QtNXWindow::loadResumeDialog(QList<NXResumeData> data)
+{
+    delete sessionsDialog;
+    sessionsDialog = new QtNXSessions(data);
+    sessionsDialog->show();
+
+    connect(sessionsDialog, SIGNAL(newPressed()), this, SLOT(resumeNewPressed()));
+    connect(sessionsDialog, SIGNAL(resumePressed(QString)),
+            this, SLOT(resumeResumePressed(QString)));
+}
+
+void QtNXWindow::resumeNewPressed()
+{
+    nxClient.setSessionData(&session);
+    nxClient.runSession();
+}
+
+void QtNXWindow::resumeResumePressed(QString id)
+{
+    session.id = id.toStdString();
+    session.suspended = true;
+    nxClient.setSessionData(&session);
+    nxClient.runSession();
+}
+
+void QtNXWindow::noSessions()
+{
+    session.suspended = false;
+    nxClient.setSessionData(&session);
+    nxClient.runSession();
+}
+
+void QtNXWindow::logStd(QString message)
+{
+    if (message.right(1) != "\n")
+        cout << message.toStdString() << endl;
+    else
+        cout << message.toStdString();
+
+    log->setPlainText(log->toPlainText() + message);
+}
+

Added: qtnx/qtnxwindow.h
===================================================================
--- qtnx/qtnxwindow.h	2008-01-03 12:25:34 UTC (rev 429)
+++ qtnx/qtnxwindow.h	2008-01-03 12:52:12 UTC (rev 430)
@@ -0,0 +1,137 @@
+/***************************************************************************
+                                qtnxwindow.h
+                            -------------------
+        begin                : Thursday August 3rd 2006
+        copyright            : (C) 2006 by George Wright
+                               (C) 2007 Defuturo Ltd
+        email                : gwright at kde.org
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef _QTNXWINDOW_H_
+#define _QTNXWINDOW_H_
+
+#include <QMainWindow>
+#include <QMenuBar>
+#include <QStatusBar>
+#include <QTimer>
+
+#include "nxclientlib.h"
+#include "nxdata.h"
+#include "nxparsexml.h"
+
+#include "qtnxsessions.h"
+#include "qtnxsettings.h"
+
+#include "ui_logindialog.h"
+#include "ui_logwindow.h"
+
+using namespace std;
+using namespace nxcl;
+
+class QtNXCallback :
+    public QObject, 
+    public NXClientLibExternalCallbacks
+{
+    Q_OBJECT
+    public:
+        QtNXCallback() {};
+        ~QtNXCallback() {};
+
+        // Library callbacks
+        void write(string msg)
+          { emit status(QString::fromStdString(msg)); }
+
+        void write(int num, string msg)
+          { emit progress(num, QString::fromStdString(msg)); }
+
+        void error(string msg)
+          { emit error(QString::fromStdString(msg)); }
+
+        void debug(string msg)
+          { emit debug(QString::fromStdString(msg)); }
+
+        void stdoutSignal(string msg)
+          { emit logging("stdout> " + QString::fromStdString(msg)); }
+
+        void stderrSignal(string msg)
+          { emit logging("stderr> " + QString::fromStdString(msg)); }
+
+        void stdinSignal(string msg)
+          { emit logging("stdin>  " + QString::fromStdString(msg)); }
+
+        void resumeSessionsSignal(list<NXResumeData> sessions)
+          { emit suspendedSessions(QList<NXResumeData>::
+                  fromStdList(sessions)); }
+
+        void noSessionsSignal()
+          { emit noSessions(); }
+
+        void serverCapacitySignal()
+          { emit serverAtCapacity(); }
+    signals:
+        void logging(QString);
+        void status(QString);
+        void progress(int, QString);
+        void debug(QString);
+        void error(QString);
+
+        void suspendedSessions(QList<NXResumeData>);
+        void noSessions();
+        void serverAtCapacity();
+};
+
+class QtNXWindow : public QMainWindow
+{
+    Q_OBJECT
+    public:
+        QtNXWindow();
+        ~QtNXWindow();
+
+    public slots:
+        void startConnect();
+        void configure();
+        void configureClosed();
+        void loadResumeDialog(QList<NXResumeData>);
+        void resumeNewPressed();
+        void resumeResumePressed(QString);
+        void noSessions();
+        void sshContinue(QString);
+        void updateStatusBar(QString);
+        void failedLogin();
+        void showLogWindow();
+        void logStd(QString);
+        void processProbeTimeout();
+        void handleProgress(int, QString);
+    private:
+        Ui::LoginDialog ui_lg;
+        Ui::LogWindow ui_lw;
+
+        NXSessionData session;
+        NXConfigData config;
+
+        NXClientLib nxClient;
+
+        QtNXSettings *settingsDialog;
+        QtNXSessions *sessionsDialog;
+
+        QDialog *logWindow;
+        QMenu *fileMenu;
+        QMenu *connectionMenu;
+        QMenuBar *menuBar;
+        QStatusBar *statusBar;
+        QTextDocument *log;
+        QTimer *processProbe;
+        QWidget *loginDialog;
+
+        QtNXCallback callback;
+};
+#endif

Added: qtnx/sessionsdialog.ui
===================================================================
--- qtnx/sessionsdialog.ui	2008-01-03 12:25:34 UTC (rev 429)
+++ qtnx/sessionsdialog.ui	2008-01-03 12:52:12 UTC (rev 430)
@@ -0,0 +1,101 @@
+<ui version="4.0" >
+ <author></author>
+ <comment></comment>
+ <exportmacro></exportmacro>
+ <class>SessionsDialog</class>
+ <widget class="QDialog" name="SessionsDialog" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>725</width>
+    <height>260</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string>Dialog</string>
+  </property>
+  <layout class="QVBoxLayout" >
+   <property name="margin" >
+    <number>9</number>
+   </property>
+   <property name="spacing" >
+    <number>6</number>
+   </property>
+   <item>
+    <widget class="QTreeWidget" name="sessionsList" >
+     <column>
+      <property name="text" >
+       <string>Display</string>
+      </property>
+     </column>
+     <column>
+      <property name="text" >
+       <string>Type</string>
+      </property>
+     </column>
+     <column>
+      <property name="text" >
+       <string>Session ID</string>
+      </property>
+     </column>
+     <column>
+      <property name="text" >
+       <string>Colour Depth</string>
+      </property>
+     </column>
+     <column>
+      <property name="text" >
+       <string>Resolution</string>
+      </property>
+     </column>
+     <column>
+      <property name="text" >
+       <string>Session Name</string>
+      </property>
+     </column>
+    </widget>
+   </item>
+   <item>
+    <layout class="QHBoxLayout" >
+     <property name="margin" >
+      <number>0</number>
+     </property>
+     <property name="spacing" >
+      <number>6</number>
+     </property>
+     <item>
+      <spacer>
+       <property name="orientation" >
+        <enum>Qt::Horizontal</enum>
+       </property>
+       <property name="sizeHint" >
+        <size>
+         <width>40</width>
+         <height>20</height>
+        </size>
+       </property>
+      </spacer>
+     </item>
+     <item>
+      <widget class="QPushButton" name="newButton" >
+       <property name="text" >
+        <string>&amp;New</string>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <widget class="QPushButton" name="resumeButton" >
+       <property name="text" >
+        <string>&amp;Resume</string>
+       </property>
+      </widget>
+     </item>
+    </layout>
+   </item>
+  </layout>
+ </widget>
+ <pixmapfunction></pixmapfunction>
+ <resources/>
+ <connections/>
+</ui>

Added: qtnx/settingsdialog.ui
===================================================================
--- qtnx/settingsdialog.ui	2008-01-03 12:25:34 UTC (rev 429)
+++ qtnx/settingsdialog.ui	2008-01-03 12:52:12 UTC (rev 430)
@@ -0,0 +1,793 @@
+<ui version="4.0" >
+ <author></author>
+ <comment></comment>
+ <exportmacro></exportmacro>
+ <class>SettingsDialog</class>
+ <widget class="QDialog" name="SettingsDialog" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>468</width>
+    <height>546</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string>Dialog</string>
+  </property>
+  <property name="modal" >
+   <bool>true</bool>
+  </property>
+  <layout class="QVBoxLayout" >
+   <property name="margin" >
+    <number>9</number>
+   </property>
+   <property name="spacing" >
+    <number>6</number>
+   </property>
+   <item>
+    <widget class="QTabWidget" name="layoutTabs" >
+     <property name="currentIndex" >
+      <number>0</number>
+     </property>
+     <widget class="QWidget" name="basicTab" >
+      <attribute name="title" >
+       <string>Basic</string>
+      </attribute>
+      <layout class="QVBoxLayout" >
+       <property name="margin" >
+        <number>9</number>
+       </property>
+       <property name="spacing" >
+        <number>6</number>
+       </property>
+       <item>
+        <widget class="QGroupBox" name="generalGroup" >
+         <property name="title" >
+          <string>General</string>
+         </property>
+         <layout class="QVBoxLayout" >
+          <property name="margin" >
+           <number>9</number>
+          </property>
+          <property name="spacing" >
+           <number>6</number>
+          </property>
+          <item>
+           <layout class="QHBoxLayout" >
+            <property name="margin" >
+             <number>0</number>
+            </property>
+            <property name="spacing" >
+             <number>6</number>
+            </property>
+            <item>
+             <widget class="QLabel" name="sessionNameLabel" >
+              <property name="sizePolicy" >
+               <sizepolicy>
+                <hsizetype>0</hsizetype>
+                <vsizetype>5</vsizetype>
+                <horstretch>0</horstretch>
+                <verstretch>0</verstretch>
+               </sizepolicy>
+              </property>
+              <property name="text" >
+               <string>Session Name:</string>
+              </property>
+             </widget>
+            </item>
+            <item>
+             <widget class="QLineEdit" name="sessionName" />
+            </item>
+           </layout>
+          </item>
+         </layout>
+        </widget>
+       </item>
+       <item>
+        <widget class="QGroupBox" name="serverGroup" >
+         <property name="title" >
+          <string>Server</string>
+         </property>
+         <layout class="QVBoxLayout" >
+          <property name="margin" >
+           <number>9</number>
+          </property>
+          <property name="spacing" >
+           <number>6</number>
+          </property>
+          <item>
+           <layout class="QHBoxLayout" >
+            <property name="margin" >
+             <number>0</number>
+            </property>
+            <property name="spacing" >
+             <number>6</number>
+            </property>
+            <item>
+             <widget class="QLabel" name="hostnameLabel" >
+              <property name="sizePolicy" >
+               <sizepolicy>
+                <hsizetype>0</hsizetype>
+                <vsizetype>5</vsizetype>
+                <horstretch>0</horstretch>
+                <verstretch>0</verstretch>
+               </sizepolicy>
+              </property>
+              <property name="text" >
+               <string>Hostname:</string>
+              </property>
+             </widget>
+            </item>
+            <item>
+             <widget class="QLineEdit" name="hostname" />
+            </item>
+            <item>
+             <widget class="QLabel" name="portLabel" >
+              <property name="sizePolicy" >
+               <sizepolicy>
+                <hsizetype>0</hsizetype>
+                <vsizetype>5</vsizetype>
+                <horstretch>0</horstretch>
+                <verstretch>0</verstretch>
+               </sizepolicy>
+              </property>
+              <property name="text" >
+               <string>Port:</string>
+              </property>
+             </widget>
+            </item>
+            <item>
+             <widget class="QSpinBox" name="port" >
+              <property name="maximum" >
+               <number>65535</number>
+              </property>
+              <property name="minimum" >
+               <number>1</number>
+              </property>
+              <property name="value" >
+               <number>22</number>
+              </property>
+             </widget>
+            </item>
+           </layout>
+          </item>
+          <item>
+           <layout class="QHBoxLayout" >
+            <property name="margin" >
+             <number>0</number>
+            </property>
+            <property name="spacing" >
+             <number>6</number>
+            </property>
+            <item>
+             <widget class="QCheckBox" name="defaultKey" >
+              <property name="text" >
+               <string>Use default key</string>
+              </property>
+              <property name="checked" >
+               <bool>true</bool>
+              </property>
+             </widget>
+            </item>
+            <item>
+             <widget class="QPushButton" name="setAuthKeyButton" >
+              <property name="enabled" >
+               <bool>false</bool>
+              </property>
+              <property name="text" >
+               <string>&amp;Set Authentication Key...</string>
+              </property>
+             </widget>
+            </item>
+           </layout>
+          </item>
+         </layout>
+        </widget>
+       </item>
+       <item>
+        <widget class="QGroupBox" name="desktopGroup" >
+         <property name="title" >
+          <string>Desktop</string>
+         </property>
+         <layout class="QVBoxLayout" >
+          <property name="margin" >
+           <number>9</number>
+          </property>
+          <property name="spacing" >
+           <number>6</number>
+          </property>
+          <item>
+           <layout class="QHBoxLayout" >
+            <property name="margin" >
+             <number>0</number>
+            </property>
+            <property name="spacing" >
+             <number>6</number>
+            </property>
+            <item>
+             <widget class="QLabel" name="platformLabel" >
+              <property name="sizePolicy" >
+               <sizepolicy>
+                <hsizetype>0</hsizetype>
+                <vsizetype>5</vsizetype>
+                <horstretch>0</horstretch>
+                <verstretch>0</verstretch>
+               </sizepolicy>
+              </property>
+              <property name="text" >
+               <string>Platform:</string>
+              </property>
+             </widget>
+            </item>
+            <item>
+             <widget class="QComboBox" name="platform" >
+              <item>
+               <property name="text" >
+                <string>UNIX</string>
+               </property>
+              </item>
+              <item>
+               <property name="text" >
+                <string>Windows</string>
+               </property>
+              </item>
+              <item>
+               <property name="text" >
+                <string>VNC Proxy</string>
+               </property>
+              </item>
+             </widget>
+            </item>
+            <item>
+             <widget class="QLabel" name="typeLabel" >
+              <property name="sizePolicy" >
+               <sizepolicy>
+                <hsizetype>0</hsizetype>
+                <vsizetype>5</vsizetype>
+                <horstretch>0</horstretch>
+                <verstretch>0</verstretch>
+               </sizepolicy>
+              </property>
+              <property name="text" >
+               <string>Type:</string>
+              </property>
+             </widget>
+            </item>
+            <item>
+             <widget class="QComboBox" name="type" >
+              <item>
+               <property name="text" >
+                <string>KDE</string>
+               </property>
+              </item>
+              <item>
+               <property name="text" >
+                <string>GNOME</string>
+               </property>
+              </item>
+              <item>
+               <property name="text" >
+                <string>CDE</string>
+               </property>
+              </item>
+              <item>
+               <property name="text" >
+                <string>XDM</string>
+               </property>
+              </item>
+              <item>
+               <property name="text" >
+                <string>Custom</string>
+               </property>
+              </item>
+             </widget>
+            </item>
+            <item>
+             <widget class="QLabel" name="linkLabel" >
+              <property name="sizePolicy" >
+               <sizepolicy>
+                <hsizetype>0</hsizetype>
+                <vsizetype>5</vsizetype>
+                <horstretch>0</horstretch>
+                <verstretch>0</verstretch>
+               </sizepolicy>
+              </property>
+              <property name="text" >
+               <string>Link:</string>
+              </property>
+             </widget>
+            </item>
+            <item>
+             <widget class="QComboBox" name="link" >
+              <item>
+               <property name="text" >
+                <string>Modem</string>
+               </property>
+              </item>
+              <item>
+               <property name="text" >
+                <string>ISDN</string>
+               </property>
+              </item>
+              <item>
+               <property name="text" >
+                <string>ADSL</string>
+               </property>
+              </item>
+              <item>
+               <property name="text" >
+                <string>WAN</string>
+               </property>
+              </item>
+              <item>
+               <property name="text" >
+                <string>LAN</string>
+               </property>
+              </item>
+             </widget>
+            </item>
+           </layout>
+          </item>
+          <item>
+           <layout class="QHBoxLayout" >
+            <property name="margin" >
+             <number>0</number>
+            </property>
+            <property name="spacing" >
+             <number>6</number>
+            </property>
+            <item>
+             <spacer>
+              <property name="orientation" >
+               <enum>Qt::Horizontal</enum>
+              </property>
+              <property name="sizeHint" >
+               <size>
+                <width>173</width>
+                <height>20</height>
+               </size>
+              </property>
+             </spacer>
+            </item>
+            <item>
+             <widget class="QPushButton" name="desktopSettingButton" >
+              <property name="enabled" >
+               <bool>false</bool>
+              </property>
+              <property name="text" >
+               <string>&amp;Settings...</string>
+              </property>
+             </widget>
+            </item>
+           </layout>
+          </item>
+         </layout>
+        </widget>
+       </item>
+       <item>
+        <widget class="QGroupBox" name="groupBox" >
+         <property name="title" >
+          <string>Geometry</string>
+         </property>
+         <layout class="QVBoxLayout" >
+          <property name="margin" >
+           <number>9</number>
+          </property>
+          <property name="spacing" >
+           <number>6</number>
+          </property>
+          <item>
+           <layout class="QHBoxLayout" >
+            <property name="margin" >
+             <number>0</number>
+            </property>
+            <property name="spacing" >
+             <number>6</number>
+            </property>
+            <item>
+             <widget class="QLabel" name="resolutionLabel" >
+              <property name="sizePolicy" >
+               <sizepolicy>
+                <hsizetype>0</hsizetype>
+                <vsizetype>5</vsizetype>
+                <horstretch>0</horstretch>
+                <verstretch>0</verstretch>
+               </sizepolicy>
+              </property>
+              <property name="text" >
+               <string>Resolution:</string>
+              </property>
+             </widget>
+            </item>
+            <item>
+             <widget class="QComboBox" name="resolution" >
+              <item>
+               <property name="text" >
+                <string>640x480</string>
+               </property>
+              </item>
+              <item>
+               <property name="text" >
+                <string>800x600</string>
+               </property>
+              </item>
+              <item>
+               <property name="text" >
+                <string>1024x768</string>
+               </property>
+              </item>
+              <item>
+               <property name="text" >
+                <string>Fullscreen</string>
+               </property>
+              </item>
+              <item>
+               <property name="text" >
+                <string>Custom</string>
+               </property>
+              </item>
+             </widget>
+            </item>
+            <item>
+             <widget class="QLabel" name="compressionLabel" >
+              <property name="sizePolicy" >
+               <sizepolicy>
+                <hsizetype>0</hsizetype>
+                <vsizetype>5</vsizetype>
+                <horstretch>0</horstretch>
+                <verstretch>0</verstretch>
+               </sizepolicy>
+              </property>
+              <property name="text" >
+               <string>Compression:</string>
+              </property>
+             </widget>
+            </item>
+            <item>
+             <widget class="QComboBox" name="imageCompressionType" >
+              <item>
+               <property name="text" >
+                <string>PNG</string>
+               </property>
+              </item>
+              <item>
+               <property name="text" >
+                <string>JPEG</string>
+               </property>
+              </item>
+              <item>
+               <property name="text" >
+                <string>Raw X11</string>
+               </property>
+              </item>
+             </widget>
+            </item>
+           </layout>
+          </item>
+          <item>
+           <layout class="QHBoxLayout" >
+            <property name="margin" >
+             <number>0</number>
+            </property>
+            <property name="spacing" >
+             <number>6</number>
+            </property>
+            <item>
+             <widget class="QLabel" name="qualityLabel" >
+              <property name="sizePolicy" >
+               <sizepolicy>
+                <hsizetype>0</hsizetype>
+                <vsizetype>5</vsizetype>
+                <horstretch>0</horstretch>
+                <verstretch>0</verstretch>
+               </sizepolicy>
+              </property>
+              <property name="text" >
+               <string>JPEG Quality:</string>
+              </property>
+             </widget>
+            </item>
+            <item>
+             <widget class="QSlider" name="imageQualityLevel" >
+              <property name="enabled" >
+               <bool>false</bool>
+              </property>
+              <property name="minimum" >
+               <number>1</number>
+              </property>
+              <property name="maximum" >
+               <number>9</number>
+              </property>
+              <property name="pageStep" >
+               <number>9</number>
+              </property>
+              <property name="value" >
+               <number>6</number>
+              </property>
+              <property name="orientation" >
+               <enum>Qt::Horizontal</enum>
+              </property>
+              <property name="tickPosition" >
+               <enum>QSlider::TicksBelow</enum>
+              </property>
+              <property name="tickInterval" >
+               <number>1</number>
+              </property>
+             </widget>
+            </item>
+           </layout>
+          </item>
+          <item>
+           <layout class="QHBoxLayout" >
+            <property name="margin" >
+             <number>0</number>
+            </property>
+            <property name="spacing" >
+             <number>6</number>
+            </property>
+            <item>
+             <widget class="QCheckBox" name="render" >
+              <property name="text" >
+               <string>Use RENDER Extension</string>
+              </property>
+              <property name="checked" >
+               <bool>true</bool>
+              </property>
+             </widget>
+            </item>
+            <item>
+             <widget class="QLabel" name="widthLabel" >
+              <property name="sizePolicy" >
+               <sizepolicy>
+                <hsizetype>0</hsizetype>
+                <vsizetype>5</vsizetype>
+                <horstretch>0</horstretch>
+                <verstretch>0</verstretch>
+               </sizepolicy>
+              </property>
+              <property name="text" >
+               <string>Width:</string>
+              </property>
+             </widget>
+            </item>
+            <item>
+             <widget class="QSpinBox" name="width" >
+              <property name="enabled" >
+               <bool>false</bool>
+              </property>
+              <property name="maximum" >
+               <number>9999</number>
+              </property>
+              <property name="value" >
+               <number>800</number>
+              </property>
+             </widget>
+            </item>
+            <item>
+             <widget class="QLabel" name="heightLabel" >
+              <property name="sizePolicy" >
+               <sizepolicy>
+                <hsizetype>0</hsizetype>
+                <vsizetype>5</vsizetype>
+                <horstretch>0</horstretch>
+                <verstretch>0</verstretch>
+               </sizepolicy>
+              </property>
+              <property name="text" >
+               <string>Height:</string>
+              </property>
+             </widget>
+            </item>
+            <item>
+             <widget class="QSpinBox" name="height" >
+              <property name="enabled" >
+               <bool>false</bool>
+              </property>
+              <property name="maximum" >
+               <number>9999</number>
+              </property>
+              <property name="value" >
+               <number>600</number>
+              </property>
+             </widget>
+            </item>
+           </layout>
+          </item>
+         </layout>
+        </widget>
+       </item>
+      </layout>
+     </widget>
+     <widget class="QWidget" name="advancedTab" >
+      <attribute name="title" >
+       <string>Advanced</string>
+      </attribute>
+      <layout class="QVBoxLayout" >
+       <property name="margin" >
+        <number>9</number>
+       </property>
+       <property name="spacing" >
+        <number>6</number>
+       </property>
+       <item>
+        <widget class="QGroupBox" name="networkGroup" >
+         <property name="title" >
+          <string>Network</string>
+         </property>
+         <layout class="QVBoxLayout" >
+          <property name="margin" >
+           <number>9</number>
+          </property>
+          <property name="spacing" >
+           <number>6</number>
+          </property>
+          <item>
+           <widget class="QCheckBox" name="encryption" >
+            <property name="text" >
+             <string>Use SSH Tunneling</string>
+            </property>
+            <property name="checked" >
+             <bool>true</bool>
+            </property>
+           </widget>
+          </item>
+         </layout>
+        </widget>
+       </item>
+       <item>
+        <widget class="QGroupBox" name="cacheGroup" >
+         <property name="title" >
+          <string>Cache</string>
+         </property>
+         <layout class="QVBoxLayout" >
+          <property name="margin" >
+           <number>9</number>
+          </property>
+          <property name="spacing" >
+           <number>6</number>
+          </property>
+          <item>
+           <layout class="QHBoxLayout" >
+            <property name="margin" >
+             <number>0</number>
+            </property>
+            <property name="spacing" >
+             <number>6</number>
+            </property>
+            <item>
+             <widget class="QLabel" name="memoryLabel" >
+              <property name="sizePolicy" >
+               <sizepolicy>
+                <hsizetype>0</hsizetype>
+                <vsizetype>5</vsizetype>
+                <horstretch>0</horstretch>
+                <verstretch>0</verstretch>
+               </sizepolicy>
+              </property>
+              <property name="text" >
+               <string>Memory:</string>
+              </property>
+             </widget>
+            </item>
+            <item>
+             <widget class="QSpinBox" name="memoryCache" >
+              <property name="maximum" >
+               <number>128</number>
+              </property>
+              <property name="value" >
+               <number>8</number>
+              </property>
+             </widget>
+            </item>
+            <item>
+             <widget class="QLabel" name="memoryMBLabel" >
+              <property name="text" >
+               <string>MB</string>
+              </property>
+             </widget>
+            </item>
+            <item>
+             <widget class="QLabel" name="diskLabel" >
+              <property name="sizePolicy" >
+               <sizepolicy>
+                <hsizetype>0</hsizetype>
+                <vsizetype>5</vsizetype>
+                <horstretch>0</horstretch>
+                <verstretch>0</verstretch>
+               </sizepolicy>
+              </property>
+              <property name="text" >
+               <string>Disk:</string>
+              </property>
+             </widget>
+            </item>
+            <item>
+             <widget class="QSpinBox" name="diskCache" >
+              <property name="maximum" >
+               <number>128</number>
+              </property>
+              <property name="value" >
+               <number>32</number>
+              </property>
+             </widget>
+            </item>
+            <item>
+             <widget class="QLabel" name="diskMBLabel" >
+              <property name="text" >
+               <string>MB</string>
+              </property>
+             </widget>
+            </item>
+           </layout>
+          </item>
+         </layout>
+        </widget>
+       </item>
+       <item>
+        <spacer>
+         <property name="orientation" >
+          <enum>Qt::Vertical</enum>
+         </property>
+         <property name="sizeHint" >
+          <size>
+           <width>20</width>
+           <height>40</height>
+          </size>
+         </property>
+        </spacer>
+       </item>
+      </layout>
+     </widget>
+    </widget>
+   </item>
+   <item>
+    <layout class="QHBoxLayout" >
+     <property name="margin" >
+      <number>0</number>
+     </property>
+     <property name="spacing" >
+      <number>6</number>
+     </property>
+     <item>
+      <widget class="QPushButton" name="cancelButton" >
+       <property name="text" >
+        <string>&amp;Cancel</string>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <spacer>
+       <property name="orientation" >
+        <enum>Qt::Horizontal</enum>
+       </property>
+       <property name="sizeHint" >
+        <size>
+         <width>40</width>
+         <height>20</height>
+        </size>
+       </property>
+      </spacer>
+     </item>
+     <item>
+      <widget class="QPushButton" name="okButton" >
+       <property name="text" >
+        <string>&amp;OK</string>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <widget class="QPushButton" name="applyButton" >
+       <property name="text" >
+        <string>&amp;Apply</string>
+       </property>
+      </widget>
+     </item>
+    </layout>
+   </item>
+  </layout>
+ </widget>
+ <pixmapfunction></pixmapfunction>
+ <resources/>
+ <connections/>
+</ui>



From gwright at mail.berlios.de  Mon Jan  7 13:11:39 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Mon, 07 Jan 2008 12:11:39 -0000
Subject: [Freenx-cvs] r433 - nxcl/lib
Message-ID: <200801071210.m07CANNx027410@sheep.berlios.de>

Author: gwright
Date: 2008-01-07 13:10:22 +0100 (Mon, 07 Jan 2008)
New Revision: 433

Modified:
   nxcl/lib/nxclientlib.cpp
   nxcl/lib/nxclientlib.h
   nxcl/lib/nxsession.cpp
   nxcl/lib/nxsession.h
Log:
Major code cleanups, remove dead code


Modified: nxcl/lib/nxclientlib.cpp
===================================================================
--- nxcl/lib/nxclientlib.cpp	2008-01-07 09:44:37 UTC (rev 432)
+++ nxcl/lib/nxclientlib.cpp	2008-01-07 12:10:22 UTC (rev 433)
@@ -6,6 +6,8 @@
     copyright            : (C) 2006 by George Wright
     modifications        : (C) 2007 Embedded Software Foundry Ltd. (U.K.)
                          :     Author: Sebastian James
+                         : (C) 2008 Defuturo Ltd
+                         :     Author: George Wright
     email                : seb at esfnet.co.uk, gwright at kde.org
  ***************************************************************************/
 
@@ -17,6 +19,7 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
+
 #include "nxclientlib_i18n.h"
 #include "nxclientlib.h"
 #include "nxdata.h"
@@ -24,10 +27,10 @@
 #include <fstream>
 
 extern "C" {
-#include <errno.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
+    #include <errno.h>
+    #include <sys/types.h>
+    #include <sys/stat.h>
+    #include <unistd.h>
 }
 
 /*
@@ -53,86 +56,82 @@
 {
 }
 
-void
-NXClientLibCallbacks::startedSignal (string name)
+void NXClientLibCallbacks::startedSignal (string name)
 {
-	this->parent->externalCallbacks->write (NXCL_PROCESS_STARTED, name + _(" process started"));
+    this->parent->externalCallbacks->write
+        (NXCL_PROCESS_STARTED, name + _(" process started"));
 }
 
-void
-NXClientLibCallbacks::processFinishedSignal (string name)
+void NXClientLibCallbacks::processFinishedSignal (string name)
 {
-	this->parent->externalCallbacks->write (NXCL_PROCESS_EXITED, name + _(" process exited"));
-	parent->setIsFinished (true);
+    this->parent->externalCallbacks->write
+        (NXCL_PROCESS_EXITED, name + _(" process exited"));
+    parent->setIsFinished (true);
 }
 
-void
-NXClientLibCallbacks::errorSignal (int error)
+void NXClientLibCallbacks::errorSignal (int error)
 {
-	string message;
-	switch (error) {
-	case NOTQPROCFAILEDTOSTART:
-		message = _("The process failed to start");
-		break;
-	case NOTQPROCCRASHED:
-		message = _("The process has crashed");
-		break;
-	case NOTQPROCTIMEDOUT:
-		message = _("The process timed out");
-		break;
-	case NOTQPROCWRITEERR:
-		message = _("There was an error writing to the process");
-		break;
-	case NOTQPROCREADERR:
-		message = _("There was an error reading from the process");
-		break;
-	default:
-		message = _("There was an unknown error with the process");
-		break;
-	}
-		
-	this->parent->externalCallbacks->error (message);
+    string message;
+    switch (error) {
+        case NOTQPROCFAILEDTOSTART:
+            message = _("The process failed to start");
+            break;
+        case NOTQPROCCRASHED:
+            message = _("The process has crashed");
+            break;
+        case NOTQPROCTIMEDOUT:
+            message = _("The process timed out");
+            break;
+        case NOTQPROCWRITEERR:
+            message = _("There was an error writing to the process");
+            break;
+        case NOTQPROCREADERR:
+            message = _("There was an error reading from the process");
+            break;
+        default:
+            message = _("There was an unknown error with the process");
+            break;
+    }
+
+    this->parent->externalCallbacks->error (message);
 }
 
-void 
-NXClientLibCallbacks::readyReadStandardOutputSignal (void)
+void NXClientLibCallbacks::readyReadStandardOutputSignal()
 {
-	this->parent->processParseStdout();
+    this->parent->processParseStdout();
 }
 
-void 
-NXClientLibCallbacks::readyReadStandardErrorSignal (void)
+void NXClientLibCallbacks::readyReadStandardErrorSignal()
 {
-	this->parent->processParseStderr();
+    this->parent->processParseStderr();
 }
+
 /*!
  * This gets called from within the NXSession object...
  */
-void 
-NXClientLibCallbacks::noSessionsSignal (void)
+void NXClientLibCallbacks::noSessionsSignal()
 {
-	/* ...and it calls another callback function in the client code */
-	this->parent->externalCallbacks->noSessionsSignal();
+    this->parent->externalCallbacks->noSessionsSignal();
 }
-void
-NXClientLibCallbacks::loginFailedSignal (void)
+
+void NXClientLibCallbacks::loginFailedSignal()
 {
-	this->parent->loginFailed();
+    this->parent->loginFailed();
 }
-void
-NXClientLibCallbacks::readyForProxySignal (void)
+
+void NXClientLibCallbacks::readyForProxySignal()
 {
-	this->parent->readyproxy();
+    this->parent->readyproxy();
 }
-void
-NXClientLibCallbacks::authenticatedSignal (void)
+
+void NXClientLibCallbacks::authenticatedSignal()
 {
-	this->parent->doneAuth();
+    this->parent->doneAuth();
 }
-void
-NXClientLibCallbacks::sessionsSignal (list<NXResumeData> data)
+
+void NXClientLibCallbacks::sessionsSignal (list<NXResumeData> data)
 {
-	this->parent->externalCallbacks->resumeSessionsSignal (data);
+    this->parent->externalCallbacks->resumeSessionsSignal (data);
 }
 //@}
 
@@ -142,508 +141,616 @@
 //@{
 NXClientLib::NXClientLib()
 {
-	this->isFinished = false;
-	this->readyForProxy = false;
-	this->sessionRunning = false;
-	this->proxyData.encrypted = false;
-	this->password = false;
+    this->isFinished = false;
+    this->readyForProxy = false;
+    this->sessionRunning = false;
+    this->proxyData.encrypted = false;
+    this->password = false;
 
-	dbgln ("In NXClientLib constructor");
+    dbgln ("In NXClientLib constructor");
 
-	this->pNxsshProcess = &this->nxsshProcess;
-	this->pNxproxyProcess = &this->nxproxyProcess;
+    this->pNxsshProcess = &this->nxsshProcess;
+    this->pNxproxyProcess = &this->nxproxyProcess;
 
-	/* Set up callback pointers */
-	this->nxsshProcess.setCallbacks (&callbacks);
-	this->nxproxyProcess.setCallbacks (&callbacks);
-	this->session.setCallbacks (&callbacks);
-	this->callbacks.setParent (this);
+    /* Set up callback pointers */
+    this->nxsshProcess.setCallbacks (&callbacks);
+    this->nxproxyProcess.setCallbacks (&callbacks);
+    this->session.setCallbacks (&callbacks);
+    this->callbacks.setParent (this);
 
-	dbgln ("Returning from NXClientLib constructor");
+    dbgln ("Returning from NXClientLib constructor");
 }
 
 NXClientLib::~NXClientLib()
 {
-	dbgln ("In NXClientLib destructor");
-	this->nxsshProcess.terminate();
+    dbgln ("In NXClientLib destructor");
+    this->nxsshProcess.terminate();
 }
 
-void NXClientLib::invokeNXSSH (string publicKey, string serverHost, bool encryption, string key, int port)
+void NXClientLib::invokeNXSSH (string publicKey, string serverHost,
+        bool encryption, string key, int port)
 {
-	list<string> arguments;
-	stringstream argtmp;
-	proxyData.server = serverHost;
+    list<string> arguments;
+    stringstream argtmp;
+    proxyData.server = serverHost;
 
-	dbgln("invokeNXSSH called");
+    dbgln("invokeNXSSH called");
 
-	// We use same environment for the process as was used for the
-	// parent, so remove nxsshProcess.setEnvironment();
+    // We use same environment for the process as was used for the
+    // parent, so remove nxsshProcess.setEnvironment();
 
-	// Start to build the arguments for the nxssh command.
-	// notQProcess requires that argv[0] contains the program name
-	arguments.push_back ("nxssh");
-	
-	argtmp << "-nx";
-	arguments.push_back (argtmp.str());
+    // Start to build the arguments for the nxssh command.
+    // notQProcess requires that argv[0] contains the program name
+    arguments.push_back ("nxssh");
 
-	argtmp.str("");
-	argtmp << "-p" << port;
-	arguments.push_back (argtmp.str());
+    argtmp << "-nx";
+    arguments.push_back (argtmp.str());
 
-	if (publicKey == "supplied") {
-		
-		this->keyFile = new notQTemporaryFile;
-		this->keyFile->open();
-		
-		argtmp.str("");
-		argtmp << "-i" << this->keyFile->fileName();
-		arguments.push_back (argtmp.str());
+    argtmp.str("");
+    argtmp << "-p" << port;
+    arguments.push_back (argtmp.str());
 
-		this->keyFile->write (key);			
-		this->keyFile->close();
+    if (publicKey == "supplied") {
 
-	} else {
-		this->keyFile = NULL;
-		argtmp.str("");
-		argtmp << "-i" << publicKey;
-		arguments.push_back (argtmp.str());
-	}
-	
-	argtmp.str("");
-	argtmp << "nx@" << serverHost;
-	arguments.push_back (argtmp.str());
+        this->keyFile = new notQTemporaryFile;
+        this->keyFile->open();
 
-	// These options copied from the way Nomachine's client
-	// specifies the nxssh command - they make good sense.
-	arguments.push_back ("-x");
-	arguments.push_back ("-2");
-	arguments.push_back ("-oRhostsAuthentication no");
-	arguments.push_back ("-oPasswordAuthentication no");
-	arguments.push_back ("-oRSAAuthentication no");
-	arguments.push_back ("-oRhostsRSAAuthentication no");
-	arguments.push_back ("-oPubkeyAuthentication yes");
+        argtmp.str("");
+        argtmp << "-i" << this->keyFile->fileName();
+        arguments.push_back (argtmp.str());
 
-	if (encryption == true) {
-		arguments.push_back("-B");
-		session.setEncryption (true);
-	} else {
-		session.setEncryption (false);
-	}
+        this->keyFile->write (key);			
+        this->keyFile->close();
 
-	// -E appears in the call to nxssh for Nomachine's nxclient
-	// -version 3 but not 1.5. Is it there in 2?
-	// nxssh -E gives this message when called:
-	// NX> 285 Enabling skip of SSH config files
-	// ...so there you have the meaning.
-	arguments.push_back ("-E");
-	
-	// Find a path for the nxssh process using getPath()
-	string nxsshPath = this->getPath ("nxssh");
-	this->nxsshProcess.start(nxsshPath, arguments);
-	if (this->nxsshProcess.waitForStarted() == false) {
-		this->externalCallbacks->write (NXCL_PROCESS_ERROR, _("Error starting nxssh!"));
-		this->isFinished = true;
-	}
+    } else {
+        this->keyFile = NULL;
+        argtmp.str("");
+        argtmp << "-i" << publicKey;
+        arguments.push_back (argtmp.str());
+    }
+
+    argtmp.str("");
+    argtmp << "nx@" << serverHost;
+    arguments.push_back (argtmp.str());
+
+    // These options copied from the way Nomachine's client
+    // specifies the nxssh command - they make good sense.
+    arguments.push_back ("-x");
+    arguments.push_back ("-2");
+    arguments.push_back ("-oRhostsAuthentication no");
+    arguments.push_back ("-oPasswordAuthentication no");
+    arguments.push_back ("-oRSAAuthentication no");
+    arguments.push_back ("-oRhostsRSAAuthentication no");
+    arguments.push_back ("-oPubkeyAuthentication yes");
+
+    if (encryption == true) {
+        arguments.push_back("-B");
+        session.setEncryption (true);
+    } else {
+        session.setEncryption (false);
+    }
+
+    // -E appears in the call to nxssh for Nomachine's nxclient
+    // -version 3 but not 1.5. Is it there in 2?
+    // nxssh -E gives this message when called:
+    // NX> 285 Enabling skip of SSH config files
+    // ...so there you have the meaning.
+    arguments.push_back ("-E");
+
+    // Find a path for the nxssh process using getPath()
+    string nxsshPath = this->getPath ("nxssh");
+    this->nxsshProcess.start(nxsshPath, arguments);
+
+    if (this->nxsshProcess.waitForStarted() == false) {
+        this->externalCallbacks->write
+            (NXCL_PROCESS_ERROR, _("Error starting nxssh!"));
+        this->isFinished = true;
+    }
 }
 
 void NXClientLib::requestConfirmation (string msg)
 {
-	this->externalCallbacks->stdoutSignal (_("This is a placeholder method to deal with sending back a yes or a no answer. "
-						 "For now, we just set this->session.setContinue(true);"));
-	this->session.setContinue(true);
+    this->externalCallbacks->stdoutSignal
+        (_("This is a placeholder method to deal with sending "
+            "back a yes or a no answer. "
+            "For now, we just set this->session.setContinue(true);"));
+    this->session.setContinue(true);
 }
 
 void NXClientLib::reset()
 {
-	this->nxsshProcess.terminate();       
-	this->isFinished = false;
-	this->proxyData.encrypted = false;
-	this->password = false;	
-	this->session.resetSession();
+    this->nxsshProcess.terminate();
+    this->isFinished = false;
+    this->proxyData.encrypted = false;
+    this->password = false;	
+    this->session.resetSession();
 }
 
 void NXClientLib::loginFailed()
 {
-	this->externalCallbacks->write (NXCL_LOGIN_FAILED, _("Got \"Login Failed\""));
-	this->isFinished = true;
-	this->nxsshProcess.terminate();
+    this->externalCallbacks->write
+        (NXCL_LOGIN_FAILED, _("Got \"Login Failed\""));
+
+    this->isFinished = true;
+    this->nxsshProcess.terminate();
 }
 
 void NXClientLib::processParseStdout()
 {
-	string message = nxsshProcess.readAllStandardOutput();
+    string message = nxsshProcess.readAllStandardOutput();
 
-	this->externalCallbacks->stdoutSignal (message);
+    this->externalCallbacks->stdoutSignal (message);
 
-	dbgln ("NXClientLib::processParseStdout() called");
+    dbgln ("NXClientLib::processParseStdout() called");
 
-	int response = 0;
-	// Message 211 is sent if ssh is asking to continue with an unknown host
-	if ((response = session.parseResponse(message)) == 211) {
-		this->requestConfirmation (message);
-	}
+    int response = 0;
 
-	dbgln ("NXClientLib::processPraseStdout(): response = " << response);
+    // Message 211 is sent if ssh is asking to continue with an unknown host
+    if ((response = session.parseResponse(message)) == 211) {
+        this->requestConfirmation (message);
+    }
 
-	if (response == 100000) {
-		// A program never started.
-		this->isFinished = true;
-		return;
-	} else if (response > 100000) {
-		dbgln ("A process crashed or exited");
-		int pid = response - 100000;
-		if (this->nxsshProcess.getPid() == pid) {
-			this->nxsshProcess.setError(NOTQPROCCRASHED);
-			this->externalCallbacks->error (_("nxsshProcess crashed or exited"));
-			this->isFinished = true;
-		} else if (this->nxproxyProcess.getPid() == pid) {
-			this->nxproxyProcess.setError(NOTQPROCCRASHED);
-			this->externalCallbacks->error (_("nxproxyProcess crashed or exited"));
-			this->isFinished = true;
-		} else {
-			this->externalCallbacks->error (_("Warning: Don't know what crashed (in processParseStdout())"));
-		}
-		return;
-	}
+    dbgln ("NXClientLib::processParseStdout(): response = " << response);
 
-	// If message 204 is picked, that's authentication failed.
-	if (response == 204) {
-		this->externalCallbacks->write (NXCL_AUTH_FAILED,
-						_("Got \"Authentication Failed\" from nxssh.\n"
-						  "Please check the certificate for the first SSL "
-						  "authentication stage,\n"
-						  "in which the \"nx\" user is authenticated."));
-		this->isFinished = true;
-		return;
-	}
+    if (response == 100000) {
+        // A program never started.
+        this->isFinished = true;
+        return;
+    } else if (response > 100000) {
+        dbgln ("A process crashed or exited");
 
-	// 147 is server capacity reached
-	if (response == 147) {
-		this->externalCallbacks->serverCapacitySignal();
-		this->isFinished = true;
-		return;
-	}
-	
-	dbgln ("NXClientLib::processParseStdout(): The message is '" + message + "'(msg end)");
-	dbgln ("...and response is " << response);
+        int pid = response - 100000;
 
-	notQtUtilities::ensureUnixNewlines (message);
-	list<string> msglist;
-	list<string>::iterator msgiter;
-	notQtUtilities::splitString (message, '\n', msglist);
+        if (this->nxsshProcess.getPid() == pid) {
+            this->nxsshProcess.setError(NOTQPROCCRASHED);
 
-	for (msgiter = msglist.begin(); msgiter != msglist.end(); msgiter++) {
-		dbgln ("NXClientLib::processParseStdout(): Processing the message '" + (*msgiter) + "'(end msg)");
-		// On some connections this is sent via stdout instead of stderr?
-		if (proxyData.encrypted && readyForProxy && ((*msgiter).find("NX> 999 Bye")!=string::npos)) {
-			// This is "NX> 299 Switching connection to: " in
-			// version 1.5.0. This was changed in nxssh version
-			// 2.0.0-8 (see the nxssh CHANGELOG).
-			string switchCommand = "NX> 299 Switch connection to: ";
-			stringstream ss;
-			ss << "127.0.0.1:" << proxyData.port << " cookie: " << proxyData.cookie << "\n";
-			switchCommand += ss.str();
-			this->write (switchCommand);
-		} else if ((*msgiter).find("NX> 287 Redirected I/O to channel descriptors") != string::npos) {
-			this->externalCallbacks->write(287, _("The session has been started successfully"));
-			this->sessionRunning = true;
-		}
+            this->externalCallbacks->error
+                (_("nxsshProcess crashed or exited"));
 
-		if ((*msgiter).find("Password") != string::npos) {
-			this->externalCallbacks->write(NXCL_AUTHENTICATING, _("Authenticating with NX server"));
-			this->password = true;
-		}
+            this->isFinished = true;
+        } else if (this->nxproxyProcess.getPid() == pid) {
+            this->nxproxyProcess.setError(NOTQPROCCRASHED);
 
-		if (!readyForProxy) {
-			string msg = session.parseSSH (*msgiter);
-			if (msg == "204\n" || msg == "147\n") {
-				// Auth failed.
-				dbgln ("NXClientLib::processParseStdout: Got auth failed or capacity reached, calling this->parseSSH.");
-				msg = this->parseSSH (*msgiter);
-			}
-			if (msg.size() > 0) {
-				this->write (msg);
-			}
-		} else {
-			this->write (this->parseSSH (*msgiter));
-		}
-	}
-	return;
+            this->externalCallbacks->error
+                (_("nxproxyProcess crashed or exited"));
+
+            this->isFinished = true;
+        } else {
+            this->externalCallbacks->error
+                (_("Warning: Don't know what crashed "
+                   "(in processParseStdout())"));
+        }
+        return;
+    }
+
+    // If message 204 is picked, that's authentication failed.
+    if (response == 204) {
+        this->externalCallbacks->write (NXCL_AUTH_FAILED,
+                _("Got \"Authentication Failed\" from nxssh.\n"
+                    "Please check the certificate for the first SSL "
+                    "authentication stage,\n"
+                    "in which the \"nx\" user is authenticated."));
+        this->isFinished = true;
+        return;
+    }
+
+    // 147 is server capacity reached
+    if (response == 147) {
+        this->externalCallbacks->serverCapacitySignal();
+        this->isFinished = true;
+        return;
+    }
+
+    dbgln ("NXClientLib::processParseStdout(): The message is '"
+            + message + "'(msg end)");
+
+    dbgln ("...and response is " << response);
+
+    notQtUtilities::ensureUnixNewlines (message);
+
+    list<string> msglist;
+    list<string>::iterator msgiter;
+
+    notQtUtilities::splitString (message, '\n', msglist);
+
+    for (msgiter = msglist.begin(); msgiter != msglist.end(); msgiter++) {
+        dbgln ("NXClientLib::processParseStdout(): Processing the message '"
+                + (*msgiter) + "'(end msg)");
+
+        // On some connections this is sent via stdout instead of stderr?
+        if (proxyData.encrypted && readyForProxy &&
+                ((*msgiter).find("NX> 999 Bye")!=string::npos)) {
+
+            // This is "NX> 299 Switching connection to: " in
+            // version 1.5.0. This was changed in nxssh version
+            // 2.0.0-8 (see the nxssh CHANGELOG).
+            string switchCommand = "NX> 299 Switch connection to: ";
+
+            stringstream ss;
+
+            ss << "127.0.0.1:" << proxyData.port << " cookie: " <<
+                proxyData.cookie << "\n";
+            switchCommand += ss.str();
+
+            this->write (switchCommand);
+        } else if ((*msgiter).find
+                ("NX> 287 Redirected I/O to channel descriptors") !=
+                string::npos) {
+
+            this->externalCallbacks->write
+                (287, _("The session has been started successfully"));
+            this->sessionRunning = true;
+        }
+
+        if ((*msgiter).find("Password") != string::npos) {
+            this->externalCallbacks->write
+                (NXCL_AUTHENTICATING, _("Authenticating with NX server"));
+            this->password = true;
+        }
+
+        if (!readyForProxy) {
+            string msg = session.parseSSH (*msgiter);
+            if (msg == "204\n" || msg == "147\n") {
+                // Auth failed.
+                dbgln ("NXClientLib::processParseStdout: Got auth failed"
+                        " or capacity reached, calling this->parseSSH.");
+                msg = this->parseSSH (*msgiter);
+            }
+            if (msg.size() > 0) {
+                this->write (msg);
+            }
+        } else {
+            this->write (this->parseSSH (*msgiter));
+        }
+    }
+    return;
 }
 
 void NXClientLib::processParseStderr()
 {
-	string message = nxsshProcess.readAllStandardError();
+    string message = nxsshProcess.readAllStandardError();
 
-	dbgln ("In NXClientLib::processParseStderr for message: '" + message + "'(msg end)");
+    dbgln ("In NXClientLib::processParseStderr for message: '"
+            + message + "'(msg end)");
 
-	this->externalCallbacks->stderrSignal (message);
+    this->externalCallbacks->stderrSignal (message);
 
-	// Now we need to split the message if necessary based on the \n or \r characters
-	notQtUtilities::ensureUnixNewlines (message);
+    // Now we need to split the message if necessary based on the
+    // \n or \r characters
+    notQtUtilities::ensureUnixNewlines (message);
 
-	list<string> msglist;
-	list<string>::iterator msgiter;
-	notQtUtilities::splitString (message, '\n', msglist);
+    list<string> msglist;
+    list<string>::iterator msgiter;
+    notQtUtilities::splitString (message, '\n', msglist);
 
-	for (msgiter=msglist.begin(); msgiter!=msglist.end(); msgiter++) {
-		dbgln ("NXClientLib::processParseStderr: Processing the message '" + (*msgiter) + "'(end msg)");
-		if (proxyData.encrypted && readyForProxy && ((*msgiter).find("NX> 999 Bye") != string::npos)) {
-			string switchCommand = "NX> 299 Switch connection to: ";
-			stringstream ss;
-			ss << "127.0.0.1:" << proxyData.port << " cookie: " << proxyData.cookie << "\n";
-			switchCommand += ss.str();
-			this->write(switchCommand);
+    for (msgiter=msglist.begin(); msgiter!=msglist.end(); msgiter++) {
 
-		} else if ((*msgiter).find("NX> 287 Redirected I/O to channel descriptors") != string::npos) {
-			this->externalCallbacks->write(287, _("The session has been started successfully"));
+        dbgln ("NXClientLib::processParseStderr: Processing the message '"
+                + (*msgiter) + "'(end msg)");
 
-		} else if ((*msgiter).find("NX> 209 Remote host identification has changed") != string::npos) {
-			this->externalCallbacks->write(209, _("SSH Host Key Problem"));
-			this->isFinished = true;
+        if (proxyData.encrypted && readyForProxy &&
+                ((*msgiter).find("NX> 999 Bye") != string::npos)) {
 
-		} else if ((*msgiter).find("NX> 280 Ignoring EOF on the monitored channel") != string::npos) {
-			this->externalCallbacks->write(280, _("Got \"NX> 280 Ignoring EOF on the monitored channel\" from nxssh..."));
-			this->isFinished = true;
+            string switchCommand = "NX> 299 Switch connection to: ";
+            stringstream ss;
 
-		} else if ((*msgiter).find("Host key verification failed") != string::npos) {
-			this->externalCallbacks->write(NXCL_HOST_KEY_VERIFAILED, _("SSH host key verification failed"));
-			this->isFinished = true;			
-		}
-	}
+            ss << "127.0.0.1:" << proxyData.port << " cookie: "
+                << proxyData.cookie << "\n";
+
+            switchCommand += ss.str();
+            this->write(switchCommand);
+
+        } else if ((*msgiter).find
+                ("NX> 287 Redirected I/O to channel descriptors") !=
+                string::npos) {
+
+            this->externalCallbacks->write
+                (287, _("The session has been started successfully"));
+
+        } else if ((*msgiter).find
+                ("NX> 209 Remote host identification has changed") !=
+                string::npos) {
+
+            this->externalCallbacks->write(209, _("SSH Host Key Problem"));
+            this->isFinished = true;
+
+        } else if ((*msgiter).find
+                ("NX> 280 Ignoring EOF on the monitored channel") !=
+                string::npos) {
+
+            this->externalCallbacks->write
+                (280, _("Got \"NX> 280 Ignoring EOF on the monitored channel\""
+                        " from nxssh..."));
+            this->isFinished = true;
+
+        } else if ((*msgiter).find
+                ("Host key verification failed") != string::npos) {
+            this->externalCallbacks->write
+                (NXCL_HOST_KEY_VERIFAILED,
+                 _("SSH host key verification failed"));
+            this->isFinished = true;
+        }
+    }
 }
 
 void NXClientLib::write (string data)
 {
-	if (data.size() == 0) { return; }
+    if (data.size() == 0) { return; }
 
-	dbgln ("Writing '" << data << "' to nxssh process.");
-	
-	this->nxsshProcess.writeIn(data);
+    dbgln ("Writing '" << data << "' to nxssh process.");
 
-	if (password) {
-		data = "********";
-		password = false;
-	}
+    this->nxsshProcess.writeIn(data);
 
-	// Output this to the user via a signal - this is data going in to nxssh.
-	this->externalCallbacks->stdinSignal (data);
+    if (password) {
+        data = "********";
+        password = false;
+    }
+
+    // Output this to the user via a signal - this is data going in to nxssh.
+    this->externalCallbacks->stdinSignal (data);
 }
 
 void NXClientLib::doneAuth()
 {
-	if (this->keyFile != NULL) {
-		this->keyFile->remove();
-		delete this->keyFile;
-	}
-	return;
+    if (this->keyFile != NULL) {
+        this->keyFile->remove();
+        delete this->keyFile;
+    }
+    return;
 }
 
 void NXClientLib::allowSSHConnect (bool auth)
 {
-	session.setContinue (auth);
+    session.setContinue (auth);
 }
 
 void NXClientLib::setSessionData (NXSessionData *nxSessionData)
 {
-	session.setSessionData (nxSessionData);
-	string a = "NX> 105";
-	string d = session.parseSSH(a);
-	if (d.size()>0) {
-		this->write(d);
-	}
+    session.setSessionData (nxSessionData);
+    string a = "NX> 105";
+    string d = session.parseSSH(a);
+    if (d.size()>0) {
+        this->write(d);
+    }
 }
 
 void NXClientLib::runSession ()
 {
-	session.runSession();
-	string a = "NX> 105";
-	string d = session.parseSSH(a);
-	if (d.size()>0) {
-		this->write(d);
-	}
+    session.runSession();
+    string a = "NX> 105";
+    string d = session.parseSSH(a);
+    if (d.size()>0) {
+        this->write(d);
+    }
 }
 
 string NXClientLib::parseSSH (string message)
 {
-	string rMessage;
-	string::size_type pos;
-	rMessage = "";
+    string rMessage;
+    string::size_type pos;
+    rMessage = "";
 
-	dbgln ("NXClientLib::parseSSH called for message '" + message + "'");
+    dbgln ("NXClientLib::parseSSH called for message '" + message + "'");
 
-	if ((pos = message.find("NX> 700 Session id: ")) != string::npos) {
-		this->externalCallbacks->write (700, _("Got a session ID"));
-		proxyData.id = message.substr(pos+20, message.length()-pos);
-	} else if ((pos = message.find("NX> 705 Session display: ")) != string::npos) {
-		stringstream portss;
-		int portnum;
-		portss << message.substr(pos+25, message.length()-pos);
-		portss >> portnum;		
-		proxyData.display = portnum;
-		proxyData.port = portnum + 4000;
-	} else if ((pos = message.find("NX> 706 Agent cookie: ")) != string::npos) {
-		proxyData.cookie = message.substr(pos+22, message.length()-pos);
-		this->externalCallbacks->write (706, _("Got an agent cookie"));
-	} else if ((pos = message.find("NX> 702 Proxy IP: ")) != string::npos) {
-		proxyData.proxyIP = message.substr(pos+18, message.length()-pos);
-		this->externalCallbacks->write (702, _("Got a proxy IP"));
-	} else if (message.find("NX> 707 SSL tunneling: 1") != string::npos) {
-		this->externalCallbacks->write (702, _("All data will be SSL tunnelled"));
-		proxyData.encrypted = true;
-	} else if (message.find("NX> 147 Server capacity") != string::npos) {
-		this->externalCallbacks->write (147, _("Got \"Server Capacity Reached\" from nxssh."));
-		this->externalCallbacks->serverCapacitySignal();
-		this->isFinished = true;
-	} else if (message.find ("NX> 204 Authentication failed.") != string::npos) {
-		this->externalCallbacks->write (204, _("NX SSH Authentication Failed, finishing"));
-		this->isFinished = true;
-	}
+    if ((pos = message.find("NX> 700 Session id: ")) != string::npos) {
+        this->externalCallbacks->write (700, _("Got a session ID"));
+        proxyData.id = message.substr(pos+20, message.length()-pos);
 
-	if (message.find("NX> 710 Session status: running") != string::npos) {
-		this->externalCallbacks->write (710, _("Session status is \"running\""));
-		invokeProxy();
-		session.wipeSessions();
-		rMessage = "bye\n";
-	}
+    } else if ((pos = message.find("NX> 705 Session display: ")) != string::npos) {
+        stringstream portss;
+        int portnum;
+        portss << message.substr(pos+25, message.length()-pos);
+        portss >> portnum;		
+        proxyData.display = portnum;
+        proxyData.port = portnum + 4000;
 
-	return rMessage;
+    } else if
+        ((pos = message.find("NX> 706 Agent cookie: ")) != string::npos) {
+
+        proxyData.cookie = message.substr(pos+22, message.length()-pos);
+        this->externalCallbacks->write (706, _("Got an agent cookie"));
+
+    } else if
+        ((pos = message.find("NX> 702 Proxy IP: ")) != string::npos) {
+
+        proxyData.proxyIP = message.substr(pos+18, message.length()-pos);
+        this->externalCallbacks->write (702, _("Got a proxy IP"));
+
+    } else if
+        (message.find("NX> 707 SSL tunneling: 1") != string::npos) {
+
+        this->externalCallbacks->write
+            (702, _("All data will be SSL tunnelled"));
+
+        proxyData.encrypted = true;
+
+    } else if (message.find("NX> 147 Server capacity") != string::npos) {
+
+        this->externalCallbacks->write
+            (147, _("Got \"Server Capacity Reached\" from nxssh."));
+
+        this->externalCallbacks->serverCapacitySignal();
+        this->isFinished = true;
+
+    } else if
+        (message.find ("NX> 204 Authentication failed.") != string::npos) {
+
+        this->externalCallbacks->write
+            (204, _("NX SSH Authentication Failed, finishing"));
+        this->isFinished = true;
+    }
+
+    if (message.find("NX> 710 Session status: running") != string::npos) {
+
+        this->externalCallbacks->write
+            (710, _("Session status is \"running\""));
+        invokeProxy();
+        session.wipeSessions();
+        rMessage = "bye\n";
+    }
+
+    return rMessage;
 }
 
 void NXClientLib::invokeProxy()
 {
-	this->externalCallbacks->write(NXCL_INVOKE_PROXY, _("Starting NX session"));
-	
-	int e;
-	char * home;
-	home = getenv ("HOME");
-	stringstream ss;
-	ss << home;
-	string nxdir = ss.str();
-	nxdir += "/.nx";
-	// Create the .nx directory first.
-	if (mkdir (nxdir.c_str(), 0770)) {
-		e = errno;
-		if (e != EEXIST) { // We don't mind .nx already
-				   // existing, though if there is a
-				   // _file_ called $HOME/.nx, we'll
-				   // get errors later.
-			this->externalCallbacks->error (_("Problem creating .nx directory"));
-		}
-	}
-	// Now the per session directory
-	nxdir += "/S-" + proxyData.id;
-	if (mkdir (nxdir.c_str(), 0770)) {
-		e = errno;
-		if (e != EEXIST) { // We don't mind .nx already
-			this->externalCallbacks->error (_("Problem creating Session directory"));
-		}
-	}
+    this->externalCallbacks->write
+        (NXCL_INVOKE_PROXY, _("Starting NX session"));
 
-	stringstream data;
-	if (proxyData.encrypted) {
-		data << "nx/nx,session=session,encryption=1,cookie=" << proxyData.cookie 
-		     << ",root=" << home << "/.nx"
-		     << ",id=" << proxyData.id << ",listen=" << proxyData.port << ":" << proxyData.display << "\n";
-		// may also need shmem=1,shpix=1,font=1,product=...
+    int e;
+    char * home;
 
-	} else {
-		// Not tested yet
-		data << "nx,session=session,cookie=" << proxyData.cookie
-		     << ",root=" << home
-		     << "/.nx,id=" << proxyData.id
-		     << ",connect=" << proxyData.server << ":" << proxyData.display << "\n";
-	}
-	
-	// Filename is nxdir plus "/options"
-	nxdir += "/options";
-	std::ofstream options;
-	options.open (nxdir.c_str(), std::fstream::out);
-	options << data.str();
-	options.close();
+    home = getenv ("HOME");
 
-	// Build arguments for the call to the nxproxy command
-	list<string> arguments;
-	arguments.push_back("nxproxy"); // argv[0] has to be the program name
-	arguments.push_back("-S");
-	ss.str("");
-	ss << "options=" << nxdir;
-	ss << ":" << proxyData.display;
-	arguments.push_back(ss.str());	
+    stringstream ss;
+    ss << home;
 
-	// Find a path for the nxproxy process using getPath()
-	string nxproxyPath = this->getPath ("nxproxy");
-	this->nxproxyProcess.start(nxproxyPath, arguments);
-	if (this->nxproxyProcess.waitForStarted() == false) {
-		this->externalCallbacks->write (NXCL_PROCESS_ERROR, _("Error starting nxproxy!"));
-		this->isFinished = true;
-	}
+    string nxdir = ss.str();
+
+    nxdir += "/.nx";
+
+    // Create the .nx directory first.
+    if (mkdir (nxdir.c_str(), 0770)) {
+        e = errno;
+
+        if (e != EEXIST) {
+            // We don't mind .nx already
+            // existing, though if there is a
+            // _file_ called $HOME/.nx, we'll
+            // get errors later.
+            this->externalCallbacks->error
+                (_("Problem creating .nx directory"));
+        }
+    }
+
+    // Now the per session directory
+    nxdir += "/S-" + proxyData.id;
+
+    if (mkdir (nxdir.c_str(), 0770)) {
+        e = errno;
+
+        if (e != EEXIST) {
+            // We don't mind .nx already
+            this->externalCallbacks->error
+                (_("Problem creating Session directory"));
+        }
+    }
+
+    stringstream data;
+    if (proxyData.encrypted) {
+        data << "nx/nx,session=session,encryption=1,cookie="
+            << proxyData.cookie
+            << ",root=" << home << "/.nx"
+            << ",id=" << proxyData.id << ",listen=" 
+            << proxyData.port << ":" << proxyData.display << "\n";
+        // may also need shmem=1,shpix=1,font=1,product=...
+
+    } else {
+        // Not tested yet
+        data << "nx,session=session,cookie=" << proxyData.cookie
+            << ",root=" << home
+            << "/.nx,id=" << proxyData.id
+            << ",connect=" << proxyData.server << ":" << proxyData.display
+            << "\n";
+    }
+
+    // Filename is nxdir plus "/options"
+    nxdir += "/options";
+    std::ofstream options;
+    options.open (nxdir.c_str(), std::fstream::out);
+    options << data.str();
+    options.close();
+
+    // Build arguments for the call to the nxproxy command
+    list<string> arguments;
+    arguments.push_back("nxproxy"); // argv[0] has to be the program name
+    arguments.push_back("-S");
+    ss.str("");
+    ss << "options=" << nxdir;
+    ss << ":" << proxyData.display;
+    arguments.push_back(ss.str());	
+
+    // Find a path for the nxproxy process using getPath()
+    string nxproxyPath = this->getPath ("nxproxy");
+    this->nxproxyProcess.start(nxproxyPath, arguments);
+
+    if (this->nxproxyProcess.waitForStarted() == false) {
+        this->externalCallbacks->write
+            (NXCL_PROCESS_ERROR, _("Error starting nxproxy!"));
+        this->isFinished = true;
+    }
 }
 
 bool NXClientLib::chooseResumable (int n)
 {
-	return (this->session.chooseResumable(n));
+    return (this->session.chooseResumable(n));
 }
 
 bool NXClientLib::terminateSession (int n)
 {
-	return (this->session.terminateSession(n));
+    return (this->session.terminateSession(n));
 }
 
 string NXClientLib::getPath (string prog)
 {
-	string path;
-	struct stat * buf;
+    string path;
+    struct stat * buf;
 
-	buf = static_cast<struct stat*>(malloc (sizeof (struct stat)));
-	if (!buf) {
-		// Malloc error.
-		return prog;
-	}
+    buf = static_cast<struct stat*>(malloc (sizeof (struct stat)));
 
-	path = PACKAGE_BIN_DIR"/" + prog;
-	memset (buf, 0, sizeof(struct stat));
-	stat (path.c_str(), buf);
-	if (S_ISREG (buf->st_mode) || S_ISLNK (buf->st_mode)) {
-		// Found prog in PACKAGE_BIN_DIR
-	} else {
-		path = "/usr/local/bin/" + prog;
-		memset (buf, 0, sizeof(struct stat));
-		stat (path.c_str(), buf);
-		if (S_ISREG (buf->st_mode) || S_ISLNK (buf->st_mode)) {
-			// Found prog in /usr/local/bin
-		} else {
-			path = "/usr/bin/" + prog;
-			memset (buf, 0, sizeof(struct stat));
-			stat (path.c_str(), buf);
-			if (S_ISREG (buf->st_mode) || 
-			    S_ISLNK (buf->st_mode)) {
-				// Found prog in /usr/bin
-			} else {
-				path = "/usr/NX/bin/" + prog;
-				memset (buf, 0, sizeof(struct stat));
-				stat (path.c_str(), buf);
-				if (S_ISREG (buf->st_mode) || 
-				    S_ISLNK (buf->st_mode)) {
+    if (!buf) {
+        // Malloc error.
+        return prog;
+    }
 
-				} else {
-					path = "/bin/" + prog;
-					memset (buf, 0, sizeof(struct stat));
-					stat (path.c_str(), buf);
-					if (S_ISREG (buf->st_mode) || 
-					    S_ISLNK (buf->st_mode)) {
-						// Found prog in /bin
-					} else {
-						// Just return the
-						// prog name.
-						path = prog;
-					}
-				}
-			}
-		}
-	}
+    path = PACKAGE_BIN_DIR"/" + prog;
+    memset (buf, 0, sizeof(struct stat));
+    stat (path.c_str(), buf);
 
-	free (buf);
-	return path;
+    if (S_ISREG (buf->st_mode) || S_ISLNK (buf->st_mode)) {
+        // Found prog in PACKAGE_BIN_DIR
+    } else {
+        path = "/usr/local/bin/" + prog;
+        memset (buf, 0, sizeof(struct stat));
+        stat (path.c_str(), buf);
+
+        if (S_ISREG (buf->st_mode) || S_ISLNK (buf->st_mode)) {
+            // Found prog in /usr/local/bin
+        } else {
+            path = "/usr/bin/" + prog;
+            memset (buf, 0, sizeof(struct stat));
+            stat (path.c_str(), buf);
+
+            if (S_ISREG (buf->st_mode) ||
+                    S_ISLNK (buf->st_mode)) {
+                // Found prog in /usr/bin
+
+            } else {
+                path = "/usr/NX/bin/" + prog;
+                memset (buf, 0, sizeof(struct stat));
+                stat (path.c_str(), buf);
+
+                if (S_ISREG (buf->st_mode) || 
+                        S_ISLNK (buf->st_mode)) {
+
+                } else {
+                    path = "/bin/" + prog;
+                    memset (buf, 0, sizeof(struct stat));
+                    stat (path.c_str(), buf);
+                    if (S_ISREG (buf->st_mode) || 
+                            S_ISLNK (buf->st_mode)) {
+                        // Found prog in /bin
+                    } else {
+                        // Just return the
+                        // prog name.
+                        path = prog;
+                    }
+                }
+            }
+        }
+    }
+
+    free (buf);
+    return path;
 }
 //@}

Modified: nxcl/lib/nxclientlib.h
===================================================================
--- nxcl/lib/nxclientlib.h	2008-01-07 09:44:37 UTC (rev 432)
+++ nxcl/lib/nxclientlib.h	2008-01-07 12:10:22 UTC (rev 433)
@@ -1,6 +1,5 @@
-/* -*-c++-*- */
 /***************************************************************************
-                                nxclientlib.h
+                               nxclientlib.h
                              -------------------
     begin                : Sat 22nd July 2006
     remove Qt dependency : Started June 2007
@@ -8,6 +7,8 @@
     copyright            : (C) 2006 by George Wright
     modifications        : (C) 2007 Embedded Software Foundry Ltd. (U.K.)
                          :     Author: Sebastian James
+                         : (C) 2008 Defuturo Ltd
+                         :     Author: George Wright
     email                : seb at esfnet.co.uk, gwright at kde.org
  ***************************************************************************/
 
@@ -33,328 +34,389 @@
 
 namespace nxcl {
 
-	struct ProxyData {
-		string id;
-		int    display;
-		string cookie;
-		string proxyIP;
-		bool   encrypted;
-		int    port;
-		string server;
-	};
+    struct ProxyData {
+        string id;
+        int    display;
+        string cookie;
+        string proxyIP;
+        bool   encrypted;
+        int    port;
+        string server;
+    };
 
-	/*!
-	 * Callbacks which are to be defined by the client code of
-	 * NXClientLib objects. In the case of nxcl, that means the
-	 * code in the class Nxcl in nxcl.cpp.
-	 */
-	class NXClientLibExternalCallbacks
-	{
-	public:
-		NXClientLibExternalCallbacks () {}
-		virtual ~NXClientLibExternalCallbacks () {}
-		virtual void write (string msg) {}
-		virtual void write (int num, string msg) {}
-		virtual void error (string msg) {}
-		virtual void debug (string msg) {}
-		virtual void stdoutSignal (string msg) {}
-		virtual void stderrSignal (string msg) {}
-		virtual void stdinSignal (string msg) {}
-		virtual void resumeSessionsSignal (list<NXResumeData>) {}
-		virtual void noSessionsSignal (void) {}
-		virtual void serverCapacitySignal (void) {}
+    /*!
+     * Callbacks which are to be defined by the client code of
+     * NXClientLib objects. In the case of nxcl, that means the
+     * code in the class Nxcl in nxcl.cpp.
+     */
+    class NXClientLibExternalCallbacks
+    {
+        public:
+            NXClientLibExternalCallbacks () {}
+            virtual ~NXClientLibExternalCallbacks () {}
+            virtual void write (string msg) {}
+            virtual void write (int num, string msg) {}
+            virtual void error (string msg) {}
+            virtual void debug (string msg) {}
+            virtual void stdoutSignal (string msg) {}
+            virtual void stderrSignal (string msg) {}
+            virtual void stdinSignal (string msg) {}
+            virtual void resumeSessionsSignal (list<NXResumeData>) {}
+            virtual void noSessionsSignal (void) {}
+            virtual void serverCapacitySignal (void) {}
 
-	};
+    };
 
-	/*!
-	 * Have to derive NXClientLib from an abstract base class,
-	 * NXClientLibBase, so that NXClientLibCallbacks can
-	 * hold a pointer to an NXClientLib object.
-	 *
-	 * The functions that are declared in NXClientLibBase are the
-	 * ones that we want to call via this->parent in
-	 * NXClientLibCallbacks. They're the ones that are called from
-	 * within objects of other classes (such as this->session
-	 * (NXSession) or this->nxsshProcess (notQProcess).
-	 */
-	class NXClientLibBase 
-	{
-	public:
-		NXClientLibBase() {}
-		virtual ~NXClientLibBase() {}
+    /*!
+     * Have to derive NXClientLib from an abstract base class,
+     * NXClientLibBase, so that NXClientLibCallbacks can
+     * hold a pointer to an NXClientLib object.
+     *
+     * The functions that are declared in NXClientLibBase are the
+     * ones that we want to call via this->parent in
+     * NXClientLibCallbacks. They're the ones that are called from
+     * within objects of other classes (such as this->session
+     * (NXSession) or this->nxsshProcess (notQProcess).
+     */
+    class NXClientLibBase 
+    {
+        public:
+            NXClientLibBase() {}
+            virtual ~NXClientLibBase() {}
 
-		virtual void setIsFinished (bool status) {}
-		virtual void processParseStdout (void) {}
-		virtual void processParseStderr (void) {}
-		virtual void loginFailed (void) {}
-		virtual void readyproxy (void) {}
-		virtual void doneAuth (void) {}
+            virtual void setIsFinished (bool status) {}
+            virtual void processParseStdout (void) {}
+            virtual void processParseStderr (void) {}
+            virtual void loginFailed (void) {}
+            virtual void readyproxy (void) {}
+            virtual void doneAuth (void) {}
 
-		/*!
-		 * External callbacks pointer is held in NXClientLibBase
-		 * because NXClientLibProcessCallbacks::parent is of
-		 * type NXClientLibBase and in NXClientLibProcessCallbacks we
-		 * refer to this->parent->externalCallbacks->write()
-		 */
-		NXClientLibExternalCallbacks * externalCallbacks;
-	};
+            /*!
+             * External callbacks pointer is held in NXClientLibBase
+             * because NXClientLibProcessCallbacks::parent is of
+             * type NXClientLibBase and in NXClientLibProcessCallbacks we
+             * refer to this->parent->externalCallbacks->write()
+             */
+            NXClientLibExternalCallbacks * externalCallbacks;
+    };
 
-	/*!
-	 * Callbacks class. This derives from several other base
-	 * callbacks classes, defining the behaviour of the callbacks.
-	 */
-	class NXClientLibCallbacks : public notQProcessCallbacks, public NXSessionCallbacks
-	{
-	public:
-		NXClientLibCallbacks();
-		~NXClientLibCallbacks();
-		
-		/*!
-		 * The callback signals
-		 */
-		//@{
-		/*!
-		 * From notQProcess:
-		 */
-		//@{
-		void startedSignal (string name);
-		void errorSignal (int error);
-		void processFinishedSignal (string name);
-		void readyReadStandardOutputSignal (void);
-		void readyReadStandardErrorSignal (void);
-		//@}
-		/*!
-		 * From NXSession:
-		 */
-		//@{
-		void noSessionsSignal (void);
-		void loginFailedSignal (void);
-		void readyForProxySignal (void);
-		void authenticatedSignal (void);
-		void sessionsSignal (list<NXResumeData>);
-		//@}
-		//@}
+    /*!
+     * Callbacks class. This derives from several other base
+     * callbacks classes, defining the behaviour of the callbacks.
+     */
+    class NXClientLibCallbacks : public notQProcessCallbacks,
+        public NXSessionCallbacks
+    {
+        public:
+            NXClientLibCallbacks();
+            ~NXClientLibCallbacks();
 
-		/*!
-		 * Accessor function to set a pointer to the parent NXCLientLib object.
-		 */
-		void setParent (NXClientLibBase * p) { this->parent = p; }
-	private:
-		NXClientLibBase * parent;
-	};
+            /*!
+             * The callback signals
+             */
+            //@{
+            /*!
+             * From notQProcess:
+             */
+            //@{
+            void startedSignal (string name);
+            void errorSignal (int error);
+            void processFinishedSignal (string name);
+            void readyReadStandardOutputSignal (void);
+            void readyReadStandardErrorSignal (void);
+            //@}
+            /*!
+             * From NXSession:
+             */
+            //@{
+            void noSessionsSignal (void);
+            void loginFailedSignal (void);
+            void readyForProxySignal (void);
+            void authenticatedSignal (void);
+            void sessionsSignal (list<NXResumeData>);
+            //@}
+            //@}
 
-	class NXClientLib : public NXClientLibBase
-	{
-	public:
-		NXClientLib();
-		~NXClientLib();
+            /*!
+             * Accessor function to set a pointer to the parent NXCLientLib
+             * object.
+             */
+            void setParent (NXClientLibBase * p) { this->parent = p; }
+        private:
+            NXClientLibBase * parent;
+    };
 
-		/*!
-		 * Set up data and then call this->nxsshProcess.start().
-		 * 
-		 * \param publicKey is the path to the ssh public key
-		 * file to authenticate with.  Pass "supplied" to use
-		 * a new key, which you should then supply as the
-		 * parameter key.
-		 *
-		 * \param serverHost is the hostname of the NX server to
-		 * connect to
-		 *
-		 * \param encryption is whether to use an encrypted NX
-		 * session
-		 *
-		 * \param key ssh key to use for authentication of the
-		 * nx user if publicKey is "supplied".
-		 *
-		 * \param port TCP port to use for the ssh connection.
-		 */
-		void invokeNXSSH (string publicKey = "supplied", string serverHost = "",
-				  bool encryption = true, string key = "", int port = 22);
+    class NXClientLib : public NXClientLibBase
+    {
+        public:
+            NXClientLib();
+            ~NXClientLib();
 
-		/*!
-		 * Overloaded to give callback data on write.
-		 * 
-		 * Writes data to this->nxsshProcess stdin and also
-		 * out to the user via stdoutCallback
-		 */
-		void write (string data);
+            /*!
+             * Set up data and then call this->nxsshProcess.start().
+             * 
+             * \param publicKey is the path to the ssh public key
+             * file to authenticate with.  Pass "supplied" to use
+             * a new key, which you should then supply as the
+             * parameter key.
+             *
+             * \param serverHost is the hostname of the NX server to
+             * connect to
+             *
+             * \param encryption is whether to use an encrypted NX
+             * session
+             *
+             * \param key ssh key to use for authentication of the
+             * nx user if publicKey is "supplied".
+             *
+             * \param port TCP port to use for the ssh connection.
+             */
+            void invokeNXSSH (string publicKey = "supplied",
+                    string serverHost = "",
+                    bool encryption = true,
+                    string key = "",
+                    int port = 22);
 
-		/*!
-		 * Passes auth to this->session.setContinue()
-		 */
-		void allowSSHConnect (bool auth);
+            /*!
+             * Overloaded to give callback data on write.
+             * 
+             * Writes data to this->nxsshProcess stdin and also
+             * out to the user via stdoutCallback
+             */
+            void write (string data);
 
-		/*!
-		 * Set up data and then call this->nxproxyProcess.start()
-		 */
-		void invokeProxy (void);
+            /*!
+             * Passes auth to this->session.setContinue()
+             */
+            void allowSSHConnect (bool auth);
 
-		/*!
-		 * Parse a line of output from
-		 * this->nxsshProcess. This is called when the proxy
-		 * has started, or if NX authentication
-		 * failed. Otherwise, this->session.parseSSH() is
-		 * used.
-		 */
-		string parseSSH (string message);
+            /*!
+             * Set up data and then call this->nxproxyProcess.start()
+             */
+            void invokeProxy (void);
 
-		/*!
-		 * Read through the nx session file, and if we find a
-		 * message saying "Session: Terminating session at
-		 * 'some date'" we need to set isFinished to true.
-		 */
-		//void checkSession (void);
+            /*!
+             * Parse a line of output from
+             * this->nxsshProcess. This is called when the proxy
+             * has started, or if NX authentication
+             * failed. Otherwise, this->session.parseSSH() is
+             * used.
+             */
+            string parseSSH (string message);
 
-		/*!
-		 * Re-set the contents of this->session.sessionData
-		 * with the nth choice.
-		 *
-		 * \return true if the nth session is resumable, false
-		 * if not, or if there is no nth session.
-		 */
-		bool chooseResumable (int n); 
+            /*!
+             * Read through the nx session file, and if we find a
+             * message saying "Session: Terminating session at
+             * 'some date'" we need to set isFinished to true.
+             */
+            //void checkSession (void);
 
-		/*!
-		 * Re-set the contents of this->session.sessionData
-		 * with the nth choice such that a terminate session
-		 * message will be sent to the nxserver
-		 *
-		 * \return true if the nth session is terminatable, false
-		 * if not, or if there is no nth session.
-		 */
-		bool terminateSession (int n);
+            /*!
+             * Re-set the contents of this->session.sessionData
+             * with the nth choice.
+             *
+             * \return true if the nth session is resumable, false
+             * if not, or if there is no nth session.
+             */
+            bool chooseResumable (int n); 
 
-    void runSession (void);
+            /*!
+             * Re-set the contents of this->session.sessionData
+             * with the nth choice such that a terminate session
+             * message will be sent to the nxserver
+             *
+             * \return true if the nth session is terminatable, false
+             * if not, or if there is no nth session.
+             */
+            bool terminateSession (int n);
 
-		// public slots:
-		//@{
-		void doneAuth (void);
-		void loginFailed (void);
-		void finished (void) { dbgln ("Finishing up on signal"); this->isFinished = true; }
-		void readyproxy (void) { dbgln ("ready for nxproxy"); this->readyForProxy = true; }
-		void reset (void);
-		void processParseStdout (void);
-		void processParseStderr (void);
+            void runSession (void);
 
-		/*!
-		 * SSH requests confirmation to go ahead with
-		 * connecting (e.g. if you haven't connected to the
-		 * host before)
-		 */
-		void requestConfirmation (string msg);
-		//@}
+            // public slots:
+            //@{
+            void doneAuth (void);
+            void loginFailed (void);
+            
+            void finished (void)
+            {
+                dbgln ("Finishing up on signal"); this->isFinished = true;
+            }
 
-		// Accessors
-		//@{
-		/*!
-		 *  Set the username for NX to log in with
-		 */
-		void setUsername (string& user) {
-			this->nxuser = user;
-			this->session.setUsername (this->nxuser); 
-		}
-		/*!
-		 *  Set the password for NX to log in with
-		 */
-		void setPassword (string& pass) {
-			this->nxpass = pass;
-			this->session.setPassword (this->nxpass); 
-		}
+            void readyproxy (void)
+            {
+                dbgln ("ready for nxproxy"); this->readyForProxy = true;
+            }
 
-		void setResolution (int x, int y) { this->session.setResolution(x, y); }
-		void setDepth (int depth) { this->session.setDepth(depth); }
-		void setRender (bool render) { this->session.setRender(render); }
-		void setSessionData (NXSessionData *);
-		notQProcess* getNXSSHProcess (void) { return this->pNxsshProcess; }
-		notQProcess* getNXProxyProcess (void) { return this->pNxproxyProcess; }
-		bool getIsFinished (void) { return this->isFinished; }
-		bool getReadyForProxy (void) { return this->readyForProxy; }
-		NXSession* getSession (void) { return &this->session; }
-		void setIsFinished (bool status) { this->isFinished = status; }
-		void setExternalCallbacks (NXClientLibExternalCallbacks * cb) { this->externalCallbacks = cb; }
-		bool getSessionRunning (void) { return this->sessionRunning; }
-		//@}
+            void reset (void);
+            void processParseStdout (void);
+            void processParseStderr (void);
 
-	private:
-		/*!
-		 * Try a number of different paths to try to find the
-		 * program prog's full path.
-		 *
-		 * \param prog The program to find, likely to be nxssh
-		 * or nxproxy.
-		 *
-		 * \return The full path; e.g. /usr/bin/nxssh
-		 */
-		string getPath (string prog);
+            /*!
+             * SSH requests confirmation to go ahead with
+             * connecting (e.g. if you haven't connected to the
+             * host before)
+             */
+            void requestConfirmation (string msg);
+            //@}
 
-		/*!
-		 * Set true when the program is ready to end, e.g if
-		 * authentication failed, nxssh failed to start amoung
-		 * other reasons.
-		 */
-		bool isFinished;
-		/*!
-		 * Set true when nxssh is ready to launch the nxproxy process.
-		 */
-		bool readyForProxy;
-		/*!
-		 * Set true when the NX session is under way. This
-		 * means we can reduce the polling frequency right
-		 * down to a level which won't impact on power
-		 * consumption.
-		 */
-		bool sessionRunning;
-		/*!
-		 * Have we said we need to enter a password?
-		 */
-		bool password;
-		
-		// FIXME: I hold the actual data, and a pointer to the
-		// data here. I tried to get rid of the pointer, and
-		// modify main.cpp in ../nxcl and that didn't work
-		// properly - I'm not sure why. I suppose I could get
-		// rid of the objects here, and then call
-		// pNxsshProcess = new notQProcess; in the
-		// constructor...
-		/*!
-		 * The nxssh process object
-		 */
-		notQProcess nxsshProcess;
-		notQProcess* pNxsshProcess;
-		/*!
-		 * The nxproxy process object
-		 */
-		notQProcess nxproxyProcess;
-		notQProcess* pNxproxyProcess;
-		/*!
-		 * A callbacks object. This holds the various callback
-		 * methods. The callback methods are defined here, but
-		 * are callable from notQProcess etc.
-		 */
-		NXClientLibCallbacks callbacks;
-		/*!
-		 * A temporary file to hold the ssl key
-		 */
-		notQTemporaryFile *keyFile;
-		/*!
-		 * The NX Session object.
-		 */
-		NXSession session;
-		/*!
-		 * A structure holding information about the
-		 * connection to be made, such as server address, port
-		 * and id.
-		 */
-		ProxyData proxyData;
-		/*!
-		 * Username for the connection
-		 */
-		string nxuser;
-		/*!
-		 * Password for the connection
-		 */
-		string nxpass;
-	};
+            // Accessors
+            //@{
+            /*!
+             *  Set the username for NX to log in with
+             */
+            void setUsername (string& user)
+            {
+                this->nxuser = user;
+                this->session.setUsername (this->nxuser);
+            }
 
+            /*!
+             *  Set the password for NX to log in with
+             */
+            void setPassword (string& pass)
+            {
+                this->nxpass = pass;
+                this->session.setPassword (this->nxpass);
+            }
+
+            void setResolution (int x, int y)
+            {
+                this->session.setResolution(x, y);
+            }
+
+            void setDepth (int depth)
+            {
+                this->session.setDepth(depth);
+            }
+
+            void setRender (bool render)
+            {
+                this->session.setRender(render);
+            }
+
+            void setSessionData (NXSessionData *);
+
+            notQProcess* getNXSSHProcess (void)
+            {
+                return this->pNxsshProcess;
+            }
+
+            notQProcess* getNXProxyProcess (void)
+            {
+                return this->pNxproxyProcess;
+            }
+
+            bool getIsFinished (void)
+            {
+                return this->isFinished;
+            }
+
+            bool getReadyForProxy (void)
+            {
+                return this->readyForProxy;
+            }
+
+            NXSession* getSession (void)
+            {
+                return &this->session;
+            }
+
+            void setIsFinished (bool status)
+            {
+                this->isFinished = status;
+            }
+
+            void setExternalCallbacks (NXClientLibExternalCallbacks * cb)
+            {
+                this->externalCallbacks = cb;
+            }
+
+            bool getSessionRunning (void)
+            {
+                return this->sessionRunning;
+            }
+            //@}
+
+        private:
+            /*!
+             * Try a number of different paths to try to find the
+             * program prog's full path.
+             *
+             * \param prog The program to find, likely to be nxssh
+             * or nxproxy.
+             *
+             * \return The full path; e.g. /usr/bin/nxssh
+             */
+            string getPath (string prog);
+
+            /*!
+             * Set true when the program is ready to end, e.g if
+             * authentication failed, nxssh failed to start amoung
+             * other reasons.
+             */
+            bool isFinished;
+            /*!
+             * Set true when nxssh is ready to launch the nxproxy process.
+             */
+            bool readyForProxy;
+            /*!
+             * Set true when the NX session is under way. This
+             * means we can reduce the polling frequency right
+             * down to a level which won't impact on power
+             * consumption.
+             */
+            bool sessionRunning;
+            /*!
+             * Have we said we need to enter a password?
+             */
+            bool password;
+
+            // FIXME: I hold the actual data, and a pointer to the
+            // data here. I tried to get rid of the pointer, and
+            // modify main.cpp in ../nxcl and that didn't work
+            // properly - I'm not sure why. I suppose I could get
+            // rid of the objects here, and then call
+            // pNxsshProcess = new notQProcess; in the
+            // constructor...
+            /*!
+             * The nxssh process object
+             */
+            notQProcess nxsshProcess;
+            notQProcess* pNxsshProcess;
+            /*!
+             * The nxproxy process object
+             */
+            notQProcess nxproxyProcess;
+            notQProcess* pNxproxyProcess;
+            /*!
+             * A callbacks object. This holds the various callback
+             * methods. The callback methods are defined here, but
+             * are callable from notQProcess etc.
+             */
+            NXClientLibCallbacks callbacks;
+            /*!
+             * A temporary file to hold the ssl key
+             */
+            notQTemporaryFile *keyFile;
+            /*!
+             * The NX Session object.
+             */
+            NXSession session;
+            /*!
+             * A structure holding information about the
+             * connection to be made, such as server address, port
+             * and id.
+             */
+            ProxyData proxyData;
+            /*!
+             * Username for the connection
+             */
+            string nxuser;
+            /*!
+             * Password for the connection
+             */
+            string nxpass;
+    };
+
 } // namespace
 #endif

Modified: nxcl/lib/nxsession.cpp
===================================================================
--- nxcl/lib/nxsession.cpp	2008-01-07 09:44:37 UTC (rev 432)
+++ nxcl/lib/nxsession.cpp	2008-01-07 12:10:22 UTC (rev 433)
@@ -1,11 +1,13 @@
 /***************************************************************************
-                               nxsession.h
+                                nxsession.cpp
                              -------------------
     begin                : Wed 26th July 2006
     modifications        : July 2007
     copyright            : (C) 2006 by George Wright
     modifications        : (C) 2007 Embedded Software Foundry Ltd. (U.K.)
                          :     Author: Sebastian James
+                         : (C) 2008 Defuturo Ltd
+                         :     Author: George Wright
     email                : seb at esfnet.co.uk, gwright at kde.org
  ***************************************************************************/
 
@@ -17,37 +19,37 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
- 
-// Enumerated type defining the stages through which the client goes when connecting
-enum { HELLO_NXCLIENT, ACKNOWLEDGE, SHELL_MODE, AUTH_MODE, LOGIN, LIST_SESSIONS, PARSESESSIONS, STARTSESSION, FINISHED };
 
-/*
-	0 HELLO NXCLIENT
-	1 Acknowledgement from server
-	2 SET SHELL_MODE SHELL
-	3 SET AUTH_MODE PASSWORD
-	4 login
-	5 listsession
-	6 resumesession/startsession
-*/
+// Enumerated type defining the stages through which the client goes when
+// connecting
+enum { HELLO_NXCLIENT,
+    ACKNOWLEDGE,
+    SHELL_MODE,
+    AUTH_MODE,
+    LOGIN,
+    LIST_SESSIONS,
+    PARSESESSIONS,
+    STARTSESSION,
+    FINISHED };
 
 #define CLIENT_VERSION "3.0.0"
 
 #include <iostream>
+
+#include "notQt.h"
+#include "nxclientlib.h"
 #include "nxsession.h"
-#include "nxclientlib.h" // nxclientlib provides some signals used here.
-#include "notQt.h"
 
 using namespace std;
 using namespace nxcl;
 
-NXSession::NXSession()
+NXSession::NXSession() :
+    devurand_fd(-1),
+    stage(HELLO_NXCLIENT),
+    sessionDataSet(false),
+    nxUsername("nouser"),
+    nxPassword("nopass")
 {
-	this->devurand_fd = -1;
-	this->stage = 0;
-	this->sessionDataSet = false;
-	this->nxUsername = "nouser";
-	this->nxPassword = "nopass";
 }
 
 NXSession::~NXSession()
@@ -56,535 +58,670 @@
 
 void NXSession::resetSession()
 {
-	this->stage = 0;
-	this->sessionDataSet = false;
+    this->stage = 0;
+    this->sessionDataSet = false;
 }
 
 string NXSession::parseSSH(string message)
 {
-	dbgln ("NXSession::parseSSH called for: " + message);
+    dbgln ("NXSession::parseSSH called for: " + message);
 
-	int response = parseResponse (message);
-	string returnMessage;
-	
-	if (response == 211) {
-		if (doSSH == true) {
-			returnMessage = "yes";
-			doSSH = false;
-		} else
-			returnMessage = "no";
-	}
+    int response = parseResponse (message);
+    string returnMessage;
 
-	if (response == 204) { // Authentication failed
-		returnMessage = "204";
-	}
-	
-	if (response == 147) { // Server capacity reached
-		returnMessage = "147";
-		this->stage = FINISHED;
-	}
+    if (response == 211) {
+        if (doSSH == true) {
+            returnMessage = "yes";
+            doSSH = false;
+        } else
+            returnMessage = "no";
+    }
 
-	switch (this->stage) {
-		case HELLO_NXCLIENT:
-			dbgln ("HELLO_NXCLIENT stage");
-			if (message.find("HELLO NXSERVER - Version") != string::npos) {
-				this->callbacks->authenticatedSignal();
-				returnMessage = "hello NXCLIENT - Version ";
-				returnMessage.append(CLIENT_VERSION);
-				this->stage++;
-			}
-			break;
-		case ACKNOWLEDGE:
-			dbgln ("ACKNOWLEDGE stage");
-			if (response == 105)
-				this->stage++;
-			break;
-		case SHELL_MODE:
-			dbgln ("SHELL_MODE stage");
-			if (response == 105) {
-				returnMessage = "SET SHELL_MODE SHELL";
-				this->stage++;
-			}
-			break;
-		case AUTH_MODE:
-			dbgln ("AUTH_MODE stage");
-			if (response == 105) {
-				returnMessage = "SET AUTH_MODE PASSWORD";
-				this->stage++;
-			}
-			break;
-		case LOGIN:
-			dbgln ("LOGIN stage");
-			switch (response) {
-				case 105:
-					returnMessage = "login";
-					break;
-				case 101:
-					returnMessage = nxUsername;
-					break;
-				case 102:
-					returnMessage = nxPassword;
-					break;
-				case 103:
-					this->stage++;
-					break;
-				case 404:
-					this->callbacks->loginFailedSignal();
-				}
-			break;
-		case LIST_SESSIONS:
-			dbgln ("LIST_SESSIONS stage");
-			if (this->sessionData->terminate == true) {
-				// Wait for termination
-				dbgln ("Waiting for termination");
-				if (response == 900) {
-					stringstream termsession;
-					termsession << "NX> 900 Session id: " << this->sessionData->id << " terminated.";
-					if (message.find (termsession.str().c_str(), 0) == 0) {
-						// Session terminated.
-						this->sessionData->terminate = false;
-					} else {
-						usleep (10000);
-					}
-				}
+    if (response == 204) { // Authentication failed
+        returnMessage = "204";
+    }
 
-			} else if (response == 105) {
-				// Get a list of the available
-				// sessions on the server, for given
-				// user, with given status, and any
-				// type. Not sure if geometry is
-				// ignored or not.
-				stringstream ss;
-				// We want to list suspended or running sessions, with this command:
-				
-				dbgln ("this->resumeSessions.size() == " << this->resumeSessions.size());
-				
-				if (this->sessionData->sessionType == "shadow") {
-					// This is how to list shadow
-					// sessions. Run NoMachine's
-					// client and see
-					// ~/.nx/temp/(pid)/sshlog for
-					// connection details
-					ss << "listsession --type=\"shadow\"";
+    if (response == 147) { // Server capacity reached
+        returnMessage = "147";
+        this->stage = FINISHED;
+    }
 
-				} else {
+    switch (this->stage) {
+        case HELLO_NXCLIENT:
+            dbgln ("HELLO_NXCLIENT stage");
 
-					ss << "listsession --user=\"" << nxUsername
-					   << "\" --status=\"suspended,running\" --geometry=\"" 
-					   << this->sessionData->xRes << "x"
-					   << this->sessionData->yRes << "x" 
-					   << this->sessionData->depth 
-					   << (this->sessionData->render ? "+render" : "") 
-						// If you leave --type blank, you can re-connect to any sessions available.
-					   <<  "\" --type=\"" << this->sessionData->sessionType << "\"";
-				}
-				
-				returnMessage = ss.str();
-				this->stage++;
-			}
-			break;
-		case PARSESESSIONS:
-			dbgln ("PARSESESSIONS stage");
+            if (message.find("HELLO NXSERVER - Version") != string::npos) {
+                this->callbacks->authenticatedSignal();
+                returnMessage = "hello NXCLIENT - Version ";
+                returnMessage.append(CLIENT_VERSION);
+                this->stage++;
+            }
 
-			if ((this->sessionData->sessionType == "shadow" && response != 105) ||
-			    (this->sessionData->sessionType != "shadow" && response != 148)  ) {
+            break;
+        case ACKNOWLEDGE:
+            dbgln ("ACKNOWLEDGE stage");
 
-				dbgln ("Building resumeSessions: resumeSessions.push_back(message);");
-				this->resumeSessions.push_back(message);
+            if (response == 105)
+                this->stage++;
 
-			} else if ( (this->sessionData->sessionType == "shadow" && response == 105 ) || 
-				    (this->sessionData->sessionType != "shadow" && response == 148)  ) {
+            break;
+        case SHELL_MODE:
+            dbgln ("SHELL_MODE stage");
 
-				dbgln ("Parsing resumeSessions: parseResumeSessions(resumeSessions);");
-				parseResumeSessions (this->resumeSessions);
-				dbgln ("parseResumeSessions(resumeSessions) returned");
-				// Now, the problem we have here, is that when
-				// we return from the last 105 response, we
-				// don't then get another stdout message to
-				// act upon. So, we want to recurse back into parseSSH to get onto the STARTSESSION stage here:
-				returnMessage = this->parseSSH (message);
-			}
-			break;
+            if (response == 105) {
+                returnMessage = "SET SHELL_MODE SHELL";
+                this->stage++;
+            }
 
-		case STARTSESSION:
-			dbgln ("STARTSESSION stage");
-			if (response == 105 && sessionDataSet) {
+            break;
+        case AUTH_MODE:
+            dbgln ("AUTH_MODE stage");
 
-				dbgln ("response is 105 and sessionDataSet is true");;
-				int media = 0;
-				string fullscreen = "";
-				if (this->sessionData->media) {
-					media = 1;
-				}
-				if (this->sessionData->fullscreen) {
-					this->sessionData->geometry = "fullscreen";
-					fullscreen = "+fullscreen";
-				}
+            if (response == 105) {
+                returnMessage = "SET AUTH_MODE PASSWORD";
+                this->stage++;
+            }
 
-				if (this->sessionData->sessionType == "shadow" && this->sessionData->terminate == false) {
-					dbgln ("It's a shadow session!");
-					stringstream ss;
-					// These are the session parameters that NoMachine's client sends for resume
-					ss << "Attachsession "
-					   << "--link=\"" << this->sessionData->linkType << "\" "
-					   << "--backingstore=\"" << this->sessionData->backingstore << "\" "
-					   << "--encryption=\"" << this->sessionData->encryption << "\" "
-					   << "--cache=\"" << this->sessionData->cache << "M\" "
-					   << "--images=\"" << this->sessionData->images << "M\" "
-					   << "--shmem=\"1\" " // probably has been autodetected from my display
-					   << "--shpix=\"1\" " // probably has been autodetected from my display
-					   << "--strict=\"0\" " // probably has been autodetected from my display
-					   << "--composite=\"1\" " // probably has been autodetected from my display
-					   << "--media=\"" << media << "\" "
-					   << "--session=\"" << this->sessionData->sessionName << "\" "
-					   << "--type=\"" << this->sessionData->sessionType << "\" "
-					   << "--client=\"linux\" " // FIXME: This may be some other OS if you compile it on Sun, Windows, etc.
-					   << "--keyboard=\"" << this->sessionData->keyboard << "\" "
-					   << "--id=\"" << this->sessionData->id << "\" "
-					   << "--display=\"0\" " // This may be the key?
-					   << "--geometry=\"" << this->sessionData->geometry << "\" ";
+            break;
+        case LOGIN:
+            dbgln ("LOGIN stage");
 
-					/* These appear not to be necessary for the shadow connection, for one reason and another.
-					        // Not required:
-						"\" --cookie=\"" << generateCookie() <<
-						// optional:
-						"\" --kbtype=\"" << this->sessionData->kbtype <<
-						// optional:
-						"\" --nodelay=\"1" << 
-						// These are obviously not required
-						"\" --agent_server=\"" << this->sessionData->agentServer <<
-						"\" --agent_user=\"" << this->sessionData->agentUser <<
-						"\" --agent_password=\"" << this->sessionData->agentPass << "\"";
-					*/
+            switch (response) {
+                case 105:
+                    returnMessage = "login";
+                    break;
+                case 101:
+                    returnMessage = nxUsername;
+                    break;
+                case 102:
+                    returnMessage = nxPassword;
+                    break;
+                case 103:
+                    this->stage++;
+                    break;
+                case 404:
+                    this->callbacks->loginFailedSignal();
+            }
 
-					returnMessage = ss.str();
-					dbgln ("session parameter command: " + ss.str());
-					this->stage++;
+            break;
+        case LIST_SESSIONS:
+            dbgln ("LIST_SESSIONS stage");
 
-				} else if (this->sessionData->terminate == true) {
-					stringstream ss;
-					// These are the session parameters that NoMachine's client sends for resume
-					ss << "Terminate --sessionid=\"" << this->sessionData->id << "\"";
-					returnMessage = ss.str();
-					dbgln ("session parameter command: " + ss.str());
-					this->stage -= 2; // Back to listsessions after terminating a session.
-					// clear the list of sessions to resume
-					this->resumeSessions.clear();
-					this->runningSessions.clear();
+            if (this->sessionData->terminate == true) {
+                // Wait for termination
+                dbgln ("Waiting for termination");
 
-				} else if (this->sessionData->suspended) {
-					dbgln ("this->sessionData->suspended is true");
-					stringstream ss;
-					// These are the session parameters that NoMachine's client sends for resume
-					ss << "restoresession --id=\"" << this->sessionData->id <<
-						"\" --session=\"" << this->sessionData->sessionName <<
-						"\" --type=\"" << this->sessionData->sessionType <<
-						"\" --cache=\"" << this->sessionData->cache <<
-						"M\" --images=\"" << this->sessionData->images <<
-						"M\" --cookie=\"" << generateCookie() <<
-						"\" --link=\"" << this->sessionData->linkType <<
-						"\" --kbtype=\"" << this->sessionData->kbtype <<
-						"\" --nodelay=\"1\" --encryption=\"" << this->sessionData->encryption <<
-						"\" --backingstore=\"" << this->sessionData->backingstore <<
-						"\" --geometry=\"" << this->sessionData->geometry <<
-						"\" --media=\"" << media <<
-						"\" --agent_server=\"" << this->sessionData->agentServer <<
-						"\" --agent_user=\"" << this->sessionData->agentUser <<
-						"\" --agent_password=\"" << this->sessionData->agentPass << "\"";
-					returnMessage = ss.str();
-					dbgln ("session parameter command: " + ss.str());
-					this->stage++;
+                if (response == 900) {
+                    stringstream termsession;
 
-				} else { 
-					dbgln ("this->sessionData->suspended is false, and it's not a shadow session.");
-					stringstream ss;
-					ss << "startsession --session=\"" << this->sessionData->sessionName <<
-						"\" --type=\"" << this->sessionData->sessionType <<
-						"\" --cache=\"" << this->sessionData->cache <<
-						"M\" --images=\"" << this->sessionData->images <<
-						"M\" --cookie=\"" << generateCookie() <<
-						"\" --link=\"" << this->sessionData->linkType <<
-						"\" --render=\"" << (this->sessionData->render ? 1 : 0) <<
-						"\" --encryption=\"" << this->sessionData->encryption <<
-						"\" --backingstore=\"" << this->sessionData->backingstore <<
-						"\" --imagecompressionmethod=\"" << this->sessionData->imageCompressionMethod <<
-						"\" --geometry=\"" << this->sessionData->geometry << 
-						"\" --screeninfo=\"" << this->sessionData->xRes << "x" << this->sessionData->yRes << "x" << this->sessionData->depth << 
-						(this->sessionData->render ? "+render" : "") << fullscreen <<
-						"\" --keyboard=\"" << this->sessionData->keyboard <<
-						"\" --kbtype=\"" << this->sessionData->kbtype <<
-						"\" --media=\"" << media <<
-						"\" --agent_server=\"" << this->sessionData->agentServer <<
-						"\" --agent_user=\"" << this->sessionData->agentUser <<
-						"\" --agent_password=\"" << this->sessionData->agentPass << "\"";
-					ss << " --title=\"sebtest\""; // testing a window title
-					if (this->sessionData->sessionType == "unix-application") {
-						ss << " --application=\"" << this->sessionData->customCommand << "\"";
-						if (this->sessionData->virtualDesktop == true) {
-							ss << " --rootless=\"0\" --virtualdesktop=\"1\"";
-						} else {
-							ss << " --rootless=\"1\" --virtualdesktop=\"0\"";
-						}
+                    termsession << "NX> 900 Session id: "
+                        << this->sessionData->id
+                        << " terminated.";
 
-					} else if (this->sessionData->sessionType == "unix-console") {
-						if (this->sessionData->virtualDesktop == true) {
-							ss << " --rootless=\"0\" --virtualdesktop=\"1\"";
-						} else {
-							ss << " --rootless=\"1\" --virtualdesktop=\"0\"";
-						}
+                    if (message.find (termsession.str().c_str(), 0) == 0) {
+                        // Session terminated.
+                        this->sessionData->terminate = false;
+                    } else {
+                        usleep (10000);
+                    }
+                }
 
-					} else if (this->sessionData->sessionType == "unix-default") {
-						// ignore this - does anyone use it?
-					}
-					returnMessage = ss.str();
-					dbgln ("session parameter command: " + ss.str());
-					this->stage++;
-				}
-			} else {
-				dbgln ("either response is not 105 or sessionDataSet is false.");;				
-			}
-			break;
+            } else if (response == 105) {
+                // Get a list of the available sessions on the server, for
+                // given user, with given status, and any type. Not sure if
+                // geometry is ignored or not.
+                stringstream ss;
 
-		case FINISHED:
-			dbgln ("FINISHED stage. Response is " << response 
-			       << ". That should mean that session set up is complete.");
-			this->callbacks->readyForProxySignal();
-	}
+                // We want to list suspended or running sessions, with this
+                // command:
+                dbgln ("this->resumeSessions.size() == "
+                        << this->resumeSessions.size());
 
-	dbgln ("NXSession::parseSSH, about to return a message: " + returnMessage);
-	if (!returnMessage.empty()) {
-		returnMessage.append("\n");
-		return returnMessage;
-	} else
-		return "";
+                if (this->sessionData->sessionType == "shadow") {
+                    // This is how to list shadow sessions. Run NoMachine's
+                    // client and see ~/.nx/temp/(pid)/sshlog for connection
+                    // details
+                    ss << "listsession --type=\"shadow\"";
+
+                } else {
+
+                    ss << "listsession --user=\"" << nxUsername
+                        << "\" --status=\"suspended,running\" --geometry=\""
+                        << this->sessionData->xRes << "x"
+                        << this->sessionData->yRes << "x"
+                        << this->sessionData->depth
+                        << (this->sessionData->render ? "+render" : "")
+
+                        // If you leave --type blank, you can re-connect to any
+                        // sessions available.
+                        << "\" --type=\"" << this->sessionData->sessionType
+                        << "\"";
+                }
+
+                returnMessage = ss.str();
+                this->stage++;
+            }
+            break;
+        case PARSESESSIONS:
+            dbgln ("PARSESESSIONS stage");
+
+            if ((this->sessionData->sessionType == "shadow" &&
+                        response != 105) ||
+                    (this->sessionData->sessionType != "shadow" &&
+                        response != 148)  ) {
+
+                dbgln ("Building resumeSessions:"
+                        << " resumeSessions.push_back(message);");
+
+                this->resumeSessions.push_back(message);
+
+            } else if ((this->sessionData->sessionType == "shadow" &&
+                        response == 105)
+                    || (this->sessionData->sessionType != "shadow" &&
+                        response == 148)) {
+
+                dbgln ("Parsing resumeSessions:"
+                        << " parseResumeSessions(resumeSessions);");
+
+                parseResumeSessions (this->resumeSessions);
+
+                dbgln ("parseResumeSessions(resumeSessions) returned");
+
+                // Now, the problem we have here, is that when
+                // we return from the last 105 response, we
+                // don't then get another stdout message to
+                // act upon. So, we want to recurse back into
+                // parseSSH to get onto the STARTSESSION stage here:
+                returnMessage = this->parseSSH (message);
+            }
+            break;
+
+        case STARTSESSION:
+            dbgln ("STARTSESSION stage");
+            if (response == 105 && sessionDataSet) {
+
+                dbgln ("response is 105 and sessionDataSet is true");;
+                int media = 0;
+                string fullscreen = "";
+                if (this->sessionData->media) {
+                    media = 1;
+                }
+
+                if (this->sessionData->fullscreen) {
+                    this->sessionData->geometry = "fullscreen";
+                    fullscreen = "+fullscreen";
+                }
+
+                if (this->sessionData->sessionType == "shadow" &&
+                        this->sessionData->terminate == false) {
+
+                    dbgln ("It's a shadow session!");
+                    stringstream ss;
+
+                    // These are the session parameters that NoMachine's client
+                    // sends for resume
+
+                    ss << "attachsession "
+                        << "--link=\"" << this->sessionData->linkType << "\" "
+                        << "--backingstore=\""
+                            << this->sessionData->backingstore << "\" "
+                        << "--encryption=\"" << this->sessionData->encryption
+                            << "\" "
+                        << "--cache=\"" << this->sessionData->cache << "M\" "
+                        << "--images=\"" << this->sessionData->images << "M\" "
+                        // probably has been autodetected from my display
+                        << "--shmem=\"1\" "
+                        // probably has been autodetected from my display
+                        << "--shpix=\"1\" "
+                        // probably has been autodetected from my display
+                        << "--strict=\"0\" "
+                        // probably has been autodetected from my display
+                        << "--composite=\"1\" "
+                        << "--media=\"" << media << "\" "
+                        << "--session=\"" << this->sessionData->sessionName
+                            << "\" "
+                        << "--type=\"" << this->sessionData->sessionType
+                            << "\" "
+                        // FIXME: This may be some other OS if you compile it on
+                        // Sun, Windows, etc.
+                        << "--client=\"linux\" "
+                        << "--keyboard=\"" << this->sessionData->keyboard
+                            << "\" "
+                        << "--id=\"" << this->sessionData->id << "\" "
+                        // This may be the key?
+                        << "--display=\"0\" "
+                        << "--geometry=\"" << this->sessionData->geometry
+                            << "\" ";
+
+                    returnMessage = ss.str();
+
+                    dbgln ("session parameter command: " + ss.str());
+
+                    this->stage++;
+
+                } else if (this->sessionData->terminate == true) {
+
+                    stringstream ss;
+
+                    // These are the session parameters that NoMachine's client
+                    // sends for resume
+                    ss << "Terminate --sessionid=\"" << this->sessionData->id
+                        << "\"";
+
+                    returnMessage = ss.str();
+
+                    dbgln ("session parameter command: " + ss.str());
+
+                    // Back to listsessions after terminating a session.
+                    this->stage -= 2;
+
+                    // Clear the list of sessions to resume
+                    this->resumeSessions.clear();
+                    this->runningSessions.clear();
+
+                } else if (this->sessionData->suspended) {
+
+                    dbgln ("this->sessionData->suspended is true");
+
+                    stringstream ss;
+
+                    // These are the session parameters that NoMachine's client
+                    // sends for resume
+                    ss << "restoresession --id=\"" << this->sessionData->id <<
+                        "\" --session=\"" << this->sessionData->sessionName <<
+                        "\" --type=\"" << this->sessionData->sessionType <<
+                        "\" --cache=\"" << this->sessionData->cache <<
+                        "M\" --images=\"" << this->sessionData->images <<
+                        "M\" --cookie=\"" << generateCookie() <<
+                        "\" --link=\"" << this->sessionData->linkType <<
+                        "\" --kbtype=\"" << this->sessionData->kbtype <<
+                        "\" --nodelay=\"1\" --encryption=\""
+                            << this->sessionData->encryption <<
+                        "\" --backingstore=\""
+                            << this->sessionData->backingstore <<
+                        "\" --geometry=\"" << this->sessionData->geometry <<
+                        "\" --media=\"" << media <<
+                        "\" --agent_server=\""
+                            << this->sessionData->agentServer <<
+                        "\" --agent_user=\"" << this->sessionData->agentUser <<
+                        "\" --agent_password=\""
+                            << this->sessionData->agentPass << "\"";
+
+                    returnMessage = ss.str();
+
+                    dbgln ("session parameter command: " + ss.str());
+
+                    this->stage++;
+
+                } else {
+
+                    dbgln ("this->sessionData->suspended is false, and it's" <<
+                            " not a shadow session.");
+
+                    stringstream ss;
+
+                    ss << "startsession --session=\""
+                            << this->sessionData->sessionName
+
+                        << "\" --type=\"" << this->sessionData->sessionType
+                        << "\" --cache=\"" << this->sessionData->cache
+                        << "M\" --images=\"" << this->sessionData->images
+                        << "M\" --cookie=\"" << generateCookie()
+                        << "\" --link=\"" << this->sessionData->linkType
+                        << "\" --render=\""
+                            << (this->sessionData->render ? 1 : 0)
+
+                        << "\" --encryption=\""
+                            << this->sessionData->encryption
+
+                        << "\" --backingstore=\""
+                            << this->sessionData->backingstore
+
+                        << "\" --imagecompressionmethod=\""
+                        << this->sessionData->imageCompressionMethod
+                        << "\" --geometry=\"" << this->sessionData->geometry
+                        << "\" --screeninfo=\"" << this->sessionData->xRes
+                        << "x" << this->sessionData->yRes << "x"
+                        << this->sessionData->depth
+                        << (this->sessionData->render ? "+render" : "")
+                        << fullscreen << "\" --keyboard=\""
+                            << this->sessionData->keyboard
+
+                        << "\" --kbtype=\"" << this->sessionData->kbtype
+                        << "\" --media=\"" << media
+                        << "\" --agent_server=\""
+                            << this->sessionData->agentServer
+
+                        << "\" --agent_user=\""
+                            << this->sessionData->agentUser
+
+                        << "\" --agent_password=\""
+                            << this->sessionData->agentPass
+
+                        << "\"";
+
+                    ss << " --title=\"sebtest\""; // testing a window title
+
+                    if (this->sessionData->sessionType == "unix-application") {
+                        ss << " --application=\"" 
+                            << this->sessionData->customCommand << "\"";
+
+                        if (this->sessionData->virtualDesktop == true) {
+                            ss << " --rootless=\"0\" --virtualdesktop=\"1\"";
+                        } else {
+                            ss << " --rootless=\"1\" --virtualdesktop=\"0\"";
+                        }
+
+                    } else if
+                        (this->sessionData->sessionType == "unix-console") {
+
+                        if (this->sessionData->virtualDesktop == true) {
+                            ss << " --rootless=\"0\" --virtualdesktop=\"1\"";
+                        } else {
+                            ss << " --rootless=\"1\" --virtualdesktop=\"0\"";
+                        }
+
+                    } else if
+                        (this->sessionData->sessionType == "unix-default") {
+                        // ignore this - does anyone use it?
+                    }
+
+                    returnMessage = ss.str();
+
+                    dbgln ("session parameter command: " + ss.str());
+
+                    this->stage++;
+                }
+            } else {
+                dbgln ("either response is not 105 or sessionDataSet is"
+                        << " false.");
+            }
+            break;
+
+        case FINISHED:
+            dbgln ("FINISHED stage. Response is " << response
+                    << ". That should mean that session set up is complete.");
+            this->callbacks->readyForProxySignal();
+    }
+
+    dbgln ("NXSession::parseSSH, about to return a message: " + returnMessage);
+
+    if (!returnMessage.empty()) {
+        returnMessage.append("\n");
+        return returnMessage;
+    } else
+        return "";
 }
 
 void NXSession::setSessionData (NXSessionData *sd)
 {
-	this->sessionData = sd;
+    this->sessionData = sd;
 }
 
 int NXSession::parseResponse(string message)
 {
-	string::size_type idx1, idx2;
-	int response;
-	dbgln ("NXSession::parseResponse called for message:" << message);
+    string::size_type idx1, idx2;
 
-	if ((idx1 = message.find ("notQProcess error", 0)) != string::npos) {
-		dbgln ("Found notQProcess error");
-		// This means a process crashed, we're going to return a number >100000 to indicate this.
-		if ( ((idx2 = message.find ("crashed", 0)) != string::npos) && idx2 > idx1) {
-			stringstream ss;
-			ss << message.substr((idx1+19), idx2-1-(idx1+19));
-			ss >> response; // this is the pid that crashed
-			response += 100000; // add 100000 and return this.
-			return response;
-		} else {
-			dbgln ("Uh oh, didn't find \"crashed\"");
-		}
-	}
+    int response;
 
-	// Find out the server response number
-	// This will only be present in strings which contain "NX>"
-	if (message.find("NX>") != string::npos && message.find("NX>") == 0) {
-		idx1 = message.find("NX>") + 4;
-		if ((idx2 = message.find(" ", idx1)) == string::npos) {
-			if ((idx2 = message.find("\n", idx1)) == string::npos) {
-				//dbgln ("NXSession::parseResponse: warning: reading up to the end of message.");
-				idx2 = message.size();
-			}
-		}
-		if (idx2>idx1) {
-			stringstream ss;
-			ss << message.substr(idx1, idx2-idx1);
-			ss >> response;
-		} else {
-			response = 0;
-		}
-	} else {
-		response = 0;
-	}
+    dbgln ("NXSession::parseResponse called for message:" << message);
 
-	dbgln ("NXSession::parseResponse() returning " << response);
-	return response;
+    if ((idx1 = message.find ("notQProcess error", 0)) != string::npos) {
+
+        dbgln ("Found notQProcess error");
+
+        // This means a process crashed, we're going to return a number >100000
+        // to indicate this.
+        if ( ((idx2 = message.find ("crashed", 0)) != string::npos) && 
+                idx2 > idx1) {
+
+            stringstream ss;
+            ss << message.substr((idx1+19), idx2-1-(idx1+19));
+
+            // This is the pid that crashed
+            ss >> response;
+
+            // Add 100000 and return this
+            response += 100000;
+
+            return response;
+        } else {
+            dbgln ("Uh oh, didn't find \"crashed\"");
+        }
+    }
+
+    // Find out the server response number
+    // This will only be present in strings which contain "NX>"
+    if (message.find("NX>") != string::npos && message.find("NX>") == 0) {
+        idx1 = message.find("NX>") + 4;
+
+        if ((idx2 = message.find(" ", idx1)) == string::npos) {
+            if ((idx2 = message.find("\n", idx1)) == string::npos) {
+                idx2 = message.size();
+            }
+        }
+
+        if (idx2>idx1) {
+            stringstream ss;
+            ss << message.substr(idx1, idx2-idx1);
+            ss >> response;
+        } else {
+            response = 0;
+        }
+
+    } else {
+        response = 0;
+    }
+
+    dbgln ("NXSession::parseResponse() returning " << response);
+    return response;
 }
 
 void NXSession::parseResumeSessions(list<string> rawdata)
 {
-	// Was: QStringList sessions, and got rawdata appended to it?
-	list<string> sessions;
-	list<string>::iterator iter, at;
+    // Was: QStringList sessions, and got rawdata appended to it?
+    list<string> sessions;
+    list<string>::iterator iter, at;
 
-	dbgln ("NXSession::parseResumeSessions called.");
+    dbgln ("NXSession::parseResumeSessions called.");
 
-	for (iter = rawdata.begin(); iter != rawdata.end(); iter++) {
-		if (((*iter).find("-------") != string::npos) && !(*iter).empty()) {
-			at = iter;
-		}
-	}
+    for (iter = rawdata.begin(); iter != rawdata.end(); iter++) {
+        if (((*iter).find("-------") != string::npos) && !(*iter).empty()) {
+            at = iter;
+        }
+    }
 
-	for (iter = ++at; iter != rawdata.end(); iter++) {
-		if ((!(*iter).find("NX> 148") != string::npos) && !(*iter).empty()) {
-			sessions.push_back(*iter);
-		}
-	}
+    for (iter = ++at; iter != rawdata.end(); iter++) {
+        if ((!(*iter).find("NX> 148") != string::npos) && !(*iter).empty()) {
+            sessions.push_back(*iter);
+        }
+    }
 
-	list < vector<string> > rawsessions;
-	list < vector<string> >::iterator rsIter;
+    list < vector<string> > rawsessions;
+    list < vector<string> >::iterator rsIter;
 
-	// Clean up each string in sessions[i], then push back
-	// sessions[i] onto rawsessions., except that means
-	// rawsessions is then just a list<string>...
-	vector<string> session;
-	vector<string>::iterator seshIter;
-	for (iter = sessions.begin(); iter != sessions.end(); iter++) {
-		session.clear();
-		/* simplify one line of list<string> sessions */
-		(*iter) = notQtUtilities::simplify (*iter); 
-		/* split one line of list<string> sessions into a vector<string> */
-		notQtUtilities::splitString (*iter, ' ', session); 
-		/* Add that to rawsessions */
-		rawsessions.push_back(session);
-	}
+    // Clean up each string in sessions[i], then push back
+    // sessions[i] onto rawsessions., except that means
+    // rawsessions is then just a list<string>...
+    vector<string> session;
+    vector<string>::iterator seshIter;
 
-	NXResumeData resData;
-	
-	for (rsIter = rawsessions.begin(); rsIter != rawsessions.end(); rsIter++) {
-		stringstream ss1, ss2;
-		int tmp;
-		dbgln ("*rsIter.size() == " << (*rsIter).size());
-		ss1 << (*rsIter)[0];
-		ss1 >> tmp;
-		resData.display = tmp;
-		dbgln ("resData.display = " << resData.display);
-		resData.sessionType = (*rsIter)[1];
-		dbgln ("resData.sessionType = " << resData.sessionType);
-		resData.sessionID = (*rsIter)[2];
-		dbgln ("resData.sessionID = " << resData.sessionID);
-		resData.options = (*rsIter)[3];
-		dbgln ("resData.options = " << resData.options);
-		ss2 << (*rsIter)[4];
-		ss2 >> tmp;
-		resData.depth = tmp;
-		dbgln ("resData.depth = " << resData.depth);
-		resData.screen = (*rsIter)[5];
-		dbgln ("resData.screen = " << resData.screen);
-		resData.available = (*rsIter)[6];
-		dbgln ("resData.available = " << resData.available);
-		resData.sessionName = (*rsIter)[7];
-		dbgln ("resData.sessionName = " << resData.sessionName);
-		this->runningSessions.push_back(resData);
-	}
+    for (iter = sessions.begin(); iter != sessions.end(); iter++) {
+        session.clear();
 
-	if (this->runningSessions.size() != 0) {
-		this->suspendedSessions = true;
-		dbgln ("NXSession::parseResumeSessions(): Calling sessionsSignal.");
-		// runningSessions is a list of NXResumeData
-		this->callbacks->sessionsSignal (this->runningSessions);
-	} else {
-		dbgln ("NXSession::parseResumeSessions(): Calling this->callbacks->noSessionsSignal()");
-		// In case we previously had one resumable session,
-		// which the user terminated, then we listsessions and
-		// got no resumable sessions, we need to make sure
-		// startsession is called, not restoresession. hence
-		// set sessionData->suspended to false.
-		this->sessionData->suspended = false;
-		this->callbacks->noSessionsSignal();
-	}
-	
-	dbgln ("Increment stage");
-	this->stage++;
-	dbgln ("NXSession::parseResumeSessions() returning.");
+        // Simplify one line of list<string> sessions
+        (*iter) = notQtUtilities::simplify (*iter); 
+
+        // Split one line of list<string> sessions into a vector<string>
+        notQtUtilities::splitString (*iter, ' ', session); 
+
+        // Add that to rawsessions
+        rawsessions.push_back(session);
+    }
+
+    NXResumeData resData;
+
+    for (rsIter = rawsessions.begin(); rsIter != rawsessions.end(); rsIter++) {
+        stringstream ss1, ss2;
+        int tmp;
+
+        dbgln ("*rsIter.size() == " << (*rsIter).size());
+        ss1 << (*rsIter)[0];
+        ss1 >> tmp;
+
+        resData.display = tmp;
+
+        dbgln ("resData.display = " << resData.display);
+        resData.sessionType = (*rsIter)[1];
+
+        dbgln ("resData.sessionType = " << resData.sessionType);
+        resData.sessionID = (*rsIter)[2];
+
+        dbgln ("resData.sessionID = " << resData.sessionID);
+        resData.options = (*rsIter)[3];
+
+        dbgln ("resData.options = " << resData.options);
+        ss2 << (*rsIter)[4];
+        ss2 >> tmp;
+
+        resData.depth = tmp;
+
+        dbgln ("resData.depth = " << resData.depth);
+        resData.screen = (*rsIter)[5];
+
+        dbgln ("resData.screen = " << resData.screen);
+        resData.available = (*rsIter)[6];
+
+        dbgln ("resData.available = " << resData.available);
+        resData.sessionName = (*rsIter)[7];
+
+        dbgln ("resData.sessionName = " << resData.sessionName);
+        this->runningSessions.push_back(resData);
+    }
+
+    if (this->runningSessions.size() != 0) {
+        this->suspendedSessions = true;
+
+        dbgln ("NXSession::parseResumeSessions(): Calling sessionsSignal.");
+
+        // runningSessions is a list of NXResumeData
+        this->callbacks->sessionsSignal (this->runningSessions);
+    } else {
+        dbgln ("NXSession::parseResumeSessions(): Calling"
+                << " this->callbacks->noSessionsSignal()");
+
+        // In case we previously had one resumable session,
+        // which the user terminated, then we listsessions and
+        // got no resumable sessions, we need to make sure
+        // startsession is called, not restoresession. hence
+        // set sessionData->suspended to false.
+        this->sessionData->suspended = false;
+        this->callbacks->noSessionsSignal();
+    }
+
+    dbgln ("Increment stage");
+    this->stage++;
+    dbgln ("NXSession::parseResumeSessions() returning.");
 }
 
 void NXSession::wipeSessions()
 {
-	while (!this->runningSessions.empty()) {
-		this->runningSessions.pop_front();
-	}
+    while (!this->runningSessions.empty()) {
+        this->runningSessions.pop_front();
+    }
 }
 
 string NXSession::generateCookie()
 {
-	unsigned long long int int1, int2;
-	stringstream cookie;
-	
-	devurand_fd = open("/dev/urandom", O_RDONLY);
+    unsigned long long int int1, int2;
+    stringstream cookie;
 
-	fillRand((unsigned char*)&int1, sizeof(int1));
-	fillRand((unsigned char*)&int2, sizeof(int2));
-	cookie << int1 << int2;
-	return cookie.str();
+    devurand_fd = open("/dev/urandom", O_RDONLY);
+
+    fillRand((unsigned char*)&int1, sizeof(int1));
+    fillRand((unsigned char*)&int2, sizeof(int2));
+    cookie << int1 << int2;
+    return cookie.str();
 }
 
-void NXSession::fillRand(unsigned char *buf, size_t nbytes) {
-	ssize_t r;
-	unsigned char *where = buf;
+void NXSession::fillRand(unsigned char *buf, size_t nbytes)
+{
+    ssize_t r;
+    unsigned char *where = buf;
 
-	while (nbytes) {
-		while ((r = read(devurand_fd, where, nbytes)) == -1)
-		where  += r;
-		nbytes -= r;
-	}
+    while (nbytes) {
+        while ((r = read(devurand_fd, where, nbytes)) == -1)
+            where  += r;
+        nbytes -= r;
+    }
 }
 
 bool NXSession::chooseResumable (int n)
 {
-	dbgln ("NXSession::chooseResumable called.");
-	if (this->runningSessions.size() <= static_cast<unsigned int>(n)) {
-		// No nth session to resume.
-		dbgln ("No nth session to resume, return false.");
-		return false;
-	}
+    dbgln ("NXSession::chooseResumable called.");
+    if (this->runningSessions.size() <= static_cast<unsigned int>(n)) {
 
-	this->sessionDataSet = false; // Set to false while we change
-				      // contents of sessionData
+        // No nth session to resume.
+        dbgln ("No nth session to resume, return false.");
+        return false;
+    }
 
-	list<NXResumeData>::iterator it = this->runningSessions.begin();
-	for (int i = 0; i<n; i++) { it++; }
+    // Set to false while we change contents of sessionData
+    this->sessionDataSet = false;
 
-	// If it's a shadow session, we don't want to replace "shadow" with X11-local
-	if (this->sessionData->sessionType != "shadow") {
-		this->sessionData->sessionType = (*it).sessionType;
-	}
-	this->sessionData->display = (*it).display;
-	this->sessionData->sessionName = (*it).sessionName;
-	this->sessionData->id = (*it).sessionID;
-	stringstream geom;	
-	geom << (*it).screen << "x" << (*it).display; // plus render, if necessary.
-	// FIXME: This not yet quite complete.
-	this->sessionData->geometry = geom.str(); // with depth in there too?
-	this->sessionData->suspended=true;
+    list<NXResumeData>::iterator it = this->runningSessions.begin();
+    for (int i = 0; i<n; i++) { it++; }
 
-	this->sessionDataSet = true;
+    // If it's a shadow session, we don't want to replace "shadow" with
+    // X11-local
+    if (this->sessionData->sessionType != "shadow") {
+        this->sessionData->sessionType = (*it).sessionType;
+    }
 
-	dbgln ("NXSession::chooseResumable returning true.");
-	return true;
+    this->sessionData->display = (*it).display;
+    this->sessionData->sessionName = (*it).sessionName;
+    this->sessionData->id = (*it).sessionID;
+
+    stringstream geom;	
+
+    // Plus render, if necessary
+    geom << (*it).screen << "x" << (*it).display;
+
+    // FIXME: This not yet quite complete.
+    // With depth in there too?
+    this->sessionData->geometry = geom.str();
+    this->sessionData->suspended=true;
+
+    this->sessionDataSet = true;
+
+    dbgln ("NXSession::chooseResumable returning true.");
+    return true;
 }
 
 bool NXSession::terminateSession (int n)
 {
-	dbgln ("NXSession::terminateSession called.");
-	if (this->runningSessions.size() <= static_cast<unsigned int>(n)) {
-		// No nth session to resume.
-		dbgln ("No nth session to terminate, return false.");
-		return false;
-	}
+    dbgln ("NXSession::terminateSession called.");
+    if (this->runningSessions.size() <= static_cast<unsigned int>(n)) {
 
-	this->sessionDataSet = false; // Set to false while we change
-				      // contents of sessionData
+        // No nth session to terminate
+        dbgln ("No nth session to terminate, return false.");
+        return false;
+    }
 
-	list<NXResumeData>::iterator it = this->runningSessions.begin();
-	for (int i = 0; i<n; i++) { it++; }
+    // Set to false while we change the contents of sessionData
+    this->sessionDataSet = false;
 
-	this->sessionData->terminate = true;
-	this->sessionData->display = (*it).display;
-	this->sessionData->sessionName = (*it).sessionName;
-	this->sessionData->id = (*it).sessionID;
-	this->sessionData->suspended=true;
+    list<NXResumeData>::iterator it = this->runningSessions.begin();
+    for (int i = 0; i<n; i++) { it++; }
 
-	this->sessionDataSet = true;
+    this->sessionData->terminate = true;
+    this->sessionData->display = (*it).display;
+    this->sessionData->sessionName = (*it).sessionName;
+    this->sessionData->id = (*it).sessionID;
+    this->sessionData->suspended=true;
 
-	return true;
+    this->sessionDataSet = true;
+
+    return true;
 }
 

Modified: nxcl/lib/nxsession.h
===================================================================
--- nxcl/lib/nxsession.h	2008-01-07 09:44:37 UTC (rev 432)
+++ nxcl/lib/nxsession.h	2008-01-07 12:10:22 UTC (rev 433)
@@ -1,4 +1,3 @@
-/* -*-c++-*- */
 /***************************************************************************
                                  nxsession.h
                              -------------------
@@ -7,6 +6,8 @@
     copyright            : (C) 2006 by George Wright
     modifications        : (C) 2007 Embedded Software Foundry Ltd. (U.K.)
                          :     Author: Sebastian James
+                         : (C) 2008 Defuturo Ltd
+                         :     Author: George Wright
     email                : seb at esfnet.co.uk, gwright at kde.org
  ***************************************************************************/
 
@@ -31,124 +32,155 @@
 
 namespace nxcl {
 
-	/*!
-	 * Virtual Callback class. These callbacks are called based on
-	 * the output which we get from the nxssh process.
-	 */
-	class NXSessionCallbacks
-	{
-	public:
-		NXSessionCallbacks() {}
-		virtual ~NXSessionCallbacks() {}
-		virtual void noSessionsSignal (void) {}
-		virtual void loginFailedSignal (void) {}
-		virtual void readyForProxySignal (void) {}
-		/*!
-		 * Emitted when the initial public key authentication
-		 * is successful 
-		 */
-		virtual void authenticatedSignal (void) {}
-		virtual void sessionsSignal (list<NXResumeData>) {}
-	};
+    /*!
+     * Virtual Callback class. These callbacks are called based on
+     * the output which we get from the nxssh process.
+     */
+    class NXSessionCallbacks
+    {
+        public:
+            NXSessionCallbacks() {}
+            virtual ~NXSessionCallbacks() {}
+            virtual void noSessionsSignal (void) {}
+            virtual void loginFailedSignal (void) {}
+            virtual void readyForProxySignal (void) {}
+            /*!
+             * Emitted when the initial public key authentication
+             * is successful 
+             */
+            virtual void authenticatedSignal (void) {}
+            virtual void sessionsSignal (list<NXResumeData>) {}
+    };
 
-	/*!
-	 * This class is used to parse the output from the nxssh
-	 * session to the server.
-	 */
-	class NXSession
-	{
-	public:
-		NXSession();
-		~NXSession();
-		
-		string parseSSH (string);
-		int parseResponse (string);
-		void parseResumeSessions (list<string>);
-		void resetSession (void);
-		void wipeSessions (void);
-		bool chooseResumable (int n);
-		bool terminateSession (int n);
-		string generateCookie (void);
-    void runSession (void) { sessionDataSet = true; }
+    /*!
+     * This class is used to parse the output from the nxssh
+     * session to the server.
+     */
+    class NXSession
+    {
+        public:
+            NXSession();
+            ~NXSession();
 
-		/*!
-		 * Accessors
-		 */
-		//@{
-		void setUsername (string& user) { nxUsername = user; }
-		void setPassword (string& pass) { nxPassword = pass; }
-		void setResolution (int x, int y) {
-			if (this->sessionDataSet) {
-				this->sessionData->xRes = x;
-				this->sessionData->yRes = y;
-			}
-		}
-		void setDepth (int d) { if (this->sessionDataSet) {this->sessionData->depth = d;} }
-		void setRender (bool isRender) { if (this->sessionDataSet) {this->sessionData->render = isRender;} }
-		void setEncryption (bool enc) { if (this->sessionDataSet) {this->sessionData->encryption = enc;} }
+            string parseSSH (string);
+            int parseResponse (string);
+            void parseResumeSessions (list<string>);
+            void resetSession (void);
+            void wipeSessions (void);
+            bool chooseResumable (int n);
+            bool terminateSession (int n);
+            string generateCookie (void);
+            void runSession (void) { sessionDataSet = true; }
 
-		void setContinue (bool allow) { doSSH = allow; }
-		void setSessionData (NXSessionData*);
-		bool getSessionDataSet (void) { return this->sessionDataSet; }
-		void setCallbacks (NXSessionCallbacks * cb) { this->callbacks = cb; }
-		//@}
-		
-	private:
-		void reset (void);
-		void fillRand(unsigned char *, size_t);
+            /*!
+             * Accessors
+             */
+            //@{
+            void setUsername (string& user) { nxUsername = user; }
+            void setPassword (string& pass) { nxPassword = pass; }
+            void setResolution (int x, int y) 
+            {
+                if (this->sessionDataSet) {
+                    this->sessionData->xRes = x;
+                    this->sessionData->yRes = y;
+                }
+            }
 
-		/*!
-		 * This is the answer to give to the ssh server if it
-		 * asks whether we want to continue (say, if we're
-		 * connecting for the first time and we don't
-		 * necessarily trust its SSL key).
-		 */
-		bool doSSH;
-		/*!
-		 * Set to true if there are suspended sessions on the
-		 * server which are owned by nxUsername.
-		 */
-		bool suspendedSessions;
-		/*!
-		 * Set to true of sessionData has been populated
-		 */
-		bool sessionDataSet;
-		/*!
-		 * Holds the stage of the process which we have
-		 * reached as we go through the process of
-		 * authenticating with the NX Server.
-		 */
-		int stage;
-		/*!
-		 * File descriptor for the random number device
-		 */
-		int devurand_fd;
-		/*!
-		 * Holds the username for this session
-		 */
-		string nxUsername;
-		/*!
-		 * Holds the password for this session
-		 */
-		string nxPassword;
-		/*!
-		 * A list of sessions which can be resumed, as strings.
-		 */
-		list<string> resumeSessions;
-		/*!
-		 * A list of running sessions, held as NXResumeData
-		 * structures.
-		 */
-		list<NXResumeData> runningSessions;
-		/*!
-		 * Data for this session.
-		 */
-		NXSessionData *sessionData;
-		/*!
-		 * Pointer to a class containing callback methods.
-		 */
-		NXSessionCallbacks * callbacks;
-	};
+            void setDepth (int d) 
+            {
+                if (this->sessionDataSet) {
+                    this->sessionData->depth = d;
+                }
+            }
 
+            void setRender (bool isRender)
+            {
+                if (this->sessionDataSet) {
+                    this->sessionData->render = isRender;
+                }
+            }
+
+            void setEncryption (bool enc)
+            {
+                if (this->sessionDataSet) {
+                    this->sessionData->encryption = enc;
+                }
+            }
+
+            void setContinue (bool allow)
+            {
+                doSSH = allow;
+            }
+
+            void setSessionData (NXSessionData*);
+
+            bool getSessionDataSet (void)
+            {
+                return this->sessionDataSet;
+            }
+
+            void setCallbacks (NXSessionCallbacks * cb) 
+            {
+                this->callbacks = cb;
+            }
+            //@}
+
+        private:
+            void reset (void);
+            void fillRand(unsigned char *, size_t);
+
+            /*!
+             * This is the answer to give to the ssh server if it
+             * asks whether we want to continue (say, if we're
+             * connecting for the first time and we don't
+             * necessarily trust its SSL key).
+             */
+            bool doSSH;
+            /*!
+             * Set to true if there are suspended sessions on the
+             * server which are owned by nxUsername.
+             */
+            bool suspendedSessions;
+            /*!
+             * Set to true of sessionData has been populated
+             */
+            bool sessionDataSet;
+            /*!
+             * Holds the stage of the process which we have
+             * reached as we go through the process of
+             * authenticating with the NX Server.
+             */
+            int stage;
+            /*!
+             * File descriptor for the random number device
+             */
+            int devurand_fd;
+            /*!
+             * Holds the username for this session
+             */
+            string nxUsername;
+            /*!
+             * Holds the password for this session
+             */
+            string nxPassword;
+            /*!
+             * A list of sessions which can be resumed, as strings.
+             */
+            list<string> resumeSessions;
+            /*!
+             * A list of running sessions, held as NXResumeData
+             * structures.
+             */
+            list<NXResumeData> runningSessions;
+            /*!
+             * Data for this session.
+             */
+            NXSessionData *sessionData;
+            /*!
+             * Pointer to a class containing callback methods.
+             */
+            NXSessionCallbacks * callbacks;
+    };
+
 } // namespace
 #endif



