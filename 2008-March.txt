From fabianx at mail.berlios.de  Sun Mar  2 10:36:09 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Sun, 2 Mar 2008 10:36:09 +0100
Subject: [Freenx-cvs] r479 - freenx-server/trunk
Message-ID: <200803020936.m229a98I014051@sheep.berlios.de>

Author: fabianx
Date: 2008-03-02 10:36:08 +0100 (Sun, 02 Mar 2008)
New Revision: 479

Modified:
   freenx-server/trunk/ChangeLog
   freenx-server/trunk/nxnode
Log:
+       * Fixed parsing of SMB port and added a fallback if mport file is empty.
+         (Patch from Gentoo Portage)



Modified: freenx-server/trunk/ChangeLog
===================================================================
--- freenx-server/trunk/ChangeLog	2008-02-13 04:38:51 UTC (rev 478)
+++ freenx-server/trunk/ChangeLog	2008-03-02 09:36:08 UTC (rev 479)
@@ -28,6 +28,8 @@
 	  (fabianx at bat.berlios.de)
 	* Fixed the default value for ENABLE_CLIPBOARD="both" instead of ' = '.
 	  (fabianx at bat.berlios.de)
+	* Fixed parsing of SMB port and added a fallback if mport file is empty.
+	  (Patch from Gentoo Portage)
 
 14.10.2007 FreeNX 0.7.1 "Hip Hop Edition"
 	* Fixed the issue that makes fonts look tiny and unreadable by default 

Modified: freenx-server/trunk/nxnode
===================================================================
--- freenx-server/trunk/nxnode	2008-02-13 04:38:51 UTC (rev 478)
+++ freenx-server/trunk/nxnode	2008-03-02 09:36:08 UTC (rev 479)
@@ -56,7 +56,7 @@
 {
 	stringinstring "&$1=" "$CMDLINE" || return 1
 	
-	echo "$CMDLINE" |  tr "&" "\n" | egrep "^"$1"=" | awk -F= '{ VAL=$2 } END { print VAL }'
+	echo "$CMDLINE" |  tr "&" "\n" | egrep "^"$1"=" | awk -F= '{ VAL=$2 } END { print VAL }' | sed 's|%24|$|'
 	
 	return 0
 }
@@ -720,7 +720,7 @@
 		# Catch NXAGENT SMB Port (sometimes the port differs from what we got from nxserver)
 		#
 		
-		if stringinstring "Info: Listening for SMB connections on port" "$line"
+		if stringinstring "Info: Listening * SMB connections on port" "$line"
 		then
 			SMBMOUNT_PORT=$(echo $line | cut -d"'" -f2)
 			echo "$SMBMOUNT_PORT" >"$USER_FAKE_HOME/.nx/C-$sess_id/scripts/mport"
@@ -1314,8 +1314,9 @@
 		sleep 1
 	done
 	# sometimes the samba port we get from nxserver is not the right one, so let's get it from nxagent
-	port=$(cat "$USER_FAKE_HOME/.nx/C-$SERVER_NAME-$display-$sessionid/scripts/mport")
-	error=$(PASSWD="$password" $COMMAND_SMBMOUNT "//$computername/$share" "$HOME/$dir" -o username="$username,ip=127.0.0.1,port=$port" 2>&1)
+	realport=$(cat "$USER_FAKE_HOME/.nx/C-$SERVER_NAME-$display-$sessionid/scripts/mport")
+	[ -n "$realport" ] && port=$realport
+	error=$(PASSWD="$password" $COMMAND_SMBMOUNT "//$computername/$share" "$HOME/$dir" -o username="$username",ip=127.0.0.1,port=$port 2>&1)
 	if [ $? -eq 0 ]
 	then
 		$PATH_BIN/nxdialog -dialog ok -caption "NXServer Message" -message "Info: Share: '//$computername/$share' mounted on: '$HOME/$dir'" -display :$display &



From fabianx at mail.berlios.de  Sun Mar  2 10:46:25 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Sun, 2 Mar 2008 10:46:25 +0100
Subject: [Freenx-cvs] r480 - freenx-server/trunk
Message-ID: <200803020946.m229kPcj014748@sheep.berlios.de>

Author: fabianx
Date: 2008-03-02 10:46:25 +0100 (Sun, 02 Mar 2008)
New Revision: 480

Modified:
   freenx-server/trunk/ChangeLog
   freenx-server/trunk/nxsetup
Log:
* Run nscd only when nscd.pid is present.
  (Patch from Gentoo Portag


Modified: freenx-server/trunk/ChangeLog
===================================================================
--- freenx-server/trunk/ChangeLog	2008-03-02 09:36:08 UTC (rev 479)
+++ freenx-server/trunk/ChangeLog	2008-03-02 09:46:25 UTC (rev 480)
@@ -30,6 +30,8 @@
 	  (fabianx at bat.berlios.de)
 	* Fixed parsing of SMB port and added a fallback if mport file is empty.
 	  (Patch from Gentoo Portage)
+	* Run nscd only when nscd.pid is present.
+	  (Patch from Gentoo Portage)
 
 14.10.2007 FreeNX 0.7.1 "Hip Hop Edition"
 	* Fixed the issue that makes fonts look tiny and unreadable by default 

Modified: freenx-server/trunk/nxsetup
===================================================================
--- freenx-server/trunk/nxsetup	2008-03-02 09:36:08 UTC (rev 479)
+++ freenx-server/trunk/nxsetup	2008-03-02 09:46:25 UTC (rev 480)
@@ -141,7 +141,10 @@
 
 run_nscd()
 {
-	nscd "$@" 2>/dev/null || true
+	if [ -f /var/run/nscd/nscd.pid ]
+	then
+		nscd "$@" 2>/dev/null || true
+	fi
 }
 
 nx_user_exists()



From fabianx at mail.berlios.de  Sun Mar  2 10:53:00 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Sun, 2 Mar 2008 10:53:00 +0100
Subject: [Freenx-cvs] r481 - freenx-server/trunk
Message-ID: <200803020953.m229r0XS015396@sheep.berlios.de>

Author: fabianx
Date: 2008-03-02 10:53:00 +0100 (Sun, 02 Mar 2008)
New Revision: 481

Modified:
   freenx-server/trunk/ChangeLog
   freenx-server/trunk/nxserver
Log:
* Fixed possible bug in nxserver when $USER is not set.
  (Patch from Gentoo Portage)


Modified: freenx-server/trunk/ChangeLog
===================================================================
--- freenx-server/trunk/ChangeLog	2008-03-02 09:46:25 UTC (rev 480)
+++ freenx-server/trunk/ChangeLog	2008-03-02 09:53:00 UTC (rev 481)
@@ -32,6 +32,8 @@
 	  (Patch from Gentoo Portage)
 	* Run nscd only when nscd.pid is present.
 	  (Patch from Gentoo Portage)
+	* Fixed possible bug in nxserver when $USER is not set.
+	  (Patch from Gentoo Portage)
 
 14.10.2007 FreeNX 0.7.1 "Hip Hop Edition"
 	* Fixed the issue that makes fonts look tiny and unreadable by default 

Modified: freenx-server/trunk/nxserver
===================================================================
--- freenx-server/trunk/nxserver	2008-03-02 09:46:25 UTC (rev 480)
+++ freenx-server/trunk/nxserver	2008-03-02 09:53:00 UTC (rev 481)
@@ -426,7 +426,7 @@
 # Main nxserver <-> nxclient communication module
 #
 
-if [ $USER = "nxfree" -o "$USER" = "nx" -o "$ENABLE_USERMODE_AUTHENTICATION" = "1" ]
+if [ "$USER" = "nxfree" -o "$USER" = "nx" -o "$ENABLE_USERMODE_AUTHENTICATION" = "1" ]
 then
 
 setup_usermode_auth()



From fabianx at mail.berlios.de  Sun Mar  2 11:06:11 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Sun, 2 Mar 2008 11:06:11 +0100
Subject: [Freenx-cvs] r482 - freenx-server/trunk
Message-ID: <200803021006.m22A6Bj8016414@sheep.berlios.de>

Author: fabianx
Date: 2008-03-02 11:06:11 +0100 (Sun, 02 Mar 2008)
New Revision: 482

Modified:
   freenx-server/trunk/ChangeLog
   freenx-server/trunk/node.conf.sample
   freenx-server/trunk/nxloadconfig
   freenx-server/trunk/nxsetup
Log:
* Set ENABLE_USESSION="1" option by default - its hard to find and those who know can
  shut it off anyway. Added automatic adding of user nx to group utmp.
  (Patch by Gentoo Portage)



Modified: freenx-server/trunk/ChangeLog
===================================================================
--- freenx-server/trunk/ChangeLog	2008-03-02 09:53:00 UTC (rev 481)
+++ freenx-server/trunk/ChangeLog	2008-03-02 10:06:11 UTC (rev 482)
@@ -34,6 +34,9 @@
 	  (Patch from Gentoo Portage)
 	* Fixed possible bug in nxserver when $USER is not set.
 	  (Patch from Gentoo Portage)
+	* Set ENABLE_USESSION="1" option by default - its hard to find and those who know can
+	  shut it off anyway. Added automatic adding of user nx to group utmp.
+	  (Patch by Gentoo Portage)
 
 14.10.2007 FreeNX 0.7.1 "Hip Hop Edition"
 	* Fixed the issue that makes fonts look tiny and unreadable by default 

Modified: freenx-server/trunk/node.conf.sample
===================================================================
--- freenx-server/trunk/node.conf.sample	2008-03-02 09:53:00 UTC (rev 481)
+++ freenx-server/trunk/node.conf.sample	2008-03-02 10:06:11 UTC (rev 482)
@@ -469,7 +469,7 @@
 # Note: You have to make sure that you add the nx user to the
 #       utmp or tty group or how its called on your system
 #       before this directive works.
-#ENABLE_USESSION="0"
+#ENABLE_USESSION="1"
 #COMMAND_SESSREG="sessreg"
 
 # Extra options sent to the different nx agents. See !M documentation

Modified: freenx-server/trunk/nxloadconfig
===================================================================
--- freenx-server/trunk/nxloadconfig	2008-03-02 09:53:00 UTC (rev 481)
+++ freenx-server/trunk/nxloadconfig	2008-03-02 10:06:11 UTC (rev 482)
@@ -201,7 +201,7 @@
 EXPORT_SESSIONID="1"
 NODE_AUTOSTART=""
 ENABLE_ROOTLESS_MODE="1"
-ENABLE_USESSION="0"
+ENABLE_USESSION="1"
 COMMAND_SESSREG="sessreg"
 AGENT_EXTRA_OPTIONS_RFB=""
 AGENT_EXTRA_OPTIONS_RDP=""

Modified: freenx-server/trunk/nxsetup
===================================================================
--- freenx-server/trunk/nxsetup	2008-03-02 09:53:00 UTC (rev 481)
+++ freenx-server/trunk/nxsetup	2008-03-02 10:06:11 UTC (rev 482)
@@ -269,6 +269,13 @@
 		echo "done"
 	fi
 	
+	if [ "$ENABLE_USESSION" = "1" ]
+	then
+		echo -n "Adding user \"nx\" to group \"utmp\" ..."
+		usermod -G utmp nx
+		echo "done"
+	fi
+	
 	if [ "$ENABLE_NOMACHINE_FORWARD_PORT" = "1" -a -x "$NOMACHINE_SERVER" ]
 	then
 		echo -n "Setting up NoMachine forwarding ..."



From fabianx at mail.berlios.de  Sun Mar  2 11:23:24 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Sun, 2 Mar 2008 11:23:24 +0100
Subject: [Freenx-cvs] r483 - freenx-server/trunk
Message-ID: <200803021023.m22ANOQq017358@sheep.berlios.de>

Author: fabianx
Date: 2008-03-02 11:23:23 +0100 (Sun, 02 Mar 2008)
New Revision: 483

Modified:
   freenx-server/trunk/ChangeLog
   freenx-server/trunk/node.conf.sample
   freenx-server/trunk/nxloadconfig
   freenx-server/trunk/nxnode
Log:
* Added support for 3.1.0 and later backends. Made 2.0.0 backend the
  default and added a fallback to 1.5.0 via the same detection mechanism.
  (fabianx at bat.berlios.de)


Modified: freenx-server/trunk/ChangeLog
===================================================================
--- freenx-server/trunk/ChangeLog	2008-03-02 10:06:11 UTC (rev 482)
+++ freenx-server/trunk/ChangeLog	2008-03-02 10:23:23 UTC (rev 483)
@@ -37,6 +37,9 @@
 	* Set ENABLE_USESSION="1" option by default - its hard to find and those who know can
 	  shut it off anyway. Added automatic adding of user nx to group utmp.
 	  (Patch by Gentoo Portage)
+	* Added support for 3.1.0 and later backends. Made 2.0.0 backend the
+	  default and added a fallback to 1.5.0 via the same detection mechanism.
+	  (fabianx at bat.berlios.de)
 
 14.10.2007 FreeNX 0.7.1 "Hip Hop Edition"
 	* Fixed the issue that makes fonts look tiny and unreadable by default 

Modified: freenx-server/trunk/node.conf.sample
===================================================================
--- freenx-server/trunk/node.conf.sample	2008-03-02 10:06:11 UTC (rev 482)
+++ freenx-server/trunk/node.conf.sample	2008-03-02 10:23:23 UTC (rev 483)
@@ -443,8 +443,8 @@
 # Misc directives
 #########################################################################
 
-# When you installed a 2.0.0 NX Backend, set this to 1.
-#ENABLE_2_0_0_BACKEND="0"
+# When you installed an old 1.5.0 NX Backend, set this to 1.
+#ENABLE_1_5_0_BACKEND="0"
 
 # When set to 1 this will automatically resume started sessions
 #ENABLE_AUTORECONNECT="0"

Modified: freenx-server/trunk/nxloadconfig
===================================================================
--- freenx-server/trunk/nxloadconfig	2008-03-02 10:06:11 UTC (rev 482)
+++ freenx-server/trunk/nxloadconfig	2008-03-02 10:23:23 UTC (rev 483)
@@ -194,7 +194,7 @@
 
 # Misc directives
 
-ENABLE_2_0_0_BACKEND=""
+ENABLE_1_5_0_BACKEND=""
 ENABLE_AUTORECONNECT="0"
 ENABLE_AUTORECONNECT_BEFORE_140="1"
 EXPORT_USERIP="0"
@@ -298,11 +298,10 @@
 [ -z "$PROXY_LIBRARY_PATH" ] && PROXY_LIBRARY_PATH=$PATH_LIB
 [ -z "$APPLICATION_LIBRARY_PATH" ] && APPLICATION_LIBRARY_PATH=$PATH_LIB
 [ -z "$APPLICATION_LIBRARY_PRELOAD" ] && APPLICATION_LIBRARY_PRELOAD="$APPLICATION_LIBRARY_PATH/libX11.so.6.2:$APPLICATION_LIBRARY_PATH/libXext.so.6.4:$APPLICATION_LIBRARY_PATH/libXcomp.so:$APPLICATION_LIBRARY_PATH/libXcompext.so:$APPLICATION_LIBRARY_PATH/libXrender.so.1.2"
-if [ -z "$ENABLE_2_0_0_BACKEND" ]
+if [ -z "$ENABLE_1_5_0_BACKEND" ]
 then
-	ENABLE_2_0_0_BACKEND="1"
-	[ -z "$(strings $PATH_BIN/nxagent | egrep 'NXAGENT - Version 2.[01].0|NXAGENT - Version 3.0.0')" ] && ENABLE_2_0_0_BACKEND="0"
-fi 
+	[ -n "$(strings $PATH_BIN/nxagent | egrep 'NXAGENT - Version 1.5.0')" ] && ENABLE_1_5_0_BACKEND="1"
+fi
 
 if [ "$ENABLE_KDE_CUPS" = "1" ]
 then
@@ -578,8 +577,8 @@
 	[ -z $(echo "$ENABLE_ROOTLESS_MODE" | egrep "^[0|1]$") ] && \
 		ERROR="yes" && echo "Error: Invalid value \"ENABLE_ROOTLESS_MODE=$ENABLE_ROOTLESS_MODE\""
 
-	[ -z "$(strings $PATH_BIN/nxagent | egrep 'NXAGENT - Version 1.5.0|NXAGENT - Version 2.[01].0|NXAGENT - Version 3.0.0')" ] && \
-		ERROR="yes" && echo "Error: Could not find 1.5.0 or 2.[01].0 or 3.0.0 version string in nxagent. NX 1.5.0 or 2.[01].0 or 3.0.0 backend is needed for this version of FreeNX."
+	[ -z "$(strings $PATH_BIN/nxagent | egrep 'NXAGENT - Version 1.5.0|NXAGENT - Version 2.[01].0|NXAGENT - Version 3.[01].0')" ] && \
+		ERROR="yes" && echo "Error: Could not find 1.5.0 or 2.[01].0 or 3.[01].0 version string in nxagent. NX 1.5.0 or 2.[01].0 or 3.[01].0 backend is needed for this version of FreeNX."
 		
 	[ -z $(echo "$ENABLE_USESSION" | egrep "^[0|1]$") ] && \
 		ERROR="yes" && echo "Error: Invalid value \"ENABLE_USESSION=$ENABLE_USESSION\""

Modified: freenx-server/trunk/nxnode
===================================================================
--- freenx-server/trunk/nxnode	2008-03-02 10:06:11 UTC (rev 482)
+++ freenx-server/trunk/nxnode	2008-03-02 10:23:23 UTC (rev 483)
@@ -419,7 +419,7 @@
 	# backingstore
 	
 	B=""
-	if [ -n "$backingstore" -a "$ENABLE_2_0_0_BACKEND" != "1" ]
+	if [ -n "$backingstore" -a "$ENABLE_1_5_0_BACKEND" = "1" ]
 	then
 		[ "$backingstore" != 1 ] && B="-bs $backingstore"
 		[ "$backingstore" = 1 ] && B="+bs"
@@ -976,8 +976,13 @@
 
 node_start_monitor()
 {
-	[ "$ENABLE_2_0_0_BACKEND" = "1" ] && node_start_monitor_2_0_0 "$@"
-	[ "$ENABLE_2_0_0_BACKEND" = "1" ] || node_start_monitor_1_5_0 "$@"
+	if [ "$ENABLE_1_5_0_BACKEND" = "1" ]
+	then
+		node_start_monitor_1_5_0 "$@"
+	else
+		node_start_monitor_2_0_0 "$@"
+	fi
+
 }
 
 #



From fabianx at mail.berlios.de  Sun Mar  2 11:29:13 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Sun, 2 Mar 2008 11:29:13 +0100
Subject: [Freenx-cvs] r484 - freenx-server/trunk
Message-ID: <200803021029.m22ATDje018009@sheep.berlios.de>

Author: fabianx
Date: 2008-03-02 11:29:13 +0100 (Sun, 02 Mar 2008)
New Revision: 484

Modified:
   freenx-server/trunk/freenx-server
Log:
Changed freenx-server to really start/stop the serving of sessions.



Modified: freenx-server/trunk/freenx-server
===================================================================
--- freenx-server/trunk/freenx-server	2008-03-02 10:23:23 UTC (rev 483)
+++ freenx-server/trunk/freenx-server	2008-03-02 10:29:13 UTC (rev 484)
@@ -16,8 +16,10 @@
 	start)
 		[ ! -d "/tmp/.X11-unix" ] && mkdir -m1755 /tmp/.X11-unix/
 		$PATH_BIN/nxserver --cleanup
+		$PATH_BIN/nxserver --start
 	;;
 	stop)
+		$PATH_BIN/nxserver --stop
 		$PATH_BIN/nxserver --cleanup
 	;;	
 	*)



From fabianx at mail.berlios.de  Sun Mar  2 11:29:53 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Sun, 2 Mar 2008 11:29:53 +0100
Subject: [Freenx-cvs] r485 - in freenx-server/trunk: . init.d
Message-ID: <200803021029.m22ATrUJ018075@sheep.berlios.de>

Author: fabianx
Date: 2008-03-02 11:29:52 +0100 (Sun, 02 Mar 2008)
New Revision: 485

Added:
   freenx-server/trunk/init.d/
   freenx-server/trunk/init.d/freenx-server
Removed:
   freenx-server/trunk/freenx-server
Log:
Added a subdir for the init.d-style script.



Deleted: freenx-server/trunk/freenx-server
===================================================================
--- freenx-server/trunk/freenx-server	2008-03-02 10:29:13 UTC (rev 484)
+++ freenx-server/trunk/freenx-server	2008-03-02 10:29:52 UTC (rev 485)
@@ -1,28 +0,0 @@
-#!/bin/bash
-#
-# Sample startup script for FreeNX server
-#
-# Coypright (c) 2007 by Fabian Franz <freenx at fabian-franz.de>.
-#
-# License: GNU GPL, version 2
-#
-# SVN: $Id$
-#
-
-# Read the config file
-. $(PATH=$(cd $(dirname $0) && pwd):$PATH which nxloadconfig) --
-
-case "$1" in
-	start)
-		[ ! -d "/tmp/.X11-unix" ] && mkdir -m1755 /tmp/.X11-unix/
-		$PATH_BIN/nxserver --cleanup
-		$PATH_BIN/nxserver --start
-	;;
-	stop)
-		$PATH_BIN/nxserver --stop
-		$PATH_BIN/nxserver --cleanup
-	;;	
-	*)
-		echo "Usage: $0 <start|stop>"
-	;;
-esac

Copied: freenx-server/trunk/init.d/freenx-server (from rev 484, freenx-server/trunk/freenx-server)



From fabianx at mail.berlios.de  Sun Mar  2 13:02:00 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Sun, 2 Mar 2008 13:02:00 +0100
Subject: [Freenx-cvs] r486 - freenx-server/trunk
Message-ID: <200803021202.m22C207v003499@sheep.berlios.de>

Author: fabianx
Date: 2008-03-02 13:02:00 +0100 (Sun, 02 Mar 2008)
New Revision: 486

Modified:
   freenx-server/trunk/ChangeLog
   freenx-server/trunk/node.conf.sample
   freenx-server/trunk/nxloadconfig
   freenx-server/trunk/nxnode
Log:
* Added the configuration key ENABLE_PULLDOWN_MENU to be able to
  disable the pulldown menu for rootless sessions.
(fabianx at bat.berlios.de)

- Added 2> /dev/null for strings command.



Modified: freenx-server/trunk/ChangeLog
===================================================================
--- freenx-server/trunk/ChangeLog	2008-03-02 10:29:52 UTC (rev 485)
+++ freenx-server/trunk/ChangeLog	2008-03-02 12:02:00 UTC (rev 486)
@@ -40,6 +40,9 @@
 	* Added support for 3.1.0 and later backends. Made 2.0.0 backend the
 	  default and added a fallback to 1.5.0 via the same detection mechanism.
 	  (fabianx at bat.berlios.de)
+	* Added the configuration key ENABLE_PULLDOWN_MENU to be able to
+	  disable the pulldown menu for rootless sessions.
+	  (fabianx at bat.berlios.de)
 
 14.10.2007 FreeNX 0.7.1 "Hip Hop Edition"
 	* Fixed the issue that makes fonts look tiny and unreadable by default 

Modified: freenx-server/trunk/node.conf.sample
===================================================================
--- freenx-server/trunk/node.conf.sample	2008-03-02 10:29:52 UTC (rev 485)
+++ freenx-server/trunk/node.conf.sample	2008-03-02 12:02:00 UTC (rev 486)
@@ -152,6 +152,21 @@
 #
 #ENABLE_CLIPBOARD="both"
 
+
+#
+# Enable or disable the pulldown dialog, which provides a graphical
+# way to suspend or terminate the rootless session:
+#
+# 1: Enabled. The pulldown menu is shown when the mouse pointer
+#     moves near the middle of the top boundary of a window and
+#     allows the user to suspend or terminate the session by means
+#     of an icon-click.
+#
+# 0: Disabled. The ctrl+alt+T key combination has to be issued
+#     to get the dialog for suspending or terminating the session.
+#
+#ENABLE_PULLDOWN_MENU="1"
+
 #########################################################################
 # Logging directives
 #########################################################################

Modified: freenx-server/trunk/nxloadconfig
===================================================================
--- freenx-server/trunk/nxloadconfig	2008-03-02 10:29:52 UTC (rev 485)
+++ freenx-server/trunk/nxloadconfig	2008-03-02 12:02:00 UTC (rev 486)
@@ -113,6 +113,7 @@
 ENABLE_DESKTOP_SHARING=1
 
 ENABLE_CLIPBOARD="both"
+ENABLE_PULLDOWN_MENU="1"
 
 # Logging directives
 
@@ -300,7 +301,7 @@
 [ -z "$APPLICATION_LIBRARY_PRELOAD" ] && APPLICATION_LIBRARY_PRELOAD="$APPLICATION_LIBRARY_PATH/libX11.so.6.2:$APPLICATION_LIBRARY_PATH/libXext.so.6.4:$APPLICATION_LIBRARY_PATH/libXcomp.so:$APPLICATION_LIBRARY_PATH/libXcompext.so:$APPLICATION_LIBRARY_PATH/libXrender.so.1.2"
 if [ -z "$ENABLE_1_5_0_BACKEND" ]
 then
-	[ -n "$(strings $PATH_BIN/nxagent | egrep 'NXAGENT - Version 1.5.0')" ] && ENABLE_1_5_0_BACKEND="1"
+	[ -n "$(strings $PATH_BIN/nxagent 2>/dev/null | egrep 'NXAGENT - Version 1.5.0')" ] && ENABLE_1_5_0_BACKEND="1"
 fi
 
 if [ "$ENABLE_KDE_CUPS" = "1" ]

Modified: freenx-server/trunk/nxnode
===================================================================
--- freenx-server/trunk/nxnode	2008-03-02 10:29:52 UTC (rev 485)
+++ freenx-server/trunk/nxnode	2008-03-02 12:02:00 UTC (rev 486)
@@ -1183,6 +1183,7 @@
 	[ -z "$nodelay" ] && nodelay=1
 
 	clipboard="$ENABLE_CLIPBOARD"
+	menu="$ENABLE_PULLDOWN_MENU"
 
 	CACHE="cache=$cache,"
 	[ -z "$cache" ] && CACHE=""
@@ -1196,7 +1197,7 @@
 	umask 0077
 
 cat << EOF > "$USER_FAKE_HOME/.nx/C-$sess_id/options"
-${keyboard:+keyboard=$keyboard,}${kbtype:+kbtype=$kbtype,}${kbload:+kbload=$kbload,}${keymap:+keymap=$keymap,}${resize:+resize=$resize,}${CACHE}${IMAGES}${PACK}link=$link,nodelay=$nodelay,type=$realtype,cleanup=0,${ACCEPT}cookie=$proxy_cookie,id=$sess_id,samba=$samba,media=$media${sync:+,sync=$sync}${cups:+,cups=$cups}${keybd:+,keybd=$keybd}${aux:+,aux=$aux}${http:+,http=$http}${rdpcolors:+,rdpcolors=$rdpcolors}${rdpcache:+,rdpcache=$rdpcache}${fullscreen:+,fullscreen=1}${clipboard:+,clipboard=$clipboard}:$display
+${keyboard:+keyboard=$keyboard,}${kbtype:+kbtype=$kbtype,}${kbload:+kbload=$kbload,}${keymap:+keymap=$keymap,}${resize:+resize=$resize,}${CACHE}${IMAGES}${PACK}link=$link,nodelay=$nodelay,type=$realtype,cleanup=0,${ACCEPT}cookie=$proxy_cookie,id=$sess_id,samba=$samba,media=$media${sync:+,sync=$sync}${cups:+,cups=$cups}${keybd:+,keybd=$keybd}${aux:+,aux=$aux}${http:+,http=$http}${rdpcolors:+,rdpcolors=$rdpcolors}${rdpcache:+,rdpcache=$rdpcache}${fullscreen:+,fullscreen=1}${clipboard:+,clipboard=$clipboard}${menu:+,menu=$menu}:$display
 EOF
 	umask $OLD_UMASK
 #samba=$samba,



From fabianx at mail.berlios.de  Sun Mar  2 13:28:09 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Sun, 2 Mar 2008 13:28:09 +0100
Subject: [Freenx-cvs] r487 - freenx-server/trunk
Message-ID: <200803021228.m22CS9Dk019029@sheep.berlios.de>

Author: fabianx
Date: 2008-03-02 13:28:09 +0100 (Sun, 02 Mar 2008)
New Revision: 487

Modified:
   freenx-server/trunk/ChangeLog
   freenx-server/trunk/nxserver
Log:
* Fixed a small bug in nxserver when password has spaces at the end or
  beginning.
  (Dimitar Paskov)


Modified: freenx-server/trunk/ChangeLog
===================================================================
--- freenx-server/trunk/ChangeLog	2008-03-02 12:02:00 UTC (rev 486)
+++ freenx-server/trunk/ChangeLog	2008-03-02 12:28:09 UTC (rev 487)
@@ -43,6 +43,9 @@
 	* Added the configuration key ENABLE_PULLDOWN_MENU to be able to
 	  disable the pulldown menu for rootless sessions.
 	  (fabianx at bat.berlios.de)
+	* Fixed a small bug in nxserver when password has spaces at the end or
+	  beginning.
+	  (Dimitar Paskov)
 
 14.10.2007 FreeNX 0.7.1 "Hip Hop Edition"
 	* Fixed the issue that makes fonts look tiny and unreadable by default 

Modified: freenx-server/trunk/nxserver
===================================================================
--- freenx-server/trunk/nxserver	2008-03-02 12:02:00 UTC (rev 486)
+++ freenx-server/trunk/nxserver	2008-03-02 12:28:09 UTC (rev 487)
@@ -671,7 +671,10 @@
 			echo_x $USER
 			
 			echo_x -n "NX> 102 Password: "
+			old_ifs="$IFS"
+			export IFS=$'\n'
 			read -s PASS
+			export IFS="$old_ifs"
 			echo_x ""
 			log 6 -n "Info: Auth method: "
 			



From fabianx at mail.berlios.de  Sun Mar  2 13:37:33 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Sun, 2 Mar 2008 13:37:33 +0100
Subject: [Freenx-cvs] r488 - freenx-server/trunk
Message-ID: <200803021237.m22CbXQe019945@sheep.berlios.de>

Author: fabianx
Date: 2008-03-02 13:37:33 +0100 (Sun, 02 Mar 2008)
New Revision: 488

Modified:
   freenx-server/trunk/ChangeLog
   freenx-server/trunk/nxserver
Log:
* Fixed round-robin mode of load balancing.
  (fabianx at bat.berlios.de)


Modified: freenx-server/trunk/ChangeLog
===================================================================
--- freenx-server/trunk/ChangeLog	2008-03-02 12:28:09 UTC (rev 487)
+++ freenx-server/trunk/ChangeLog	2008-03-02 12:37:33 UTC (rev 488)
@@ -46,6 +46,8 @@
 	* Fixed a small bug in nxserver when password has spaces at the end or
 	  beginning.
 	  (Dimitar Paskov)
+	* Fixed round-robin mode of load balancing.
+	  (fabianx at bat.berlios.de)
 
 14.10.2007 FreeNX 0.7.1 "Hip Hop Edition"
 	* Fixed the issue that makes fonts look tiny and unreadable by default 

Modified: freenx-server/trunk/nxserver
===================================================================
--- freenx-server/trunk/nxserver	2008-03-02 12:28:09 UTC (rev 487)
+++ freenx-server/trunk/nxserver	2008-03-02 12:37:33 UTC (rev 488)
@@ -1037,7 +1037,7 @@
 		return
 	fi
 	
-	trap "rm -f $SERVER_LB_LOCKFILE $NX_SESS_DIR/round-robin.lock" EXIT
+	trap "rm -f \"$SERVER_LB_LOCKFILE\" \"$NX_SESS_DIR/round-robin.lock\"" EXIT
 
 	# Lock held
 
@@ -1046,7 +1046,7 @@
 	echo $SERVER_LB_NR >$NX_SESS_DIR/round-robin
 
 	# Exit critical section
-	rm -f "$SERVER_LB_LOCKFILE $NX_SESS_DIR/round-robin.lock"
+	rm -f "$SERVER_LB_LOCKFILE" "$NX_SESS_DIR/round-robin.lock"
 
 	trap - EXIT
 



From fabianx at mail.berlios.de  Sun Mar  2 14:01:55 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Sun, 2 Mar 2008 14:01:55 +0100
Subject: [Freenx-cvs] r489 - freenx-server/trunk
Message-ID: <200803021301.m22D1tKw022135@sheep.berlios.de>

Author: fabianx
Date: 2008-03-02 14:01:55 +0100 (Sun, 02 Mar 2008)
New Revision: 489

Modified:
   freenx-server/trunk/ChangeLog
   freenx-server/trunk/nxserver
Log:
* Added check for /tmp/.X11-unix/X*.
  (Yves-Ga?\195?\171l Ch?\195?\169ny <yves-gael.cheny at tranquil-it-systems.fr


Modified: freenx-server/trunk/ChangeLog
===================================================================
--- freenx-server/trunk/ChangeLog	2008-03-02 12:37:33 UTC (rev 488)
+++ freenx-server/trunk/ChangeLog	2008-03-02 13:01:55 UTC (rev 489)
@@ -48,6 +48,8 @@
 	  (Dimitar Paskov)
 	* Fixed round-robin mode of load balancing.
 	  (fabianx at bat.berlios.de)
+	* Added check for /tmp/.X11-unix/X*.
+	  (Yves-Ga?l Ch?ny <yves-gael.cheny at tranquil-it-systems.fr>)
 
 14.10.2007 FreeNX 0.7.1 "Hip Hop Edition"
 	* Fixed the issue that makes fonts look tiny and unreadable by default 

Modified: freenx-server/trunk/nxserver
===================================================================
--- freenx-server/trunk/nxserver	2008-03-02 12:37:33 UTC (rev 488)
+++ freenx-server/trunk/nxserver	2008-03-02 13:01:55 UTC (rev 489)
@@ -1221,7 +1221,7 @@
 			
 		while true
 		do
-			while [ -e /tmp/.X$SESS_DISPLAY-lock -o -e "/tmp/.nX$SESS_DISPLAY-lock" ]
+			while [ -e /tmp/.X$SESS_DISPLAY-lock -o -e "/tmp/.nX$SESS_DISPLAY-lock"  -o -e "/tmp/.X11-unix/X$SESS_DISPLAY" ]
 			do
 				let SESS_DISPLAY=$SESS_DISPLAY+1
 			done



From fabianx at mail.berlios.de  Tue Mar  4 04:40:15 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Tue, 4 Mar 2008 04:40:15 +0100
Subject: [Freenx-cvs] r490 - freenx-server/trunk
Message-ID: <200803040340.m243eFJp015446@sheep.berlios.de>

Author: fabianx
Date: 2008-03-04 04:40:13 +0100 (Tue, 04 Mar 2008)
New Revision: 490

Modified:
   freenx-server/trunk/ChangeLog
   freenx-server/trunk/nxserver
Log:
* Fixed --send|--broadcast for load balancing case.
  Note: ssh is used, so you need to either insert your root ssh password
  for the nodes again and again, use a public key + agent or use host keys.
  (fabianx at bat.berlios.de)


Modified: freenx-server/trunk/ChangeLog
===================================================================
--- freenx-server/trunk/ChangeLog	2008-03-02 13:01:55 UTC (rev 489)
+++ freenx-server/trunk/ChangeLog	2008-03-04 03:40:13 UTC (rev 490)
@@ -50,6 +50,10 @@
 	  (fabianx at bat.berlios.de)
 	* Added check for /tmp/.X11-unix/X*.
 	  (Yves-Ga?l Ch?ny <yves-gael.cheny at tranquil-it-systems.fr>)
+	* Fixed --send|--broadcast for load balancing case.
+	  Note: ssh is used, so you need to either insert your root ssh password 
+	  for the nodes again and again, use a public key + agent or use host keys.
+	  (fabianx at bat.berlios.de)
 
 14.10.2007 FreeNX 0.7.1 "Hip Hop Edition"
 	* Fixed the issue that makes fonts look tiny and unreadable by default 

Modified: freenx-server/trunk/nxserver
===================================================================
--- freenx-server/trunk/nxserver	2008-03-02 13:01:55 UTC (rev 489)
+++ freenx-server/trunk/nxserver	2008-03-04 03:40:13 UTC (rev 490)
@@ -1741,12 +1741,17 @@
 			cmd_user=$(getparam userName)
 			cmd_type=$(getparam type)
 			cmd_status=$(getparam status)
+			cmd_host=$(getparam host)
 
 			# is it a "good" session?
 			if [ "$cmd_status" = "Running" ] && stringinstring "unix-" "$cmd_type"
 			then
-				su - "$cmd_user" -c "$PATH_BIN/nxdialog --dialog ok --caption \"NX Administrator Message\" --message \"$@\" -display \":$cmd_display\"" &
-				disown $!
+				if [ "$cmd_host" = "127.0.0.1" -o "$cmd_host" = "localhost" ]
+				then
+					su - "$cmd_user" -c "$PATH_BIN/nxdialog --dialog ok --caption \"NX Administrator Message\" --message \"$@\" -display \":$cmd_display\" &"
+				else
+					ssh $cmd_host su - "$cmd_user" -c "'$PATH_BIN/nxdialog --dialog ok --caption \"NX Administrator Message\" --message \"$@\" -display \":$cmd_display\" &'"
+				fi
 			fi
 	done
 	#nxnode_start --send "$CMD_PARAMS"



From fabianx at mail.berlios.de  Tue Mar  4 04:45:18 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Tue, 4 Mar 2008 04:45:18 +0100
Subject: [Freenx-cvs] r491 - freenx-server/trunk
Message-ID: <200803040345.m243jIhP015770@sheep.berlios.de>

Author: fabianx
Date: 2008-03-04 04:45:16 +0100 (Tue, 04 Mar 2008)
New Revision: 491

Added:
   freenx-server/trunk/nxredir/
Log:
Imported nxredir from nxutils as from now on its mandatory.



Copied: freenx-server/trunk/nxredir (from rev 293, nx-utils/nxredir)



From fabianx at mail.berlios.de  Tue Mar  4 05:10:55 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Tue, 4 Mar 2008 05:10:55 +0100
Subject: [Freenx-cvs] r492 - freenx-server/trunk/nxredir
Message-ID: <200803040410.m244AtCm017101@sheep.berlios.de>

Author: fabianx
Date: 2008-03-04 05:10:53 +0100 (Tue, 04 Mar 2008)
New Revision: 492

Modified:
   freenx-server/trunk/nxredir/Makefile
   freenx-server/trunk/nxredir/nxredir
Log:
- Added -fPIC to Makefile
- Changed LD_PRELOAD to use : as delimiter.



Modified: freenx-server/trunk/nxredir/Makefile
===================================================================
--- freenx-server/trunk/nxredir/Makefile	2008-03-04 03:45:16 UTC (rev 491)
+++ freenx-server/trunk/nxredir/Makefile	2008-03-04 04:10:53 UTC (rev 492)
@@ -1,7 +1,7 @@
 all: libnxredir.so.0
 
 CC=gcc
-CFLAGS=-g -O2 -Wall
+CFLAGS=-g -O2 -Wall -fPIC
 
 libnxredir.so.0: nxredir.o
 	$(CC) -fPIC $(CFLAGS) -nostdlib -shared -o libnxredir.so.0 nxredir.o -ldl -lc

Modified: freenx-server/trunk/nxredir/nxredir
===================================================================
--- freenx-server/trunk/nxredir/nxredir	2008-03-04 03:45:16 UTC (rev 491)
+++ freenx-server/trunk/nxredir/nxredir	2008-03-04 04:10:53 UTC (rev 492)
@@ -9,7 +9,7 @@
 	exit 0
 fi
 
-LD_PRELOAD="/usr/lib/libnxredir.so.0 $LD_PRELOAD"
+LD_PRELOAD="/usr/lib/libnxredir.so.0:$LD_PRELOAD"
 export LD_PRELOAD
 
 # invoke the program with the args given



From fabianx at mail.berlios.de  Wed Mar  5 14:11:56 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Wed, 5 Mar 2008 14:11:56 +0100
Subject: [Freenx-cvs] r493 - freenx-server/trunk/nxredir
Message-ID: <200803051311.m25DBuYD026229@sheep.berlios.de>

Author: fabianx
Date: 2008-03-05 14:11:55 +0100 (Wed, 05 Mar 2008)
New Revision: 493

Added:
   freenx-server/trunk/nxredir/nxsmb
Modified:
   freenx-server/trunk/nxredir/Makefile
Log:
- Added nxsmb new backend.

- Added nxsmb to Makefile, used install instead of copy.



Modified: freenx-server/trunk/nxredir/Makefile
===================================================================
--- freenx-server/trunk/nxredir/Makefile	2008-03-04 04:10:53 UTC (rev 492)
+++ freenx-server/trunk/nxredir/Makefile	2008-03-05 13:11:55 UTC (rev 493)
@@ -11,8 +11,9 @@
 	rm -f *.o
 
 install: all
-	cp -a libnxredir.so.0 $(DESTDIR)/usr/lib
-	cp -a nxredir $(DESTDIR)/usr/bin
+	install -m755 libnxredir.so.0 $(DESTDIR)/usr/lib
+	install -m755 nxredir $(DESTDIR)/usr/bin
+	install -m755 nxsmb $(DESTDIR)/usr/lib/cups/backend/
 	ldconfig
 
 .PHONY: clean install

Added: freenx-server/trunk/nxredir/nxsmb
===================================================================
--- freenx-server/trunk/nxredir/nxsmb	2008-03-04 04:10:53 UTC (rev 492)
+++ freenx-server/trunk/nxredir/nxsmb	2008-03-05 13:11:55 UTC (rev 493)
@@ -0,0 +1,37 @@
+#!/bin/sh
+#
+# nxsmb: Small wrapper for the SMB backend to be able to print to CIFS or SMB ports directly.
+#
+# Copyright (c) 2008 by Fabian Franz.
+#
+#
+
+# turn on DEBUG?
+#set -x -v
+
+NXREDIR_LIBRARY="/usr/lib/libnxredir.so.0"
+COMMAND_SMB="/usr/lib/cups/backend/smb"
+
+PORT=$(echo $DEVICE_URI | cut -d/ -f3 | cut -d@ -f2 | cut -d: -f2 | cut -d- -f1)
+REAL_PORT=$(echo $DEVICE_URI | cut -d/ -f3 | cut -d@ -f2 | cut -d: -f2 | cut -d- -f2)
+
+if [ -z "$PORT" -o "$PORT" = "$REALPORT" ] # old style setup
+then
+	echo "Warning: Not using nxredir library. The DEVICE_URI is not in the right format."
+	exec "$COMMAND_SMB" "$@"
+fi
+
+if [ ! -x "$NXREDIR_LIBRARY" ]
+then
+	# repair DEVICE_URI
+	DEVICE_URI=$(echo $DEVICE_URI | sed "s|:$PORT-$REAL_PORT/|:$PORT/|g")
+	echo "Error: Not using nxredir library. $NXREDIR_LIBRARY could not be found or is not executable."
+	exec "$COMMAND_SMB" "$@"
+fi
+
+DEVICE_URI=$(echo $DEVICE_URI | sed "s|:$PORT-$REAL_PORT/|:$REAL_PORT/|g")
+
+export NXSAMBA_PORT="$PORT"
+export LD_PRELOAD="$NXREDIR_LIBRARY${LD_PRELOAD:+:$LD_PRELOAD}"
+
+exec "$COMMAND_SMB" "$@"


Property changes on: freenx-server/trunk/nxredir/nxsmb
___________________________________________________________________
Name: svn:executable
   + *



From fabianx at mail.berlios.de  Wed Mar  5 14:33:10 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Wed, 5 Mar 2008 14:33:10 +0100
Subject: [Freenx-cvs] r494 - freenx-server/trunk
Message-ID: <200803051333.m25DXAB0028408@sheep.berlios.de>

Author: fabianx
Date: 2008-03-05 14:33:10 +0100 (Wed, 05 Mar 2008)
New Revision: 494

Modified:
   freenx-server/trunk/ChangeLog
   freenx-server/trunk/nxnode
Log:
* Added possibility to use the new nxsmb backend. This enables us to support
  CIFS and SMB printing at the same time - without recompiling samba -
  via the nxredir preload library.
  (fabianx at bat.berlios.de)



Modified: freenx-server/trunk/ChangeLog
===================================================================
--- freenx-server/trunk/ChangeLog	2008-03-05 13:11:55 UTC (rev 493)
+++ freenx-server/trunk/ChangeLog	2008-03-05 13:33:10 UTC (rev 494)
@@ -54,6 +54,10 @@
 	  Note: ssh is used, so you need to either insert your root ssh password 
 	  for the nodes again and again, use a public key + agent or use host keys.
 	  (fabianx at bat.berlios.de)
+	* Added possibility to use the new nxsmb backend. This enables us to support
+	  CIFS and SMB printing at the same time - without recompiling samba -
+	  via the nxredir preload library.
+	  (fabianx at bat.berlios.de)
 
 14.10.2007 FreeNX 0.7.1 "Hip Hop Edition"
 	* Fixed the issue that makes fonts look tiny and unreadable by default 

Modified: freenx-server/trunk/nxnode
===================================================================
--- freenx-server/trunk/nxnode	2008-03-05 13:11:55 UTC (rev 493)
+++ freenx-server/trunk/nxnode	2008-03-05 13:33:10 UTC (rev 494)
@@ -1263,7 +1263,11 @@
 EOF
 
 # File-sharing port options
-[ "$samba" = "1" -a -n "$smbport" ] && echo "NX> 709 File-sharing port: $smbport"
+if [ "$samba" = "1" -a -n "$smbport" ]
+then
+	echo "NX> 709 File-sharing port: $smbport"
+	echo "$smbport" >"$USER_FAKE_HOME/.nx/C-$sess_id/scripts/smbport"
+fi
 
 # collection ...
 
@@ -1353,7 +1357,15 @@
 	
 	if [ "$type" = "smb" ]
 	then
-		DEVICE_URI="smb://$username:$password at 127.0.0.1:$port/$share"
+		if [ -x "$CUPS_BACKEND/nxsmb" ]
+		then
+			smbport=$(cat "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/smbport" 2>/dev/null)
+			[ -z "$smbport" ] && smbport=139 # should not happen
+
+			DEVICE_URI="nxsmb://$username:$password at 127.0.0.1:$port-$smbport/$share"
+		else
+			DEVICE_URI="smb://$username:$password at 127.0.0.1:$port/$share"
+		fi
 		NAME="$share"
 		ENABLE_CUPS_SEAMLESS="0"
 	else



From fabianx at mail.berlios.de  Wed Mar  5 14:57:12 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Wed, 5 Mar 2008 14:57:12 +0100
Subject: [Freenx-cvs] r495 - in freenx-server/trunk: . nxredir
Message-ID: <200803051357.m25DvCYd032178@sheep.berlios.de>

Author: fabianx
Date: 2008-03-05 14:57:12 +0100 (Wed, 05 Mar 2008)
New Revision: 495

Modified:
   freenx-server/trunk/nxnode
   freenx-server/trunk/nxredir/nxsmb
Log:
Changed protocol to be compatible with !M and look at lot nicer and especially be still compliant to URI struct.



Modified: freenx-server/trunk/nxnode
===================================================================
--- freenx-server/trunk/nxnode	2008-03-05 13:33:10 UTC (rev 494)
+++ freenx-server/trunk/nxnode	2008-03-05 13:57:12 UTC (rev 495)
@@ -1362,7 +1362,14 @@
 			smbport=$(cat "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/smbport" 2>/dev/null)
 			[ -z "$smbport" ] && smbport=139 # should not happen
 
-			DEVICE_URI="nxsmb://$username:$password at 127.0.0.1:$port-$smbport/$share"
+			if [ "$smbport" = "445" ]
+			then
+				smbproto="cifs"
+			else
+				smbproto="smb"
+			fi
+
+			DEVICE_URI="nxsmb://$username:$password at 127.0.0.1:$port/$smbproto/$share"
 		else
 			DEVICE_URI="smb://$username:$password at 127.0.0.1:$port/$share"
 		fi

Modified: freenx-server/trunk/nxredir/nxsmb
===================================================================
--- freenx-server/trunk/nxredir/nxsmb	2008-03-05 13:33:10 UTC (rev 494)
+++ freenx-server/trunk/nxredir/nxsmb	2008-03-05 13:57:12 UTC (rev 495)
@@ -12,10 +12,11 @@
 NXREDIR_LIBRARY="/usr/lib/libnxredir.so.0"
 COMMAND_SMB="/usr/lib/cups/backend/smb"
 
-PORT=$(echo $DEVICE_URI | cut -d/ -f3 | cut -d@ -f2 | cut -d: -f2 | cut -d- -f1)
-REAL_PORT=$(echo $DEVICE_URI | cut -d/ -f3 | cut -d@ -f2 | cut -d: -f2 | cut -d- -f2)
+PORT=$(echo $DEVICE_URI | cut -d/ -f3 | cut -d@ -f2 | cut -d: -f2)
+PROTOCOL=$(echo $DEVICE_URI | cut -d/ -f4)
+PRINTER=$(echo $DEVICE_URI | cut -d/ -f5)
 
-if [ -z "$PORT" -o "$PORT" = "$REALPORT" ] # old style setup
+if [ -z "$PRINTER" ] # old style setup
 then
 	echo "Warning: Not using nxredir library. The DEVICE_URI is not in the right format."
 	exec "$COMMAND_SMB" "$@"
@@ -24,13 +25,20 @@
 if [ ! -x "$NXREDIR_LIBRARY" ]
 then
 	# repair DEVICE_URI
-	DEVICE_URI=$(echo $DEVICE_URI | sed "s|:$PORT-$REAL_PORT/|:$PORT/|g")
+	DEVICE_URI=$(echo $DEVICE_URI | sed "s|/$PROTOCOL/|/$PRINTER|g")
 	echo "Error: Not using nxredir library. $NXREDIR_LIBRARY could not be found or is not executable."
 	exec "$COMMAND_SMB" "$@"
 fi
 
-DEVICE_URI=$(echo $DEVICE_URI | sed "s|:$PORT-$REAL_PORT/|:$REAL_PORT/|g")
+if [ "$PROTOCOL" = "cifs" -o "$PROTOCOL" = "CIFS" ]
+then
+	REAL_PORT="445"
+else
+	REAL_PORT="139"
+fi
 
+DEVICE_URI=$(echo $DEVICE_URI | sed "s|:$PORT/$PROTOCOL/|:$REAL_PORT/|g")
+
 export NXSAMBA_PORT="$PORT"
 export LD_PRELOAD="$NXREDIR_LIBRARY${LD_PRELOAD:+:$LD_PRELOAD}"
 



From gwright at mail.berlios.de  Wed Mar  5 17:01:21 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Wed, 5 Mar 2008 17:01:21 +0100
Subject: [Freenx-cvs] r496 - qtnx
Message-ID: <200803051601.m25G1LOD011060@sheep.berlios.de>

Author: gwright
Date: 2008-03-05 17:01:21 +0100 (Wed, 05 Mar 2008)
New Revision: 496

Modified:
   qtnx/logindialog.ui
   qtnx/qtnxwindow.cpp
   qtnx/qtnxwindow.h
Log:
Link type setting on the login dialog


Modified: qtnx/logindialog.ui
===================================================================
--- qtnx/logindialog.ui	2008-03-05 13:57:12 UTC (rev 495)
+++ qtnx/logindialog.ui	2008-03-05 16:01:21 UTC (rev 496)
@@ -13,21 +13,6 @@
    <string>QtNX</string>
   </property>
   <layout class="QVBoxLayout" >
-   <property name="spacing" >
-    <number>6</number>
-   </property>
-   <property name="leftMargin" >
-    <number>9</number>
-   </property>
-   <property name="topMargin" >
-    <number>9</number>
-   </property>
-   <property name="rightMargin" >
-    <number>9</number>
-   </property>
-   <property name="bottomMargin" >
-    <number>9</number>
-   </property>
    <item>
     <widget class="QLabel" name="logo" >
      <property name="text" >
@@ -40,21 +25,6 @@
    </item>
    <item>
     <layout class="QHBoxLayout" >
-     <property name="spacing" >
-      <number>6</number>
-     </property>
-     <property name="leftMargin" >
-      <number>0</number>
-     </property>
-     <property name="topMargin" >
-      <number>0</number>
-     </property>
-     <property name="rightMargin" >
-      <number>0</number>
-     </property>
-     <property name="bottomMargin" >
-      <number>0</number>
-     </property>
      <item>
       <layout class="QVBoxLayout" >
        <property name="spacing" >
@@ -97,21 +67,6 @@
      </item>
      <item>
       <layout class="QVBoxLayout" >
-       <property name="spacing" >
-        <number>6</number>
-       </property>
-       <property name="leftMargin" >
-        <number>0</number>
-       </property>
-       <property name="topMargin" >
-        <number>0</number>
-       </property>
-       <property name="rightMargin" >
-        <number>0</number>
-       </property>
-       <property name="bottomMargin" >
-        <number>0</number>
-       </property>
        <item>
         <widget class="QLineEdit" name="username" >
          <property name="minimumSize" >
@@ -136,14 +91,47 @@
         </widget>
        </item>
        <item>
-        <widget class="QComboBox" name="session" >
-         <property name="sizePolicy" >
-          <sizepolicy vsizetype="Fixed" hsizetype="MinimumExpanding" >
-           <horstretch>0</horstretch>
-           <verstretch>0</verstretch>
-          </sizepolicy>
-         </property>
-        </widget>
+        <layout class="QHBoxLayout" >
+         <item>
+          <widget class="QComboBox" name="session" >
+           <property name="sizePolicy" >
+            <sizepolicy vsizetype="Fixed" hsizetype="MinimumExpanding" >
+             <horstretch>0</horstretch>
+             <verstretch>0</verstretch>
+            </sizepolicy>
+           </property>
+          </widget>
+         </item>
+         <item>
+          <widget class="QComboBox" name="link" >
+           <item>
+            <property name="text" >
+             <string>Modem</string>
+            </property>
+           </item>
+           <item>
+            <property name="text" >
+             <string>ISDN</string>
+            </property>
+           </item>
+           <item>
+            <property name="text" >
+             <string>ADSL</string>
+            </property>
+           </item>
+           <item>
+            <property name="text" >
+             <string>WAN</string>
+            </property>
+           </item>
+           <item>
+            <property name="text" >
+             <string>LAN</string>
+            </property>
+           </item>
+          </widget>
+         </item>
+        </layout>
        </item>
       </layout>
      </item>
@@ -151,21 +139,6 @@
    </item>
    <item>
     <layout class="QHBoxLayout" >
-     <property name="spacing" >
-      <number>6</number>
-     </property>
-     <property name="leftMargin" >
-      <number>0</number>
-     </property>
-     <property name="topMargin" >
-      <number>0</number>
-     </property>
-     <property name="rightMargin" >
-      <number>0</number>
-     </property>
-     <property name="bottomMargin" >
-      <number>0</number>
-     </property>
      <item>
       <widget class="QPushButton" name="configureButton" >
        <property name="text" >

Modified: qtnx/qtnxwindow.cpp
===================================================================
--- qtnx/qtnxwindow.cpp	2008-03-05 13:57:12 UTC (rev 495)
+++ qtnx/qtnxwindow.cpp	2008-03-05 16:01:21 UTC (rev 496)
@@ -55,11 +55,15 @@
 
     ui_lg.session->addItem(tr("Create new session"));
 
+    parseXML();
+
     connect(ui_lg.connectButton, SIGNAL(pressed()), this, SLOT(startConnect()));
     connect(ui_lg.password, SIGNAL(returnPressed()), this, SLOT(startConnect()));
 
     connect(ui_lg.configureButton, SIGNAL(pressed()), this, SLOT(configure()));
 
+    connect(ui_lg.session, SIGNAL(currentIndexChanged(QString)), this, SLOT(updateLinkType(QString)));
+
     connect(processProbe, SIGNAL(timeout()), this, SLOT(handleTimeout()));
 
     connect(&callback, SIGNAL(logging(QString)), this, SLOT(handleLogging(QString)));
@@ -80,6 +84,11 @@
     connect(&callback, SIGNAL(connectedSuccessfully()), this, SLOT(quit()));
 }
 
+void QtNXWindow::updateLinkType(QString sessionName)
+{
+    parseXML();
+}
+
 QtNXWindow::~QtNXWindow()
 {
     delete m_NXClient;
@@ -236,21 +245,24 @@
 {
     string key = "";
 
-    NXParseXML handler;
-    handler.setData(&config);
+    parseXML();
 
-    QFile file(QDir::homePath() + "/.qtnx/" +
-            ui_lg.session->currentText() + ".nxml");
+    if (config.sessionType == "unix-application")
+        session.customCommand = config.customCommand;
 
-    QXmlInputSource inputSource(&file);
+    setDefaultData();
 
-    QXmlSimpleReader reader;
-    reader.setContentHandler(&handler);
-    reader.setErrorHandler(&handler);
-    reader.parse(inputSource);
+    if (ui_lg.link->currentText() == tr("Modem"))
+        session.linkType = "modem";
+    else if (ui_lg.link->currentText() == tr("ISDN"))
+        session.linkType = "isdn";
+    else if (ui_lg.link->currentText() == tr("ADSL"))
+        session.linkType = "adsl";
+    else if (ui_lg.link->currentText() == tr("WAN"))
+        session.linkType = "wan";
+    else if (ui_lg.link->currentText() == tr("LAN"))
+        session.linkType = "lan";
 
-    setDefaultData();
-
     if (!config.key.empty()) {
         key = config.key;
         session.key = "supplied";
@@ -350,6 +362,33 @@
     }
 }
 
+void QtNXWindow::parseXML()
+{
+    NXParseXML handler;
+    handler.setData(&config);
+
+    QFile file(QDir::homePath() + "/.qtnx/" +
+            ui_lg.session->currentText() + ".nxml");
+
+    QXmlInputSource inputSource(&file);
+
+    QXmlSimpleReader reader;
+    reader.setContentHandler(&handler);
+    reader.setErrorHandler(&handler);
+    reader.parse(inputSource);
+
+    if (config.linkType == "modem")
+        ui_lg.link->setCurrentIndex(ui_lg.link->findText(tr("Modem")));
+    else if (config.linkType == "isdn")
+        ui_lg.link->setCurrentIndex(ui_lg.link->findText(tr("ISDN")));
+    else if (config.linkType == "adsl")
+        ui_lg.link->setCurrentIndex(ui_lg.link->findText(tr("ADSL")));
+    else if (config.linkType == "wan")
+        ui_lg.link->setCurrentIndex(ui_lg.link->findText(tr("WAN")));
+    else if (config.linkType == "lan")
+        ui_lg.link->setCurrentIndex(ui_lg.link->findText(tr("LAN")));
+}
+
 void QtNXWindow::configure()
 {
     if (ui_lg.session->currentText() == tr("Create new session"))

Modified: qtnx/qtnxwindow.h
===================================================================
--- qtnx/qtnxwindow.h	2008-03-05 13:57:12 UTC (rev 495)
+++ qtnx/qtnxwindow.h	2008-03-05 16:01:21 UTC (rev 496)
@@ -105,6 +105,7 @@
         void startConnect();
         void configure();
         void configureClosed(QString);
+        void updateLinkType(QString);
 
         // Callback handlers
         void handleSuspendedSessions(QList<NXResumeData>);
@@ -127,6 +128,7 @@
         void setupUI();
         void setDefaultData();
         void initialiseClient();
+        void parseXML();
         void reinitialiseClient();
 
         int getWidth();



From gwright at mail.berlios.de  Fri Mar  7 01:46:21 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Fri, 7 Mar 2008 01:46:21 +0100
Subject: [Freenx-cvs] r497 - qtnx
Message-ID: <200803070046.m270kL3n008475@sheep.berlios.de>

Author: gwright
Date: 2008-03-07 01:46:20 +0100 (Fri, 07 Mar 2008)
New Revision: 497

Modified:
   qtnx/qtnxwindow.cpp
Log:
Sanity checking in connection


Modified: qtnx/qtnxwindow.cpp
===================================================================
--- qtnx/qtnxwindow.cpp	2008-03-05 16:01:21 UTC (rev 496)
+++ qtnx/qtnxwindow.cpp	2008-03-07 00:46:20 UTC (rev 497)
@@ -245,6 +245,13 @@
 {
     string key = "";
 
+    if (ui_lg.session->currentText() == tr("Create new session")) {
+        QMessageBox::critical(this, tr("Unconfigured"),
+                tr("Please select a session profile to connect with, or configure one"), 
+                QMessageBox::Ok, QMessageBox::NoButton, QMessageBox::NoButton);
+        return;
+    }
+
     parseXML();
 
     if (config.sessionType == "unix-application")



From gwright at mail.berlios.de  Fri Mar  7 01:51:25 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Fri, 7 Mar 2008 01:51:25 +0100
Subject: [Freenx-cvs] r498 - /
Message-ID: <200803070051.m270pPDF008904@sheep.berlios.de>

Author: gwright
Date: 2008-03-07 01:51:25 +0100 (Fri, 07 Mar 2008)
New Revision: 498

Added:
   tags/
Log:
Add a tags subdirectory




From gwright at mail.berlios.de  Fri Mar  7 01:53:10 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Fri, 7 Mar 2008 01:53:10 +0100
Subject: [Freenx-cvs] r499 - tags
Message-ID: <200803070053.m270rALB008989@sheep.berlios.de>

Author: gwright
Date: 2008-03-07 01:53:10 +0100 (Fri, 07 Mar 2008)
New Revision: 499

Added:
   tags/nxcl-0.9/
Log:
Tagging nxcl 0.9


Copied: tags/nxcl-0.9 (from rev 498, nxcl)



From gwright at mail.berlios.de  Fri Mar  7 01:53:25 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Fri, 7 Mar 2008 01:53:25 +0100
Subject: [Freenx-cvs] r500 - tags
Message-ID: <200803070053.m270rPf0009046@sheep.berlios.de>

Author: gwright
Date: 2008-03-07 01:53:24 +0100 (Fri, 07 Mar 2008)
New Revision: 500

Added:
   tags/qtnx-0.9/
Log:
Tagging qtnx 0.9


Copied: tags/qtnx-0.9 (from rev 499, qtnx)



From gwright at mail.berlios.de  Fri Mar  7 18:14:52 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Fri, 7 Mar 2008 18:14:52 +0100
Subject: [Freenx-cvs] r501 - /
Message-ID: <200803071714.m27HEqmj006422@sheep.berlios.de>

Author: gwright
Date: 2008-03-07 18:14:51 +0100 (Fri, 07 Mar 2008)
New Revision: 501

Added:
   branches/
   trunk/
Log:
Add branches/trunk directories




From gwright at mail.berlios.de  Fri Mar  7 18:19:08 2008
From: gwright at mail.berlios.de (gwright at BerliOS)
Date: Fri, 7 Mar 2008 18:19:08 +0100
Subject: [Freenx-cvs] r502 - / tags trunk
Message-ID: <200803071719.m27HJ80g006716@sheep.berlios.de>

Author: gwright
Date: 2008-03-07 18:19:07 +0100 (Fri, 07 Mar 2008)
New Revision: 502

Added:
   tags/FreeNX-0_5_0-LWE/
   trunk/freenx-redesign/
   trunk/freenx-server/
   trunk/freenx-website/
   trunk/gnx/
   trunk/nx-utils/
   trunk/nxcl/
   trunk/nxclientlib/
   trunk/nxlaunch/
   trunk/qtnx/
   trunk/thinnx/
Removed:
   freenx-redesign/
   freenx-server/
   freenx-website/
   gnx/
   nx-utils.tags/
   nx-utils/
   nxcl/
   nxclientlib/
   nxlaunch/
   qtnx/
   thinnx/
Log:
Rearrange svn


Copied: tags/FreeNX-0_5_0-LWE (from rev 501, nx-utils.tags/FreeNX-0_5_0-LWE)

Copied: trunk/freenx-redesign (from rev 501, freenx-redesign)

Copied: trunk/freenx-server (from rev 501, freenx-server)

Copied: trunk/freenx-website (from rev 501, freenx-website)

Copied: trunk/gnx (from rev 501, gnx)

Copied: trunk/nx-utils (from rev 501, nx-utils)

Copied: trunk/nxcl (from rev 501, nxcl)

Copied: trunk/nxclientlib (from rev 501, nxclientlib)

Copied: trunk/nxlaunch (from rev 501, nxlaunch)

Copied: trunk/qtnx (from rev 501, qtnx)

Copied: trunk/thinnx (from rev 501, thinnx)



From fabianx at mail.berlios.de  Mon Mar 10 23:28:34 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Mon, 10 Mar 2008 23:28:34 +0100
Subject: [Freenx-cvs] r504 - in tags: . nx-utils nxcl qtnx
Message-ID: <200803102228.m2AMSYmn004132@sheep.berlios.de>

Author: fabianx
Date: 2008-03-10 23:28:33 +0100 (Mon, 10 Mar 2008)
New Revision: 504

Added:
   tags/freenx-redesign/
   tags/freenx-server/
   tags/freenx-website/
   tags/gnx/
   tags/nx-utils/
   tags/nx-utils/FreeNX-0_5_0-LWE/
   tags/nxcl/
   tags/nxcl/nxcl-0.9/
   tags/nxclientlib/
   tags/nxlaunch/
   tags/qtnx/
   tags/qtnx/qtnx-0.9/
   tags/thinnx/
Removed:
   tags/FreeNX-0_5_0-LWE/
   tags/nxcl-0.9/
   tags/qtnx-0.9/
Log:
Reworking the repository to be trunk, branches, tags.



Copied: tags/nx-utils/FreeNX-0_5_0-LWE (from rev 502, tags/FreeNX-0_5_0-LWE)

Copied: tags/nxcl/nxcl-0.9 (from rev 502, tags/nxcl-0.9)

Copied: tags/qtnx/qtnx-0.9 (from rev 502, tags/qtnx-0.9)



From fabianx at mail.berlios.de  Mon Mar 10 23:39:31 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Mon, 10 Mar 2008 23:39:31 +0100
Subject: [Freenx-cvs] r505 - in trunk: . abandoned-clients freenx-client
Message-ID: <200803102239.m2AMdVAD005208@sheep.berlios.de>

Author: fabianx
Date: 2008-03-10 23:39:31 +0100 (Mon, 10 Mar 2008)
New Revision: 505

Added:
   trunk/abandoned-clients/
   trunk/abandoned-clients/gnx/
   trunk/abandoned-clients/nxclientlib/
   trunk/abandoned-clients/thinnx/
   trunk/freenx-client/
   trunk/freenx-client/nxcl/
   trunk/freenx-client/qtnx/
   trunk/freenx-utils/
Removed:
   trunk/gnx/
   trunk/nx-utils/
   trunk/nxcl/
   trunk/nxclientlib/
   trunk/qtnx/
   trunk/thinnx/
Log:
More repository reorganisation.



Copied: trunk/abandoned-clients/gnx (from rev 502, trunk/gnx)

Copied: trunk/abandoned-clients/nxclientlib (from rev 502, trunk/nxclientlib)

Copied: trunk/abandoned-clients/thinnx (from rev 502, trunk/thinnx)

Copied: trunk/freenx-client/nxcl (from rev 502, trunk/nxcl)

Copied: trunk/freenx-client/qtnx (from rev 502, trunk/qtnx)

Copied: trunk/freenx-utils (from rev 502, trunk/nx-utils)



From fabianx at mail.berlios.de  Mon Mar 10 23:40:58 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Mon, 10 Mar 2008 23:40:58 +0100
Subject: [Freenx-cvs] r506 - in trunk: . freenx-client
Message-ID: <200803102240.m2AMewRC005589@sheep.berlios.de>

Author: fabianx
Date: 2008-03-10 23:40:58 +0100 (Mon, 10 Mar 2008)
New Revision: 506

Added:
   trunk/freenx-client/nxlaunch/
Removed:
   trunk/nxlaunch/
Log:
Forgot nxlaunch.



Copied: trunk/freenx-client/nxlaunch (from rev 502, trunk/nxlaunch)



From fabianx at mail.berlios.de  Mon Mar 10 23:47:08 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Mon, 10 Mar 2008 23:47:08 +0100
Subject: [Freenx-cvs] r507 - in tags: . freenx-client
	freenx-client/freenx-client-0.9 nxcl qtnx
Message-ID: <200803102247.m2AMl81E007023@sheep.berlios.de>

Author: fabianx
Date: 2008-03-10 23:47:07 +0100 (Mon, 10 Mar 2008)
New Revision: 507

Added:
   tags/freenx-client/
   tags/freenx-client/freenx-client-0.9/
   tags/freenx-client/freenx-client-0.9/nxcl/
   tags/freenx-client/freenx-client-0.9/qtnx/
   tags/freenx-utils/
Removed:
   tags/gnx/
   tags/nx-utils/
   tags/nxcl/nxcl-0.9/
   tags/nxclientlib/
   tags/nxlaunch/
   tags/qtnx/qtnx-0.9/
   tags/thinnx/
Log:
More repository reorganisation.



Copied: tags/freenx-client/freenx-client-0.9/nxcl (from rev 504, tags/nxcl/nxcl-0.9)

Copied: tags/freenx-client/freenx-client-0.9/qtnx (from rev 504, tags/qtnx/qtnx-0.9)

Copied: tags/freenx-utils (from rev 504, tags/nx-utils)



From fabianx at mail.berlios.de  Mon Mar 10 23:50:12 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Mon, 10 Mar 2008 23:50:12 +0100
Subject: [Freenx-cvs] r508 - tags
Message-ID: <200803102250.m2AMoCAD007727@sheep.berlios.de>

Author: fabianx
Date: 2008-03-10 23:50:12 +0100 (Mon, 10 Mar 2008)
New Revision: 508

Removed:
   tags/nxcl/
   tags/qtnx/
Log:
More repository reorganization.





From fabianx at mail.berlios.de  Mon Mar 10 23:52:37 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Mon, 10 Mar 2008 23:52:37 +0100
Subject: [Freenx-cvs] r509 - tags/freenx-server trunk/freenx-server/tags
Message-ID: <200803102252.m2AMqbqq007943@sheep.berlios.de>

Author: fabianx
Date: 2008-03-10 23:52:37 +0100 (Mon, 10 Mar 2008)
New Revision: 509

Added:
   tags/freenx-server/FreeNX-0.4.4/
   tags/freenx-server/FreeNX-0.4.5/
   tags/freenx-server/FreeNX-0.5.0/
   tags/freenx-server/FreeNX-0.6.0.99/
   tags/freenx-server/FreeNX-0.6.0/
   tags/freenx-server/FreeNX-0.7.0/
   tags/freenx-server/FreeNX-0.7.1/
   tags/freenx-server/FreeNX-0_4_4-RC1/
   tags/freenx-server/FreeNX-0_5_0-LWE/
Removed:
   trunk/freenx-server/tags/FreeNX-0.4.4/
   trunk/freenx-server/tags/FreeNX-0.4.5/
   trunk/freenx-server/tags/FreeNX-0.5.0/
   trunk/freenx-server/tags/FreeNX-0.6.0.99/
   trunk/freenx-server/tags/FreeNX-0.6.0/
   trunk/freenx-server/tags/FreeNX-0.7.0/
   trunk/freenx-server/tags/FreeNX-0.7.1/
   trunk/freenx-server/tags/FreeNX-0_4_4-RC1/
   trunk/freenx-server/tags/FreeNX-0_5_0-LWE/
Log:
Moved tags from trunk/*/tags to tags.



Copied: tags/freenx-server/FreeNX-0.4.4 (from rev 502, trunk/freenx-server/tags/FreeNX-0.4.4)

Copied: tags/freenx-server/FreeNX-0.4.5 (from rev 502, trunk/freenx-server/tags/FreeNX-0.4.5)

Copied: tags/freenx-server/FreeNX-0.5.0 (from rev 502, trunk/freenx-server/tags/FreeNX-0.5.0)

Copied: tags/freenx-server/FreeNX-0.6.0 (from rev 502, trunk/freenx-server/tags/FreeNX-0.6.0)

Copied: tags/freenx-server/FreeNX-0.6.0.99 (from rev 502, trunk/freenx-server/tags/FreeNX-0.6.0.99)

Copied: tags/freenx-server/FreeNX-0.7.0 (from rev 502, trunk/freenx-server/tags/FreeNX-0.7.0)

Copied: tags/freenx-server/FreeNX-0.7.1 (from rev 502, trunk/freenx-server/tags/FreeNX-0.7.1)

Copied: tags/freenx-server/FreeNX-0_4_4-RC1 (from rev 502, trunk/freenx-server/tags/FreeNX-0_4_4-RC1)

Copied: tags/freenx-server/FreeNX-0_5_0-LWE (from rev 502, trunk/freenx-server/tags/FreeNX-0_5_0-LWE)



From fabianx at mail.berlios.de  Mon Mar 10 23:58:26 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Mon, 10 Mar 2008 23:58:26 +0100
Subject: [Freenx-cvs] r510 - branches branches/freenx-server
	trunk/freenx-server trunk/freenx-server/branches
Message-ID: <200803102258.m2AMwQ2b008432@sheep.berlios.de>

Author: fabianx
Date: 2008-03-10 23:58:26 +0100 (Mon, 10 Mar 2008)
New Revision: 510

Added:
   branches/freenx-server/
   branches/freenx-server/FreeNX-0.4/
   branches/freenx-server/FreeNX-0.5/
Removed:
   trunk/freenx-server/branches/FreeNX-0.4/
   trunk/freenx-server/branches/FreeNX-0.5/
   trunk/freenx-server/tags/
Log:
More repository reorganization.



Copied: branches/freenx-server/FreeNX-0.4 (from rev 502, trunk/freenx-server/branches/FreeNX-0.4)

Copied: branches/freenx-server/FreeNX-0.5 (from rev 502, trunk/freenx-server/branches/FreeNX-0.5)



From fabianx at mail.berlios.de  Mon Mar 10 23:59:39 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Mon, 10 Mar 2008 23:59:39 +0100
Subject: [Freenx-cvs] r511 - branches/freenx-server
	trunk/freenx-server/branches
Message-ID: <200803102259.m2AMxdml008521@sheep.berlios.de>

Author: fabianx
Date: 2008-03-10 23:59:38 +0100 (Mon, 10 Mar 2008)
New Revision: 511

Added:
   branches/freenx-server/0_5_0-based-on-0.4.1/
Removed:
   trunk/freenx-server/branches/0_5_0-based-on-0.4.1/
Log:
More repository reorganization.



Copied: branches/freenx-server/0_5_0-based-on-0.4.1 (from rev 502, trunk/freenx-server/branches/0_5_0-based-on-0.4.1)



From fabianx at mail.berlios.de  Tue Mar 11 00:01:29 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Tue, 11 Mar 2008 00:01:29 +0100
Subject: [Freenx-cvs] r513 - trunk/freenx-server
Message-ID: <200803102301.m2AN1T8g008953@sheep.berlios.de>

Author: fabianx
Date: 2008-03-11 00:01:28 +0100 (Tue, 11 Mar 2008)
New Revision: 513

Removed:
   trunk/freenx-server/trunk/
Log:
More repository reorganization.





From fabianx at mail.berlios.de  Tue Mar 11 01:29:30 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Tue, 11 Mar 2008 01:29:30 +0100
Subject: [Freenx-cvs] r514 - trunk/freenx-server/nxredir
Message-ID: <200803110029.m2B0TU0I020221@sheep.berlios.de>

Author: fabianx
Date: 2008-03-11 01:29:30 +0100 (Tue, 11 Mar 2008)
New Revision: 514

Modified:
   trunk/freenx-server/nxredir/nxredir
Log:
Some small nxredir fixes to prepare usage via nxnode.



Modified: trunk/freenx-server/nxredir/nxredir
===================================================================
--- trunk/freenx-server/nxredir/nxredir	2008-03-10 23:01:28 UTC (rev 513)
+++ trunk/freenx-server/nxredir/nxredir	2008-03-11 00:29:30 UTC (rev 514)
@@ -1,16 +1,20 @@
 #!/bin/sh
 
+NXREDIR_LIBRARY="/usr/lib/libnxredir.so.0"
+
 if [ -z "$NXCUPS_PORT" -a -z "$NXSAMBA_PORT" ]
 then
 	echo "nxredir: Redirect standard ports to nxproxy"
 	echo ""
 	echo "Usage: export NXCUPS_PORT='where_cups_is_running'"
 	echo "       export NXSAMBA_PORT='where_samba_is_running'"
+	
+	# invoke the program with the args given
+	exec "$@"
 	exit 0
 fi
 
-LD_PRELOAD="/usr/lib/libnxredir.so.0:$LD_PRELOAD"
-export LD_PRELOAD
+export LD_PRELOAD="$NXREDIR_LIBRARY${LD_PRELOAD:+:$LD_PRELOAD}"
 
 # invoke the program with the args given
 exec "$@"



From fabianx at mail.berlios.de  Tue Mar 11 02:03:55 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Tue, 11 Mar 2008 02:03:55 +0100
Subject: [Freenx-cvs] r515 - trunk/freenx-server
Message-ID: <200803110103.m2B13tY5007167@sheep.berlios.de>

Author: fabianx
Date: 2008-03-11 02:03:54 +0100 (Tue, 11 Mar 2008)
New Revision: 515

Modified:
   trunk/freenx-server/ChangeLog
   trunk/freenx-server/node.conf.sample
   trunk/freenx-server/nxloadconfig
   trunk/freenx-server/nxnode
Log:
* Added usage of nxredir library to forward port 139,445 to the
  client side forwarded SMB port.
  (fabianx at bat.berlios.de)



Modified: trunk/freenx-server/ChangeLog
===================================================================
--- trunk/freenx-server/ChangeLog	2008-03-11 00:29:30 UTC (rev 514)
+++ trunk/freenx-server/ChangeLog	2008-03-11 01:03:54 UTC (rev 515)
@@ -58,6 +58,9 @@
 	  CIFS and SMB printing at the same time - without recompiling samba -
 	  via the nxredir preload library.
 	  (fabianx at bat.berlios.de)
+	* Added usage of nxredir library to forward port 139,445 to the
+	  client side forwarded SMB port.
+	  (fabianx at bat.berlios.de)
 
 14.10.2007 FreeNX 0.7.1 "Hip Hop Edition"
 	* Fixed the issue that makes fonts look tiny and unreadable by default 

Modified: trunk/freenx-server/node.conf.sample
===================================================================
--- trunk/freenx-server/node.conf.sample	2008-03-11 00:29:30 UTC (rev 514)
+++ trunk/freenx-server/node.conf.sample	2008-03-11 01:03:54 UTC (rev 515)
@@ -356,6 +356,14 @@
 
 #SAMBA_MOUNT_SHARE_PROTOCOL="both"
 
+# FreeNX with ENABLE_SAMBA_PRELOAD="1" will automatically setup
+# port 445 and 139 and forward them to the used samba port.
+#
+# This enables samba browsing to the local subnet in for example 
+# konqueror.
+#
+#ENABLE_SAMBA_PRELOAD="0"
+
 #########################################################################
 # Path directives
 #########################################################################

Modified: trunk/freenx-server/nxloadconfig
===================================================================
--- trunk/freenx-server/nxloadconfig	2008-03-11 00:29:30 UTC (rev 514)
+++ trunk/freenx-server/nxloadconfig	2008-03-11 01:03:54 UTC (rev 515)
@@ -163,6 +163,7 @@
 CUPS_ETC="/etc/cups/"
 
 SAMBA_MOUNT_SHARE_PROTOCOL="both"
+ENABLE_SAMBA_PRELOAD="0"
 
 # Path directives
 

Modified: trunk/freenx-server/nxnode
===================================================================
--- trunk/freenx-server/nxnode	2008-03-11 00:29:30 UTC (rev 514)
+++ trunk/freenx-server/nxnode	2008-03-11 01:03:54 UTC (rev 515)
@@ -291,6 +291,14 @@
 	fi
 
 	[ "$cups" = "1" -a "$ENABLE_CUPS_SERVER_EXPORT" = "1" ] && export CUPS_SERVER="$USER_FAKE_HOME/.nx/C-$sess_id/cups/cups.sock"
+	
+	if [ "$ENABLE_SAMBA_PRELOAD" = "1" -a -x "$PATH_BIN/nxredir" ]
+	then
+		let NXSAMBA_PORT=$display+3000
+		export NXSAMBA_PORT
+		NODE_APPLICATION="$PATH_BIN/nxredir $NODE_APPLICATION"
+		echo "Info: NXNODE - Using nxredir wrapper script to forward SMB ports 139 and 445 to port $NXSAMBA_PORT." >> "$USER_FAKE_HOME/.nx/C-$sess_id/session"
+	fi
 
 	#
 	# Do we need to PRELOAD any libraries?



From fabianx at mail.berlios.de  Tue Mar 11 02:58:53 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Tue, 11 Mar 2008 02:58:53 +0100
Subject: [Freenx-cvs] r516 - trunk/freenx-server/nxredir
Message-ID: <200803110158.m2B1wrJL014955@sheep.berlios.de>

Author: fabianx
Date: 2008-03-11 02:58:52 +0100 (Tue, 11 Mar 2008)
New Revision: 516

Modified:
   trunk/freenx-server/nxredir/nxredir.c
Log:
Extended nxredir to only redirect 127.0.0.1:<port> and no other adresses.



Modified: trunk/freenx-server/nxredir/nxredir.c
===================================================================
--- trunk/freenx-server/nxredir/nxredir.c	2008-03-11 01:03:54 UTC (rev 515)
+++ trunk/freenx-server/nxredir/nxredir.c	2008-03-11 01:58:52 UTC (rev 516)
@@ -1,10 +1,28 @@
 /*
  * libnxredir - Redirect certain ports to other forwarded ports.
  *
- * Copyright (c) 2005 by Fabian Franz.
+ * Copyright (c) 2005-2008 by Fabian Franz <freenx at fabian-franz.de>.
  *
- * License: GPL
+ * License: GPL, version 2
  *
+ * Based on TSOCKS - Wrapper library for transparent SOCKS
+ *
+ * Copyright (C) 2000 Shaun Clowes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
  */
 
 char *progname = "libnxredir";              /* Name used in err msgs    */
@@ -45,20 +63,54 @@
         realconnect = dlsym(RTLD_NEXT, "connect");
 }
 
+int is_local(struct in_addr *testip) {
+
+	if (testip->s_addr == htonl(0x7f000001))
+		return(1);
+
+        return(0);
+}
+
 int connect(CONNECT_SIGNATURE) 
 {
+	struct sockaddr_in *connaddr;
+        struct sockaddr_in peer_address;
+        int sock_type = -1;
+        socklen_t sock_type_len = sizeof(sock_type);
+	socklen_t namelen = sizeof(peer_address);
+
 	if (realconnect == NULL) {
                 perror("Unresolved symbol: connect\n");
                 return(-1);
         }
 
+        connaddr = (struct sockaddr_in *) __addr;
+
+        /* Get the type of the socket */
+        getsockopt(__fd, SOL_SOCKET, SO_TYPE,
+                   (void *) &sock_type, &sock_type_len);
+
+        /* If this isn't an INET socket for a TCP stream we can't  */
+        /* handle it, just call the real connect now               */
+	if ((connaddr->sin_family != AF_INET) || (sock_type != SOCK_STREAM))
+                return(realconnect(__fd, __addr, __len));
+
+	/* If the socket is already connected, just call connect  */
+	/* and get its standard reply                             */
+	if (!getpeername(__fd, (struct sockaddr *) &peer_address, &namelen))
+		return(realconnect(__fd, __addr, __len));
+
+	/* If the address is not local call realconnect */
+	if (!is_local(&(connaddr->sin_addr)))
+		return(realconnect(__fd, __addr, __len));
+
 	/* CUPS */
-	if ((getenv("NXCUPS_PORT") != NULL) && ((struct sockaddr_in*)__addr)->sin_port==htons(631))
-		((struct sockaddr_in*)__addr)->sin_port=htons(atoi(getenv("NXCUPS_PORT")));
+	if ((getenv("NXCUPS_PORT") != NULL) && connaddr->sin_port==htons(631))
+		connaddr->sin_port=htons(atoi(getenv("NXCUPS_PORT")));
 
 	/* SAMBA */
-	if ((getenv("NXSAMBA_PORT") != NULL) && (((struct sockaddr_in*)__addr)->sin_port==htons(139) || ((struct sockaddr_in*)__addr)->sin_port==htons(445)))
-		((struct sockaddr_in*)__addr)->sin_port=htons(atoi(getenv("NXSAMBA_PORT")));
+	if ((getenv("NXSAMBA_PORT") != NULL) && (connaddr->sin_port==htons(139) || connaddr->sin_port==htons(445)))
+		connaddr->sin_port=htons(atoi(getenv("NXSAMBA_PORT")));
 
 	return realconnect(__fd, __addr, __len);
 }



From fabianx at mail.berlios.de  Tue Mar 11 06:55:38 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Tue, 11 Mar 2008 06:55:38 +0100
Subject: [Freenx-cvs] r517 - in trunk/freenx-server: . nxserver-helper
Message-ID: <200803110555.m2B5tc3d028551@sheep.berlios.de>

Author: fabianx
Date: 2008-03-11 06:55:27 +0100 (Tue, 11 Mar 2008)
New Revision: 517

Modified:
   trunk/freenx-server/ChangeLog
   trunk/freenx-server/node.conf.sample
   trunk/freenx-server/nxloadconfig
   trunk/freenx-server/nxnode
   trunk/freenx-server/nxserver
   trunk/freenx-server/nxserver-helper/nxserver-helper.c
Log:
* Made the slave mode finally functional. With that slave mode it is
 possible to do a single sign on instead of the multiple logins used
 before. It is also possible to use a suid wrapper to login as user.
 With single sign on session startup is a lot faster. This is true
 especially if there are many printers and files to be shared.
(fabianx at bat.berlios.de)

This is also the basis for importing nxserver_suid from redesign.



Modified: trunk/freenx-server/ChangeLog
===================================================================
--- trunk/freenx-server/ChangeLog	2008-03-11 01:58:52 UTC (rev 516)
+++ trunk/freenx-server/ChangeLog	2008-03-11 05:55:27 UTC (rev 517)
@@ -61,6 +61,12 @@
 	* Added usage of nxredir library to forward port 139,445 to the
 	  client side forwarded SMB port.
 	  (fabianx at bat.berlios.de)
+	* Made the slave mode finally functional. With that slave mode it is
+	  possible to do a single sign on instead of the multiple logins used
+	  before. It is also possible to use a suid wrapper to login as user.
+	  With single sign on session startup is a lot faster. This is true 
+	  especially if there are many printers and files to be shared.
+	  (fabianx at bat.berlios.de)
 
 14.10.2007 FreeNX 0.7.1 "Hip Hop Edition"
 	* Fixed the issue that makes fonts look tiny and unreadable by default 

Modified: trunk/freenx-server/node.conf.sample
===================================================================
--- trunk/freenx-server/node.conf.sample	2008-03-11 01:58:52 UTC (rev 516)
+++ trunk/freenx-server/node.conf.sample	2008-03-11 05:55:27 UTC (rev 517)
@@ -92,6 +92,19 @@
 #    is not provided.
 #SSHD_CHECK_IP="0"
 
+# If ENABLE_SLAVE_MODE="1" the user will be just logged in _once_ and the 
+# communication is done via nxnode slave mode.
+#
+# This is useful for one time passwords or to have less traffic in utmp 
+# and wtmp.
+#
+# Also session startup times are much faster in slave mode. This is true especially 
+# if many printers or shares have to be added.
+#
+# For this to work the binary nxserver-helper has to be installed in 
+# PATH_BIN.
+#
+#ENABLE_SLAVE_MODE="0"
 
 #########################################################################
 # Restriction directives

Modified: trunk/freenx-server/nxloadconfig
===================================================================
--- trunk/freenx-server/nxloadconfig	2008-03-11 01:58:52 UTC (rev 516)
+++ trunk/freenx-server/nxloadconfig	2008-03-11 05:55:27 UTC (rev 517)
@@ -98,6 +98,7 @@
 ENABLE_FORCE_ENCRYPTION="0"
 SSHD_CHECK_IP="0"
 
+ENABLE_SLAVE_MODE="0"
 
 # Restriction directives
 

Modified: trunk/freenx-server/nxnode
===================================================================
--- trunk/freenx-server/nxnode	2008-03-11 01:58:52 UTC (rev 516)
+++ trunk/freenx-server/nxnode	2008-03-11 05:55:27 UTC (rev 517)
@@ -26,8 +26,12 @@
 # -----------------------------------------------------------------------------
 #
 
-echo "NX> 1000 NXNODE - Version $NX_VERSION $NX_LICENSE"
+DELIM="NX>"
 
+[ -n "$2" ] && DELIM="NX-$2>"
+
+echo "$DELIM 1000 NXNODE - Version $NX_VERSION $NX_LICENSE"
+
 if [ "$1" != "--check" -a "$1" != "--setkey" -a "$1" != "--agent" -a "$1" != "--slave" ]
 then 
 	read CMDLINE
@@ -1300,7 +1304,7 @@
 cmd_node_terminate()
 {
 	sessionid=$(getparam_sessionid)
-	echo "NX> 716 Terminating session $sessionid on user request."
+	echo "$DELIM 716 Terminating session $sessionid on user request."
 	display=$(cd $USER_FAKE_HOME/.nx/; echo C-$SERVER_NAME-*-$sessionid | awk 'BEGIN {FS="-"} {i=NF-1; print $i}')
 	node_terminate_session "$SERVER_NAME-$display-$sessionid"
 }
@@ -1308,7 +1312,7 @@
 cmd_node_suspend()
 {
 	sessionid=$(getparam_sessionid)
-	echo "NX> 716 Suspending session $sessionid on user request."
+	echo "$DELIM 716 Suspending session $sessionid on user request."
 	display=$(cd $USER_FAKE_HOME/.nx/; echo C-$SERVER_NAME-*-$sessionid | awk 'BEGIN {FS="-"} {i=NF-1; print $i}') 
 	node_suspend_session "$SERVER_NAME-$display-$sessionid"
 }
@@ -1480,23 +1484,28 @@
 then
 	# New slave mode accepts more than 1 command at a time
 	echo "NX> 716 Slave mode started successfully."
-	
+	NODE_SESSION=""
+
 	while read CMD
 	do
-		set -- "$CMD"
-		if [ "$1" != "--check" -a "$1" != "--setkey" -a "$1" != "--agent" ]
+		[ "$CMD" = "--quit" ] && break
+		
+		if [ "$CMD" != "--check" -a "$CMD" != "--setkey" -a "$CMD" != "--agent" ]
 		then 
 			read CMDLINE
 
 			CMDLINE="a=b&$CMDLINE"
 		fi
 		
-		if [ "$1" = "--startsession" -o "$1" = "--resumesession" ]
+		if [ "$CMD" = "--startsession" -o "$CMD" = "--resumesession" ]
 		then
 			export SLAVE_PID=$$
 			( echo $CMDLINE | "$0" "$CMD"; kill $SLAVE_PID ) &
+			NODE_SESSION="$!"
 		else
-			( echo $CMDLINE | "$0" "$CMD" ) &
+			DELIM=""
+			[ -n "$NODE_SESSION" ] && DELIM="$NODE_SESSION->$CMD"
+			( echo $CMDLINE | "$0" "$CMD" "$DELIM" ) &
 		fi
 
 	done
@@ -1504,4 +1513,4 @@
 	nxnode_func "$@"
 fi
 
-echo "NX> 1001 Bye."
+echo "$DELIM 1001 Bye."

Modified: trunk/freenx-server/nxserver
===================================================================
--- trunk/freenx-server/nxserver	2008-03-11 01:58:52 UTC (rev 516)
+++ trunk/freenx-server/nxserver	2008-03-11 05:55:27 UTC (rev 517)
@@ -502,9 +502,15 @@
 {
 	if [ -n "$NXNODE_LOGIN_SLAVE" ]
 	then
+		log 3 "Info: Closing connection to slave with pid $NXNODE_LOGIN_SLAVE."
+		# send quit command
+		echo "--quit" >&$NX_COMM_FD
+
+		# kill process
 		kill "$NXNODE_LOGIN_SLAVE"
 		sleep 2
 		kill -0 "$NXNODE_LOGIN_SLAVE" && kill -9 "$NXNODE_LOGIN_SLAVE"
+		unset NXNODE_LOGIN_SLAVE
 	fi
 }
 
@@ -517,43 +523,58 @@
 	then
 		NXNODE_TOSEND="$NXNODE_TOSEND" echo $PASS | $PATH_BIN/nxnode-login "$@"
 	else
-		if [ -z "$NXNODE_LOGIN_SLAVE" ]
+		if [ -z "$NXNODE_LOGIN_SLAVE" -a -z "$NX_TRUSTED_USER" ]
 		then
 			# Send password
-			echo "$PASS" >&4 
+			echo "$PASS" >&$NX_COMM_FD
 
 			# Connect to NXNODE
 			
-			$PATH_BIN/nxnode-login "$1" "$2" "$3" "$4" "$5" "--slave" <&3 >&3 2>&3 &
+			( $PATH_BIN/nxnode-login "$1" "$2" "$3" "$4" "$5" "--slave" <&$NX_SERVER_FD >&$NX_SERVER_FD 2>&$NX_SERVER_FD || echo "FREENX> 716 Slave mode failed to start." >&$NX_SERVER_FD )  &
 			NXNODE_LOGIN_SLAVE="$!"
 			disown $!
 
 			trap nxnode_login_stop_slave EXIT
+
+			NXNODE_SLAVE_STARTED=""
 			
-			while read line <&4
+			# FIXME: Make timeout configurable
+			while read -t 10 line <&$NX_COMM_FD
 			do
 				log 6 "$line"
 				case "$line" in
 					"NX> 716 Slave mode started successfully.")
+						NXNODE_SLAVE_STARTED="1"
 						break
 					;;
+					"FREENX> 716 Slave mode failed to start.")
+						break
+					;;
 				esac
 			done
 
-			# TODO: KILL the slave node at end of session
+			if [ -z "$NXNODE_SLAVE_STARTED" ]
+			then
+				# stop it, if it still exists
+				nxnode_login_stop_slave 
+				unset NXNODE_LOGIN_SLAVE
+				# return an error
+				return 1
+			fi
 		fi
 		
 		#send CMD to nxnode
 		
-		echo "$6" >&4
-		[ -n "$NXNODE_TOSEND" ] && echo "$NXNODE_TOSEND" >&4
+		echo "$6" >&$NX_COMM_FD
+		[ -n "$NXNODE_TOSEND" ] && echo "$NXNODE_TOSEND" >&$NX_COMM_FD
 
 		NXNODE_RETURN="1"
 
 		if [ -z "$NXNODE_READER" ]
 		then
-			while read line <&4
+			while read line <&$NX_COMM_FD
 			do
+				log 6 "nxnode_reader: $line"
 				echo "$line"
 				case "$line" in
 					"NX> 716"*) 
@@ -575,8 +596,6 @@
 	NXNODE_READER="1"
 }
 
-#ENABLE_NXNODE_SLAVE_MODE="1"
-
 # Start!
 [ "$NX_LOG_LEVEL" -ge "1" ] && touch "$NX_LOGFILE" >/dev/null 2>&1
 log 3 "-- NX SERVER START: $@ - ORIG_COMMAND=$SSH_ORIGINAL_COMMAND"
@@ -606,20 +625,47 @@
 NXNODE_LOGIN_SLAVE_ENABLED="0"
 NXNODE_LOGIN_SLAVE=""
 
-if [ "$ENABLE_NXNODE_SLAVE_MODE" = "1" -a "$NXSERVER_HELPER_ACTIVE" != "1" ]
+if [ "$ENABLE_SLAVE_MODE" = "1" -a "$NXSERVER_HELPER_ACTIVE" != "1" ]
 then
 	export SSH_ORIGINAL_COMMAND
 	export NXSERVER_HELPER_ACTIVE="1"
 	exec $PATH_BIN/nxserver-helper "$0"
 	log 1 "Error: Execution of $PATH_BIN/nxserver-helper failed. Disabling slave mode of nxnode."
+	export NXSERVER_HELPER_ACTIVE="0"
 fi
 
-if [ "$ENABLE_NXNODE_SLAVE_MODE" = "1" -a "$NXSERVER_HELPER_ACTIVE" = "1" ]
+if [ "$ENABLE_SLAVE_MODE" = "1" -a "$NXSERVER_HELPER_ACTIVE" = "1" ]
 then
-	log 3 "Info: Using fds #3 and #4 for communication with nxnode."
+	log 3 "Info: Using fds #$NX_SERVER_FD and #$NX_COMM_FD for communication with nxnode."
 	NXNODE_LOGIN_SLAVE_ENABLED="1"
 fi
 
+if [ -n "$NX_TRUSTED_USER" -a -n "$NX_COMMFD" ]
+then
+	NXNODE_LOGIN_SLAVE_ENABLED="1"
+	USER=$NX_TRUSTED_USER
+	
+	# check that communication works
+	nxnode_login "" -- su "$USER" "" "$PATH_BIN/nxnode" --check 2>&1 >/dev/null
+
+	if [ $? -ne 0 ]
+	then
+		log 1 "Error: Could not establish communication with trusted user ($USER) nxnode."
+		echo_x "NX> 404 ERROR: wrong password or login"
+		echo_x "NX> 999 Bye"
+		exit 1
+	fi
+	
+	LOGIN_SUCCESS="1"
+	LOGIN_METHOD="SU"
+
+	log 3 "Info: Using fd #$NX_COMM_FD for communication with trusted user ($USER) established nxnode."
+	
+	# Reread the config files (so that $USER.node.conf get sourced)
+	. $(PATH=$(cd $(dirname $0) && pwd):$PATH which nxloadconfig) --userconf
+	echo_x "NX> 103 Welcome to: $SERVER_NAME user: $USER"
+else
+
 echo_x "HELLO NXSERVER - Version $NX_VERSION $NX_LICENSE"
 
 # Login stage
@@ -747,6 +793,11 @@
 	esac
 done
 
+fi
+
+# Add the slave mode shutdown trap (just in case)
+[ -n "$NXNODE_LOGIN_SLAVE" ] && trap nxnode_login_stop_slave EXIT
+
 # remove old session infos from history
 session_cleanup
 

Modified: trunk/freenx-server/nxserver-helper/nxserver-helper.c
===================================================================
--- trunk/freenx-server/nxserver-helper/nxserver-helper.c	2008-03-11 01:58:52 UTC (rev 516)
+++ trunk/freenx-server/nxserver-helper/nxserver-helper.c	2008-03-11 05:55:27 UTC (rev 517)
@@ -10,12 +10,27 @@
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
 
 int main(int argc, char* argv[])
 {
 	int fds[2];
+	char buf[1024];
 
 	socketpair(AF_UNIX, SOCK_STREAM, 0, fds);
+	
+	// This fd can be used by the server for spawning the node
+	snprintf(buf, 1022, "%d", fds[1]);
+	setenv("NX_SERVER_FD", buf, 1);
+	
+	// This fd can be used for communication with the node
+	snprintf(buf, 1022, "%d", fds[0]);
+	setenv("NX_COMM_FD", buf, 1);
+
+	// We do not trust this user, he still has to login
+	unsetenv("NX_TRUSTED_USER");
+
 	argv++;
 	execv(argv[0], argv);
 }



From fabianx at mail.berlios.de  Tue Mar 11 08:04:11 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Tue, 11 Mar 2008 08:04:11 +0100
Subject: [Freenx-cvs] r518 - trunk/freenx-redesign/server/utility
Message-ID: <200803110704.m2B74B6H019605@sheep.berlios.de>

Author: fabianx
Date: 2008-03-11 08:04:10 +0100 (Tue, 11 Mar 2008)
New Revision: 518

Modified:
   trunk/freenx-redesign/server/utility/nxserver-suid.c
Log:
- Fixed to drop all priviledges of previous user for user nx.
- Added a clean environment so the server cannot be manipulated.



Modified: trunk/freenx-redesign/server/utility/nxserver-suid.c
===================================================================
--- trunk/freenx-redesign/server/utility/nxserver-suid.c	2008-03-11 05:55:27 UTC (rev 517)
+++ trunk/freenx-redesign/server/utility/nxserver-suid.c	2008-03-11 07:04:10 UTC (rev 518)
@@ -15,7 +15,8 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  *
- * Author: alriddoch at google.com (Alistair Riddoch)
+ * Authors: alriddoch at google.com (Alistair Riddoch)
+ * 	    freenx at fabian-franz.de (Fabian Franz)
  */
 
 #include <sys/types.h>
@@ -36,7 +37,7 @@
 
 #define STRING_BUFLEN 512
 #define NXNODE_COMMAND "nxnode"
-#define NXSERVER_COMMAND "nxserver"
+#define NXSERVER_COMMAND "/usr/freenx/bin/nxserver"
 
 int launch_nxnode(uid_t user, int comm_fd)
 {
@@ -68,23 +69,61 @@
 {
     size_t env_string_length;
     char * env_string;
+    char ** new_env;
     char ** new_argv;
     int i;
 
+    // Really drop the user priviledges
+    setreuid(geteuid(), geteuid());
+   
+    // Setup a clean environment.
+    new_env = calloc(5+1, sizeof(char *));
+
+    i=0;
+	
     env_string_length = snprintf(0, 0, "%s=%s",
                                  "NX_TRUSTED_USER", username);
     env_string = malloc(env_string_length + 1);
     assert(env_string != NULL);
     sprintf(env_string, "%s=%s", "NX_TRUSTED_USER", username);
-    putenv(env_string);
+    new_env[i++] = env_string;
 
     env_string_length = snprintf(0, 0, "%s=%d",
                                  "NX_COMMFD", comm_fd);
     env_string = malloc(env_string_length + 1);
     assert(env_string != NULL);
     sprintf(env_string, "%s=%d", "NX_COMMFD", comm_fd);
-    putenv(env_string);
+    new_env[i++] = env_string;
+    
+    env_string_length = snprintf(0, 0, "%s=%s",
+                                 "USER", "nx");
+    env_string = malloc(env_string_length + 1);
+    assert(env_string != NULL);
+    sprintf(env_string, "%s=%s", "USER", "nx");
+    new_env[i++] = env_string;
+    
+    if (getenv("SSH_CLIENT") != NULL)
+    {
+    	env_string_length = snprintf(0, 0, "%s=%s",
+    	                             "SSH_CLIENT", getenv("SSH_CLIENT"));
+    	env_string = malloc(env_string_length + 1);
+    	assert(env_string != NULL);
+    	sprintf(env_string, "%s=%s", "SSH_CLIENT", getenv("SSH_CLIENT"));
+    	new_env[i++] = env_string;
+    }
+    
+    if (getenv("SSH_CLIENT2") != NULL)
+    {
+    	env_string_length = snprintf(0, 0, "%s=%s",
+    	                             "SSH_CLIENT2", getenv("SSH_CLIENT2"));
+    	env_string = malloc(env_string_length + 1);
+    	assert(env_string != NULL);
+    	sprintf(env_string, "%s=%s", "SSH_CLIENT2", getenv("SSH_CLIENT2"));
+    	new_env[i++] = env_string;
+    }
 
+    // Setup argv array
+    
     new_argv = calloc(argc + 1, sizeof(char *));
     new_argv[0] = NXSERVER_COMMAND;
 
@@ -92,7 +131,7 @@
         new_argv[i] = argv[i];
     }
 
-    return execvp(NXSERVER_COMMAND, new_argv);
+    return execve(NXSERVER_COMMAND, new_argv, new_env);
 }
 
 int main(int argc, char ** argv)



From fabianx at mail.berlios.de  Tue Mar 11 08:06:44 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Tue, 11 Mar 2008 08:06:44 +0100
Subject: [Freenx-cvs] r519 - in trunk/freenx-server: . nxserver-helper
Message-ID: <200803110706.m2B76ii5019810@sheep.berlios.de>

Author: fabianx
Date: 2008-03-11 08:06:43 +0100 (Tue, 11 Mar 2008)
New Revision: 519

Modified:
   trunk/freenx-server/nxserver
   trunk/freenx-server/nxserver-helper/nxserver-helper.c
Log:
Changed COMM_FD to COMMFD and SERVER_FD to SERVERFD to be compatible with redesign syntax.



Modified: trunk/freenx-server/nxserver
===================================================================
--- trunk/freenx-server/nxserver	2008-03-11 07:04:10 UTC (rev 518)
+++ trunk/freenx-server/nxserver	2008-03-11 07:06:43 UTC (rev 519)
@@ -504,7 +504,7 @@
 	then
 		log 3 "Info: Closing connection to slave with pid $NXNODE_LOGIN_SLAVE."
 		# send quit command
-		echo "--quit" >&$NX_COMM_FD
+		echo "--quit" >&$NX_COMMFD
 
 		# kill process
 		kill "$NXNODE_LOGIN_SLAVE"
@@ -526,11 +526,11 @@
 		if [ -z "$NXNODE_LOGIN_SLAVE" -a -z "$NX_TRUSTED_USER" ]
 		then
 			# Send password
-			echo "$PASS" >&$NX_COMM_FD
+			echo "$PASS" >&$NX_COMMFD
 
 			# Connect to NXNODE
 			
-			( $PATH_BIN/nxnode-login "$1" "$2" "$3" "$4" "$5" "--slave" <&$NX_SERVER_FD >&$NX_SERVER_FD 2>&$NX_SERVER_FD || echo "FREENX> 716 Slave mode failed to start." >&$NX_SERVER_FD )  &
+			( $PATH_BIN/nxnode-login "$1" "$2" "$3" "$4" "$5" "--slave" <&$NX_SERVERFD >&$NX_SERVERFD 2>&$NX_SERVERFD || echo "FREENX> 716 Slave mode failed to start." >&$NX_SERVERFD )  &
 			NXNODE_LOGIN_SLAVE="$!"
 			disown $!
 
@@ -539,7 +539,7 @@
 			NXNODE_SLAVE_STARTED=""
 			
 			# FIXME: Make timeout configurable
-			while read -t 10 line <&$NX_COMM_FD
+			while read -t 10 line <&$NX_COMMFD
 			do
 				log 6 "$line"
 				case "$line" in
@@ -565,14 +565,14 @@
 		
 		#send CMD to nxnode
 		
-		echo "$6" >&$NX_COMM_FD
-		[ -n "$NXNODE_TOSEND" ] && echo "$NXNODE_TOSEND" >&$NX_COMM_FD
+		echo "$6" >&$NX_COMMFD
+		[ -n "$NXNODE_TOSEND" ] && echo "$NXNODE_TOSEND" >&$NX_COMMFD
 
 		NXNODE_RETURN="1"
 
 		if [ -z "$NXNODE_READER" ]
 		then
-			while read line <&$NX_COMM_FD
+			while read line <&$NX_COMMFD
 			do
 				log 6 "nxnode_reader: $line"
 				echo "$line"
@@ -625,7 +625,7 @@
 NXNODE_LOGIN_SLAVE_ENABLED="0"
 NXNODE_LOGIN_SLAVE=""
 
-if [ "$ENABLE_SLAVE_MODE" = "1" -a "$NXSERVER_HELPER_ACTIVE" != "1" ]
+if [ "$ENABLE_SLAVE_MODE" = "1" -a "$NXSERVER_HELPER_ACTIVE" != "1" -a -z "$NX_TRUSTED_USER" ]
 then
 	export SSH_ORIGINAL_COMMAND
 	export NXSERVER_HELPER_ACTIVE="1"
@@ -636,7 +636,7 @@
 
 if [ "$ENABLE_SLAVE_MODE" = "1" -a "$NXSERVER_HELPER_ACTIVE" = "1" ]
 then
-	log 3 "Info: Using fds #$NX_SERVER_FD and #$NX_COMM_FD for communication with nxnode."
+	log 3 "Info: Using fds #$NX_SERVERFD and #$NX_COMMFD for communication with nxnode."
 	NXNODE_LOGIN_SLAVE_ENABLED="1"
 fi
 
@@ -659,7 +659,7 @@
 	LOGIN_SUCCESS="1"
 	LOGIN_METHOD="SU"
 
-	log 3 "Info: Using fd #$NX_COMM_FD for communication with trusted user ($USER) established nxnode."
+	log 3 "Info: Using fd #$NX_COMMFD for communication with trusted user ($USER) established nxnode."
 	
 	# Reread the config files (so that $USER.node.conf get sourced)
 	. $(PATH=$(cd $(dirname $0) && pwd):$PATH which nxloadconfig) --userconf

Modified: trunk/freenx-server/nxserver-helper/nxserver-helper.c
===================================================================
--- trunk/freenx-server/nxserver-helper/nxserver-helper.c	2008-03-11 07:04:10 UTC (rev 518)
+++ trunk/freenx-server/nxserver-helper/nxserver-helper.c	2008-03-11 07:06:43 UTC (rev 519)
@@ -22,11 +22,11 @@
 	
 	// This fd can be used by the server for spawning the node
 	snprintf(buf, 1022, "%d", fds[1]);
-	setenv("NX_SERVER_FD", buf, 1);
+	setenv("NX_SERVERFD", buf, 1);
 	
 	// This fd can be used for communication with the node
 	snprintf(buf, 1022, "%d", fds[0]);
-	setenv("NX_COMM_FD", buf, 1);
+	setenv("NX_COMMFD", buf, 1);
 
 	// We do not trust this user, he still has to login
 	unsetenv("NX_TRUSTED_USER");



From fabianx at mail.berlios.de  Wed Mar 12 04:40:07 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Wed, 12 Mar 2008 04:40:07 +0100
Subject: [Freenx-cvs] r520 - trunk/freenx-client/nxcl/lib
Message-ID: <200803120340.m2C3e7DK011370@sheep.berlios.de>

Author: fabianx
Date: 2008-03-12 04:40:04 +0100 (Wed, 12 Mar 2008)
New Revision: 520

Modified:
   trunk/freenx-client/nxcl/lib/notQt.cpp
   trunk/freenx-client/nxcl/lib/notQt.h
   trunk/freenx-client/nxcl/lib/nxclientlib.cpp
   trunk/freenx-client/nxcl/lib/nxsession.cpp
Log:
Added usage of nxproxy with NX_COMMFD set to some filedescriptor to be able to have encrypted sessions over standard ssh without using nxssh.

Still todo:

- Remove workaround for sleep 2 race condition.
- create id.key with mode 600 as else ssh does not accept it.
- Try out user only mode with nxserver_suid.



Modified: trunk/freenx-client/nxcl/lib/notQt.cpp
===================================================================
--- trunk/freenx-client/nxcl/lib/notQt.cpp	2008-03-11 07:06:43 UTC (rev 519)
+++ trunk/freenx-client/nxcl/lib/notQt.cpp	2008-03-12 03:40:04 UTC (rev 520)
@@ -26,6 +26,7 @@
 #include <sys/wait.h>
 #include <sys/stat.h>
 #include <sys/poll.h>	
+#include <sys/socket.h>	
 #include <signal.h>
 }
 
@@ -52,7 +53,8 @@
     progName("unknown"),
     error (NOTQPROCNOERROR),
     pid(0),
-    signalledStart(false)
+    signalledStart(false),
+    parentFD(-1)
 {
     // Set up the polling structs
     this->p = static_cast<struct pollfd*>(malloc (2*sizeof (struct pollfd)));	
@@ -62,6 +64,15 @@
 notQProcess::~notQProcess ()
 {
     free (this->p);
+    if (parentFD != -1)
+    {
+    	close(parentFD);
+	parentFD=-1;
+    }
+    // FIXME: this should be closed here
+   // close (parentToChild[READING_END]);
+   // close (childToParent[WRITING_END]);
+   // close (childErrToParent[WRITING_END]);
 }
 
     void
@@ -84,10 +95,18 @@
     // NB: The first item in the args list should be the program name.
     this->progName = program;
 
+#ifdef NXCL_USE_NXSSH
     // Set up our pipes
     if (pipe(parentToChild) == -1 || pipe(childToParent) == -1 || pipe(childErrToParent) == -1) {
         return NOTQTPROCESS_FAILURE;
     }
+#else /* We need a socketpair for that to work */
+    if (socketpair(AF_UNIX, SOCK_STREAM, 0, parentToChild) == -1 || pipe(childErrToParent) == -1)
+        return NOTQTPROCESS_FAILURE;
+    
+    childToParent[READING_END]=dup(parentToChild[WRITING_END]);
+    childToParent[WRITING_END]=dup(parentToChild[READING_END]);
+#endif
 
     this->pid = fork();
 

Modified: trunk/freenx-client/nxcl/lib/notQt.h
===================================================================
--- trunk/freenx-client/nxcl/lib/notQt.h	2008-03-11 07:06:43 UTC (rev 519)
+++ trunk/freenx-client/nxcl/lib/notQt.h	2008-03-12 03:40:04 UTC (rev 520)
@@ -117,7 +117,19 @@
 		pid_t getPid (void) { return this->pid; }
 		int getError (void) { return this->error; }
 		void setError (int e) { this->error = e; }
+		
+		int getParentFD() 
+		{ 
+			this->parentFD = this->parentToChild[1];
+			close(this->childToParent[0]);
 
+			// Create new pipes
+			pipe(this->parentToChild);
+			pipe(this->childToParent);
+
+			return this->parentFD;
+		}
+
 		/*!
 		 * Setter for the callbacks.
 		 */
@@ -180,6 +192,11 @@
 		 * Pointer to a callback object
 		 */
 		notQProcessCallbacks * callbacks;
+
+		/*! 
+		 * old parent FD for comm with child
+		 */
+		int parentFD;
 	};
 
 	/*!

Modified: trunk/freenx-client/nxcl/lib/nxclientlib.cpp
===================================================================
--- trunk/freenx-client/nxcl/lib/nxclientlib.cpp	2008-03-11 07:06:43 UTC (rev 519)
+++ trunk/freenx-client/nxcl/lib/nxclientlib.cpp	2008-03-12 03:40:04 UTC (rev 520)
@@ -8,7 +8,8 @@
                          :     Author: Sebastian James
                          : (C) 2008 Defuturo Ltd
                          :     Author: George Wright
-    email                : seb at esfnet.co.uk, gwright at kde.org
+                         : (C) 2008 Fabian Franz
+    email                : seb at esfnet.co.uk, gwright at kde.org, freenx at fabian-franz.de
  ***************************************************************************/
 
 /***************************************************************************
@@ -28,6 +29,14 @@
 
 #include <fstream>
 
+// Define to use nxssh
+#if defined(NXCL_CYGWIN) || defined(NXCL_DARWIN)
+
+// FF-FIXME That does not work.
+//#define NXCL_USE_NXSSH 1
+
+#endif
+
 extern "C" {
     #include <errno.h>
     #include <sys/types.h>
@@ -186,10 +195,14 @@
 
     // Start to build the arguments for the nxssh command.
     // notQProcess requires that argv[0] contains the program name
+#ifdef NXCL_USE_NXSSH
     arguments.push_back ("nxssh");
 
     argtmp << "-nx";
     arguments.push_back (argtmp.str());
+#else
+    arguments.push_back ("ssh");
+#endif
 
     argtmp.str("");
     argtmp << "-p" << port;
@@ -215,6 +228,7 @@
     }
 
     argtmp.str("");
+    // FF-FIXME: Perhaps the user wants to login as user directly
     argtmp << "nx@" << serverHost;
     arguments.push_back (argtmp.str());
 
@@ -227,9 +241,13 @@
     arguments.push_back ("-oRSAAuthentication no");
     arguments.push_back ("-oRhostsRSAAuthentication no");
     arguments.push_back ("-oPubkeyAuthentication yes");
+    // FF-FIXME: Perhaps the user wants to login as user directly
+    //arguments.push_back ("-c nxserver");
 
     if (encryption == true) {
+#ifdef NXCL_USE_NXSSH
         arguments.push_back("-B");
+#endif
         session.setEncryption (true);
     } else {
         session.setEncryption (false);
@@ -240,10 +258,16 @@
     // nxssh -E gives this message when called:
     // NX> 285 Enabling skip of SSH config files
     // ...so there you have the meaning.
+#ifdef NXCL_USE_NXSSH
     arguments.push_back ("-E");
+#endif
 
     // Find a path for the nxssh process using getPath()
+#ifdef NXCL_USE_NXSSH
     string nxsshPath = this->getPath ("nxssh");
+#else
+    string nxsshPath = this->getPath ("ssh");
+#endif
 
     this->nxsshProcess->start(nxsshPath, arguments);
 
@@ -365,8 +389,9 @@
 
         // On some connections this is sent via stdout instead of stderr?
         if (proxyData.encrypted && readyForProxy &&
-                ((*msgiter).find("NX> 999 Bye")!=string::npos)) {
-
+                ((*msgiter).find("NX> 999 Bye")!=string::npos)) 
+#ifdef NXCL_USE_NXSSH
+	{
             // This is "NX> 299 Switching connection to: " in
             // version 1.5.0. This was changed in nxssh version
             // 2.0.0-8 (see the nxssh CHANGELOG).
@@ -388,6 +413,11 @@
             this->externalCallbacks->connectedSuccessfullySignal();
             this->sessionRunning = true;
         }
+#else /* don't use nxssh, start nxproxy -stdin */
+	{
+		invokeProxy();
+	}
+#endif
 
         if ((*msgiter).find("Password") != string::npos) {
             this->externalCallbacks->write
@@ -402,6 +432,9 @@
                 dbgln ("NXClientLib::processParseStdout: Got auth failed"
                         " or capacity reached, calling this->parseSSH.");
                 msg = this->parseSSH (*msgiter);
+#ifndef NXCL_USE_NXSSH
+		this->isFinished = true;
+#endif
             }
             if (msg.size() > 0) {
                 this->write (msg);
@@ -436,7 +469,9 @@
                 + (*msgiter) + "'(end msg)");
 
         if (proxyData.encrypted && readyForProxy &&
-                ((*msgiter).find("NX> 999 Bye") != string::npos)) {
+                ((*msgiter).find("NX> 999 Bye") != string::npos)) 
+#ifdef NXCL_USE_NXSSH
+	{
 
             string switchCommand = "NX> 299 Switch connection to: ";
             stringstream ss;
@@ -478,6 +513,11 @@
                  _("SSH host key verification failed"));
             this->isFinished = true;
         }
+#else /* don't use nxssh, use nxproxy -stdin */
+	{
+		invokeProxy();
+	}
+#endif
     }
 }
 
@@ -580,21 +620,41 @@
         this->externalCallbacks->serverCapacitySignal();
         this->isFinished = true;
 
-    } else if
+    } 
+#ifdef NXCL_USE_NXSSH
+    else if
         (message.find ("NX> 204 Authentication failed.") != string::npos) {
 
         this->externalCallbacks->write
             (204, _("NX SSH Authentication Failed, finishing"));
         this->isFinished = true;
     }
+#endif
 
     if (message.find("NX> 710 Session status: running") != string::npos) {
 
         this->externalCallbacks->write
             (710, _("Session status is \"running\""));
+    }
+
+    // FF-FIXME: This is technically incorrect as the proxy is just ready once 1002 and 1006 have 
+    // been sent.
+    if (message.find("NX> 710 Session status: running") != string::npos) {
+        
+	//this->externalCallbacks->write
+        //    (1006, _("Session status is \"running\""));
+
+#ifdef NXCL_USE_NXSSH
         invokeProxy();
+#else
+	if (!proxyData.encrypted)
+        	invokeProxy();
+#endif
         session.wipeSessions();
-        rMessage = "bye\n";
+        if (proxyData.encrypted)
+	        rMessage = "bye\n";
+	else
+	        rMessage = "quit\n";
     }
 
     return rMessage;
@@ -700,18 +760,24 @@
     stringstream data;
  
     if (proxyData.encrypted) {
+#ifdef NXCL_USE_NXSSH
         data << "nx/nx" << x11Display << ",session=session,encryption=1,cookie="
             << proxyData.cookie
             << ",id=" << proxyData.id << ",listen=" 
             << proxyData.port << ":" << proxyData.display << "\n";
         // may also need shmem=1,shpix=1,font=1,product=...
+#else
+	data << "nx/nx" << x11Display << ",session=session,encryption=1,cookie="
+            << proxyData.cookie
+            << ",id=" << proxyData.id << ":" << proxyData.display << "\n";
+#endif
 
     } else {
-        // Not tested yet
+        // Not tested yet, FF-FIXME: Test
         data << "nx/nx" << x11Display << ",session=session,cookie=" << proxyData.cookie
-            << ",id=" << proxyData.id
-            // << ",connect=" << proxyData.server << ":" << proxyData.display
-            << ",listen=" << proxyData.port << ":" << proxyData.display
+            << ",connect=" << proxyData.server << ":" << proxyData.port
+            << ",id=" << proxyData.id << ":" << proxyData.display
+            //<< ",listen=" << proxyData.port << ":" << proxyData.display
             << "\n";
     }
 
@@ -726,11 +792,24 @@
     list<string> arguments;
     arguments.push_back("nxproxy"); // argv[0] has to be the program name
     arguments.push_back("-S");
+
     ss.str("");
-    ss << "options=" << nxdir;
-    ss << ":" << proxyData.display;
-    arguments.push_back(ss.str());	
+    ss << "nx/nx,options=" << nxdir << ":" << proxyData.display;
 
+    setenv("NX_DISPLAY", ss.str().c_str(), 1);
+
+#ifndef NXCL_USE_NXSSH
+    if (proxyData.encrypted)
+    {
+    	ss.str("");
+    	ss << this->nxsshProcess->getParentFD();
+	fprintf(stderr, "NX_COMMFD=%d", this->nxsshProcess->getParentFD());
+    	setenv("NX_COMMFD", ss.str().c_str(), 1);
+	// FF-FIXME: need to wait for 2 secs due to race condition with "bye" in buffer
+	sleep(2);
+    }
+#endif
+
     // Find a path for the nxproxy process using getPath()
     string nxproxyPath = this->getPath ("nxproxy");
     this->nxproxyProcess->start(nxproxyPath, arguments);

Modified: trunk/freenx-client/nxcl/lib/nxsession.cpp
===================================================================
--- trunk/freenx-client/nxcl/lib/nxsession.cpp	2008-03-11 07:06:43 UTC (rev 519)
+++ trunk/freenx-client/nxcl/lib/nxsession.cpp	2008-03-12 03:40:04 UTC (rev 520)
@@ -69,6 +69,7 @@
     int response = parseResponse (message);
     string returnMessage;
 
+#ifdef NXCL_USE_NXSSH
     if (response == 211) {
         if (doSSH == true) {
             returnMessage = "yes";
@@ -80,6 +81,7 @@
     if (response == 204) { // Authentication failed
         returnMessage = "204";
     }
+#endif
 
     if (response == 147) { // Server capacity reached
         returnMessage = "147";
@@ -90,6 +92,17 @@
         case HELLO_NXCLIENT:
             dbgln ("HELLO_NXCLIENT stage");
 
+	    if (message.find("Are you sure you want to continue connecting (yes/no)?") != string::npos)
+            	returnMessage = "yes"; // FF-FIXME: Or 211?
+	    
+	    if (message.find("assword") != string::npos)
+            	returnMessage = nxPassword; // FF-FIXME: -> What to do? What to do?
+	    
+	    if (message.find("Permission denied") != string::npos || 
+	            message.find("su: Authentication failure") != string::npos || 
+		    message.find("Unknown id:") != string::npos)
+                returnMessage = "204"; // Authentication failed
+
             if (message.find("HELLO NXSERVER - Version") != string::npos) {
                 this->callbacks->authenticatedSignal();
                 returnMessage = "hello NXCLIENT - Version ";



From fabianx at mail.berlios.de  Fri Mar 14 10:58:18 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Fri, 14 Mar 2008 10:58:18 +0100
Subject: [Freenx-cvs] r521 - trunk/freenx-server
Message-ID: <200803140958.m2E9wIiP030464@sheep.berlios.de>

Author: fabianx
Date: 2008-03-14 10:58:17 +0100 (Fri, 14 Mar 2008)
New Revision: 521

Modified:
   trunk/freenx-server/ChangeLog
   trunk/freenx-server/gentoo-nomachine.diff
   trunk/freenx-server/nxloadconfig
Log:
* Added detection of backend version and added this output
  to version string.
  (fabianx at bat.berlios.de)


Modified: trunk/freenx-server/ChangeLog
===================================================================
--- trunk/freenx-server/ChangeLog	2008-03-12 03:40:04 UTC (rev 520)
+++ trunk/freenx-server/ChangeLog	2008-03-14 09:58:17 UTC (rev 521)
@@ -67,6 +67,9 @@
 	  With single sign on session startup is a lot faster. This is true 
 	  especially if there are many printers and files to be shared.
 	  (fabianx at bat.berlios.de)
+	* Added detection of backend version and added this output 
+	  to version string.
+	  (fabianx at bat.berlios.de)
 
 14.10.2007 FreeNX 0.7.1 "Hip Hop Edition"
 	* Fixed the issue that makes fonts look tiny and unreadable by default 

Modified: trunk/freenx-server/gentoo-nomachine.diff
===================================================================
--- trunk/freenx-server/gentoo-nomachine.diff	2008-03-12 03:40:04 UTC (rev 520)
+++ trunk/freenx-server/gentoo-nomachine.diff	2008-03-14 09:58:17 UTC (rev 521)
@@ -1,7 +1,7 @@
 --- nxloadconfig.old	2005-02-14 01:08:56.482546352 +0100
 +++ nxloadconfig	2005-02-14 01:09:40.109913984 +0100
 @@ -56,12 +56,12 @@
- NX_LICENSE="OS (GPL)"
+ NX_LICENSE="OS (GPL, using backend: %BACKEND%)"
  
  # Where can different nx components be found
 -NX_DIR=/usr

Modified: trunk/freenx-server/nxloadconfig
===================================================================
--- trunk/freenx-server/nxloadconfig	2008-03-12 03:40:04 UTC (rev 520)
+++ trunk/freenx-server/nxloadconfig	2008-03-14 09:58:17 UTC (rev 521)
@@ -53,7 +53,7 @@
 #########################################################################
 
 NX_VERSION=2.1.0-72-SVN
-NX_LICENSE="OS (GPL)"
+NX_LICENSE="OS (GPL, using backend: %BACKEND%)"
 
 # Where can different nx components be found
 NX_DIR=/usr
@@ -301,9 +301,17 @@
 [ -z "$PROXY_LIBRARY_PATH" ] && PROXY_LIBRARY_PATH=$PATH_LIB
 [ -z "$APPLICATION_LIBRARY_PATH" ] && APPLICATION_LIBRARY_PATH=$PATH_LIB
 [ -z "$APPLICATION_LIBRARY_PRELOAD" ] && APPLICATION_LIBRARY_PRELOAD="$APPLICATION_LIBRARY_PATH/libX11.so.6.2:$APPLICATION_LIBRARY_PATH/libXext.so.6.4:$APPLICATION_LIBRARY_PATH/libXcomp.so:$APPLICATION_LIBRARY_PATH/libXcompext.so:$APPLICATION_LIBRARY_PATH/libXrender.so.1.2"
+
+NX_BACKEND_VERSION=$(strings $PATH_BIN/nxagent 2>/dev/null | egrep 'NXAGENT - Version' | sed 's/.*Version //g')
+
+[ "$ENABLE_1_5_0_BACKEND" = "1" ] && NX_BACKEND_VERSION="1.5.0" # forced the backend
+
+[ -z "$NX_BACKEND_VERSION" ] && NX_BACKEND_VERSION="not detected"
+NX_LICENSE=$(echo $NX_LICENSE | sed "s/%BACKEND%/$NX_BACKEND_VERSION/g")
+
 if [ -z "$ENABLE_1_5_0_BACKEND" ]
 then
-	[ -n "$(strings $PATH_BIN/nxagent 2>/dev/null | egrep 'NXAGENT - Version 1.5.0')" ] && ENABLE_1_5_0_BACKEND="1"
+	[ "$NX_BACKEND_VERSION" = "1.5.0" ] && ENABLE_1_5_0_BACKEND="1"
 fi
 
 if [ "$ENABLE_KDE_CUPS" = "1" ]



From fabianx at mail.berlios.de  Fri Mar 14 11:03:45 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Fri, 14 Mar 2008 11:03:45 +0100
Subject: [Freenx-cvs] r522 - trunk/freenx-server
Message-ID: <200803141003.m2EA3j56031010@sheep.berlios.de>

Author: fabianx
Date: 2008-03-14 11:03:44 +0100 (Fri, 14 Mar 2008)
New Revision: 522

Modified:
   trunk/freenx-server/ChangeLog
   trunk/freenx-server/nxloadconfig
Log:
* Added foomatic-ppdfile to the retested values.
  (fabianx at bat.berlios.de)



Modified: trunk/freenx-server/ChangeLog
===================================================================
--- trunk/freenx-server/ChangeLog	2008-03-14 09:58:17 UTC (rev 521)
+++ trunk/freenx-server/ChangeLog	2008-03-14 10:03:44 UTC (rev 522)
@@ -70,6 +70,8 @@
 	* Added detection of backend version and added this output 
 	  to version string.
 	  (fabianx at bat.berlios.de)
+	* Added foomatic-ppdfile to the retested values.
+	  (fabianx at bat.berlios.de)
 
 14.10.2007 FreeNX 0.7.1 "Hip Hop Edition"
 	* Fixed the issue that makes fonts look tiny and unreadable by default 

Modified: trunk/freenx-server/nxloadconfig
===================================================================
--- trunk/freenx-server/nxloadconfig	2008-03-14 09:58:17 UTC (rev 521)
+++ trunk/freenx-server/nxloadconfig	2008-03-14 10:03:44 UTC (rev 522)
@@ -269,6 +269,7 @@
 then
 	{ ! mywhich "$COMMAND_XAUTH" && which xauth; } >/dev/null 2>&1 && COMMAND_XAUTH=$(which xauth)
 	{ ! mywhich "$COMMAND_NETCAT" && which nc; } >/dev/null 2>&1 && COMMAND_NETCAT=$(which nc)
+	{ ! mywhich "$COMMAND_FOOMATIC" && which foomatic-ppdfile; } >/dev/null 2>&1 && COMMAND_FOOMATIC=$(which foomatic-ppdfile)
 	{ ! mywhich "$PATH_BIN/nxdesktop"; } >/dev/null 2>&1 && ENABLE_EXTERNAL_NXDESKTOP="1"
 	{ ! mywhich "$PATH_BIN/nxviewer"; } >/dev/null 2>&1 && ENABLE_EXTERNAL_NXVIEWER="1"
 	{ ! mywhich "$COMMAND_VNCPASSWD" && which vncpasswd; } >/dev/null 2>&1 && COMMAND_VNCPASSWD=$(which vncpasswd)



From fabianx at mail.berlios.de  Fri Mar 14 11:32:17 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Fri, 14 Mar 2008 11:32:17 +0100
Subject: [Freenx-cvs] r523 - trunk/freenx-server
Message-ID: <200803141032.m2EAWH4I000447@sheep.berlios.de>

Author: fabianx
Date: 2008-03-14 11:32:16 +0100 (Fri, 14 Mar 2008)
New Revision: 523

Modified:
   trunk/freenx-server/ChangeLog
   trunk/freenx-server/node.conf.sample
   trunk/freenx-server/nxloadconfig
Log:
* Added possibility to balance all nx services to different cores
  using taskset. Use for example USE_PROCESSOR_TASKSET="3,4" to
  balance all services to processor cores 3 and 4.
  This wish was granted for Gregory Carter.
  (fabianx at bat.berlios.de)



Modified: trunk/freenx-server/ChangeLog
===================================================================
--- trunk/freenx-server/ChangeLog	2008-03-14 10:03:44 UTC (rev 522)
+++ trunk/freenx-server/ChangeLog	2008-03-14 10:32:16 UTC (rev 523)
@@ -72,6 +72,11 @@
 	  (fabianx at bat.berlios.de)
 	* Added foomatic-ppdfile to the retested values.
 	  (fabianx at bat.berlios.de)
+	* Added possibility to balance all nx services to different cores
+	  using taskset. Use for example USE_PROCESSOR_TASKSET="3,4" to 
+	  balance all services to processor cores 3 and 4.
+	  This wish was granted for Gregory Carter.
+	  (fabianx at bat.berlios.de)
 
 14.10.2007 FreeNX 0.7.1 "Hip Hop Edition"
 	* Fixed the issue that makes fonts look tiny and unreadable by default 

Modified: trunk/freenx-server/node.conf.sample
===================================================================
--- trunk/freenx-server/node.conf.sample	2008-03-14 10:03:44 UTC (rev 522)
+++ trunk/freenx-server/node.conf.sample	2008-03-14 10:32:16 UTC (rev 523)
@@ -180,6 +180,23 @@
 #
 #ENABLE_PULLDOWN_MENU="1"
 
+
+# The option USE_PROCESSOR_TASKSET is for setting the CPU affinity of all
+# nx related processes.
+#
+# Note: To have for example startkde run on even another core, just specify:
+#
+# COMMAND_STARTKDE="taskset -c 2 -- startkde"
+#
+# FreeNX runs this option like: $COMMAND_TASKSET -cp "$USE_PROCESSOR_TASKSET" $$
+# 
+# So with $USE_PROCESSOR_TASKSET set to 3,4 it would balance the tasks to cores
+# 3 and 4.
+#
+# If this option is empty, no balance to cores is done.
+#
+#USE_PROCESSOR_TASKSET=""
+
 #########################################################################
 # Logging directives
 #########################################################################
@@ -475,6 +492,9 @@
 # The key that contains the name of the complete path of the 'x11vnc' command.
 #COMMAND_X11VNC=x11vnc
 
+# The key that contains the name of the complete path of the 'taskset' command.
+#COMMAND_TASKSET=taskset
+
 #########################################################################
 # Misc directives
 #########################################################################

Modified: trunk/freenx-server/nxloadconfig
===================================================================
--- trunk/freenx-server/nxloadconfig	2008-03-14 10:03:44 UTC (rev 522)
+++ trunk/freenx-server/nxloadconfig	2008-03-14 10:32:16 UTC (rev 523)
@@ -116,6 +116,8 @@
 ENABLE_CLIPBOARD="both"
 ENABLE_PULLDOWN_MENU="1"
 
+USE_PROCESSOR_TASKSET=""
+
 # Logging directives
 
 NX_LOG_LEVEL=0
@@ -194,6 +196,7 @@
 COMMAND_VNCVIEWER="vncviewer"
 COMMAND_VNCPASSWD="$PATH_BIN/nxpasswd"
 COMMAND_X11VNC="x11vnc"
+COMMAND_TASKSET="taskset"
 
 # Misc directives
 
@@ -322,6 +325,9 @@
 	[ -z "$KDE_PRINTRC" -o ! -r "$KDE_PRINTRC" ] && KDE_PRINTRC="$HOME/.kde/share/config/kdeprintrc"
 fi
 
+# Load balance to some other core if specified
+[ -n "$USE_PROCESSOR_TASKSET" ] && $COMMAND_TASKSET -cp "$USE_PROCESSOR_TASKSET" $$
+
 #########################################################################
 # Support for --check
 #########################################################################



From fabianx at mail.berlios.de  Fri Mar 14 16:03:45 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Fri, 14 Mar 2008 16:03:45 +0100
Subject: [Freenx-cvs] r524 - trunk/freenx-server
Message-ID: <200803141503.m2EF3j8L017882@sheep.berlios.de>

Author: fabianx
Date: 2008-03-14 16:03:44 +0100 (Fri, 14 Mar 2008)
New Revision: 524

Modified:
   trunk/freenx-server/ChangeLog
   trunk/freenx-server/node.conf.sample
   trunk/freenx-server/nxloadconfig
   trunk/freenx-server/nxnode
   trunk/freenx-server/nxserver
Log:
* Added initial code to add an application to an already running
rootless session.
Set ENABLE_ADVANCED_SESSION_CONTROL="1" and use session name
like "add <sessionname>". Unfortunately the client returns an
error, but the application is started anyway.
(fabianx at bat.berlios.de)



Modified: trunk/freenx-server/ChangeLog
===================================================================
--- trunk/freenx-server/ChangeLog	2008-03-14 10:32:16 UTC (rev 523)
+++ trunk/freenx-server/ChangeLog	2008-03-14 15:03:44 UTC (rev 524)
@@ -77,6 +77,12 @@
 	  balance all services to processor cores 3 and 4.
 	  This wish was granted for Gregory Carter.
 	  (fabianx at bat.berlios.de)
+	* Added initial code to add an application to an already running
+	  rootless session.
+	  Set ENABLE_ADVANCED_SESSION_CONTROL="1" and use session name
+	  like "add <sessionname>". Unfortunately the client returns an
+	  error, but the application is started anyway.
+	  (fabianx at bat.berlios.de)
 
 14.10.2007 FreeNX 0.7.1 "Hip Hop Edition"
 	* Fixed the issue that makes fonts look tiny and unreadable by default 

Modified: trunk/freenx-server/node.conf.sample
===================================================================
--- trunk/freenx-server/node.conf.sample	2008-03-14 10:32:16 UTC (rev 523)
+++ trunk/freenx-server/node.conf.sample	2008-03-14 15:03:44 UTC (rev 524)
@@ -197,6 +197,14 @@
 #
 #USE_PROCESSOR_TASKSET=""
 
+# If you set ENABLE_ADVANCED_SESSION_CONTROL="1" you can start a new application in an already
+# running rootless session by using "add <rest of name>" as session name.
+#
+# Note: The client will return a message on that.
+#
+#ENABLE_ADVANCED_SESSION_CONTROL="0"
+
+
 #########################################################################
 # Logging directives
 #########################################################################

Modified: trunk/freenx-server/nxloadconfig
===================================================================
--- trunk/freenx-server/nxloadconfig	2008-03-14 10:32:16 UTC (rev 523)
+++ trunk/freenx-server/nxloadconfig	2008-03-14 15:03:44 UTC (rev 524)
@@ -118,6 +118,8 @@
 
 USE_PROCESSOR_TASKSET=""
 
+ENABLE_ADVANCED_SESSION_CONTROL="0"
+
 # Logging directives
 
 NX_LOG_LEVEL=0

Modified: trunk/freenx-server/nxnode
===================================================================
--- trunk/freenx-server/nxnode	2008-03-14 10:32:16 UTC (rev 523)
+++ trunk/freenx-server/nxnode	2008-03-14 15:03:44 UTC (rev 524)
@@ -253,7 +253,7 @@
 	. /etc/profile
 	[ -f ~/.bash_profile ] && . ~/.bash_profile
 
-	mkdir -p "$USER_FAKE_HOME/.nx/C-$sess_id/pids/"
+	mkdir -p "$USER_FAKE_HOME/.nx/C-$sess_id/pids/apps/"
 
 	#
 	# Which application do we start?
@@ -330,7 +330,7 @@
 	NODE_APP_PID=$!
 	
 	mkdir -p "$USER_FAKE_HOME/.nx/C-$sess_id/pids/"
-	echo "$NODE_APP_PID" >"$USER_FAKE_HOME/.nx/C-$sess_id/pids/applications"
+	echo "$NODE_APP_PID" >"$USER_FAKE_HOME/.nx/C-$sess_id/pids/apps/$NODE_APP_PID"
 	wait $NODE_APP_PID
 
 	#
@@ -344,7 +344,7 @@
 		# or just wait until it finishes?
 		[ "$KILL_DEFAULT_X_WM" = "1" ] || wait $NODE_WM_PID
 	fi
-	rm -f "$USER_FAKE_HOME/.nx/C-$sess_id/pids/applications"
+	rm -f "$USER_FAKE_HOME/.nx/C-$sess_id/pids/apps/$NODE_APP_PID"
 
 	# Do not terminate agent in case of rootless agent mode.
 	# The agent times out after a while by itself anyway.
@@ -1205,6 +1205,16 @@
 	ACCEPT="accept=$userip,"
 	[ "$userip" = "*" ] && ACCEPT=""
 
+if [ "$1" = "application" ]
+then
+	# This needs to be set, else nxagent is terminated
+	rootless="1"
+	virtualdesktop="0"
+	node_start_applications &
+	echo "NX> 596 Application $application started successfully."
+	return
+fi
+
 	OLD_UMASK=$(umask)
 	umask 0077
 
@@ -1439,6 +1449,9 @@
 	--resumesession)
 		startsession "restore"
 	;;
+	--applicationsession)
+		startsession "application"
+	;;
 	--terminate)
 		cmd_node_terminate
 	;;
@@ -1499,13 +1512,13 @@
 		
 		if [ "$CMD" = "--startsession" -o "$CMD" = "--resumesession" ]
 		then
-			export SLAVE_PID=$$
-			( echo $CMDLINE | "$0" "$CMD"; kill $SLAVE_PID ) &
+			export SLAVE_PID="$$"
+			( echo "$CMDLINE" | "$0" "$CMD"; kill "$SLAVE_PID"; ) &
 			NODE_SESSION="$!"
 		else
 			DELIM=""
 			[ -n "$NODE_SESSION" ] && DELIM="$NODE_SESSION->$CMD"
-			( echo $CMDLINE | "$0" "$CMD" "$DELIM" ) &
+			( echo "$CMDLINE" | "$0" "$CMD" "$DELIM"; ) &
 		fi
 
 	done

Modified: trunk/freenx-server/nxserver
===================================================================
--- trunk/freenx-server/nxserver	2008-03-14 10:32:16 UTC (rev 523)
+++ trunk/freenx-server/nxserver	2008-03-14 15:03:44 UTC (rev 524)
@@ -1325,6 +1325,19 @@
 		SESS_DISPLAY=$(getparam display)
 		SERVER_HOST=$(getparam host)
 		[ -z "$SERVER_HOST" ] && SERVER_HOST="127.0.0.1"
+		
+		if [ "$ENABLE_ADVANCED_SESSION_CONTROL" = "1" ]
+		then
+			CMDLINE="$FULL_PARAMS"
+			case "$(getparam session)" in
+				"add "*)
+					server_nxnode_start --applicationsession "$USER" "$FULL_PARAMS"
+					echo_x "Quit"
+					echo_x "NX> 999 Quit"
+					exit 1
+				;;
+			esac
+		fi
 	fi
 
 	# now start the node



From fabianx at mail.berlios.de  Fri Mar 14 16:18:18 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Fri, 14 Mar 2008 16:18:18 +0100
Subject: [Freenx-cvs] r525 - trunk/freenx-server
Message-ID: <200803141518.m2EFIIrJ020485@sheep.berlios.de>

Author: fabianx
Date: 2008-03-14 16:18:17 +0100 (Fri, 14 Mar 2008)
New Revision: 525

Modified:
   trunk/freenx-server/ChangeLog
Log:
Wish grant.


Modified: trunk/freenx-server/ChangeLog
===================================================================
--- trunk/freenx-server/ChangeLog	2008-03-14 15:03:44 UTC (rev 524)
+++ trunk/freenx-server/ChangeLog	2008-03-14 15:18:17 UTC (rev 525)
@@ -82,6 +82,7 @@
 	  Set ENABLE_ADVANCED_SESSION_CONTROL="1" and use session name
 	  like "add <sessionname>". Unfortunately the client returns an
 	  error, but the application is started anyway.
+	  The wish was granted for Bernhard Donaubauer.
 	  (fabianx at bat.berlios.de)
 
 14.10.2007 FreeNX 0.7.1 "Hip Hop Edition"



From fabianx at mail.berlios.de  Fri Mar 14 16:45:09 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Fri, 14 Mar 2008 16:45:09 +0100
Subject: [Freenx-cvs] r526 - trunk/freenx-server
Message-ID: <200803141545.m2EFj9sY024059@sheep.berlios.de>

Author: fabianx
Date: 2008-03-14 16:45:09 +0100 (Fri, 14 Mar 2008)
New Revision: 526

Modified:
   trunk/freenx-server/ChangeLog
   trunk/freenx-server/node.conf.sample
   trunk/freenx-server/nxloadconfig
   trunk/freenx-server/nxserver
Log:
* Added option to disable the showing of running sessions.
  Set ENABLE_SHOW_RUNNING_SESSIONS="0" if you want that behaviour.
  (fabianx at bat.berlios.de)



Modified: trunk/freenx-server/ChangeLog
===================================================================
--- trunk/freenx-server/ChangeLog	2008-03-14 15:18:17 UTC (rev 525)
+++ trunk/freenx-server/ChangeLog	2008-03-14 15:45:09 UTC (rev 526)
@@ -84,6 +84,9 @@
 	  error, but the application is started anyway.
 	  The wish was granted for Bernhard Donaubauer.
 	  (fabianx at bat.berlios.de)
+	* Added option to disable the showing of running sessions.
+	  Set ENABLE_SHOW_RUNNING_SESSIONS="0" if you want that behaviour.
+	  (fabianx at bat.berlios.de)
 
 14.10.2007 FreeNX 0.7.1 "Hip Hop Edition"
 	* Fixed the issue that makes fonts look tiny and unreadable by default 

Modified: trunk/freenx-server/node.conf.sample
===================================================================
--- trunk/freenx-server/node.conf.sample	2008-03-14 15:18:17 UTC (rev 525)
+++ trunk/freenx-server/node.conf.sample	2008-03-14 15:45:09 UTC (rev 526)
@@ -204,6 +204,11 @@
 #
 #ENABLE_ADVANCED_SESSION_CONTROL="0"
 
+# If you set ENABLE_SHOW_RUNNING_SESSIONS="0" then nxserver will only show
+# suspended sessions and you will not be able to resume or terminate a running 
+# session.
+#
+#ENABLE_SHOW_RUNNING_SESSIONS="1"
 
 #########################################################################
 # Logging directives

Modified: trunk/freenx-server/nxloadconfig
===================================================================
--- trunk/freenx-server/nxloadconfig	2008-03-14 15:18:17 UTC (rev 525)
+++ trunk/freenx-server/nxloadconfig	2008-03-14 15:45:09 UTC (rev 526)
@@ -119,6 +119,7 @@
 USE_PROCESSOR_TASKSET=""
 
 ENABLE_ADVANCED_SESSION_CONTROL="0"
+ENABLE_SHOW_RUNNING_SESSIONS="1"
 
 # Logging directives
 

Modified: trunk/freenx-server/nxserver
===================================================================
--- trunk/freenx-server/nxserver	2008-03-14 15:18:17 UTC (rev 525)
+++ trunk/freenx-server/nxserver	2008-03-14 15:45:09 UTC (rev 526)
@@ -1428,6 +1428,7 @@
 			elif [ "$status" = "suspended,running" -o "$status" = "suspended" ] # since 1.5.0
 			then
 				status=$(echo $status | sed 's/,/$|^status=/g; s/suspended/Suspended/g; s/running/Running/g')
+				[ "$ENABLE_SHOW_RUNNING_SESSIONS" = "0" ] && status="Suspended"
 				session_list_user_suspended "$USER" "$status" "$(getparam geometry)" "$(getparam type)"
 			else
 				session_list_user "$USER" | log_tee



From fabianx at mail.berlios.de  Fri Mar 14 18:45:40 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Fri, 14 Mar 2008 18:45:40 +0100
Subject: [Freenx-cvs] r527 - trunk/freenx-server
Message-ID: <200803141745.m2EHjeKX031445@sheep.berlios.de>

Author: fabianx
Date: 2008-03-14 18:45:36 +0100 (Fri, 14 Mar 2008)
New Revision: 527

Modified:
   trunk/freenx-server/ChangeLog
   trunk/freenx-server/INSTALL
Log:
* Updated documentation in INSTALL file.
  (fabianx at bat.berlios.de)



Modified: trunk/freenx-server/ChangeLog
===================================================================
--- trunk/freenx-server/ChangeLog	2008-03-14 15:45:09 UTC (rev 526)
+++ trunk/freenx-server/ChangeLog	2008-03-14 17:45:36 UTC (rev 527)
@@ -87,6 +87,8 @@
 	* Added option to disable the showing of running sessions.
 	  Set ENABLE_SHOW_RUNNING_SESSIONS="0" if you want that behaviour.
 	  (fabianx at bat.berlios.de)
+	* Updated documentation in INSTALL file.
+	  (fabianx at bat.berlios.de)
 
 14.10.2007 FreeNX 0.7.1 "Hip Hop Edition"
 	* Fixed the issue that makes fonts look tiny and unreadable by default 

Modified: trunk/freenx-server/INSTALL
===================================================================
--- trunk/freenx-server/INSTALL	2008-03-14 15:45:09 UTC (rev 526)
+++ trunk/freenx-server/INSTALL	2008-03-14 17:45:36 UTC (rev 527)
@@ -32,44 +32,77 @@
 
 You must apply the gentoo-nomachine.diff and then copy the files to /usr/NX/bin and /usr/NX/lib.
 
-You can use the following schema to do the install to /usr/NX/:
+Get all sources from www.nomachine.com/sources.php
 
-NXPREFIX=/usr/NX
-mkdir -p ${NXPREFIX}/lib ${NXPREFIX}/bin
+Untar all sources, install all dependencies then do:
 
+  $ cd nx-X11
+  $ make World
+  $ cd ..
+  $ cd nxproxy
+  $ ./configure && make
+
 # Libraries
-cp -a nx-X11/lib/X11/libX11.so* ${NXPREFIX}/lib
-cp -a nx-X11/lib/Xext/libXext.so* ${NXPREFIX}/lib
-cp -a nx-X11/lib/Xrender/libXrender.so* ${NXPREFIX}/lib
-cp -a nxcomp/libXcomp.so* ${NXPREFIX}/lib
-cp -a nxcompext/libXcompext.so* ${NXPREFIX}/lib
 
+You can use the following schema to do the install to /usr/NX/:
+
+  $ NXPREFIX=/usr/NX
+  $ mkdir -p ${NXPREFIX}/lib ${NXPREFIX}/bin
+
+  $ cp -a nx-X11/lib/X11/libX11.so* ${NXPREFIX}/lib
+  $ cp -a nx-X11/lib/Xext/libXext.so* ${NXPREFIX}/lib
+  $ cp -a nx-X11/lib/Xrender/libXrender.so* ${NXPREFIX}/lib
+  $ cp -a nxcomp/libXcomp.so* ${NXPREFIX}/lib
+  $ cp -a nxcompext/libXcompext.so* ${NXPREFIX}/lib
+
 # binaries
-cp -a nx-X11/programs/Xserver/nxagent ${NXPREFIX}/bin
-cp -a nxproxy/nxproxy ${NXPREFIX}/bin
-cp -a nxdesktop/nxdesktop ${NXPREFIX}/bin
-cp -a nxviewer/nxviewer/nxviewer ${NXPREFIX}/bin
-cp -a nxviewer/nxpasswd/nxpasswd ${NXPREFIX}/bin
 
-# windows-keymaps for nxdesktop RDP-sessions and keyboard layout != us
-cd nxdesktop
-make installkeymaps
+  $ cp -a nx-X11/programs/Xserver/nxagent ${NXPREFIX}/bin
+  $ cp -a nxproxy/nxproxy ${NXPREFIX}/bin
 
+### Now comes the FreeNX part
+
+# build binaries and libs included in FreeNX distribution
+
+  $ cd freenx-<version>
+
+# nxredir
+
+  $ cd nxredir
+  $ make
+  $ cd ..
+
+# nxserver-helper
+  
+  $ cd nxserver-helper
+  $ make
+  $ cd ..
+
+# nxpasswd
+
+  $ cd nxviewer-passwd
+  $ xmkmf
+  $ make World
+  $ cd ..
+
+# install binaries included in FreeNX trunk
+
+  $ cd nxredir
+  $ make install
+  $ cd ..
+  $ cp -a nxserver-helper/nxserver-helper ${NXPREFIX}/bin
+  $ cp -a nxviewer-passwd/nxpasswd/nxpasswd ${NXPREFIX}/bin
+
 # scripts
-cp -a freenx*/nxnode ${NXPREFIX}/bin
-cp -a freenx*/nxserver ${NXPREFIX}/bin
-cp -a freenx*/nxsetup ${NXPREFIX}/bin
-cp -a freenx*/nxkeygen ${NXPREFIX}/bin
-cp -a freenx*/nxnode-login ${NXPREFIX}/bin
-cp -a freenx*/nxloadconfig ${NXPREFIX}/bin
-cp -a freenx*/nxprint ${NXPREFIX}/bin
-cp -a freenx*/nxclient ${NXPREFIX}/bin
 
+  $ cp nx* ${NXPREFIX}/bin
+
 # config file
-cp -a freenx*/node.conf.sample ${NXPREFIX}/etc/
 
-You should also install the nxclient from NoMachine or also copy the nxclient program from freenx. 
+  $ cp -a freenx*/node.conf.sample ${NXPREFIX}/etc/
 
+You should also install the nxclient from NoMachine or install Xdialog. 
+
 Then you need to run 'nxsetup --install' and follow the instructions given.
 
 If you use 1.5.0 as backend be sure to set ENABLE_1_5_0_BACKEND to 1 in node.conf or nxloadconfig.



From fabianx at mail.berlios.de  Fri Mar 14 21:52:48 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Fri, 14 Mar 2008 21:52:48 +0100
Subject: [Freenx-cvs] r529 - in trunk/freenx-server: . nxredir
Message-ID: <200803142052.m2EKqmEo011318@sheep.berlios.de>

Author: fabianx
Date: 2008-03-14 21:52:47 +0100 (Fri, 14 Mar 2008)
New Revision: 529

Added:
   trunk/freenx-server/Makefile
Modified:
   trunk/freenx-server/ChangeLog
   trunk/freenx-server/INSTALL
   trunk/freenx-server/nxredir/Makefile
   trunk/freenx-server/nxredir/nxredir
   trunk/freenx-server/nxredir/nxsmb
Log:
* Added a Makefile so FreeNX can be build and installed via.
  $ make
  $ # edit nxloadconfig to point where it should install to
  $ make install
  Hereby FreeNX is installed to where nxloadconfig points and
  static paths in nxredir and nxsmb are adjusted accordingly.
  So if you want it to be in /usr/NX/ be sure to apply
  gentoo-nomachine.diff first or edit nxloadconfig manually.
  (fabianx at bat.berlios.de)



Modified: trunk/freenx-server/ChangeLog
===================================================================
--- trunk/freenx-server/ChangeLog	2008-03-14 17:54:12 UTC (rev 528)
+++ trunk/freenx-server/ChangeLog	2008-03-14 20:52:47 UTC (rev 529)
@@ -93,6 +93,15 @@
 	  tightvnc vncpasswd part, which is necessary for FreeNX to work
 	  with standard vncviewer.
 	  (fabianx at bat.berlios.de)
+	* Added a Makefile so FreeNX can be build and installed via.
+	  $ make
+	  $ # edit nxloadconfig to point where it should install to
+	  $ make install
+	  Hereby FreeNX is installed to where nxloadconfig points and
+	  static paths in nxredir and nxsmb are adjusted accordingly.
+	  So if you want it to be in /usr/NX/ be sure to apply
+	  gentoo-nomachine.diff first or edit nxloadconfig manually.
+	  (fabianx at bat.berlios.de)
 
 14.10.2007 FreeNX 0.7.1 "Hip Hop Edition"
 	* Fixed the issue that makes fonts look tiny and unreadable by default 

Modified: trunk/freenx-server/INSTALL
===================================================================
--- trunk/freenx-server/INSTALL	2008-03-14 17:54:12 UTC (rev 528)
+++ trunk/freenx-server/INSTALL	2008-03-14 20:52:47 UTC (rev 529)
@@ -32,6 +32,8 @@
 
 You must apply the gentoo-nomachine.diff and then copy the files to /usr/NX/bin and /usr/NX/lib.
 
+Here is a howto:
+
 Get all sources from www.nomachine.com/sources.php
 
 Untar all sources, install all dependencies then do:
@@ -65,7 +67,24 @@
 # build binaries and libs included in FreeNX distribution
 
   $ cd freenx-<version>
+  $ patch -p0 < gentoo-nomachine.diff
+  $ make
+  $ make install
 
+You should also install the nxclient from NoMachine or install Xdialog. 
+
+Then you need to run 'nxsetup --install' and follow the instructions given.
+
+Have Fun!
+
+Best regards,
+
+Fabian
+
+--
+
+Old way without Makefile (instead of make; make install):
+
 # nxredir
 
   $ cd nxredir
@@ -101,12 +120,4 @@
 
   $ cp -a freenx*/node.conf.sample ${NXPREFIX}/etc/
 
-You should also install the nxclient from NoMachine or install Xdialog. 
-
-Then you need to run 'nxsetup --install' and follow the instructions given.
-
-If you use 1.5.0 as backend be sure to set ENABLE_1_5_0_BACKEND to 1 in node.conf or nxloadconfig.
-
---
-
 SVN: $Id$

Added: trunk/freenx-server/Makefile
===================================================================
--- trunk/freenx-server/Makefile	2008-03-14 17:54:12 UTC (rev 528)
+++ trunk/freenx-server/Makefile	2008-03-14 20:52:47 UTC (rev 529)
@@ -0,0 +1,26 @@
+.PHONY: all install
+
+SUBDIRS=nxredir nxviewer-passwd nxserver-helper
+PROGRAMS=nxcheckload.sample nxcups-gethost nxdesktop_helper nxdialog nxkeygen nxloadconfig nxnode nxnode-login nxprint nxserver nxserver-helper/nxserver-helper nxsetup nxviewer_helper nxviewer-passwd/nxpasswd/nxpasswd
+
+all:
+	( cd nxviewer-passwd; xmkmf; make Makefiles; make depend; cd ..)
+	for i in $(SUBDIRS) ; \
+	do\
+		echo "making" all "in $$i..."; \
+	        $(MAKE) -C $$i  all;\
+	done
+
+install:
+	. nxloadconfig;\
+	install -m755 -d $(DESTDIR)/$$PATH_BIN/ ;\
+	install -m755 -d $(DESTDIR)/$$PATH_LIB/ ;\
+	install -m755 -d $(DESTDIR)/$$NX_ETC_DIR/ ;\
+	install -m755 -d $(DESTDIR)/$$CUPS_BACKEND/ ;\
+	for i in $(PROGRAMS) ; \
+	do\
+	        install -m755 $$i $(DESTDIR)/$$PATH_BIN/ ;\
+	done;\
+	export PATH_BIN PATH_LIB CUPS_BACKEND NX_VERSION;\
+	install -m644 node.conf.sample $(DESTDIR)/$$NX_ETC_DIR/ ; \
+	make -C nxredir install

Modified: trunk/freenx-server/nxredir/Makefile
===================================================================
--- trunk/freenx-server/nxredir/Makefile	2008-03-14 17:54:12 UTC (rev 528)
+++ trunk/freenx-server/nxredir/Makefile	2008-03-14 20:52:47 UTC (rev 529)
@@ -2,18 +2,29 @@
 
 CC=gcc
 CFLAGS=-g -O2 -Wall -fPIC
+LIBNAME=libnxredir.so.0
 
 libnxredir.so.0: nxredir.o
-	$(CC) -fPIC $(CFLAGS) -nostdlib -shared -o libnxredir.so.0 nxredir.o -ldl -lc
+	$(CC) -fPIC $(CFLAGS) -nostdlib -shared -o $(LIBNAME) nxredir.o -ldl -lc
 
 clean:
-	rm -f libnxredir.so.0
+	rm -f $(LIBNAME)
 	rm -f *.o
 
 install: all
-	install -m755 libnxredir.so.0 $(DESTDIR)/usr/lib
-	install -m755 nxredir $(DESTDIR)/usr/bin
-	install -m755 nxsmb $(DESTDIR)/usr/lib/cups/backend/
-	ldconfig
+	# install and possibly patch paths gotten by nxloadconfig
+	if [ -n "$$NX_VERSION" ]; \
+	then \
+		install -m755 $(LIBNAME) $(DESTDIR)/$$PATH_LIB/ ;\
+		install -m755 nxredir $(DESTDIR)/$$PATH_BIN/ ;\
+		install -m755 nxsmb $(DESTDIR)/$$CUPS_BACKEND/ ;\
+		perl -pi -e "s,PATH_LIB=.*,PATH_LIB=\"$$PATH_LIB\",g" $(DESTDIR)/$$PATH_BIN/nxredir ;\
+		perl -pi -e "s,PATH_LIB=.*,PATH_LIB=\"$$PATH_LIB\",g" $(DESTDIR)/$$CUPS_BACKEND/nxsmb ;\
+		perl -pi -e "s,CUPS_BACKEND=.*,CUPS_BACKEND=\"$$CUPS_BACKEND\",g" $(DESTDIR)/$$CUPS_BACKEND/nxsmb ;\
+	else \
+		install -m755 libnxredir.so.0 $(DESTDIR)/usr/lib ;\
+		install -m755 nxredir $(DESTDIR)/usr/bin ;\
+		install -m755 nxsmb $(DESTDIR)/usr/lib/cups/backend/ ;\
+	fi
 
 .PHONY: clean install

Modified: trunk/freenx-server/nxredir/nxredir
===================================================================
--- trunk/freenx-server/nxredir/nxredir	2008-03-14 17:54:12 UTC (rev 528)
+++ trunk/freenx-server/nxredir/nxredir	2008-03-14 20:52:47 UTC (rev 529)
@@ -1,6 +1,7 @@
 #!/bin/sh
 
-NXREDIR_LIBRARY="/usr/lib/libnxredir.so.0"
+PATH_LIB="/usr/lib/"
+NXREDIR_LIBRARY="$PATH_LIB/libnxredir.so.0"
 
 if [ -z "$NXCUPS_PORT" -a -z "$NXSAMBA_PORT" ]
 then

Modified: trunk/freenx-server/nxredir/nxsmb
===================================================================
--- trunk/freenx-server/nxredir/nxsmb	2008-03-14 17:54:12 UTC (rev 528)
+++ trunk/freenx-server/nxredir/nxsmb	2008-03-14 20:52:47 UTC (rev 529)
@@ -8,9 +8,11 @@
 
 # turn on DEBUG?
 #set -x -v
+CUPS_BACKEND="/usr/lib/cups/backend/"
+PATH_LIB="/usr/lib/"
 
-NXREDIR_LIBRARY="/usr/lib/libnxredir.so.0"
-COMMAND_SMB="/usr/lib/cups/backend/smb"
+NXREDIR_LIBRARY="$PATH_LIB/libnxredir.so.0"
+COMMAND_SMB="$CUPS_BACKEND/smb"
 
 PORT=$(echo $DEVICE_URI | cut -d/ -f3 | cut -d@ -f2 | cut -d: -f2)
 PROTOCOL=$(echo $DEVICE_URI | cut -d/ -f4)



From fabianx at mail.berlios.de  Fri Mar 14 22:30:04 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Fri, 14 Mar 2008 22:30:04 +0100
Subject: [Freenx-cvs] r530 - trunk/freenx-server
Message-ID: <200803142130.m2ELU4Bx016326@sheep.berlios.de>

Author: fabianx
Date: 2008-03-14 22:30:03 +0100 (Fri, 14 Mar 2008)
New Revision: 530

Added:
   trunk/freenx-server/nxacl.sample
Modified:
   trunk/freenx-server/ChangeLog
   trunk/freenx-server/Makefile
   trunk/freenx-server/nxserver
Log:
* Added nxacl.sample component. If you copy nxacl.sample to
  $PATH_BIN/nxacl you can make as complex acl scenarios as you
  want. You have complete control over all data and can deny
  any session.
  (fabianx at bat.berlios.de)


Modified: trunk/freenx-server/ChangeLog
===================================================================
--- trunk/freenx-server/ChangeLog	2008-03-14 20:52:47 UTC (rev 529)
+++ trunk/freenx-server/ChangeLog	2008-03-14 21:30:03 UTC (rev 530)
@@ -102,6 +102,11 @@
 	  So if you want it to be in /usr/NX/ be sure to apply
 	  gentoo-nomachine.diff first or edit nxloadconfig manually.
 	  (fabianx at bat.berlios.de)
+	* Added nxacl.sample component. If you copy nxacl.sample to
+	  $PATH_BIN/nxacl you can make as complex acl scenarios as you
+	  want. You have complete control over all data and can deny
+	  any session.
+	  (fabianx at bat.berlios.de)
 
 14.10.2007 FreeNX 0.7.1 "Hip Hop Edition"
 	* Fixed the issue that makes fonts look tiny and unreadable by default 

Modified: trunk/freenx-server/Makefile
===================================================================
--- trunk/freenx-server/Makefile	2008-03-14 20:52:47 UTC (rev 529)
+++ trunk/freenx-server/Makefile	2008-03-14 21:30:03 UTC (rev 530)
@@ -1,7 +1,7 @@
 .PHONY: all install
 
 SUBDIRS=nxredir nxviewer-passwd nxserver-helper
-PROGRAMS=nxcheckload.sample nxcups-gethost nxdesktop_helper nxdialog nxkeygen nxloadconfig nxnode nxnode-login nxprint nxserver nxserver-helper/nxserver-helper nxsetup nxviewer_helper nxviewer-passwd/nxpasswd/nxpasswd
+PROGRAMS=nxacl.sample nxcheckload.sample nxcups-gethost nxdesktop_helper nxdialog nxkeygen nxloadconfig nxnode nxnode-login nxprint nxserver nxserver-helper/nxserver-helper nxsetup nxviewer_helper nxviewer-passwd/nxpasswd/nxpasswd
 
 all:
 	( cd nxviewer-passwd; xmkmf; make Makefiles; make depend; cd ..)

Added: trunk/freenx-server/nxacl.sample
===================================================================
--- trunk/freenx-server/nxacl.sample	2008-03-14 20:52:47 UTC (rev 529)
+++ trunk/freenx-server/nxacl.sample	2008-03-14 21:30:03 UTC (rev 530)
@@ -0,0 +1,64 @@
+#!/bin/sh
+
+# Syntax: getparam <param>
+getparam()
+{
+	stringinstring "&$1=" "$CMDLINE" || return 1
+	echo "$CMDLINE" |  tr "&" "\n" | egrep "^"$1"=" | awk -F= '{ VAL=$2 } END { print VAL }'
+	return 0
+}
+
+# Syntax: changeparam <param> <value>
+# 	  Don't use & in value its the separator.
+
+changeparam()
+{
+	CMDLINE=$(echo "$CMDLINE" | tr "&" "\n" | sed "s&^$1=.*&$1=$2&g" | tr "\n" "&")
+}
+
+CMDLINE="$1"
+
+# Example 0: All allowed
+
+allow_all()
+{
+	# Parameters unchanged
+	echo "$CMDLINE"
+
+	# Session allowed
+	exit 0
+}
+
+# Example 1: Allow only unix-kde sessions, deny others
+
+allow_unix_kde()
+{
+	type=$(getparam type)
+	if [ "$type" != "unix-kde" ]
+	then
+		echo "Only sessions with type unix-kde are allowed."
+		exit 1
+	fi
+
+	allow_all
+}
+
+# Example 3: Allow only unix-kde sessions, change type always to unix-kde and virtualdesktop=1, rootless=0
+
+allow_unix_kde_2()
+{
+	change_param type unix-kde
+	change_param virtualdesktop 1
+	change_param rootless 0
+
+	allow_all
+}
+
+#
+# You can make as complex samples as you want, if you have one, I would be very interested!
+# Fabian
+#
+# Send it to: FreeNX-kNX at kde.org.
+#
+
+allow_all


Property changes on: trunk/freenx-server/nxacl.sample
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/freenx-server/nxserver
===================================================================
--- trunk/freenx-server/nxserver	2008-03-14 20:52:47 UTC (rev 529)
+++ trunk/freenx-server/nxserver	2008-03-14 21:30:03 UTC (rev 530)
@@ -1243,6 +1243,25 @@
 			return 1
 	fi
 
+	if [ -x "$PATH_BIN/nxacl" ]
+	then
+			log 3 "Info: Using $PATH_BIN/nxacl to change session parameters or deny session."
+			NEW_PARAMS=$($PATH_BIN/nxacl "$CMDLINE")
+			if [ $? -ne 0 ]
+			then
+				echo_x "NX> 596 The session failed due to a nxacl policy setting:"
+				echo_x "$NEW_PARAMS"
+				return 1
+			fi
+
+			# check if the acl input did make sense
+			if [ -n "$NEW_PARAMS" ]
+			then
+				PARAMS=$NEW_PARAMS
+				CMDLINE=$PARAMS
+			fi
+	fi
+
 	# check if there is a suspended session, which we could resume
 	if [ "$ENABLE_AUTORECONNECT" = "1" -a "$ACTION" = "start" ]
 	then



From fabianx at mail.berlios.de  Fri Mar 14 22:39:08 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Fri, 14 Mar 2008 22:39:08 +0100
Subject: [Freenx-cvs] r531 - trunk/freenx-server
Message-ID: <200803142139.m2ELd8M5017286@sheep.berlios.de>

Author: fabianx
Date: 2008-03-14 22:39:08 +0100 (Fri, 14 Mar 2008)
New Revision: 531

Modified:
   trunk/freenx-server/nxacl.sample
   trunk/freenx-server/nxserver
Log:
Small fix for nxacl new policy.



Modified: trunk/freenx-server/nxacl.sample
===================================================================
--- trunk/freenx-server/nxacl.sample	2008-03-14 21:30:03 UTC (rev 530)
+++ trunk/freenx-server/nxacl.sample	2008-03-14 21:39:08 UTC (rev 531)
@@ -47,9 +47,9 @@
 
 allow_unix_kde_2()
 {
-	change_param type unix-kde
-	change_param virtualdesktop 1
-	change_param rootless 0
+	changeparam type unix-kde
+	changeparam virtualdesktop 1
+	changeparam rootless 0
 
 	allow_all
 }

Modified: trunk/freenx-server/nxserver
===================================================================
--- trunk/freenx-server/nxserver	2008-03-14 21:30:03 UTC (rev 530)
+++ trunk/freenx-server/nxserver	2008-03-14 21:39:08 UTC (rev 531)
@@ -1249,8 +1249,7 @@
 			NEW_PARAMS=$($PATH_BIN/nxacl "$CMDLINE")
 			if [ $? -ne 0 ]
 			then
-				echo_x "NX> 596 The session failed due to a nxacl policy setting:"
-				echo_x "$NEW_PARAMS"
+				echo_x "NX> 596 The session failed due to a nxacl policy setting: $NEW_PARAMS"
 				return 1
 			fi
 



From fabianx at mail.berlios.de  Fri Mar 14 22:45:58 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Fri, 14 Mar 2008 22:45:58 +0100
Subject: [Freenx-cvs] r532 - trunk/freenx-server
Message-ID: <200803142145.m2ELjw1P018025@sheep.berlios.de>

Author: fabianx
Date: 2008-03-14 22:45:58 +0100 (Fri, 14 Mar 2008)
New Revision: 532

Modified:
   trunk/freenx-server/ChangeLog
   trunk/freenx-server/nxloadconfig
Log:
Released FreeNX 0.7.2 "Priscilla Edition".



Modified: trunk/freenx-server/ChangeLog
===================================================================
--- trunk/freenx-server/ChangeLog	2008-03-14 21:39:08 UTC (rev 531)
+++ trunk/freenx-server/ChangeLog	2008-03-14 21:45:58 UTC (rev 532)
@@ -1,4 +1,4 @@
-xx.01.2008 FreeNX 0.7.2
+14.03.2008 FreeNX 0.7.2 "Priscilla Edition"
 	* Opened the 0.7.2 development.
 	* Fixed the display of local sessions to display only 
 	  when session type is VNC.

Modified: trunk/freenx-server/nxloadconfig
===================================================================
--- trunk/freenx-server/nxloadconfig	2008-03-14 21:39:08 UTC (rev 531)
+++ trunk/freenx-server/nxloadconfig	2008-03-14 21:45:58 UTC (rev 532)
@@ -52,7 +52,7 @@
 # DO NOT TOUCH unless you REALLY know what you are doing
 #########################################################################
 
-NX_VERSION=2.1.0-72-SVN
+NX_VERSION=2.1.0-72
 NX_LICENSE="OS (GPL, using backend: %BACKEND%)"
 
 # Where can different nx components be found



From fabianx at mail.berlios.de  Fri Mar 14 22:47:48 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Fri, 14 Mar 2008 22:47:48 +0100
Subject: [Freenx-cvs] r533 - in tags/freenx-server: . FreeNX-0.7.2
	FreeNX-0.7.2/nxredir FreeNX-0.7.2/nxserver-helper
Message-ID: <200803142147.m2ELlmYl018142@sheep.berlios.de>

Author: fabianx
Date: 2008-03-14 22:47:47 +0100 (Fri, 14 Mar 2008)
New Revision: 533

Added:
   tags/freenx-server/FreeNX-0.7.2/
   tags/freenx-server/FreeNX-0.7.2/AUTHORS
   tags/freenx-server/FreeNX-0.7.2/CONTRIB
   tags/freenx-server/FreeNX-0.7.2/COPYING
   tags/freenx-server/FreeNX-0.7.2/ChangeLog
   tags/freenx-server/FreeNX-0.7.2/INSTALL
   tags/freenx-server/FreeNX-0.7.2/Makefile
   tags/freenx-server/FreeNX-0.7.2/gentoo-nomachine.diff
   tags/freenx-server/FreeNX-0.7.2/init.d/
   tags/freenx-server/FreeNX-0.7.2/node.conf.sample
   tags/freenx-server/FreeNX-0.7.2/nxacl.sample
   tags/freenx-server/FreeNX-0.7.2/nxcheckload.sample
   tags/freenx-server/FreeNX-0.7.2/nxcups-gethost
   tags/freenx-server/FreeNX-0.7.2/nxdesktop_helper
   tags/freenx-server/FreeNX-0.7.2/nxdialog
   tags/freenx-server/FreeNX-0.7.2/nxkeygen
   tags/freenx-server/FreeNX-0.7.2/nxloadconfig
   tags/freenx-server/FreeNX-0.7.2/nxnode
   tags/freenx-server/FreeNX-0.7.2/nxnode-login
   tags/freenx-server/FreeNX-0.7.2/nxprint
   tags/freenx-server/FreeNX-0.7.2/nxredir/
   tags/freenx-server/FreeNX-0.7.2/nxredir/Makefile
   tags/freenx-server/FreeNX-0.7.2/nxredir/nxredir
   tags/freenx-server/FreeNX-0.7.2/nxredir/nxredir.c
   tags/freenx-server/FreeNX-0.7.2/nxredir/nxsmb
   tags/freenx-server/FreeNX-0.7.2/nxserver
   tags/freenx-server/FreeNX-0.7.2/nxserver-helper/
   tags/freenx-server/FreeNX-0.7.2/nxserver-helper/nxserver-helper.c
   tags/freenx-server/FreeNX-0.7.2/nxsetup
   tags/freenx-server/FreeNX-0.7.2/nxviewer-passwd/
   tags/freenx-server/FreeNX-0.7.2/nxviewer_helper
Removed:
   tags/freenx-server/FreeNX-0.7.2/branches/
   tags/freenx-server/FreeNX-0.7.2/nxredir/Makefile
   tags/freenx-server/FreeNX-0.7.2/nxredir/nxredir
   tags/freenx-server/FreeNX-0.7.2/nxredir/nxredir.c
   tags/freenx-server/FreeNX-0.7.2/nxredir/nxsmb
   tags/freenx-server/FreeNX-0.7.2/nxserver-helper/nxserver-helper.c
   tags/freenx-server/FreeNX-0.7.2/tags/
   tags/freenx-server/FreeNX-0.7.2/trunk/
Log:
Released FreeNX 0.7.2 "Priscilla Edition".



Copied: tags/freenx-server/FreeNX-0.7.2 (from rev 502, trunk/freenx-server)

Copied: tags/freenx-server/FreeNX-0.7.2/AUTHORS (from rev 512, trunk/freenx-server/AUTHORS)

Copied: tags/freenx-server/FreeNX-0.7.2/CONTRIB (from rev 512, trunk/freenx-server/CONTRIB)

Copied: tags/freenx-server/FreeNX-0.7.2/COPYING (from rev 512, trunk/freenx-server/COPYING)

Copied: tags/freenx-server/FreeNX-0.7.2/ChangeLog (from rev 532, trunk/freenx-server/ChangeLog)

Copied: tags/freenx-server/FreeNX-0.7.2/INSTALL (from rev 529, trunk/freenx-server/INSTALL)

Copied: tags/freenx-server/FreeNX-0.7.2/Makefile (from rev 530, trunk/freenx-server/Makefile)

Copied: tags/freenx-server/FreeNX-0.7.2/gentoo-nomachine.diff (from rev 521, trunk/freenx-server/gentoo-nomachine.diff)

Copied: tags/freenx-server/FreeNX-0.7.2/init.d (from rev 512, trunk/freenx-server/init.d)

Copied: tags/freenx-server/FreeNX-0.7.2/node.conf.sample (from rev 526, trunk/freenx-server/node.conf.sample)

Copied: tags/freenx-server/FreeNX-0.7.2/nxacl.sample (from rev 531, trunk/freenx-server/nxacl.sample)

Copied: tags/freenx-server/FreeNX-0.7.2/nxcheckload.sample (from rev 512, trunk/freenx-server/nxcheckload.sample)

Copied: tags/freenx-server/FreeNX-0.7.2/nxcups-gethost (from rev 512, trunk/freenx-server/nxcups-gethost)

Copied: tags/freenx-server/FreeNX-0.7.2/nxdesktop_helper (from rev 512, trunk/freenx-server/nxdesktop_helper)

Copied: tags/freenx-server/FreeNX-0.7.2/nxdialog (from rev 512, trunk/freenx-server/nxdialog)

Copied: tags/freenx-server/FreeNX-0.7.2/nxkeygen (from rev 512, trunk/freenx-server/nxkeygen)

Copied: tags/freenx-server/FreeNX-0.7.2/nxloadconfig (from rev 532, trunk/freenx-server/nxloadconfig)

Copied: tags/freenx-server/FreeNX-0.7.2/nxnode (from rev 524, trunk/freenx-server/nxnode)

Copied: tags/freenx-server/FreeNX-0.7.2/nxnode-login (from rev 512, trunk/freenx-server/nxnode-login)

Copied: tags/freenx-server/FreeNX-0.7.2/nxprint (from rev 512, trunk/freenx-server/nxprint)

Copied: tags/freenx-server/FreeNX-0.7.2/nxredir (from rev 512, trunk/freenx-server/nxredir)

Deleted: tags/freenx-server/FreeNX-0.7.2/nxredir/Makefile
===================================================================
--- trunk/freenx-server/nxredir/Makefile	2008-03-10 23:01:03 UTC (rev 512)
+++ tags/freenx-server/FreeNX-0.7.2/nxredir/Makefile	2008-03-14 21:47:47 UTC (rev 533)
@@ -1,19 +0,0 @@
-all: libnxredir.so.0
-
-CC=gcc
-CFLAGS=-g -O2 -Wall -fPIC
-
-libnxredir.so.0: nxredir.o
-	$(CC) -fPIC $(CFLAGS) -nostdlib -shared -o libnxredir.so.0 nxredir.o -ldl -lc
-
-clean:
-	rm -f libnxredir.so.0
-	rm -f *.o
-
-install: all
-	install -m755 libnxredir.so.0 $(DESTDIR)/usr/lib
-	install -m755 nxredir $(DESTDIR)/usr/bin
-	install -m755 nxsmb $(DESTDIR)/usr/lib/cups/backend/
-	ldconfig
-
-.PHONY: clean install

Copied: tags/freenx-server/FreeNX-0.7.2/nxredir/Makefile (from rev 529, trunk/freenx-server/nxredir/Makefile)

Deleted: tags/freenx-server/FreeNX-0.7.2/nxredir/nxredir
===================================================================
--- trunk/freenx-server/nxredir/nxredir	2008-03-10 23:01:03 UTC (rev 512)
+++ tags/freenx-server/FreeNX-0.7.2/nxredir/nxredir	2008-03-14 21:47:47 UTC (rev 533)
@@ -1,16 +0,0 @@
-#!/bin/sh
-
-if [ -z "$NXCUPS_PORT" -a -z "$NXSAMBA_PORT" ]
-then
-	echo "nxredir: Redirect standard ports to nxproxy"
-	echo ""
-	echo "Usage: export NXCUPS_PORT='where_cups_is_running'"
-	echo "       export NXSAMBA_PORT='where_samba_is_running'"
-	exit 0
-fi
-
-LD_PRELOAD="/usr/lib/libnxredir.so.0:$LD_PRELOAD"
-export LD_PRELOAD
-
-# invoke the program with the args given
-exec "$@"

Copied: tags/freenx-server/FreeNX-0.7.2/nxredir/nxredir (from rev 529, trunk/freenx-server/nxredir/nxredir)

Deleted: tags/freenx-server/FreeNX-0.7.2/nxredir/nxredir.c
===================================================================
--- trunk/freenx-server/nxredir/nxredir.c	2008-03-10 23:01:03 UTC (rev 512)
+++ tags/freenx-server/FreeNX-0.7.2/nxredir/nxredir.c	2008-03-14 21:47:47 UTC (rev 533)
@@ -1,64 +0,0 @@
-/*
- * libnxredir - Redirect certain ports to other forwarded ports.
- *
- * Copyright (c) 2005 by Fabian Franz.
- *
- * License: GPL
- *
- */
-
-char *progname = "libnxredir";              /* Name used in err msgs    */
-
-#define _GNU_SOURCE
-
-/* Header Files */
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <dlfcn.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <string.h>
-#include <strings.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <sys/poll.h>
-#include <sys/time.h>
-#include <pwd.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <stdarg.h>
-
-#include <sys/un.h>
-
-#define CONNECT_SIGNATURE int __fd, const struct sockaddr * __addr, socklen_t __len
-
-static int (*realconnect)(CONNECT_SIGNATURE);
-
-/* Exported Function Prototypes */
-void _init(void);
-
-int connect(CONNECT_SIGNATURE);
-
-void _init(void) 
-{
-        realconnect = dlsym(RTLD_NEXT, "connect");
-}
-
-int connect(CONNECT_SIGNATURE) 
-{
-	if (realconnect == NULL) {
-                perror("Unresolved symbol: connect\n");
-                return(-1);
-        }
-
-	/* CUPS */
-	if ((getenv("NXCUPS_PORT") != NULL) && ((struct sockaddr_in*)__addr)->sin_port==htons(631))
-		((struct sockaddr_in*)__addr)->sin_port=htons(atoi(getenv("NXCUPS_PORT")));
-
-	/* SAMBA */
-	if ((getenv("NXSAMBA_PORT") != NULL) && (((struct sockaddr_in*)__addr)->sin_port==htons(139) || ((struct sockaddr_in*)__addr)->sin_port==htons(445)))
-		((struct sockaddr_in*)__addr)->sin_port=htons(atoi(getenv("NXSAMBA_PORT")));
-
-	return realconnect(__fd, __addr, __len);
-}

Copied: tags/freenx-server/FreeNX-0.7.2/nxredir/nxredir.c (from rev 516, trunk/freenx-server/nxredir/nxredir.c)

Deleted: tags/freenx-server/FreeNX-0.7.2/nxredir/nxsmb
===================================================================
--- trunk/freenx-server/nxredir/nxsmb	2008-03-10 23:01:03 UTC (rev 512)
+++ tags/freenx-server/FreeNX-0.7.2/nxredir/nxsmb	2008-03-14 21:47:47 UTC (rev 533)
@@ -1,45 +0,0 @@
-#!/bin/sh
-#
-# nxsmb: Small wrapper for the SMB backend to be able to print to CIFS or SMB ports directly.
-#
-# Copyright (c) 2008 by Fabian Franz.
-#
-#
-
-# turn on DEBUG?
-#set -x -v
-
-NXREDIR_LIBRARY="/usr/lib/libnxredir.so.0"
-COMMAND_SMB="/usr/lib/cups/backend/smb"
-
-PORT=$(echo $DEVICE_URI | cut -d/ -f3 | cut -d@ -f2 | cut -d: -f2)
-PROTOCOL=$(echo $DEVICE_URI | cut -d/ -f4)
-PRINTER=$(echo $DEVICE_URI | cut -d/ -f5)
-
-if [ -z "$PRINTER" ] # old style setup
-then
-	echo "Warning: Not using nxredir library. The DEVICE_URI is not in the right format."
-	exec "$COMMAND_SMB" "$@"
-fi
-
-if [ ! -x "$NXREDIR_LIBRARY" ]
-then
-	# repair DEVICE_URI
-	DEVICE_URI=$(echo $DEVICE_URI | sed "s|/$PROTOCOL/|/$PRINTER|g")
-	echo "Error: Not using nxredir library. $NXREDIR_LIBRARY could not be found or is not executable."
-	exec "$COMMAND_SMB" "$@"
-fi
-
-if [ "$PROTOCOL" = "cifs" -o "$PROTOCOL" = "CIFS" ]
-then
-	REAL_PORT="445"
-else
-	REAL_PORT="139"
-fi
-
-DEVICE_URI=$(echo $DEVICE_URI | sed "s|:$PORT/$PROTOCOL/|:$REAL_PORT/|g")
-
-export NXSAMBA_PORT="$PORT"
-export LD_PRELOAD="$NXREDIR_LIBRARY${LD_PRELOAD:+:$LD_PRELOAD}"
-
-exec "$COMMAND_SMB" "$@"

Copied: tags/freenx-server/FreeNX-0.7.2/nxredir/nxsmb (from rev 529, trunk/freenx-server/nxredir/nxsmb)

Copied: tags/freenx-server/FreeNX-0.7.2/nxserver (from rev 531, trunk/freenx-server/nxserver)

Copied: tags/freenx-server/FreeNX-0.7.2/nxserver-helper (from rev 512, trunk/freenx-server/nxserver-helper)

Deleted: tags/freenx-server/FreeNX-0.7.2/nxserver-helper/nxserver-helper.c
===================================================================
--- trunk/freenx-server/nxserver-helper/nxserver-helper.c	2008-03-10 23:01:03 UTC (rev 512)
+++ tags/freenx-server/FreeNX-0.7.2/nxserver-helper/nxserver-helper.c	2008-03-14 21:47:47 UTC (rev 533)
@@ -1,21 +0,0 @@
-/*
- * Copyright (c) 2006 by Fabian Franz.
- *
- * License: GPL, v2
- *
- * SVN: $Id$
- *
- */
-
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <unistd.h>
-
-int main(int argc, char* argv[])
-{
-	int fds[2];
-
-	socketpair(AF_UNIX, SOCK_STREAM, 0, fds);
-	argv++;
-	execv(argv[0], argv);
-}

Copied: tags/freenx-server/FreeNX-0.7.2/nxserver-helper/nxserver-helper.c (from rev 519, trunk/freenx-server/nxserver-helper/nxserver-helper.c)

Copied: tags/freenx-server/FreeNX-0.7.2/nxsetup (from rev 512, trunk/freenx-server/nxsetup)

Copied: tags/freenx-server/FreeNX-0.7.2/nxviewer-passwd (from rev 528, trunk/freenx-server/nxviewer-passwd)

Copied: tags/freenx-server/FreeNX-0.7.2/nxviewer_helper (from rev 512, trunk/freenx-server/nxviewer_helper)



From fabianx at mail.berlios.de  Sun Mar 16 21:40:15 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Sun, 16 Mar 2008 21:40:15 +0100
Subject: [Freenx-cvs] r534 - trunk/freenx-server
Message-ID: <200803162040.m2GKeFB1019035@sheep.berlios.de>

Author: fabianx
Date: 2008-03-16 21:40:13 +0100 (Sun, 16 Mar 2008)
New Revision: 534

Modified:
   trunk/freenx-server/ChangeLog
   trunk/freenx-server/node.conf.sample
   trunk/freenx-server/nxloadconfig
   trunk/freenx-server/nxserver
Log:
* Added logging of failed authentication attempts
  to auth.log via syslog (3). This can be disabled by
  setting ENABLE_LOG_FAILED_LOGINS="0".
  (fabianx at bat.berlios.de)


Modified: trunk/freenx-server/ChangeLog
===================================================================
--- trunk/freenx-server/ChangeLog	2008-03-14 21:47:47 UTC (rev 533)
+++ trunk/freenx-server/ChangeLog	2008-03-16 20:40:13 UTC (rev 534)
@@ -1,3 +1,10 @@
+XX.06.2008 FreeNX 0.7.3
+	* Opened the 0.7.3 development.
+	* Added logging of failed authentication attempts
+	  to auth.log via syslog (3). This can be disabled by 
+	  setting ENABLE_LOG_FAILED_LOGINS="0".
+	  (fabianx at bat.berlios.de)
+
 14.03.2008 FreeNX 0.7.2 "Priscilla Edition"
 	* Opened the 0.7.2 development.
 	* Fixed the display of local sessions to display only 

Modified: trunk/freenx-server/node.conf.sample
===================================================================
--- trunk/freenx-server/node.conf.sample	2008-03-14 21:47:47 UTC (rev 533)
+++ trunk/freenx-server/node.conf.sample	2008-03-16 20:40:13 UTC (rev 534)
@@ -106,6 +106,15 @@
 #
 #ENABLE_SLAVE_MODE="0"
 
+# If ENABLE_LOG_FAILED_LOGINS="1" then failed login attempts are logged to the system
+# auth.log.
+#
+# This is useful in combination with tools like fail2ban.
+#
+# The default is to log failed login attemps via syslog (3).
+#
+#ENABLE_LOG_FAILED_LOGINS="1"
+
 #########################################################################
 # Restriction directives
 #########################################################################

Modified: trunk/freenx-server/nxloadconfig
===================================================================
--- trunk/freenx-server/nxloadconfig	2008-03-14 21:47:47 UTC (rev 533)
+++ trunk/freenx-server/nxloadconfig	2008-03-16 20:40:13 UTC (rev 534)
@@ -100,6 +100,8 @@
 
 ENABLE_SLAVE_MODE="0"
 
+ENABLE_LOG_FAILED_LOGINS="1"
+
 # Restriction directives
 
 DISPLAY_BASE=1000

Modified: trunk/freenx-server/nxserver
===================================================================
--- trunk/freenx-server/nxserver	2008-03-14 21:47:47 UTC (rev 533)
+++ trunk/freenx-server/nxserver	2008-03-16 20:40:13 UTC (rev 534)
@@ -787,6 +787,10 @@
 			else
 				echo_x "NX> 404 ERROR: wrong password or login"
 				echo_x "NX> 999 Bye"
+				if [ "$ENABLE_LOG_FAILED_LOGINS" = "1" ]
+				then
+					logger -t nxserver -i -p auth.info "($(whoami)) Failed login for user=$USER from IP=$(echo $SSH_CLIENT | awk '{print $1}')"
+				fi
 				exit 1
 			fi
 		;;



From fabianx at mail.berlios.de  Sun Mar 16 21:41:03 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Sun, 16 Mar 2008 21:41:03 +0100
Subject: [Freenx-cvs] r535 - trunk/freenx-server
Message-ID: <200803162041.m2GKf3K7019462@sheep.berlios.de>

Author: fabianx
Date: 2008-03-16 21:41:02 +0100 (Sun, 16 Mar 2008)
New Revision: 535

Modified:
   trunk/freenx-server/nxloadconfig
Log:
Opened the 0.7.3 development.



Modified: trunk/freenx-server/nxloadconfig
===================================================================
--- trunk/freenx-server/nxloadconfig	2008-03-16 20:40:13 UTC (rev 534)
+++ trunk/freenx-server/nxloadconfig	2008-03-16 20:41:02 UTC (rev 535)
@@ -52,7 +52,7 @@
 # DO NOT TOUCH unless you REALLY know what you are doing
 #########################################################################
 
-NX_VERSION=2.1.0-72
+NX_VERSION=2.1.0-73-SVN
 NX_LICENSE="OS (GPL, using backend: %BACKEND%)"
 
 # Where can different nx components be found



From fabianx at mail.berlios.de  Thu Mar 27 19:54:09 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Thu, 27 Mar 2008 19:54:09 +0100
Subject: [Freenx-cvs] r536 - trunk/freenx-server
Message-ID: <200803271854.m2RIs9bC013227@sheep.berlios.de>

Author: fabianx
Date: 2008-03-27 19:54:08 +0100 (Thu, 27 Mar 2008)
New Revision: 536

Modified:
   trunk/freenx-server/INSTALL
Log:
Added exception for nx-X11-compat as this breaks compilation.



Modified: trunk/freenx-server/INSTALL
===================================================================
--- trunk/freenx-server/INSTALL	2008-03-16 20:41:02 UTC (rev 535)
+++ trunk/freenx-server/INSTALL	2008-03-27 18:54:08 UTC (rev 536)
@@ -34,7 +34,7 @@
 
 Here is a howto:
 
-Get all sources from www.nomachine.com/sources.php
+Get all sources except nx-X11-compat.tar.gz from www.nomachine.com/sources.php
 
 Untar all sources, install all dependencies then do:
 



From fabianx at mail.berlios.de  Mon Mar 10 23:24:41 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Mon, 10 Mar 2008 22:24:41 -0000
Subject: [Freenx-cvs] r503 - in trunk/freenx-redesign/server: .
	compatibility lib lib/nxparser test test/include utility
Message-ID: <200803102223.m2AMN1vY003644@sheep.berlios.de>

Author: fabianx
Date: 2008-03-10 23:22:58 +0100 (Mon, 10 Mar 2008)
New Revision: 503

Added:
   trunk/freenx-redesign/server/COPYING
   trunk/freenx-redesign/server/Makefile
   trunk/freenx-redesign/server/compatibility/nxagent
   trunk/freenx-redesign/server/compatibility/nxnode
   trunk/freenx-redesign/server/compatibility/nxserver
   trunk/freenx-redesign/server/compatibility/nxservice
   trunk/freenx-redesign/server/compatibility/nxsession
   trunk/freenx-redesign/server/compatibility/nxshadow
   trunk/freenx-redesign/server/compatibility/nxstart
   trunk/freenx-redesign/server/lib/
   trunk/freenx-redesign/server/lib/nxloadconfig.py
   trunk/freenx-redesign/server/lib/nxloadconfig_test.py
   trunk/freenx-redesign/server/lib/nxlog.py
   trunk/freenx-redesign/server/lib/nxlog_test.py
   trunk/freenx-redesign/server/lib/nxparser.py.orig
   trunk/freenx-redesign/server/lib/nxparser/
   trunk/freenx-redesign/server/lib/nxparser/__init__.py
   trunk/freenx-redesign/server/lib/nxparser/base.py
   trunk/freenx-redesign/server/lib/nxparser/base_test.py
   trunk/freenx-redesign/server/lib/nxparser/node.py
   trunk/freenx-redesign/server/lib/nxparser/server.py
   trunk/freenx-redesign/server/lib/nxsession.py
   trunk/freenx-redesign/server/lib/nxsession_test.py
   trunk/freenx-redesign/server/test/
   trunk/freenx-redesign/server/test/README.TXT
   trunk/freenx-redesign/server/test/client2server-regression.run
   trunk/freenx-redesign/server/test/client2server-regression.template
   trunk/freenx-redesign/server/test/include/
   trunk/freenx-redesign/server/test/include/commercial-nx-3.0-functions
   trunk/freenx-redesign/server/test/include/nxserver-fuctions.inc
   trunk/freenx-redesign/server/test/include/test-functions.inc
   trunk/freenx-redesign/server/test/run-test-suite
   trunk/freenx-redesign/server/test/testClient2server-regression-1.5.0
   trunk/freenx-redesign/server/test/testClient2server-regression-2.0.0
   trunk/freenx-redesign/server/test/testClient2server-regression-2.1.0
   trunk/freenx-redesign/server/test/testClient2server-regression-3.0.0
   trunk/freenx-redesign/server/test/testNxloadconfig
   trunk/freenx-redesign/server/test/testNxlog
   trunk/freenx-redesign/server/test/testNxserver-login
   trunk/freenx-redesign/server/test/testTest-functions
   trunk/freenx-redesign/server/utility/log4sh
   trunk/freenx-redesign/server/utility/nxagent-helper
   trunk/freenx-redesign/server/utility/nxloadconfig-helper.sh
   trunk/freenx-redesign/server/utility/nxserver-suid.c
   trunk/freenx-redesign/server/utility/shunit2
Modified:
   trunk/freenx-redesign/server/compatibility/nxserver-login
   trunk/freenx-redesign/server/compatibility/nxserver-login-helper
   trunk/freenx-redesign/server/compatibility/nxserver-login-hook
   trunk/freenx-redesign/server/utility/nxloadconfig
   trunk/freenx-redesign/server/utility/nxlog
Log:
Imported redesign snapshot by Google.

Thanks to diamond at google.com.



Added: trunk/freenx-redesign/server/COPYING
===================================================================
--- trunk/freenx-redesign/server/COPYING	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/COPYING	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,339 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.

Added: trunk/freenx-redesign/server/Makefile
===================================================================
--- trunk/freenx-redesign/server/Makefile	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/Makefile	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,104 @@
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: alriddoch at google.com (Alistair Riddoch)
+
+.PHONY: all install dist
+
+SUDO_PROMPT = Your password for sudo access:
+
+PACKAGE = freenx
+VERSION = 0.0.0
+CC = gcc
+CFLAGS = -Wall -g
+
+INSTALL = install
+TAR = tar
+PREFIX = /usr/freenx
+BINDIR = $(PREFIX)/bin
+LIBDIR = $(PREFIX)/lib
+PARSERLIBDIR = $(LIBDIR)/nxparser
+ETCDIR = $(PREFIX)/etc
+VARDIR = $(PREFIX)/var
+SESSDBDIR = $(VARDIR)/sessdb
+TMPNXDIR = /tmp/nx
+COMPATABILITY = compatibility/nxagent \
+                compatibility/nxnode \
+                compatibility/nxserver \
+                compatibility/nxserver-login \
+                compatibility/nxserver-login-helper \
+                compatibility/nxserver-login-hook \
+                compatibility/nxserver-login-userhook \
+                compatibility/nxservice \
+                compatibility/nxshadow \
+                compatibility/nxstart
+UTILITY = utility/nxloadconfig \
+          utility/nxloadconfig-helper.sh \
+          utility/nxlog \
+          utility/log4sh \
+          utility/nxagent-helper
+SOURCES = utility/nxserver-suid.c
+PROGRAMS = utility/nxserver-suid
+BINARIES = $(COMPATABILITY) $(UTILITY) $(PROGRAMS)
+LIBRARIES = lib/nxloadconfig.py \
+            lib/nxlog.py \
+            lib/nxsession.py
+PARSER_LIB = lib/nxparser/__init__.py \
+             lib/nxparser/base.py \
+             lib/nxparser/node.py \
+             lib/nxparser/server.py
+
+all: $(PROGRAMS)
+
+ARCHIVE=$(PWD)/$(PACKAGE)-$(VERSION).tar.gz
+DISTDIR=$${TMPDIR-/tmp}/$(PACKAGE)-$(VERSION)
+dist:
+	$(RM) -r $(DISTDIR)
+	$(INSTALL) -d $(DISTDIR)
+	$(INSTALL) -m 644 Makefile $(DISTDIR)
+	$(INSTALL) -d $(DISTDIR)/utility
+	$(INSTALL) -m 755 $(UTILITY) $(DISTDIR)/utility
+	$(INSTALL) -d $(DISTDIR)/compatability
+	$(INSTALL) -m 755 $(COMPATABILITY) $(DISTDIR)/compatability
+	$(INSTALL) -m 644 $(SOURCES) $(DISTDIR)/utility
+	$(INSTALL) -d $(DISTDIR)/lib
+	$(INSTALL) -m 644 $(LIBRARIES) $(DISTDIR)/lib
+	$(INSTALL) -d $(DISTDIR)/lib/nxparser
+	$(INSTALL) -m 644 $(PARSER_LIB) $(DISTDIR)/lib/nxparser
+	(cd $${TMPDIR-/tmp} && $(TAR) chozf $(ARCHIVE) $(PACKAGE)-$(VERSION))
+	$(RM) -r $(DISTDIR)
+
+install: utility/nxserver-suid
+	@sudo -p "$(SUDO_PROMPT)" true
+	sudo $(INSTALL) -o $(LOGNAME) -d -m 755 $(BINDIR)
+	sudo $(INSTALL) -o nx -d -m 755 $(VARDIR)
+	sudo $(INSTALL) -o nx -d -m 700 $(SESSDBDIR)
+	$(INSTALL) -m 755 $(BINARIES) $(BINDIR)
+	$(INSTALL) -d -m 755 $(LIBDIR)
+	$(INSTALL) -m 644 $(LIBRARIES) $(LIBDIR)
+	$(INSTALL) -d -m 755 $(PARSERLIBDIR)
+	$(INSTALL) -m 644 $(PARSER_LIB) $(PARSERLIBDIR)
+	$(INSTALL) -d -m 755 $(ETCDIR)
+	echo -e "PATH_BIN=\"$(BINDIR)\"\nPATH=\"$$PATH:$(BINDIR)\"\nLOG_LEVEL=DEBUG" > $(ETCDIR)/general.conf
+	echo -e "LOG_LEVEL=NOTICE" > $(ETCDIR)/nxstart.conf
+	echo -e "COMMAND_START_GNOME='/usr/bin/dbus-launch --exit-with-session gnome-session'\n\
+	COMMAND_START_KDE='/usr/bin/dbus-launch --exit-with-session startkde'" > $(ETCDIR)/nxagent-helper.conf
+	chmod 644 $(ETCDIR)/general.conf
+	sudo chown nx $(BINDIR)/nxserver-suid
+	sudo chmod 4755 $(BINDIR)/nxserver-suid
+	[ ! -e $(TMPNXDIR] && sudo mkdir $(TMPNXDIR)
+	sudo chown root:root $(TMPNXDIR)
+	sudo chmod 1777 $(TMPNXDIR)

Added: trunk/freenx-redesign/server/compatibility/nxagent
===================================================================
--- trunk/freenx-redesign/server/compatibility/nxagent	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/compatibility/nxagent	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,43 @@
+#!/bin/bash
+
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# nxfoo - Provides functionality for the freenx redesign
+#
+# Authors: diamond at google.com (Stephen Shirley)
+#          alriddoch at google.com (Alistair Riddoch)
+#
+# Used configuration keys:
+#
+# Used internal subfunctions:
+#
+# Used internal variables:
+#
+# Used internal components:
+#
+# Used external programs:
+#
+# Accepted protocol requests from client:
+#
+# Used protocol responses to client:
+#
+# FAQ-Questions:
+#
+# SVN: $Id: $
+#
+
+exec /usr/NX/bin/nxagent "$@"


Property changes on: trunk/freenx-redesign/server/compatibility/nxagent
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/compatibility/nxnode
===================================================================
--- trunk/freenx-redesign/server/compatibility/nxnode	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/compatibility/nxnode	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,55 @@
+#!/usr/bin/python2.4
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: alriddoch at google.com (Alistair Riddoch)
+
+"""nxnode program for handling nx nodes.
+
+"""
+
+import sys
+import signal
+
+sys.path.append('/usr/freenx/lib')
+import nxlog
+import nxparser
+
+
+def signal_handler(signum, unused_frame):
+  nxlog.log(nxlog.LOG_DEBUG, 'Going down on signal %d' % signum)
+  sys.exit(1)
+
+
+def main():
+  nxlog.setup('nxnode')
+  nxlog.set_log_level(nxlog.LOG_DEBUG)
+  nxlog.log(nxlog.LOG_DEBUG, 'Startup')
+  nxlog.log(nxlog.LOG_DEBUG, 'Args %r' % sys.argv)
+
+  signal.signal(signal.SIGINT, signal_handler)
+  signal.signal(signal.SIGTERM, signal_handler)
+  signal.signal(signal.SIGHUP, signal.SIG_IGN)
+
+  parser = nxparser.node.parser(sys.stdin, sys.stdout)
+  parser.banner()
+  parser.loop()
+  nxlog.log(nxlog.LOG_DEBUG, 'Finished')
+
+
+if __name__ == '__main__':
+  main()


Property changes on: trunk/freenx-redesign/server/compatibility/nxnode
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/compatibility/nxserver
===================================================================
--- trunk/freenx-redesign/server/compatibility/nxserver	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/compatibility/nxserver	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,55 @@
+#!/usr/bin/python2.4
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: alriddoch at google.com (Alistair Riddoch)
+
+"""nxserver program for accepting nx connections.
+
+"""
+
+import sys
+import signal
+
+sys.path.append('/usr/freenx/lib')
+import nxlog
+import nxparser
+
+
+def signal_handler(signum, unused_frame):
+  nxlog.log(nxlog.LOG_DEBUG, 'Going down on signal %d' % signum)
+  sys.exit(1)
+
+
+def main():
+  nxlog.setup('nxserver')
+  nxlog.set_log_level(nxlog.LOG_DEBUG)
+  nxlog.log(nxlog.LOG_DEBUG, 'Startup')
+  nxlog.log(nxlog.LOG_DEBUG, 'Args %r' % sys.argv)
+
+  signal.signal(signal.SIGINT, signal_handler)
+  signal.signal(signal.SIGTERM, signal_handler)
+  signal.signal(signal.SIGHUP, signal_handler)
+
+  parser = nxparser.server.parser(sys.stdin, sys.stdout)
+  parser.banner()
+  parser.loop()
+  nxlog.log(nxlog.LOG_DEBUG, 'Finished')
+
+
+if __name__ == '__main__':
+  main()


Property changes on: trunk/freenx-redesign/server/compatibility/nxserver
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/freenx-redesign/server/compatibility/nxserver-login
===================================================================
--- trunk/freenx-redesign/server/compatibility/nxserver-login	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/compatibility/nxserver-login	2008-03-10 22:22:58 UTC (rev 503)
@@ -17,7 +17,6 @@
 # @sub echo_x echo and possibly log and/or translate
 # @sub read_x read with specified timeout
 # @sub "read_x_prompt <prompt> " like read_x but show <prompt> first
-# @sub "log n" log to (sys)log with loglevel n
 #
 # Used internal variables:
 #
@@ -53,9 +52,9 @@
 # @rsp 102	"NX> 404 ERROR: wrong password or login" Answer for wrong user or wrong password.
 # @rsp 102	"NX> 103 Welcome" Used implicitely as nxserver-login-helper will go into interact mode on 103.
 # @rsp *	"NX> 996 ERROR: Operation timeout in server protocol" Thrown if the read_x times out.
-# @rsp bye	"NX> 999 Bye."
-# @rsp exit	"NX> 999 Bye."
-# @rsp quit	"NX> 999 Bye."
+# @rsp bye	"NX> 999 Bye"
+# @rsp exit	"NX> 999 Bye"
+# @rsp quit	"NX> 999 Bye"
 # 
 # FAQ-Questions:
 #
@@ -72,26 +71,21 @@
 NXSERVER_LOGIN_HOOK_LOGIN_USER=""
 NXSERVER_LOGIN_AUTHENTICATION_METHOD="su"
 
+_NXLOADCONFIG="$(cd $(dirname $0) && pwd -L)/nxloadconfig"
+[ -f "$_NXLOADCONFIG" ] || _NXLOADCONFIG='nxloadconfig'
+
 #Read the nxserver-login.cfg file and load some helper functions
-#. $(PATH=$(cd $(dirname $0) && pwd):$PATH which nxloadconfig) -- --config=nxserver-login || { echo "NX 503> Internal server error. nxloadconfig could not be loaded."; exit 1; }
+. "$_NXLOADCONFIG" --config="nxserver-login" || { echo "NX 503> Internal server error. nxloadconfig could not be loaded."; exit 1; }
 
-# FIXME: Remove this section once nxloadconfig above works
-
-PATH_BIN=$(cd $(dirname $0) && pwd)
-COMMAND_NETCAT="$(which netcat)"
-
 echo_x() 
 {
 	echo "$@"
+  nxlog_log DEBUG "Sent: $@"
 }
 
-log()
-{
-	echo "LOG: $@"
-} 
 read_x()
 {
-	read -t 10 "$@"
+	read -t "${READ_X_TIMEOUT:-10}" "$@" || { echo_x; return 1; }
 }
 
 read_x_prompt() 
@@ -101,24 +95,6 @@
 	read_x "$@"
 }
 
-# Re-check configuration keys
-
-if [ -n "$NXSERVER_LOGIN_HOOK_LOGIN_USER" -a ! -x "$NXSERVER_LOGIN_HOOK_LOGIN_USER" ]
-then
-	log $LOG_WARN $"Warning: Configuration key NXSERVER_LOGIN_HOOK_LOGIN_USER=$NXSERVER_LOGIN_HOOK_LOGIN_USER is invalid. Reset to \"\"."
-	NXSERVER_LOGIN_HOOK_LOGIN_USER=""
-fi
-
-case "$NXSERVER_LOGIN_AUTHENTICATION_METHOD" in
-	ssh|su)
-	;;
-	*)
-		log $LOG_WARN $"Warning: Configuration key NXSERVER_LOGIN_AUTHENTICATION_METHOD=$NXSERVER_LOGIN_AUTHENTICATION_METHOD is invalid. Reset to su."
-		NXSERVER_LOGIN_AUTHENTICATION_METHOD="su"
-	;;
-esac
-
-
 # helper functions
 
 timeout()
@@ -128,76 +104,140 @@
 	exit 1
 }
 
-# main program
+config_check()
+{
+  # Re-check configuration keys
 
-echo_x "HELLO NXSERVER - Version $NX_VERSION $NX_LICENSE"
+  if [ -n "$NXSERVER_LOGIN_HOOK_LOGIN_USER" -a ! -x "$NXSERVER_LOGIN_HOOK_LOGIN_USER" ]
+  then
+    nxlog_log WARNING $"Warning: Configuration key NXSERVER_LOGIN_HOOK_LOGIN_USER=$NXSERVER_LOGIN_HOOK_LOGIN_USER is invalid. Reset to \"\"."
+    NXSERVER_LOGIN_HOOK_LOGIN_USER=""
+  fi
 
-# Login stage
-while read_x_prompt "NX> 105 " CMD
-do
-	echo_x "$CMD"
-	
-	case "$CMD" in 
-		quit|QUIT)
-			echo_x "Quit"
-			break
-		;;
-		exit|EXIT)
-			echo_x "Exit"
-			break
-		;;
-		bye|BYE)
-			echo_x "Bye"
-			break
-		;;
-		hello*|HELLO*)
-			PROTO=$(echo $CMD | sed 's/.*Version \(.*\)/\1/g')
-			echo_x $"NX> 134 Accepted protocol: $PROTO"
-		;;
-		"set auth_mode*"|"SET AUTH_MODE*")
-			if [ "$CMD" = "set auth_mode password" -o "$CMD" = "SET AUTH_MODE PASSWORD" ]
-			then
-				echo_x "Set auth_mode: password"
-			else
-				echo_x $"NX> 500 ERROR: unknown auth mode ''"
-			fi
-		;;
-		login|LOGIN)
-			LOGIN_SUCCESS="0"
-			
-			echo_x -n $"NX> 101 User: "
-			read_x USER || timeout
-			echo_x $USER
-			
-			echo_x -n $"NX> 102 Password: "
-			read_x -s PASS || timeout
-			echo_x ""
-			log $LOG_INFO $"Info: Using authentication method $NXSERVER_LOGIN_AUTHENTICATION_METHOD for user $USER."
+  case "$NXSERVER_LOGIN_AUTHENTICATION_METHOD" in
+    ssh|su)
+    ;;
+    *)
+      nxlog_log WARNING $"Warning: Configuration key NXSERVER_LOGIN_AUTHENTICATION_METHOD=$NXSERVER_LOGIN_AUTHENTICATION_METHOD is invalid. Reset to su."
+      NXSERVER_LOGIN_AUTHENTICATION_METHOD="su"
+    ;;
+  esac
+}
 
-			NODE_HOOK_LOGIN="$PATH_BIN/nxserver-login-hook"
-			[ -n "$NXSERVER_LOGIN_HOOK_LOGIN_USER" ] && NODE_HOOK_LOGIN="$NXSERVER_LOGIN_HOOK_LOGIN_USER"
-			export NODE_HOOK_LOGIN
+nxserver-login_main()
+{
+  # main program
 
-			NODE_PASSWORD="$PASS" $PATH_BIN/nxserver-login-helper -- "$NXSERVER_LOGIN_AUTHENTICATION_METHOD" "$USER" "$PATH_BIN/nxserver-suid" "--proto=$PROTO"
-			AUTHENTICATION_FAILED="$?"
-			
-			if [ "$AUTHENTICATION_FAILED" = "1" ]
-			then
-				echo_x $"NX> 404 ERROR: wrong password or login"
-				echo_x $"NX> 999 Bye."
-				exit 1
-			fi
-			
-			if [ "$AUTHENTICATION_FAILED" = "2" ]
-			then
-				echo_x $"NX> 503 ERROR: Redirection to nxagent failed."
-				echo_x $"NX> 999 Bye."
-				exit 2
-			fi
+  echo_x "HELLO NXSERVER - Version $NX_VERSION $NX_LICENSE"
+  nxlog_log INFO "Started"
 
-			exit 0
-		;;
-	esac
-done
-echo_x $"NX> 999 Bye."
-exit 0
+  # Login stage
+  while read_x_prompt "NX> 105 " CMD
+  do
+    nxlog_log DEBUG "Got: $CMD"
+    CMD=$(echo $CMD | tr '[A-Z]' '[a-z]')
+    case "$CMD" in
+      quit)
+        echo_x "Quit"
+        nxlog_log DEBUG "Exiting"
+        break
+      ;;
+      exit)
+        echo_x "Exit"
+        nxlog_log DEBUG "Exiting"
+        break
+      ;;
+      bye)
+        echo_x "Bye"
+        nxlog_log DEBUG "Exiting"
+        break
+      ;;
+      hello*)
+        echo_x "$CMD"
+        CLIENT_PROTO="$(echo $CMD | sed 's/.*[Vv]ersion \(.*\)/\1/g')"
+        PROTO="$(echo -e "$NX_VERSION\n$CLIENT_PROTO" | \
+            sort -n -t. -k1,1 -k2,2 -k3 | head -1)"
+        echo_x $"NX> 134 Accepted protocol: $PROTO"
+      ;;
+      set\ auth_mode\ *)
+        mode=$(echo "$CMD" | sed 's/^[^[:blank:]]\+ [^[:blank:]]\+ \(.*\)/\1/')
+        echo_x "Set auth_mode: $mode"
+        if ! echo "$mode" | egrep -q "password"; then
+          echo_x "NX> 500 ERROR: unknown auth mode ''"
+        fi
+      ;;
+      set\ shell_mode\ *)
+        mode=$(echo "$CMD" | sed 's/^[^[:blank:]]\+ [^[:blank:]]\+ \(.*\)/\1/')
+        echo_x "Set shell_mode: $mode"
+        if ! echo "$mode" | egrep -q "shell"; then
+          echo_x "NX> 500 ERROR: unknown shell mode ''"
+        fi
+      ;;
+      login)
+        echo_x "$CMD"
+        LOGIN_SUCCESS="0"
+
+        echo_x -n $"NX> 101 User: "
+        read_x USER || timeout
+        echo_x $USER
+
+        echo_x -n $"NX> 102 Password: "
+        read_x -s PASS || timeout
+        echo_x "**********"
+        nxlog_log INFO "Info: Using authentication method $NXSERVER_LOGIN_AUTHENTICATION_METHOD for user $USER."
+
+        NODE_HOOK_LOGIN="$PATH_BIN/nxserver-login-hook"
+        [ -n "$NXSERVER_LOGIN_HOOK_LOGIN_USER" ] && \
+            NODE_HOOK_LOGIN="$NXSERVER_LOGIN_HOOK_LOGIN_USER"
+        export NODE_HOOK_LOGIN
+
+        # Redirection is used to get around | only being useful for stdout.
+        nxlog_log INFO "Info: Invoking nxserver-login-helper"
+        # This fifo is opened by nxserver-login-helper to log through
+        export SERVER_LOGIN_HELPER_LOG="$(mktemp -d /tmp/nxserver-login.XXXXXX)/fifo"
+        mkfifo "$SERVER_LOGIN_HELPER_LOG"
+        (
+          nxlog_log DEBUG "Starting to log nxserver-login-helper debug output $SERVER_LOGIN_HELPER_LOG"
+          NXLOG_LOG_PIPE_PREFIX="helper output:" nxlog_log_pipe DEBUG < "$SERVER_LOGIN_HELPER_LOG"
+          nxlog_log DEBUG "Finished logging nxserver-login-helper debug output"
+          # Cleanup after the fifo
+          rm "$SERVER_LOGIN_HELPER_LOG"
+          rmdir $(dirname "$SERVER_LOGIN_HELPER_LOG")
+        ) &
+        NODE_PASSWORD="$PASS" "$PATH_BIN/nxserver-login-helper" -- \
+          "$NXSERVER_LOGIN_AUTHENTICATION_METHOD" "$USER" \
+          "$PATH_BIN/nxserver-suid" "--proto=${PROTO:-}"
+
+        AUTHENTICATION_FAILED="$?"
+
+        if [ "$AUTHENTICATION_FAILED" = "0" ]
+        then
+          true
+        elif [ "$AUTHENTICATION_FAILED" = "1" ]
+        then
+          echo_x $"NX> 404 ERROR: wrong password or login."
+          echo_x $"NX> 999 Bye."
+          exit 1
+        elif [ "$AUTHENTICATION_FAILED" = "2" ]
+        then
+          echo_x $"NX> 503 ERROR: Redirection to nxagent failed."
+          echo_x $"NX> 999 Bye."
+          exit 2
+        else
+          echo_x $"NX> 500 ERROR: Unknown error \"$AUTHENTICATION_FAILED\" occurred while logging in."
+          echo_x $"NX> 999 Bye."
+          exit 3
+        fi
+
+        exit 0
+      ;;
+    esac
+  done
+  echo_x "NX> 999 Bye."
+  exit 0
+}
+
+if [ -z "${UNITTESTING:-}" ]; then
+  config_check
+  nxserver-login_main
+fi

Modified: trunk/freenx-redesign/server/compatibility/nxserver-login-helper
===================================================================
--- trunk/freenx-redesign/server/compatibility/nxserver-login-helper	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/compatibility/nxserver-login-helper	2008-03-10 22:22:58 UTC (rev 503)
@@ -58,6 +58,14 @@
 # SVN: $Id$
 #
 
+## Uncomment for debugging:
+#exp_internal 1
+
+#Log the interaction to a fifo, and not to stdout.
+catch {set helper_log_fifo $env(SERVER_LOGIN_HELPER_LOG)}
+log_file -a -noappend $helper_log_fifo
+log_user 0
+
 set auth_method [lindex $argv 0]
 set user [lindex $argv 1]
 set executable [lindex $argv 2]
@@ -69,14 +77,14 @@
 set command_netcat "netcat"
 catch {set command_netcat $env(COMMAND_NETCAT)}
 set host "127.0.0.1"
-set timeout 2
+set timeout 20
 
 #
 # Special test-nx instruction for nxsetup
 #
 
 if { "$auth_method"=="test-nx" } {
-	set stty_init "raw icrnl -echo"
+	set stty_init "raw -echo"
 
 	set publickey ""
 	catch {set publickey $env(NODE_PUBLICKEY)}
@@ -85,10 +93,10 @@
 	expect {
 		timeout { exit 1 }
 		eof { exit 1 }
-		"Are you sure you want to continue connecting (yes/no)?" { send "yes\r"; exp_continue }
+		"Are you sure you want to continue connecting (yes/no)?" { send "yes\n"; exp_continue }
 		"Permission denied*" { exit 1 }
 		"HELLO NXSERVER - Version" { 
-			expect "NX> 105" { send "quit\r" }
+			expect "NX> 105" { send "quit\n" }
 			expect "NX> 999 Bye" { exit 0 }
 		}
 	}
@@ -101,9 +109,9 @@
 
 set password ""
 catch {set password $env(NODE_PASSWORD)}
+set env(NODE_PASSWORD) ""
+set stty_init "raw -echo"
 
-set stty_init "raw icrnl -echo"
-
 if { "$auth_method"!="test-nx" } {
 	set pid [ spawn -noecho $command_login "$auth_method" "$user" "$executable" "$parameters" ]
 } else {
@@ -113,11 +121,17 @@
 expect {
 	timeout { exit 1 }
 	eof { exit 1 }
-	"Are you sure you want to continue connecting (yes/no)?" { send "yes\r"; exp_continue }
-	"assword*:"  { sleep 0.3; send "$password\r"; set password ""; exp_continue }
+	"Are you sure you want to continue connecting (yes/no)?" { send "yes\n"; exp_continue }
+	"assword*:"  { sleep 0.3; send "$password\n"; set password ""; exp_continue }
 	"Permission denied*" { exit 1 }
 	"su: Authentication failure" { exit 1 }
-	"NX> 103" {
+	"Unknown id:*" { exit 1 }
+	-notransfer "NX> 103*" {
+		# Stop logging to stderr:
+		log_file
+		send_user "$expect_out(buffer)"
+		# Send all output to the user:
+		log_user 1
 		set redir "0"
 		interact {
 			-o "FREENX> 100 " {

Modified: trunk/freenx-redesign/server/compatibility/nxserver-login-hook
===================================================================
--- trunk/freenx-redesign/server/compatibility/nxserver-login-hook	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/compatibility/nxserver-login-hook	2008-03-10 22:22:58 UTC (rev 503)
@@ -12,7 +12,7 @@
 # FIXME: Read general config
 
 SSH_PORT="22"
-SSH_HOST="127.0.0.1"
+SSH_HOST="$HOSTNAME"
 COMMAND_SU="su"
 COMMAND_SSH="ssh"
 
@@ -23,10 +23,10 @@
 
 case "$1" in
 	ssh)
-		exec $COMMAND_SSH -2 -x -l "$2" "$SSH_HOST" -p "$SSH_PORT" -o "NumberOfPasswordPrompts 1" "$3" "$4"
+		exec $COMMAND_SSH -2 -x -l "$2" "$SSH_HOST" -p "$SSH_PORT" -o "NumberOfPasswordPrompts 1" "PATH=$PATH" "$3" "$4"
 	;;
 	su)
-		exec $COMMAND_SU - "$2" -c "$3 $4"
+		exec $COMMAND_SU - "$2" -c "PATH=$PATH $3 $4"
 	;;
 esac
 

Added: trunk/freenx-redesign/server/compatibility/nxservice
===================================================================
--- trunk/freenx-redesign/server/compatibility/nxservice	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/compatibility/nxservice	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,44 @@
+#!/bin/bash
+
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# nxfoo - Provides functionality for the freenx redesign
+#
+# Author: alriddoch at google.com (Alistair Riddoch)
+#
+# Used configuration keys:
+#
+# Used internal subfunctions:
+#
+# Used internal variables:
+#
+# Used internal components:
+#
+# Used external programs:
+#
+# Accepted protocol requests from client:
+#
+# Used protocol responses to client:
+#
+# FAQ-Questions:
+#
+# SVN: $Id: $
+#
+
+export LOG_LEVEL=7
+
+nxlog 7 Unimplemented command $0 invoked with arguments $@


Property changes on: trunk/freenx-redesign/server/compatibility/nxservice
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/compatibility/nxsession
===================================================================
--- trunk/freenx-redesign/server/compatibility/nxsession	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/compatibility/nxsession	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,44 @@
+#!/bin/bash
+
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# nxfoo - Provides functionality for the freenx redesign
+#
+# Author: alriddoch at google.com (Alistair Riddoch)
+#
+# Used configuration keys:
+#
+# Used internal subfunctions:
+#
+# Used internal variables:
+#
+# Used internal components:
+#
+# Used external programs:
+#
+# Accepted protocol requests from client:
+#
+# Used protocol responses to client:
+#
+# FAQ-Questions:
+#
+# SVN: $Id: $
+#
+
+export LOG_LEVEL=7
+
+nxlog 7 Unimplemented command $0 invoked with arguments $@


Property changes on: trunk/freenx-redesign/server/compatibility/nxsession
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/compatibility/nxshadow
===================================================================
--- trunk/freenx-redesign/server/compatibility/nxshadow	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/compatibility/nxshadow	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,44 @@
+#!/bin/bash
+
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# nxfoo - Provides functionality for the freenx redesign
+#
+# Author: alriddoch at google.com (Alistair Riddoch)
+#
+# Used configuration keys:
+#
+# Used internal subfunctions:
+#
+# Used internal variables:
+#
+# Used internal components:
+#
+# Used external programs:
+#
+# Accepted protocol requests from client:
+#
+# Used protocol responses to client:
+#
+# FAQ-Questions:
+#
+# SVN: $Id: $
+#
+
+export LOG_LEVEL=7
+
+nxlog 7 Unimplemented command $0 invoked with arguments $@


Property changes on: trunk/freenx-redesign/server/compatibility/nxshadow
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/compatibility/nxstart
===================================================================
--- trunk/freenx-redesign/server/compatibility/nxstart	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/compatibility/nxstart	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,61 @@
+#!/bin/bash
+
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# nxfoo - Provides functionality for the freenx redesign
+#
+# Authors: diamond at google.com (Stephen Shirley)
+#
+# License: GNU GPL, version 2
+#
+# Used configuration keys:
+#
+# Used internal subfunctions:
+#
+# Used internal variables:
+#
+# Used internal components:
+#
+# Used external programs:
+#
+# Accepted protocol requests from client:
+#
+# Used protocol responses to client:
+#
+# FAQ-Questions:
+#
+# SVN: $Id: $
+#
+
+. nxloadconfig --config="nxstart" || { echo "NX 503> Internal server error. nxloadconfig could not be loaded by nxstart."; exit 1; }
+
+AGENT_PID="$1"
+shift
+
+nxlog_log NOTICE "Agent: $AGENT_PID Cmd: $@"
+
+echo "Xft.dpi: 96" | LANG=C xrdb -merge 2>&1 | nxlog_log_pipe DEBUG
+
+"$@" 2>&1 | nxlog_log_pipe DEBUG
+
+msg="Cmd exited, nxagent (pid $AGENT_PID)"
+if kill -0 "$AGENT_PID" &>/dev/null; then
+  nxlog_log DEBUG "$msg still exists, killing"
+  kill "$AGENT_PID" || nxlog_log ERR "Killing nxagent returned error $?"
+else
+  nxlog_log NOTICE "$msg already exited"
+fi


Property changes on: trunk/freenx-redesign/server/compatibility/nxstart
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/lib/nxloadconfig.py
===================================================================
--- trunk/freenx-redesign/server/lib/nxloadconfig.py	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/lib/nxloadconfig.py	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,150 @@
+#!/usr/bin/python2.4
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: diamond at google.com (Stephen Shirley)
+
+"""nxloadconfg module"""
+
+__author__ = 'diamond at google.com (Stephen Shirley)'
+__copyright__ = 'Copyright 2007 Google Inc.'
+
+import os
+import subprocess
+import sys
+
+import nxlog
+
+
+__default_prefix = '/usr/freenx'
+__conf_errors = False
+
+conf={'PATH_BASE': __default_prefix,
+  'PATH_ETC': os.path.join(__default_prefix, 'etc'),
+  'PATH': os.getenv('PATH')}
+
+
+def setup(conf_file=None):
+  global __conf_errors
+  __conf_errors = False
+
+  __conf_load("general")
+  if conf_file: __conf_load(conf_file)
+  __check_command_vars()
+  __check_dir_vars()
+
+  if __conf_errors:
+    nxlog.log(nxlog.LOG_CRIT, "Configuration errors, exiting\n")
+    sys.exit(1)
+
+
+def __conf_load(conf_file):
+  conf_file_path = os.path.join(conf["PATH_ETC"], "%s.conf" % conf_file)
+  if not os.path.exists(conf_file_path):
+    nxlog.log(nxlog.LOG_DEBUG, "Requested file %s doesn't exist\n" % conf_file_path)
+    return
+  for line in subprocess.Popen('nxloadconfig-helper.sh %s' % conf_file_path,
+    shell=True, stdout=subprocess.PIPE, env=conf).stdout:
+    var, val = line.split('=')
+    conf[var] = val.rstrip()
+
+
+def __check_command_vars():
+  check_command_var("COMMAND_START_KDE", which("startkde"))
+  check_command_var("COMMAND_START_GNOME", which("gnome-session"))
+  check_command_var("COMMAND_START_CDE", which("cdwm"))
+  check_command_var("COMMAND_XTERM", which("xterm"))
+  check_command_var("COMMAND_XAUTH", which("xauth"))
+  check_command_var("COMMAND_SMBMOUNT", which("smbmount"))
+  check_command_var("COMMAND_SMBUMOUNT", which("smbumount"))
+  check_command_var("COMMAND_NETCAT", which("netcat"))
+  check_command_var("COMMAND_SSH", which("ssh"))
+  check_command_var("COMMAND_SSH_KEYGEN", which("ssh-keygen"))
+  check_command_var("COMMAND_CUPSD", which("cupsd"))
+  check_command_var("COMMAND_MD5SUM", which("md5sum"))
+
+
+def __check_dir_vars():
+  check_dir_var("PATH_BASE", conf.get("PATH_BASE"))
+  check_dir_var("PATH_BIN", os.path.join(conf.get("PATH_BASE"), "bin"))
+  check_dir_var("PATH_ETC", os.path.join(conf.get("PATH_BASE"), "etc"))
+  check_dir_var("PATH_LIB", os.path.join(conf.get("PATH_BASE"), "lib"))
+
+
+def check_command_var(varname, defval):
+  def is_valid(path):
+    try:
+      cmd = path.split()[0]
+    except IndexError:
+      # Can happen if path is None, or "" etc
+      cmd = path
+    return cmd is not None and os.path.isfile(cmd) and os.access(cmd, os.X_OK)
+
+  global __conf_errors
+  varval = conf.get(varname)
+
+  if varval is not None: # Is there a value set already?
+    if is_valid(varval):
+      return True # Everything checks out.
+    else:
+      nxlog.log(nxlog.LOG_WARNING, "Invalid command variable %s: \"%s\"\n" %
+          (varname, varval))
+
+  if defval == "" or is_valid(defval):
+    # Everything ok now, we assume it's blank if deliberately unset
+    # (or if the command isn't available
+    conf[varname] = defval
+    return True
+  else:
+    nxlog.log(nxlog.LOG_ERR, "Invalid default command variable %s: \"%s\"\n" %
+        (varname, defval))
+    __conf_errors = True
+    return False
+
+
+def check_dir_var(varname, defval):
+  def is_valid(path):
+    return path is not None and os.path.isdir(path)
+
+  global __conf_errors
+  varval = conf.get(varname)
+
+  if varval is not None: # Is there a value set already?
+    if is_valid(varval):
+      return True # Everything checks out.
+    else:
+      nxlog.log(nxlog.LOG_WARNING, "Invalid directory variable %s: \"%s\"\n" %
+          (varname, varval))
+
+  if is_valid(defval):
+    # Everything ok now
+    conf[varname] = defval
+    return True
+  else:
+    nxlog.log(nxlog.LOG_ERR, "Invalid default directory variable %s: \"%s\"\n" %
+        (varname, defval))
+    __conf_errors = True
+    return False
+
+
+def which(cmd):
+  return os.popen("which %s" % cmd).read().rstrip()
+
+
+if __name__ == '__main__':
+  print 'This is a library. Please use it from python using import.'
+  sys.exit(0)


Property changes on: trunk/freenx-redesign/server/lib/nxloadconfig.py
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/lib/nxloadconfig_test.py
===================================================================
--- trunk/freenx-redesign/server/lib/nxloadconfig_test.py	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/lib/nxloadconfig_test.py	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,117 @@
+#!/usr/bin/python2.4
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: diamond at google.com (Stephen Shirley)
+
+"""nxloadconfig module unit tests"""
+
+import copy
+import unittest
+
+import nxlog
+import nxloadconfig
+
+__author__ = 'diamond at google.com (Stephen Shirley)'
+__copyright__ = 'Copyright 2007 Google Inc.'
+
+nxlog.setup("nxloadconfig_test")
+
+
+class NXLoadConifgUnitTest(unittest.TestCase):
+  """Unit test for nxloadconfig module."""
+
+  def setUp(self):
+    # Not actually needed for every test, but it handy to have.
+    self.conf = nxloadconfig.conf
+    self.orig_conf = copy.copy(self.conf)
+
+  def tearDown(self):
+    # Cleanup after ourselves. See note on setUp()
+    nxloadconfig.copy = copy.copy(self.orig_conf)
+
+  def testWhich(self):
+    self.assertEquals('/bin/bash', nxloadconfig.which("bash"))
+    self.assertEquals('', nxloadconfig.which("somethingwhichdoesntexist"))
+
+  def testCheckCommandVar(self):
+    # Var is unset, default value is valid
+    if 'TEST' in self.conf: del self.conf['TEST']
+    ret = nxloadconfig.check_command_var("TEST", "/bin/bash")
+    self.assertEquals(True, ret)
+    self.assertEquals("/bin/bash", self.conf['TEST'])
+
+    # Var points to unexecutable file, default value is valid.
+    nxloadconfig.copy = copy.copy(self.orig_conf)
+    self.conf['TEST'] = '/etc/fstab'
+    ret = nxloadconfig.check_command_var("TEST", "/bin/bash")
+    self.assertEquals(True, ret)
+    self.assertEquals("/bin/bash", self.conf['TEST'])
+
+    # Var points to executable dir, default value is valid.
+    nxloadconfig.copy = copy.copy(self.orig_conf)
+    self.conf['TEST'] = '/bin'
+    ret = nxloadconfig.check_command_var("TEST", "/bin/bash")
+    self.assertEquals(True, ret)
+    self.assertEquals("/bin/bash", self.conf['TEST'])
+
+    # Test valid value with valid default
+    nxloadconfig.copy = copy.copy(self.orig_conf)
+    self.conf['TEST'] = '/bin/sh'
+    ret = nxloadconfig.check_command_var("TEST", "/bin/bash")
+    self.assertEquals(True, ret)
+    self.assertEquals("/bin/sh", self.conf['TEST'])
+
+    # Test invalid value with invalid default
+    nxloadconfig.copy = copy.copy(self.orig_conf)
+    self.conf['TEST'] = '/etc/fstab'
+    ret = nxloadconfig.check_command_var("TEST", "/etc/hosts")
+    self.assertEquals(False, ret)
+    self.assertEquals("/etc/fstab", self.conf['TEST'])
+
+
+  def testCheckDirVar(self):
+    # Var is unset, default value is valid
+    if 'TEST' in self.conf: del self.conf['TEST']
+    ret = nxloadconfig.check_dir_var("TEST", "/bin")
+    self.assertEquals(True, ret)
+    self.assertEquals("/bin", self.conf['TEST'])
+
+    # Var points to file, default value is valid.
+    nxloadconfig.copy = copy.copy(self.orig_conf)
+    self.conf['TEST'] = '/etc/fstab'
+    ret = nxloadconfig.check_dir_var("TEST", "/bin")
+    self.assertEquals(True, ret)
+    self.assertEquals("/bin", self.conf['TEST'])
+
+    # Test valid value with valid default
+    nxloadconfig.copy = copy.copy(self.orig_conf)
+    self.conf['TEST'] = '/bin'
+    ret = nxloadconfig.check_dir_var("TEST", "/usr")
+    self.assertEquals(True, ret)
+    self.assertEquals("/bin", self.conf['TEST'])
+
+    # Test invalid value with invalid default
+    nxloadconfig.copy = copy.copy(self.orig_conf)
+    self.conf['TEST'] = '/etc/fstab'
+    ret = nxloadconfig.check_dir_var("TEST", "/etc/hosts")
+    self.assertEquals(False, ret)
+    self.assertEquals("/etc/fstab", self.conf['TEST'])
+
+
+if __name__ == '__main__':
+  unittest.main()


Property changes on: trunk/freenx-redesign/server/lib/nxloadconfig_test.py
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/lib/nxlog.py
===================================================================
--- trunk/freenx-redesign/server/lib/nxlog.py	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/lib/nxlog.py	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,227 @@
+#!/usr/bin/python2.4
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: alriddoch at google.com (Alistair Riddoch)
+
+"""nxlog module for logging to syslog and stderr.
+
+  __setup_syslog: Function for setting up logging to syslog.
+  __log_syslog: Function for logging to syslog.
+  __setup_stderr: Function for setting up logging to stderr.
+  __log_stderr: Function for logging to stderr.
+  __setup: Function for setting up the logging systems.
+
+  setup: Function for setting the faciltiy name.
+  set_log_level: Function for setting the log level.
+  log: Function for writing logs.
+"""
+
+import os
+import sys
+import syslog
+
+__author__ = 'alriddoch at google.com (Alistair Riddoch)'
+__copyright__ = 'Copyright 2007 Google Inc.'
+
+__pychecker__ = 'no-miximport'
+
+from syslog import LOG_EMERG
+from syslog import LOG_ALERT
+from syslog import LOG_CRIT
+from syslog import LOG_ERR
+from syslog import LOG_WARNING
+from syslog import LOG_NOTICE
+from syslog import LOG_INFO
+from syslog import LOG_DEBUG
+
+
+__level = LOG_INFO
+__handlers = []
+__stderr_name = ''
+_level_names = {
+    'EMERG': LOG_EMERG,
+    'ALERT': LOG_ALERT,
+    'CRIT': LOG_CRIT,
+    'ERR': LOG_ERR,
+    'WARNING': LOG_WARNING,
+    'NOTICE': LOG_NOTICE,
+    'INFO': LOG_INFO,
+    'DEBUG': LOG_DEBUG
+  }
+
+
+
+def __setup_syslog(name):
+  """Initialize logging to the syslog.
+  
+  Args:
+    name: The name to be used for the logging facility.
+
+  Returns:
+    None
+  """
+
+  syslog.openlog(name, syslog.LOG_PID)
+
+
+def __log_syslog(level, message):
+  """Write a message to syslog.
+
+  Args:
+    level: Number giving the level of this message.
+    message: String giving the message to be logged.
+
+  Returns:
+    None
+  """
+
+  syslog.syslog(level, message)
+
+
+def __setup_stderr(name):
+  """Initialize loggin to stderr.
+  
+  Args:
+    name: The name to be used for the logging facility.
+
+  Returns:
+    None
+  """
+  global __stderr_name
+
+  __stderr_name = name
+
+
+def __log_stderr(level, message):
+  """Write a message to stderr.
+
+  Args:
+    level: Number giving the level of this message.
+    message: String giving the message to be logged.
+
+  Returns:
+    None
+  """
+  global __stderr_name
+  global __level
+
+  if level <= __level:
+    sys.stderr.write('%s: %s' % (__stderr_name, message))
+
+
+def __setup(name):
+  """Set up the library.
+  
+  Args:
+    name: The name to be used for the logging facility.
+
+  Returns:
+    None
+  """
+  global __level
+
+  level = os.getenv('LOG_LEVEL')
+  if level is not None:
+    __level = _name_to_level(level)
+
+  __setup_syslog(name)
+  __handlers.append(__log_syslog)
+
+#  __setup_stderr(name)
+#  __handlers.append(__log_stderr)
+
+
+def setup(name):
+  """Set the facility name for logging.
+
+  Note: this can be called multiple times, to change the name.
+
+  Args:
+    name: The name to be used for the logging facility.
+
+  Returns:
+    None
+  """
+
+  __setup_syslog(name)
+  __setup_stderr(name)
+  
+
+def set_log_level(level):
+  """Set the log level.
+
+  Args:
+    level: Number giving the highest level to log at.
+
+  Returns:
+    None
+  """
+  global __level
+
+  __level = _name_to_level(level)
+
+
+def log(level, message):
+  """Handle a log message with a given level.
+
+  If the message is high enough level to be written, pass it to the
+  configured log channels.
+
+  Args:
+    level: Integer or string giving the level of this message.
+    message: String giving the message to be logged.
+
+  Returns:
+    None
+  """
+  global __level
+
+  lev_num = _name_to_level(level)
+
+  if lev_num <= __level:
+    for handler in __handlers:
+      handler(lev_num, message)
+
+
+def _name_to_level(level):
+  """Translate from level number or name to log level
+
+  Args:
+    level: Integer, number string, or name string for log level
+
+  Returns:
+    The corresponding log level
+  """
+  try:
+    return int(level)
+  except ValueError:
+    pass
+  # The value is not a number
+  try:
+    return _level_names[level]
+  except KeyError:
+    # ValueError makes more sense to raise for an invalid name
+    raise ValueError('invalid name for log level: %s' % level)
+
+
+if __name__ == '__main__':
+  print 'This is a library. Please use it from python using import.'
+  sys.exit(0)
+else:
+  __setup(__name__)
+

Added: trunk/freenx-redesign/server/lib/nxlog_test.py
===================================================================
--- trunk/freenx-redesign/server/lib/nxlog_test.py	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/lib/nxlog_test.py	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,172 @@
+#!/usr/bin/python2.4 -E
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: alriddoch at google.com (Alistair Riddoch)
+
+"""nxlog module unit tests for logging to syslog and stderr.
+
+  NXLogUnitTest: Test log and set_log_level.
+"""
+
+import os
+import syslog
+import unittest
+
+import nxlog
+
+__author__ = 'alriddoch at google.com (Alistair Riddoch)'
+__copyright__ = 'Copyright 2007 Google Inc.'
+
+
+class NXLogUnitTest(unittest.TestCase):
+  """Unit test for nxlog module."""
+
+  def mock_syslog_openlog(self, ident, opt = None, facility = None):
+    """Flag that this mock syslog function has been called"""
+
+    self._openlog_called = True
+
+  def mock_syslog_syslog(self, level, message = None):
+    """Flag that this mock syslog function has been called"""
+
+    self._syslog_called = True
+
+  def setUp(self):
+    """Install mock versions of the syscall functions."""
+
+    self._saved_openlog = syslog.openlog
+    self._saved_syslog = syslog.syslog
+    syslog.openlog = self.mock_syslog_openlog
+    syslog.syslog = self.mock_syslog_syslog
+    self._openlog_called = False
+    self._syslog_called = False
+
+  def tearDown(self):
+    """Remove the mocked versions of the syscall functions."""
+
+    syslog.openlog = self._saved_openlog 
+    syslog.syslog = self._saved_syslog 
+
+  def testSetupSyslog(self):
+    """Test the code path through the syslog setup function."""
+
+    nxlog.__dict__['__setup_syslog']('syslog_test')
+
+    self.failUnless(self._openlog_called)
+
+  def testLogSyslog(self):
+    """Test the code path through the syslog log function."""
+
+    nxlog.__dict__['__log_syslog'](0, 'syslog_test_message')
+
+    self.failUnless(self._syslog_called)
+
+  def testSetupStderr(self):
+    """Test the code path through the stderr setup function."""
+
+    name = 'stderr_test_name'
+
+    nxlog.__dict__['__setup_stderr'](name)
+
+    self.assertEqual(name, nxlog.__dict__['__stderr_name'])
+
+  def testLogStderr(self):
+    """Test the code path through the stderr log function."""
+
+    nxlog.__dict__['__log_stderr'](0, 'stderr_test_message')
+
+  def testInternalSetup(self):
+    """Test calling __setup()"""
+
+    nxlog.__dict__['__setup']('setup_test_name')
+
+    log_level = nxlog.__dict__['__level']
+
+    self.failUnless(log_level in [nxlog.LOG_EMERG, nxlog.LOG_ALERT,
+                                  nxlog.LOG_CRIT, nxlog.LOG_ERR,
+                                  nxlog.LOG_WARNING, nxlog.LOG_NOTICE,
+                                  nxlog.LOG_INFO, nxlog.LOG_DEBUG])
+
+  def testInternalSetupEnvionment(self):
+    """Test calling __setup() with a log level environment variable"""
+
+    os.environ['LOG_LEVEL'] = 'ERR'
+
+    nxlog.__dict__['__setup']('setup_test_name')
+
+    log_level = nxlog.__dict__['__level']
+
+    self.assertEqual(log_level, nxlog.LOG_ERR)
+
+    os.unsetenv('LOG_LEVEL')
+
+  def testLogLevelSet(self):
+    """Test that the log level has been set to a valid value"""
+
+    # Ensure that before set_log_level has been called, the internal value
+    # of log level is sane.
+    log_level = nxlog.__dict__['__level']
+
+    self.failUnless(log_level in [nxlog.LOG_EMERG, nxlog.LOG_ALERT,
+                                  nxlog.LOG_CRIT, nxlog.LOG_ERR,
+                                  nxlog.LOG_WARNING, nxlog.LOG_NOTICE,
+                                  nxlog.LOG_INFO, nxlog.LOG_DEBUG])
+
+  def testLog(self):
+    """Test calling log function"""
+
+    nxlog.log(0, 'test log message')
+
+  def testSetup(self):
+    """Test calling external setup()"""
+
+    nxlog.setup('nxlog_test')
+
+  def testSetLogLevel(self):
+    """Test the code path through set_log_level() with a valid level"""
+
+    nxlog.set_log_level(nxlog.LOG_INFO)
+
+  def testSetLogLevelRaises(self):
+    """Test the code path through set_log_level() with an invalid level"""
+
+    self.assertRaises(ValueError, nxlog.set_log_level, 'not_a_level')
+
+  def testNameToLevelNameString(self):
+    """Test calling _name_to_level with a string specifying a level"""
+
+    self.assertEquals(nxlog.LOG_DEBUG, nxlog._name_to_level('DEBUG'))
+
+  def testNametoLevelNumberString(self):
+    """Test calling _name_to_level() with an integer represented as a string"""
+
+    self.assertEquals(nxlog.LOG_DEBUG, nxlog._name_to_level('7'))
+
+  def testNametoLevelInteger(self):
+    """Test calling _name_to_level() with an integer."""
+
+    self.assertEquals(nxlog.LOG_DEBUG, nxlog._name_to_level(nxlog.LOG_DEBUG))
+
+  def testNametoLevelInvalidNameString(self):
+    """Test calling _name_to_level() on a meaningless string."""
+
+    self.assertRaises(ValueError, nxlog._name_to_level, 'BLARG')
+
+
+if __name__ == '__main__':
+  unittest.main()


Property changes on: trunk/freenx-redesign/server/lib/nxlog_test.py
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/lib/nxparser/__init__.py
===================================================================
--- trunk/freenx-redesign/server/lib/nxparser/__init__.py	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/lib/nxparser/__init__.py	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,23 @@
+#!/usr/bin/python2.4
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: diamond at google.com (Stephen Shirley)
+
+import base
+import node
+import server


Property changes on: trunk/freenx-redesign/server/lib/nxparser/__init__.py
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/lib/nxparser/base.py
===================================================================
--- trunk/freenx-redesign/server/lib/nxparser/base.py	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/lib/nxparser/base.py	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,213 @@
+#!/usr/bin/python2.4
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Authors: alriddoch at google.com (Alistair Riddoch)
+#          diamond at google.com (Stephen Shirley)
+
+"""nxparser.base module for handling the nx protocol.
+"""
+
+import optparse
+import re
+import traceback
+import sys
+
+import nxlog
+
+__author__ = 'alriddoch at google.com (Alistair Riddoch)'
+__copyright__ = 'Copyright 2007 Google Inc.'
+
+class parser:
+  """Base parser for NX protocol parsers.
+
+  This class handles breaking up the messages into components,
+  and dispatching them.
+  """
+
+  DEFAULT_VERSION = '3.0.0'
+  DEFAULT_PROGRAM = 'NXBASE'
+
+  NX_PROMPT = 'NX>'
+  NX_COMMANDS = ['hello', 'login', 'bye', 'set', 'listsession',
+                 'restoresession', 'startsession', 'terminate']
+  NX_PARAM_RX = re.compile(r'^--(?P<key>[a-z]+)="(?P<value>.+)"')
+
+  def __init__(self, input, output, version=DEFAULT_VERSION,
+               program=DEFAULT_PROGRAM):
+    """base_parser constructor
+
+    Args:
+      input: The file object to read parser input from.
+      output: The file object to write the results to.
+      version: The version string used to negotiate the protocol.
+      program: The program name used in the protocol banner.
+    """
+
+    self.input = input
+    self.output = output
+    self.state = 105
+    self.running = True
+    self.parse_args(version=version, program=program)
+    nxlog.log(nxlog.LOG_DEBUG, "Version: %s Program: %s" %
+        (self.version, self.program))
+
+  def banner(self):
+    """Write the protocol banner to the output."""
+
+    self.write('HELLO %s - Version %s - GPL' % (self.program, self.version))
+
+  def prompt(self, state, message='', override_newline=None):
+    """Write the protocol prompt to the output.
+
+    If no message is given, just print the prompt & state, no newline.
+    If a message is provided, by default append a newline.
+
+    Args:
+      state: The state number to put after the NX> prompt
+      message: Optional message to print after the state
+      override_newline: Optional param to force a trailing newline on/off"""
+
+
+    newline = False
+    if override_newline is not None:
+      newline = override_newline
+    elif message:
+      newline=True
+    self.write('%s %d %s' % (self.NX_PROMPT, state, message), newline=newline)
+
+  def loop(self):
+    """Write the protocol prompt to the output, and accept commands."""
+
+    try:
+      while self.running:
+        self.prompt(self.state)
+        line = self.input.readline()
+        if not line:
+          nxlog.log(nxlog.LOG_DEBUG, "Exiting due to EOF")
+          return
+        line = line.rstrip()
+        nxlog.log(nxlog.LOG_DEBUG, 'Got %r' % line)
+        command = line.split()
+        if not command:
+          # If the line was all whitespace this could happen.
+          continue
+        cmd = command[0].lower()
+        if cmd == 'set':
+          self.write("%s %s: %s" % (cmd.capitalize(), command[1].lower(),
+            command[2].lower()))
+        elif cmd == 'startsession':
+          self.write("Start session with: %s" % " ".join(command[1:]))
+        else:
+          self.write(line.capitalize())
+        if cmd not in self.NX_COMMANDS:
+          self.prompt(503, 'Error: undefined command: \'%s\'' % cmd)
+          continue
+        handler_name = '_nx_%s_handler' % cmd
+        try:
+          handler_method = getattr(self, handler_name)
+        except AttributeError:
+          nxlog.log(nxlog.LOG_DEBUG, 'Unhandled nx command %r' % cmd)
+          continue
+        handler_method(command)
+    except IOError, e:
+      nxlog.log(nxlog.LOG_ERR, 'IOError. Connection lost: %s' % e)
+    except Exception, e:
+      trace = traceback.format_exc()
+      nxlog.log(nxlog.LOG_ERR, 'Going down because exception caught '
+                               'at the top level.')
+      for line in trace.split('\n'):
+        nxlog.log(nxlog.LOG_ERR, '%s' % line)
+      self.prompt(500, 'Error: Fatal error in module %s, '
+          'check log file for more details.' % self.program.lower())
+      self.prompt(999, 'Bye.')
+
+  def write(self, output, newline=True, flush=True, log=True,
+      log_level=nxlog.LOG_DEBUG, fd=None):
+    """Write given string to output, and optionally:
+      - append a newline
+      - flush output afterwards
+      - log the output, with a specified log level."""
+
+    if newline:
+      output += '\n'
+    use_fd = self.output
+    if fd:
+      use_fd = fd
+    use_fd.write(output)
+    if flush:
+      use_fd.flush()
+    if log:
+      nxlog.log(log_level, 'Sent: %r\n' % output)
+
+  def parse_args(self, version=None, program=None):
+    """Parse cmdline arguments"""
+
+    optparser = optparse.OptionParser()
+    optparser.add_option("--proto", action="store", type="string",
+        dest="version", default=version, metavar="PROTO_VER",
+        help="use the PROTO_VER version of the NX protocol")
+    optparser.add_option("--program", action="store", type="string",
+        dest="program", default=program, metavar="PROG_NAME",
+        help="the PROG_NAME name to announce")
+    options, args = optparser.parse_args()
+    self.version = options.version
+    self.program = options.program
+
+  def _diff_version(self, ver1, ver2):
+    """Compare 2 version strings"""
+
+    for i,j in zip(ver1.split('.', 2), ver2.split('.', 2)):
+      try:
+        icomp = int(i)
+        jcomp = int(j)
+      except ValueError:
+        icomp = i
+        jcomp = j
+      if icomp > jcomp:
+        return 1
+      elif icomp == jcomp:
+        continue
+      elif icomp < jcomp:
+        return -1
+    return 0
+
+  def _parse_param(self, param):
+    """Check that param is correctly formatted via the NX_PARAM_RX regex
+
+    Args:
+      param: parameter string to be checked, of the form --key="value"
+
+    Returns:
+      key,value tuple if param was correctly formatted, returns None,None
+      otherwise.
+    """
+
+    m = self.NX_PARAM_RX.search(param)
+    if m:
+      key = m.group('key')
+      value = m.group('value')
+      nxlog.log(nxlog.LOG_DEBUG, 'Param matched: %r=%r' % (key, value))
+    else:
+      key = value = None
+      nxlog.log(nxlog.LOG_WARNING, "Param didn't match: %r" % param)
+    return key,value
+
+
+if __name__ == '__main__':
+  print 'This is a library. Please use it from python using import.'
+  sys.exit(0)


Property changes on: trunk/freenx-redesign/server/lib/nxparser/base.py
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/lib/nxparser/base_test.py
===================================================================
--- trunk/freenx-redesign/server/lib/nxparser/base_test.py	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/lib/nxparser/base_test.py	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,398 @@
+#!/usr/bin/python2.4
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: diamond at google.com (Stephen Shirley)
+
+"""Unittest for nxparser.base"""
+
+import os
+import StringIO
+import sys
+import unittest
+
+sys.path.append(os.path.join(os.path.dirname(__file__), '..'))
+
+import nxlog
+import nxparser.base
+
+__author__ = 'diamond at google.com (Stephen Shirley)'
+__copyright__ = 'Copyright 2008 Google Inc.'
+
+class NxParserBaseUnitTest(unittest.TestCase):
+
+  class MockStringIO(StringIO.StringIO):
+    """Mock file object to check to log what's written and whether it's flushed"""
+
+    def __init__(self, buf=None):
+      if buf:
+        StringIO.StringIO.__init__(self, buf)
+      else:
+        StringIO.StringIO.__init__(self)
+      self.flushed = False
+
+    def flush(self):
+      StringIO.StringIO.flush(self)
+      self.flushed = True
+
+  def MockLog(self, *args):
+    """Mock logging function to replace nxlog.log and store all arguments"""
+
+    self.logged_data.append(args)
+
+  def MockLogFlush(self, *args):
+    """Wipe the MockLog() history"""
+
+    self.logged_data = []
+
+  def utilCheckInitialAttributes(self, p, input, output, version, program):
+    """Check if the nxparser.base instance has initialised correctly"""
+
+    self.assertEquals(input, p.input)
+    self.assertEquals(output, p.output)
+    self.assertEquals(105, p.state)
+    self.assertEquals(True, p.running)
+    self.assertEquals(version, p.version)
+    self.assertEquals(program, p.program)
+    self.assertEquals((nxlog.LOG_DEBUG,
+      "Version: %(version)s Program: %(program)s" % locals()),
+      self.logged_data.pop(0))
+    self.assertEquals([], self.logged_data)
+
+  def utilCheckOutput(self, out, exp_output, flush=True, log=True,
+      log_level=nxlog.LOG_DEBUG):
+    """Check if output has been written, flushed, and/or logged"""
+
+    self.assertEquals(exp_output, out.getvalue())
+    if flush:
+      self.assertEquals(flush, out.flushed)
+    if log:
+      self.assertEquals((log_level, "Sent: %(exp_output)r\n" % locals()),
+        self.logged_data.pop(0))
+    else:
+      self.assertEquals(0, len(self.logged_data))
+
+  def setUp(self):
+    """Before every test substitute Mocklog for nxlog.log"""
+
+    self.nxlog_log_old = nxlog.log
+    nxlog.log = self.MockLog
+    self.MockLogFlush()
+
+  def tearDown(self):
+    """Restore the original nxlog.log"""
+
+    nxlog.log = self.nxlog_log_old
+
+  def testInitDefaults(self):
+    """Does an instance with default args initialise correctly?"""
+
+    p = nxparser.base.parser(sys.stdin, sys.stdout)
+
+    self.utilCheckInitialAttributes(p, sys.stdin, sys.stdout, p.DEFAULT_VERSION,
+      p.DEFAULT_PROGRAM)
+
+  def testInitVersion(self):
+    """Does an instance with an overridden version string initialise correctly?"""
+
+    ver_name = "testverstring"
+    p = nxparser.base.parser(sys.stdin, sys.stdout, version=ver_name)
+
+    self.utilCheckInitialAttributes(p, sys.stdin, sys.stdout, ver_name,
+      p.DEFAULT_PROGRAM)
+
+  def testInitProgram(self):
+    """Does an instance with an overridden program name initialise correctly?"""
+
+    prog_name = "testprogstring"
+    p = nxparser.base.parser(sys.stdin, sys.stdout, program=prog_name)
+
+    self.utilCheckInitialAttributes(p, sys.stdin, sys.stdout, p.DEFAULT_VERSION,
+      prog_name)
+
+  def testInitVersionProgram(self):
+    """Does an instance with an overridden program name and version string
+    initialise correctly?"""
+
+    ver_name = "testverstring"
+    prog_name = "testprogstring"
+    p = nxparser.base.parser(sys.stdin, sys.stdout,
+        version=ver_name, program=prog_name)
+
+    self.utilCheckInitialAttributes(p, sys.stdin, sys.stdout, ver_name, prog_name)
+
+  def testBannerDefaults(self):
+    """Does base.banner() output correctly with no arguments?"""
+
+    out = self.MockStringIO()
+    exp_output = "HELLO NXBASE - Version 3.0.0 - GPL\n"
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    p.banner()
+
+    self.utilCheckOutput(out, exp_output)
+
+  def testBannerVersionProgram(self):
+    """Does base.banner() output correctly with a specified version string
+    and program name?"""
+
+    ver_name = "testverstring"
+    prog_name = "testprogstring"
+    exp_output = "HELLO %(prog_name)s - Version %(ver_name)s - GPL\n" % locals()
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out,
+        version=ver_name, program=prog_name)
+    self.MockLogFlush()
+
+    p.banner()
+
+    self.utilCheckOutput(out, exp_output)
+
+  def testPromptDefaults(self):
+    """Does base.prompt() output correctly with default arguments?"""
+
+    state = 101
+    out = self.MockStringIO()
+    exp_output = "NX> %(state)d " % locals()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    p.prompt(state)
+
+    self.utilCheckOutput(out, exp_output)
+
+  def testPromptMessage(self):
+    """Does base.prompt() output correctly with a message?"""
+
+    state = 101
+    send = "Hello, World!"
+    exp_output = "NX> %(state)d %(send)s\n" % locals()
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    p.prompt(state, send)
+
+    self.utilCheckOutput(out, exp_output)
+
+  def testPromptOverrideNewlineTrueWithMsg(self):
+    """Does base.prompt() output correctly with a message and forced newline?"""
+
+    state = 101
+    send = "Hello, World!"
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    exp_output = "NX> %(state)d %(send)s\n" % locals()
+    p.prompt(state, send, override_newline=True)
+    self.utilCheckOutput(out, exp_output)
+
+  def testPromptOverrideNewlineFalseWithMsg(self):
+    """Does base.prompt() output correctly with a message and forced no newline?"""
+
+    state = 101
+    send = "Hello, World!"
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    exp_output = "NX> %(state)d %(send)s" % locals()
+    p.prompt(state, send, override_newline=False)
+    self.utilCheckOutput(out, exp_output)
+
+  def testPromptOverrideNewlineTrueWithoutMsg(self):
+    """Does base.prompt() output correctly without a message and forced newline?"""
+
+    state = 101
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    exp_output = "NX> %(state)d \n" % locals()
+    p.prompt(state, override_newline=True)
+    self.utilCheckOutput(out, exp_output)
+
+  def testPromptOverrideNewlineFalseWithoutMsg(self):
+    """Does base.prompt() output correctly without a message and forced no newline?"""
+
+    state = 101
+    send = "Hello, World!"
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    exp_output = "NX> %(state)d " % locals()
+    p.prompt(state, override_newline=False)
+    self.utilCheckOutput(out, exp_output)
+
+  def testWriteDefaults(self):
+    """Does base.write() output correctly with a message?"""
+
+    send = "Hello, World!"
+    exp_output = "%(send)s\n" % locals()
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    p.write(send)
+
+    self.utilCheckOutput(out, exp_output)
+
+  def testWriteEmptyMsg(self):
+    """Does base.write() output correctly with an empty message?"""
+
+    send=""
+    exp_output = "\n"
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    p.write(send)
+
+    self.utilCheckOutput(out, exp_output)
+
+  def testWriteEmptyMsgNoNewline(self):
+    """Does base.write() output correctly with an empty message and no newline?"""
+
+    send = exp_output = ""
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    p.write(send, newline=False)
+
+    self.utilCheckOutput(out, exp_output)
+
+  def testWriteNoNewline(self):
+    """Does base.write() output correctly with a message and no newline?"""
+
+    send = exp_output = "Hello, World!"
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    p.write(send, newline=False)
+
+    self.utilCheckOutput(out, exp_output)
+
+  def testWriteNoFlush(self):
+    """Does base.write() output correctly with a message and without flushing?"""
+
+    send = "Hello, World!"
+    exp_output = "%(send)s\n" % locals()
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    p.write(send, flush=False)
+
+    self.utilCheckOutput(out, exp_output, flush=False)
+
+  def testWriteNoLog(self):
+    """Does base.write() output correctly with a message and without logging?"""
+
+    self.args = None
+    send = "Hello, World!"
+    exp_output = "%(send)s\n" % locals()
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    p.write(send, log=False)
+
+    self.utilCheckOutput(out, exp_output, log=False)
+
+  def testWriteLogLevel(self):
+    """Does base.write() output correctly with a message and a specific log level?"""
+
+    self.args = None
+    send = "Hello, World!"
+    exp_output = "%(send)s\n" % locals()
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    p.write(send, log_level=nxlog.LOG_ERR)
+
+    self.utilCheckOutput(out, exp_output, log_level=nxlog.LOG_ERR)
+
+  def testWriteFd(self):
+    """Does base.write() output correctly with a message and a specific fd?"""
+
+    self.args = None
+    send = "Hello, World!"
+    exp_output = "%(send)s\n" % locals()
+    out = self.MockStringIO()
+    p = nxparser.base.parser(sys.stdin, out)
+    self.MockLogFlush()
+
+    p.write(send, fd=out)
+
+    self.utilCheckOutput(out, exp_output)
+
+  def testParseArgsNoArgsDefaults(self):
+    """Does base.parse_args() parse correctly with no extra args?"""
+
+    sys.argv = ['argv0']
+    p = nxparser.base.parser(sys.stdin, sys.stdout)
+
+    p.parse_args()
+
+    self.assertEquals(None, p.version)
+    self.assertEquals(None, p.program)
+
+  def testParseArgsNoArgsVersionProgram(self):
+    """Does base.parse_args() parse correctly with no extra args and specified
+    default version string and program name?"""
+
+    sys.argv = ['argv0']
+    ver_name = "testverstring"
+    prog_name = "testprogstring"
+    p = nxparser.base.parser(sys.stdin, sys.stdout)
+
+    p.parse_args(version=ver_name, program=prog_name)
+
+    self.assertEquals(ver_name, p.version)
+    self.assertEquals(prog_name, p.program)
+
+#Need to figure out how to test this:
+#  def testParseArgsWithArgsDefaults(self):
+#    sys.argv = ['argv0', '--help']
+#    p = nxparser.base.parser(sys.stdin, sys.stdout)
+#
+#    p.parse_args()
+#
+
+  def testParseArgsWithArgsVersionProgram(self):
+    """Does base.parse_args() parse correctly with version string and program 
+    name specified by both args and defaults?"""
+
+    ver_name = "testverstring"
+    prog_name = "testprogstring"
+    sys.argv = ['argv0', '--proto', ver_name, '--program', prog_name]
+    p = nxparser.base.parser(sys.stdin, sys.stdout)
+
+    p.parse_args()
+
+    self.assertEquals(ver_name, p.version)
+    self.assertEquals(prog_name, p.program)
+
+
+if __name__ == '__main__':
+  unittest.main()


Property changes on: trunk/freenx-redesign/server/lib/nxparser/base_test.py
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/lib/nxparser/node.py
===================================================================
--- trunk/freenx-redesign/server/lib/nxparser/node.py	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/lib/nxparser/node.py	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,251 @@
+#!/usr/bin/python2.4
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Authors: diamond at google.com (Stephen Shirley)
+#          alriddoch at google.com (Alistair Riddoch)
+
+import os
+import pwd
+import socket
+import subprocess
+import sys
+
+import nxlog
+import nxparser
+import nxsession
+
+class parser(nxparser.base.parser):
+  """Node parser for NX protocol
+
+  This class handles the NX protocol messages required by a node.
+  """
+
+  DEFAULT_PROGRAM = 'NXNODE'
+
+  class node_session:
+    """Internal representation of a session
+
+    This class is used by nxnode to store session parameters, to create the
+    needed session args & options file, and to print out the parameters for
+    transmission to nxserver-inner.
+    """
+
+    def __init__(self, id, args):
+      """node_session constructor
+
+      Args:
+        args: The id of the session, followed by all the other
+              parameters the client requested
+      """
+
+      self.id = id
+      self.args = args
+      self.display = self._gen_disp_num()
+      self.hostname = socket.getfqdn()
+      self.full_id = "%s-%s-%s" % (self.hostname, self.display, self.id)
+      self.cookie = nxsession.gen_uniq_id()
+      self.dir = os.path.join('/tmp/nx', 'S-%s' % self.full_id)
+      #FIXME(diamond): needs error checking, maybe different mode
+      os.makedirs(self.dir, 0755)
+      self.opts_file_path = os.path.join(self.dir, 'options') 
+      self.args_file_path = os.path.join(self.dir, 'args') 
+      self.application = self.args.get('application')
+      self.user = pwd.getpwuid(os.getuid())[0]
+      self.name = self.args.get('session', "%s:%s" % (self.hostname, self.display))
+      self.keyboard = self.args.get('keyboard', 'pc105/gb')
+      self.geometry = self.args.get('geometry', '640x480')
+      self.client = self.args.get('client', 'unknown')
+      self.link = self.args.get('link', 'isdn')
+      self.fullscreen = self.args.get('fullscreen', '0')
+      #DEBUG, FIXME(diamond): all of these
+      self.type = self.args.get('type', 'unix-default')
+      self.options = '-----PSA' #FIXME(diamond): see note in self.info()
+      self.depth = 24
+      self.resolution = "640x480"
+      #FIXME(diamond): Not ipv6 compatible
+      self.proxyip = socket.gethostbyname(self.hostname)
+      self.ssl = 1
+      #End DEBUG/FIXME(diamond)
+
+      if self.type == 'unix-application':
+        assert(self.application)
+        self.mode = '-R' # Run nxagent in rootless mode
+      else:
+        self.mode = '-D' # Run nxagent in desktop mode
+
+      # We need to write the type without the 'unix-' prefix for nxagent.
+      if self.type.startswith('unix-'):
+        self.shorttype = self.type.split('-', 1)[1]
+      else:
+        self.shorttype = self.type
+
+      self._write_args()
+      self._write_opts()
+
+    def __getitem__(self, item):
+      """Allow node_session instances to be treated as dicts
+
+      This is used in places like self.info(), to allow cleaner variable
+      substitution of variables in strings.
+      """
+
+      return getattr(self, item)
+
+    def _gen_disp_num(self):
+      """Return an unused display number (corresponding to an unused port)"""
+      return 20 #DEBUG, FIXME(diamond)
+
+    def _write_args(self):
+      """Create the session's 'args' file
+
+      The args file is a newline-delimited list of arguments to be passed to
+      nxagent
+      """
+
+      try:
+        args_file = open(self.args_file_path, 'w')
+        #DEBUG, FIXME(diamond):
+        args_file.write("\n".join([self.mode, '-options', self.opts_file_path,
+          '-name', 'FreeNX - %(user)s@%(hostname)s:%(display)s' % self,
+          '-nolisten', 'tcp', ':%d' % self.display]))
+        args_file.write("\n")
+        args_file.close()
+      except IOError, e:
+        nxlog.log(nxlog.LOG_ERR, 'IOError when writing '
+            'session args file: %s' % e)
+      except OSError, e:
+        nxlog.log(nxlog.LOG_ERR, 'OSError when writing '
+            'session args file: %s' % e)
+
+    def _write_opts(self):
+      """Create the session's 'options' file
+
+      The options file is a comma-delimited list of options that are read in
+      by nxagent
+      """
+
+      try:
+        opts_file = open(self.opts_file_path, 'w')
+        opts = ['nx/nx', 'keyboard=%(keyboard)s' % self,
+            'geometry=%(geometry)s' % self, 'client=%(client)s' % self,
+            'cache=8M', 'images=32M', 'link=%(link)s' % self,
+            'type=%(shorttype)s' % self, 'clipboard=both', 'composite=1',
+            'cleanup=0', 'accept=127.0.0.1', 'product=Freenx-gpl', 'shmem=1',
+            'backingstore=1', 'shpix=1', 'cookie=%s' % self.cookie,
+            'id=%s' % self.full_id, 'strict=0']
+        if self.type == 'unix-application':
+          opts.append('application=%(application)s' % self)
+        if self.fullscreen == '1':
+          opts.append('fullscreen=%(fullscreen)s' % self)
+        opts_file.write("%s:%d\n" % (",".join(opts), self.display))
+        opts_file.close()
+      except IOError, e:
+        nxlog.log(nxlog.LOG_ERR, 'IOError when writing '
+            'session options file: %s' % e)
+      except OSError, e:
+        nxlog.log(nxlog.LOG_ERR, 'OSError when writing '
+            'session options file: %s' % e)
+
+    def info(self): #This is for reporting back to nxserver
+      """Return a string with all parameter values encoded into it"""
+      # Needed for session list:
+      #   Display number
+      #   type
+      #   id
+      #   options(?) FRD--PSA (F=fullscreen, R=render,
+      #              D=non-rootless(Desktop?), PSA?)
+      #   depth
+      #   resolution
+      #   status
+      #   name
+      # Needed for session start:
+      #   hostname
+      #   cookie
+      #   proxy ip
+      #   ssl
+
+      return ("display=%(display)d type=%(type)s id=%(id)s "
+          "options=%(options)s depth=%(depth)d resolution=%(resolution)s "
+          "name=%(name)s hostname=%(hostname)s cookie=%(cookie)s "
+          "proxyip=%(proxyip)s ssl=%(ssl)s" % self)
+
+
+  def __init__(self, input, output, version=nxparser.base.parser.DEFAULT_VERSION,
+               program=DEFAULT_PROGRAM):
+    """node_parser constructor
+
+    Args:
+      input: The file object to read parser input from.
+      output: The file object to write the results to.
+      version: The version string used to negotiate the protocol.
+      program: The program name used in the protocol banner.
+    """
+    nxparser.base.parser.__init__(self, input, output, version=version, program=program)
+
+  def banner(self):
+    """Write the protocol banner to the output."""
+
+    self.prompt(1000, '%s - Version %s' % (self.program.upper(), self.version))
+
+  def _nx_startsession_handler(self, command):
+    # Remove 'startsession' from the front of the list of args
+    command.pop(0)
+
+    id = command.pop(0)
+    req = {}
+    for param in command:
+      key,val = self._parse_param(param)
+      if key: req[key] = val
+    sess = self.node_session(id, req)
+
+    # FIXME(diamond): change number to something sensible
+    self.write("NX> 8888 sessioncreate %s" % sess.info())
+    # Let stdout go directly to our stdout, i.e. to nxserver
+    # Check stderr for error messages if things go badly
+    p = subprocess.Popen('/usr/freenx/bin/nxagent-helper',
+                         stdin=subprocess.PIPE,
+                         stderr=subprocess.PIPE,
+                         shell=True)
+    p.stdin.write('start %s\n' % sess.full_id)
+    p.stdin.flush()
+    nxlog.log(nxlog.LOG_DEBUG, 'Starting session')
+    child_status = p.wait()
+    if child_status != 0:
+      lines = p.stderr.readlines()
+      if not lines:
+        out_msg = ", no output printed"
+      else:
+        out_msg = ", with %d lines of output (shown below):" % len(lines)
+      nxlog.log(nxlog.LOG_ERR, 'Start session failed %d%s' %
+          (child_status, out_msg))
+      for line in lines:
+        nxlog.log(nxlog.LOG_ERR, 'from nxagent-helper: %s' % line)
+      self.prompt(500, 'Error: Startsession failed')
+      self.running = False
+      return
+    nxlog.log(nxlog.LOG_ERR, 'Session completed %d' % child_status)
+    self.running = False
+    #FIXME(diamond): cleanup session dir here?
+
+  def _nx_resumesession_handler(self, unused_command):
+    nxlog.log(nxlog.LOG_DEBUG, 'Resuming session')
+
+
+if __name__ == '__main__':
+  print 'This is a library. Please use it from python using import.'
+  sys.exit(0)


Property changes on: trunk/freenx-redesign/server/lib/nxparser/node.py
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/lib/nxparser/server.py
===================================================================
--- trunk/freenx-redesign/server/lib/nxparser/server.py	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/lib/nxparser/server.py	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,695 @@
+#!/usr/bin/python2.4
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Authors: diamond at google.com (Stephen Shirley)
+#          alriddoch at google.com (Alistair Riddoch)
+
+import errno
+import os
+import re
+import signal
+import socket
+import sys
+import termios
+import time
+import traceback
+
+import nxlog
+import nxparser
+import nxsession
+
+class parser(nxparser.base.parser):
+  """Server parser for NX protocol.
+
+  This class handles the NX protocol messages required by a server.
+  """
+
+  DEFAULT_PROGRAM = 'NXSERVER'
+
+  STATUS_CONNECTED, \
+  STATUS_LOGGEDIN = range(2)
+
+  SET_ACCEPTED_VARIABLES = ['AUTH_MODE', 'SHELL_MODE']
+
+  LISTSESSION_ACCEPTED_PARAMETERS = ['user', 'status', 'geometry', 'type']
+  LISTSESSION_COLUMNS = [["Display", 7, "display"], ["Type", 16, "type"],
+      ["Session ID", 32, "id"], ["Options", 8, "options"],
+      ["Depth", -5, "depth"], ["Screen", 14, "resolution"],
+      ["Status", 11, "state"], ["Session Name", 30, 'name']]
+
+  STARTSESSION_ACCEPTED_PARAMETERS = [ 'backingstore', 'cache', 'client',
+                                       'composite', 'encryption', 'geometry',
+                                       'images', 'keyboard', 'link',
+                                       'media', 'screeninfo' 'session',
+                                       'shmem', 'shpix', 'strict', 'type', ]
+
+  def __init__(self, input, output, version=nxparser.base.parser.DEFAULT_VERSION,
+               program=DEFAULT_PROGRAM):
+    """server_parser constructor
+
+    Args:
+      input: The file object to read parser input from.
+      output: The file object to write the results to.
+      version: The version string used to negotiate the protocol.
+      program: The program name used in the protocol banner.
+    """
+    nxparser.base.parser.__init__(self, input, output, version=version, program=program)
+    self.port = 0
+
+    username = os.getenv('NX_TRUSTED_USER')
+
+    if username:
+      self.status = self.STATUS_LOGGEDIN
+      self.username = username
+    else:
+      self.status = self.STATUS_CONNECTED
+
+    commfd = os.getenv('NX_COMMFD')
+
+    if commfd:
+      self.nxnode_commfd = int(commfd)
+      self.nxnode_rfile = os.fdopen(self.nxnode_commfd, 'r')
+      self.nxnode_wfile = os.fdopen(self.nxnode_commfd, 'w')
+      nxlog.log(nxlog.LOG_DEBUG, 'Got commfd %d\n' % self.nxnode_commfd)
+
+  def __del__(self):
+    """Destructor for the server_parser class
+
+    This is needed to cleanup after server_parser is done. In particular,
+    the file descriptors used for comms with nxnode may be in an errored state
+    if nxnode has exited.
+    """
+
+    for i in ['r', 'w']:
+      var = "nxnode_%sfile" % i
+      try:
+        getattr(self, var).close()
+      except IOError, e:
+        if e.args[0] != errno.EBADF:
+          nxlog.log(nxlog.LOG_WARNING, "Got error closing %s: %s\n" %
+              (var, e))
+      except AttributeError:
+        pass # self.nxnode_(r|w)file doesn't exist
+
+  def banner(self):
+    """Write the protocol banner to the output."""
+
+    if self.status == self.STATUS_LOGGEDIN:
+      assert(hasattr(self, 'username'))
+      self.prompt(103, 'Welcome to: %s user: %s' % (socket.getfqdn().lower(),
+                                                      self.username))
+    else:
+      self.write('HELLO %s - Version %s - GPL' % (self.program, self.version))
+
+  def _nx_bye_handler(self, unused_command):
+    """Handle the bye NX command.
+
+    'bye' signals the end of a commandline session. Currently it is ignored
+    as the other end typically closes the connection, causing termination.
+    It may be a good idea to explicitly exit.
+
+    Args:
+      command: The NX command and arguments invoked
+
+    Returns:
+      None
+    """
+
+    # Basic checking of the right status
+    if self.status < self.STATUS_LOGGEDIN:
+      self.prompt(554, 'Error: the command \'bye\' cannot '
+          'be called before login')
+      return
+    self.prompt(999, 'Bye.')
+    if self.port != 0:
+      os.execve("/bin/netcat", ["netcat", "localhost", str(self.port)], {})
+
+  def _nx_hello_handler(self, command):
+    """Handle the hello NX command.
+
+    'hello' is used to handshake the commandline session, and appears to
+    support negotiation of the protocol version. We currently only
+    accept versions which look like 3.x.x, matched using a regex.
+
+    Args:
+      command: The NX command and arguments invoked
+
+    Returns:
+      None
+    """
+
+    # Basic checking of the right status
+    if self.status >= self.STATUS_LOGGEDIN:
+      self.prompt(554, 'Error: the command \'hello\' cannot '
+          'be called after login')
+      return
+    if len(command) < 5:
+      nxlog.log(nxlog.LOG_DEBUG, 'Hello too short')
+      return
+    if not re.match('^3(\.[0-9]+(\.[0-9]+))', command[4]):
+      nxlog.log(nxlog.LOG_DEBUG, 'Version too fucked')
+      self.prompt(552, 'Protocol you requested is not supported')
+      return
+    # If the proffered version is the same as ours, or older..
+    if self._diff_version(self.version, command[4]) < 1:
+      accept_ver = self.version
+    else:
+      accept_ver = command[4]
+    self.prompt(134, 'Accepted protocol: %s' % accept_ver)
+
+  def _nx_login_handler(self, unused_command):
+    """Handle the login NX command.
+
+    'login' is used to start the process of authenticating to NX. The username
+    and password is send in response to requests from the server. If no
+    options have been set, nxserver will ask for the password, and will then
+    ask for an 'MD5 Password' if no password is given. If
+    'SET AUTH_MODE PASSWORD' has been sent by the client, it does not do this
+     however. This code currently never requests the MD5 Password. It is
+    possible that making use of this feature requires storing the users
+    password and verifying it with the hash.
+
+    Args:
+      command: The NX command and arguments invoked
+
+    Returns:
+      None
+    """
+
+    # Basic checking of the right status
+    if self.status >= self.STATUS_LOGGEDIN:
+      self.prompt(554, 'Error: the command \'login\' cannot be '
+          'called after login')
+      return
+    self.prompt(101, 'User: ', override_newline=False)
+    line = self.input.readline()
+    split_line = line.split()
+    if not line or len(split_line) != 1:
+      self.prompt(500, 'Error: Username is not in expected format')
+      return
+    self.write('') # Print newline after username
+    self.username = split_line[0]
+    nxlog.log(nxlog.LOG_DEBUG, 'Got user %r' % self.username)
+    self.prompt(102, 'Password: ', override_newline=False)
+
+    fd = self.input.fileno()
+    nxlog.log(nxlog.LOG_DEBUG, 'Got fd %r' % fd)
+    # Save the terminal settings
+    try:
+      old = termios.tcgetattr(fd)
+      new = old[:]
+
+      # Disable the echo flag
+      new[3] = new[3] & ~termios.ECHO # 3 == 'lflags'
+      try:
+        termios.tcsetattr(fd, termios.TCSADRAIN, new)
+        passwd = self.input.readline()
+      finally:
+        termios.tcsetattr(fd, termios.TCSADRAIN, old)
+    except termios.error:
+      passwd = self.input.readline()
+
+    nxlog.log(nxlog.LOG_DEBUG, 'Got a passwd')
+
+    self.write('\n')
+    # FIXME(diamond): ssh to localhost to verify the username and password are
+    # correct. Also store the authentication information we need in a secure
+    # way.
+    del passwd
+    self.status = self.STATUS_LOGGEDIN
+    self.banner()
+
+  def _nx_set_handler(self, command):
+    """Handle the SET NX command.
+
+    'SET' is used to configure the session in various ways. Two variables
+    have been seen.
+    'SET SHELL_MODE SHELL' has no known effect.
+    'SET AUTH_MODE PASSWORD' prevents nxserver fromm asking for an MD5
+    password if no password has been given.
+
+    Args:
+      command: The NX command and arguments invoked
+
+    Returns:
+      None
+    """
+    if len(command) < 2:
+      self.prompt(500, 'Error: missing parameter \'variable\'')
+      return
+    var = command[1].upper()
+    if var not in self.SET_ACCEPTED_VARIABLES:
+      self.prompt(500, 'Error: unknown variable \'%s\'' % var)
+      return
+
+  def _nx_listsession_handler(self, command):
+    """Handle the listsession NX command.
+
+    'listsession' requests a table of session information for the current
+    user. It requires parameters be specified. The following parameters have
+    been seen.
+    '--user="alriddoch"'
+    This seems to be ignored. No matter what is specified, the user given at
+    login is used.
+    '--status="suspended,running"'
+    This seems to constrain the list to sessions in the given states.
+    '--geometry="3840x1200x24+render"'
+    This seems to specify the desired geometry.
+    '--type="unix-gnome"'
+    This seems to specify the desired type.
+    The format of the returned data is somewhat freeform, and looks hard to
+    parse. Currently this function returns an empty table, which forces the
+    the client to always start a new session
+
+    Args:
+      command: The NX command and arguments invoked
+
+    Returns:
+      None
+    """
+
+    # Basic checking of the right status
+    if self.status < self.STATUS_LOGGEDIN:
+      self.prompt(554, 'Error: the command \'listsession\' cannot '
+          'be called before login')
+      return
+    # Make sure the state is consistent
+    assert(hasattr(self, 'username'))
+    # Ask for parameters if none have been given
+    if len(command) > 1:
+      parameters = command[1:]
+    else:
+      self.prompt(106, 'Parameters: ', override_newline=False)
+      response = self.input.readline()
+      self.write('') # Do newline after parameters.
+      parameters = response.split()
+    req = {}
+    # Check the parameters fit with the expected syntax
+    for param in parameters:
+      key,val = self._parse_param(param)
+      if key: req[key] = val
+    # Ignore --user, as per commercial implementation
+    req['user'] = [self.username]
+    if 'type' not in req:
+      # Default to showing any type
+      req['type'] = None
+    else:
+      req['type'] = req['type'].split(',')
+    if 'status' not in req:
+      # Default to showing any state
+      req['type'] = None
+    else:
+      req['status'] = req['status'].split(',')
+    self.prompt(127, 'Available sessions:')
+    self.__print_list_session(nxsession.db_find_sessions(
+      users=req['user'],
+      states=req['status'],
+      types=req['type']))
+    self.write('') # Print newline.
+    self.prompt(148, "Server capacity: not reached for user: %s" %
+        self.username)
+
+  def _nx_startsession_handler(self, command):
+    """Handle the startsession NX command.
+
+    'startsession' seems to request a new session be started.
+    It requires parameters be specified. The following parameters have
+    been seen.
+    '--link="lan"'
+    '--backingstore="1"'
+    '--encryption="1"'
+    '--cache="16M"'
+    '--images="64M"'
+    '--shmem="1"'
+    '--shpix="1"'
+    '--strict="0"'
+    '--composite="1"'
+    '--media="0"'
+    '--session="localtest"'
+    '--type="unix-gnome"'
+    '--geometry="3840x1150"'
+    '--client="linux"'
+    '--keyboard="pc102/gb"'
+    '--screeninfo="3840x1150x24+render"'
+    Experiments with this command by directly invoked nxserver have not
+    worked, as it refuses to create a session saying the unencrypted sessions
+    are not supported. This is independent of whether the --encryption option
+    has been set, so probably is related to the fact the nxserver has not
+    been launched by sshd.
+
+    Args:
+      command: The NX command and arguments invoked
+
+    Returns:
+      None
+    """
+
+    # Basic checking of the right status
+    if self.status < self.STATUS_LOGGEDIN:
+      self.prompt(554, 'Error: the command \'%s\' cannot '
+          'be called before login' % command[0])
+      return
+    # Make sure the state is consistent
+    assert(hasattr(self, 'username'))
+    # Ask for parameters if none have been given
+    if len(command) > 1:
+      parameters = command[1:]
+    else:
+      self.prompt(106, 'Parameters: ', override_newline=False)
+      response = self.input.readline()
+      self.write('') # Do newline after parameters.
+      parameters = response.split()
+    # Check the parameters fit with the expected syntax
+    for param in parameters:
+      key,val = self._parse_param(param)
+      # FIXME(diamond): DO something with the params.
+    # FIXME(diamond): Start the session.
+    if not hasattr(self, 'nxnode_commfd'):
+      nxlog.log(nxlog.LOG_ERR, 'Nxserver does not have an nxnode yet.')
+      return
+    # Send the command to the connected nxnode running
+    # FIXME(diamond): Convert the arguments to the form expected by nxnode.
+    sess_id = nxsession.gen_uniq_id()
+    self.write('startsession %s %s' %
+        (sess_id, " ".join(parameters)), fd=self.nxnode_wfile)
+
+    if self.daemonize():
+    # Two threads return here, one connected to the client, one connected to
+    # nxnode.
+      self.running = False
+      return
+
+    start_waiting = time.time()
+    wait_time = 30 #FIXME(diamond): make configurable
+    while True:
+      if time.time() - start_waiting > wait_time:
+        nxlog.log(nxlog.LOG_ERR, "Session %s has not appeared in session db "
+            "within %d seconds\n" % (sess_id, wait_time))
+        sys.exit(1)
+        #FIXME(diamond): raise proper error
+      sessions = nxsession.db_find_sessions(id=sess_id)
+      if len(sessions) == 1:
+        sess = sessions[0]
+        nxlog.log(nxlog.LOG_DEBUG, "Session %s has appeared in session db\n" %
+            sess.params['full_id'])
+        break
+      elif len(sessions) > 1:
+        nxlog.log(nxlog.LOG_DEBUG, "Multiple sessions matching %d have been "
+            "found in the session db: %r\n" % sess_id)
+        #FIXME(diamond): raise proper error
+        break
+      else:
+        time.sleep(1)
+
+    self.__print_sess_info(sess)
+
+    start_waiting = time.time()
+    wait_time = 30 #FIXME(diamond): make configurable
+    while True:
+      if time.time() - start_waiting > wait_time:
+        nxlog.log(nxlog.LOG_ERR, "Session %s has not achieved running status "
+            "within %d seconds\n" % (sess_id, wait_time))
+        sys.exit(1)
+        #FIXME(diamond): raise proper error
+      sess.reload()
+      if sess.params['state'] == 'starting':
+        break
+      elif sess.params['state'] in ['terminating', 'terminated']:
+        nxlog.log(nxlog.LOG_ERR, "Session %(full_id)s has status "
+            "'%(state)s', exiting." % sess.params)
+        self.prompt(500, "Error: Session %(full_id)s has status '%(state)s'." %
+            sess.params)
+        self.prompt(999, "Bye.")
+        self.running = False
+        return
+        #FIXME(diamond): raise proper error
+      else:
+        time.sleep(1)
+    self.prompt(710, 'Session status: %s' % sess.params['state'])
+    #FIXME(diamond): use configurable offset
+    self.port = int(sess.params['display']) + 4000
+
+  def _nx_restoresession_handler(self, command):
+    """Handle the restoresession NX command.
+
+    'restoresession' requests an existing session be resume.
+    It requires parameters be specified. The following parameters have
+    been seen, at a minimum the session id must be specified:
+    '--link="lan"'
+    '--backingstore="1"'
+    '--encryption="1"'
+    '--cache="16M"'
+    '--images="64M"'
+    '--shmem="1"'
+    '--shpix="1"'
+    '--strict="0"'
+    '--composite="1"'
+    '--media="0"'
+    '--session="localtest"'
+    '--type="unix-gnome"'
+    '--geometry="3840x1150"'
+    '--client="linux"'
+    '--keyboard="pc102/gb"'
+    '--screeninfo="3840x1150x24+render"'
+    --id="A28EBF5AAC354E9EEAFEEB867980C543"
+
+    Args:
+      command: The NX command and arguments invoked
+
+    Returns:
+      None
+    """
+
+    # Basic checking of the right status
+    if self.status < self.STATUS_LOGGEDIN:
+      self.prompt(554, 'Error: the command \'%s\' cannot '
+          'be called before login' % command[0])
+      return
+    # Make sure the state is consistent
+    assert(hasattr(self, 'username'))
+    # Ask for parameters if none have been given
+    if len(command) > 1:
+      parameters = command[1:]
+    else:
+      self.prompt(106, 'Parameters: ', override_newline=False)
+      response = self.input.readline()
+      self.write('') # Do newline after parameters.
+      parameters = response.split()
+    req = {}
+    # Check the parameters fit with the expected syntax
+    for param in parameters:
+      key,val = self._parse_param(param)
+      if key: req[key] = val
+      # FIXME(diamond): DO something with the params.
+    if not req.has_key('id'):
+      msg = "Restore session requested, but no session specified"
+      nxlog.log(nxlog.LOG_ERR, "%s (args: %r)\n" % (msg, req))
+      self.prompt(500, 'Error: %s. check log file for more details.' % msg)
+      self.running = False
+      return
+    nxlog.log(nxlog.LOG_DEBUG, "Got id param: %s" % req['id'])
+    sessions = nxsession.db_find_sessions(id=req['id'], users=[self.username],
+        states=['suspended', 'running'])
+    if len(sessions) != 1:
+      nxlog.log(nxlog.LOG_ERR, "%d sessions found matching %s in "
+          "session db %s\n" % (len(sessions), req['id'], sessions))
+      self.prompt(500, 'Error: Fatal error in module %s, '
+          'check log file for more details.' % self.program.lower())
+      self.running = False
+      return
+
+    sess = sessions[0]
+    nxlog.log(nxlog.LOG_DEBUG, "Session %s found in session db\n" %
+        sess.params['full_id'])
+
+    # Needed to get nxagent to open it's port again.
+    try:
+      os.kill(int(sess.params['agent_pid']), signal.SIGHUP)
+    except OSError, e:
+      nxlog.log(nxlog.LOG_WARNING, "Attempted to send SIGHUP to nxagent, "
+          "got error from kill[%d]: %s\n" % e.args)
+      self.prompt(500, 'Error: Fatal error in module %s, '
+          'check log file for more details.' % self.program.lower())
+      self.prompt(999, 'Bye.')
+      self.running = False
+      return
+    except (TypeError, ValueError), e:
+      nxlog.log(nxlog.LOG_WARNING, "Session does not have a valid nxagent pid "
+          "stored (instead has %r), got error: %s" %
+          (sess.params['agent_pid'], e))
+      self.prompt(500, 'Error: Fatal error in module %s, '
+          'check log file for more details.' % self.program.lower())
+      self.prompt(999, 'Bye.')
+      self.running = False
+      return
+    else:
+      nxlog.log(nxlog.LOG_NOTICE, "Sent SIGHUP to nxagent\n")
+
+    self.__print_sess_info(sess)
+    self.prompt(710, 'Session status: %s' % sess.params['state'])
+    #FIXME(diamond): use configurable offset
+    self.port = int(sess.params['display']) + 4000
+
+  def daemonize(self):
+    """Drop into the background."""
+
+    # I am assumuing this throws if fork fails.
+    pid = os.fork()
+    # In the parent, return.
+    if pid != 0:
+      # self.nxnode_rfile.close()
+      # self.nxnode_wfile.close()
+      os.close(self.nxnode_commfd)
+      # del(self.nxnode_rfile)
+      # del(self.nxnode_wfile)
+      # del(self.nxnode_commfd)
+      nxlog.setup('nxserver-outer')
+      nxlog.log(nxlog.LOG_INFO, "Forked child to take care of nxsession stuff")
+      return False
+
+    # Dissociate from the nxserver terminal
+    os.setsid()
+
+    # If we need to change signal behavior, do it here.
+
+    # Close the stdio fds.
+    os.close(0)
+    os.close(1)
+    os.close(2)
+
+    self.input = self.nxnode_rfile
+    self.output = self.nxnode_wfile
+
+    # I'm not sure what to do here with self.nxnode_rfile and self.nxnode_wfile
+    # Closing the fd is enough, but the file objects would linger on.
+    del(self.nxnode_rfile)
+    del(self.nxnode_wfile)
+    del(self.nxnode_commfd)
+
+    nxlog.setup('nxserver-inner')
+    nxlog.log(nxlog.LOG_INFO, "Successfully forked, "
+        "taking care of nxsession stuff\n")
+    try:
+      self._session_read_loop()
+    except Exception:
+      trace = traceback.format_exc()
+      nxlog.log(nxlog.LOG_ERR, 'Going down because exception caught '
+                               'at the top level.')
+      for line in trace.split('\n'):
+        nxlog.log(nxlog.LOG_ERR, '%s' % line)
+    return True
+
+  def _session_read_loop(self):
+    sess = None
+    while True:
+      line = self.input.readline()
+      if not line:
+        return
+      line = line.rstrip()
+      nxlog.log(nxlog.LOG_DEBUG, 'Got from nxnode %r\n' % line)
+      # FIXME(diamond): change number to something sensible
+      if line.startswith('NX> 8888 sessioncreate'):
+        if sess:
+          nxlog.log(nxlog.LOG_ERR, 'Nxnode tried to create a session when one '
+              'already exists: %s\n' % line)
+        else:
+          args = line.split(' ', 3)[-1].replace(' ', '\n')
+          sess = nxsession.nxsession(args)
+      elif line.startswith('NX> 8888 agentpid:'):
+        if not sess:
+          nxlog.log(nxlog.LOG_ERR, 'Nxagent-helper tried to change session '
+              'when none exists: %s\n' % line)
+        else:
+          agent_pid = line.rstrip().split(' ')[3]
+          sess.params['agent_pid'] = agent_pid
+          sess.save()
+          nxlog.log(nxlog.LOG_DEBUG, "Agent pid set to '%s'\n" %
+              sess.params['agent_pid'])
+      elif line.startswith('NX> 1009 Session status:'):
+        if not sess:
+          nxlog.log(nxlog.LOG_ERR, 'Nxagent-helper tried to change session '
+              'when none exists: %s\n' % line)
+        else:
+          state_name = line.rstrip().split(' ')[4]
+          sess.set_state(state_name)
+          sess.save()
+          nxlog.log(nxlog.LOG_DEBUG, "Session state updated to '%s'\n" %
+              sess.params['state'])
+      elif line.startswith('NX> 500 Error:'):
+        if sess:
+          sess.set_state('terminated')
+          sess.save()
+          nxlog.log(nxlog.LOG_DEBUG, "Session state updated to '%s', exiting\n"
+              % sess.params['state'])
+          break
+
+  def __print_list_session(self, sessions):
+    """Given a list of sessions, print the listsession output
+
+    Args:
+      sessions: A list of nxsession.nxsesion() instances
+    """
+
+    # Print headers
+    cols = []
+    for header,width,param in self.LISTSESSION_COLUMNS:
+      if width >= 0:
+        text = header.ljust(width)
+      else:
+        text = header.rjust(abs(width))
+      cols.append(text)
+    self.write(" ".join(cols))
+
+    # Print dashes
+    cols = []
+    for header,width,param in self.LISTSESSION_COLUMNS:
+      cols.append("-" * abs(width))
+    self.write(" ".join(cols))
+
+    # Print sessions
+    for sess in sessions:
+      cols = []
+      for header,width,param in self.LISTSESSION_COLUMNS:
+        if width >= 0:
+          text = sess.params[param].ljust(width)
+        else:
+          text = sess.params[param].rjust(abs(width))
+        if param == 'state': text = text.capitalize()
+        cols.append(text)
+      self.write(" ".join(cols))
+
+  def __print_sess_info(self, sess):
+    """Print out session information to the client
+
+    This is used for starting/resuming a session.
+    """
+
+    self.prompt(700, 'Session id: %(full_id)s' % sess.params)
+    self.prompt(705, 'Session display: %(display)s' % sess.params)
+    self.prompt(703, 'Session type: %(type)s' % sess.params)
+    self.prompt(701, 'Proxy cookie: %(cookie)s' % sess.params)
+    self.prompt(702, 'Proxy IP: %(proxyip)s' % sess.params)
+    self.prompt(706, 'Agent cookie: %(cookie)s' % sess.params)
+    self.prompt(704, 'Session cache: %(cache)s' % sess.params)
+    self.prompt(707, 'SSL tunneling: %(ssl)s' % sess.params)
+    self.prompt(708, 'Subscription: GPL')
+
+
+if __name__ == '__main__':
+  print 'This is a library. Please use it from python using import.'
+  sys.exit(0)


Property changes on: trunk/freenx-redesign/server/lib/nxparser/server.py
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/lib/nxparser.py.orig
===================================================================
--- trunk/freenx-redesign/server/lib/nxparser.py.orig	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/lib/nxparser.py.orig	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,588 @@
+#!/usr/bin/python
+#
+# Copyright 2007 Google Inc. All Rights Reserved.
+#
+# $Id: $
+# $Author: $
+# $Date: $
+
+"""nxparser module for handling the nx protocol.
+"""
+
+import os
+import optparse
+import re
+import socket
+import subprocess
+import sys
+import termios
+import time
+import traceback
+
+import nxlog
+
+__author__ = 'alriddoch at google.com (Alistair Riddoch)'
+__version__ = '$Revision: #1 $'
+__copyright__ = 'Copyright 2007 Google Inc. All rights reserved.'
+
+
+class base_parser:
+  """Base parser for NX protocol parsers.
+
+  This class handles breaking up the messages into components,
+  and dispatching them.
+  """
+
+  DEFAULT_VERSION = '3.0.0'
+  DEFAULT_PROGRAM = 'NXBASE'
+
+  NX_PROMPT = 'NX>'
+  NX_COMMANDS = ['hello', 'login', 'bye', 'set', 'listsession',
+                 'restoresession', 'startsession', 'terminate']
+
+  def __init__(self, input, output, version=DEFAULT_VERSION,
+               program=DEFAULT_PROGRAM):
+    """base_parser constructor
+
+    Args:
+      input: The file object to read parser input from.
+      output: The file object to write the results to.
+      version: The version string used to negotiate the protocol.
+      program: The program name used in the protocol banner.
+    """
+
+    self.input = input
+    self.output = output
+    self.state = 105
+    self.running = True
+    self.parse_args(version=version, program=program)
+    nxlog.log(nxlog.LOG_DEBUG, "Version: %s Program: %s" %
+        (self.version, self.program))
+
+  def banner(self):
+    """Write the protocol banner to the output."""
+
+    self.write('HELLO %s - Version %s - GPL' % (self.program, self.version))
+
+  def prompt(self, state, message='', override_newline=None):
+    """Write the protocol prompt to the output."""
+
+    newline = False
+    if override_newline is not None:
+      newline = override_newline
+    elif message:
+      newline=True
+    self.write('%s %d %s' % (self.NX_PROMPT, state, message), newline=newline)
+
+  def loop(self):
+    """Write the protocol prompt to the output, and accept commands."""
+
+    try:
+      while self.running:
+        self.prompt(self.state)
+        line = self.input.readline().rstrip()
+        if not line:
+          return
+        nxlog.log(nxlog.LOG_DEBUG, 'Got %r' % line)
+        command = line.split()
+        if not command:
+          # If the line was all whitespace this could happen.
+          continue
+        cmd = command[0].lower()
+        if cmd == 'set':
+          self.write("%s %s: %s" % (cmd.capitalize(), command[1].lower(), command[2].lower()))
+        elif cmd == 'startsession':
+          self.write("Start session with: %s" % " ".join(command[1:]))
+        else:
+          self.write(line.capitalize())
+        if cmd not in self.NX_COMMANDS:
+          self.prompt(503, 'Error: undefined command: \'%s\'' % cmd)
+          continue
+        handler_name = '_nx_%s_handler' % cmd
+        try:
+          handler_method = getattr(self, handler_name)
+        except AttributeError:
+          nxlog.log(nxlog.LOG_DEBUG, 'Unhandled nx command %r' % cmd)
+          continue
+        handler_method(command)
+    except IOError, e:
+      nxlog.log(nxlog.LOG_ERR, 'IOError. Connection lost.')
+    except Exception, e:
+      trace = traceback.format_exc()
+      nxlog.log(nxlog.LOG_ERR, 'Going down because exception caught '
+                               'at the top level.')
+      for line in trace.split('\n'):
+        nxlog.log(nxlog.LOG_ERR, '%s' % line)
+
+  def write(self, output, newline=True, flush=True, log=True,
+      log_level=nxlog.LOG_DEBUG, fd=None):
+    """Write given string to output, and optionally:
+      - append a newline
+      - flush output afterwards
+      - log the output, with a specified log level."""
+
+    if newline:
+      output += '\n'
+    use_fd = self.output
+    if fd:
+      use_fd = fd
+    use_fd.write(output)
+    if flush:
+      use_fd.flush()
+    if log:
+      nxlog.log(log_level, 'Sent: %r' % output)
+
+  def parse_args(self, version=None, program=None):
+    """Parse cmdline arguments"""
+    parser = optparse.OptionParser()
+    parser.add_option("--proto", action="store", type="string",
+        dest="version", default=version, metavar="PROTO_VER",
+        help="use the PROTO_VER version of the NX protocol")
+    parser.add_option("--program", action="store", type="string",
+        dest="program", default=program, metavar="PROG_NAME",
+        help="the PROG_NAME name to announce")
+    options, args = parser.parse_args()
+    self.version = options.version
+    self.program = options.program
+
+
+
+class node_parser(base_parser):
+  """Node parser for NX protocol
+
+  This class handles the NX protocl messages requires by a node.
+  """
+
+  DEFAULT_PROGRAM = 'NXNODE'
+
+  def __init__(self, input, output, version=base_parser.DEFAULT_VERSION,
+               program=DEFAULT_PROGRAM):
+    """server_parser constructor
+
+    Args:
+      input: The file object to read parser input from.
+      output: The file object to write the results to.
+      version: The version string used to negotiate the protocol.
+      program: The program name used in the protocol banner.
+    """
+    base_parser.__init__(self, input, output, version=version, program=program)
+
+  def banner(self):
+    """Write the protocol banner to the output."""
+
+    self.prompt(1000, '%s - Version %s' % (self.program.upper(), self.version))
+
+  def _nx_startsession_handler(self, command):
+    p = subprocess.Popen('/usr/freenx/bin/nxagent-helper',
+                         stdin=subprocess.PIPE,
+                         stdout=subprocess.PIPE,
+                         stderr=subprocess.STDOUT,
+                         shell=True)
+    p.stdin.write('start %s-1116-DA49F2B8F86161BAD68B5349D63AC1D3\n' %
+        socket.getfqdn().lower())
+    p.stdin.flush()
+    nxlog.log(nxlog.LOG_DEBUG, 'Starting session')
+    child_status = p.wait()
+    if child_status != 0:
+      lines = p.stdout.readlines()
+      if not lines:
+        out_msg = ", no output printed"
+      else:
+        out_msg = ", with %d lines of output (shown below):" % len(lines)
+      nxlog.log(nxlog.LOG_ERR, 'Start session failed %d%s' %
+          (child_status, out_msg))
+      for line in lines:
+        nxlog.log(nxlog.LOG_ERR, 'from nxagent-helper: %s' % line)
+      self.prompt(500, 'Error: Startsession failed')
+      return
+    nxlog.log(nxlog.LOG_ERR, 'Session completed %d' % child_status)
+    self.running = False
+
+  def _nx_resumesession_handler(self, command):
+    nxlog.log(nxlog.LOG_DEBUG, 'Resuming session')
+
+
+class server_parser(base_parser):
+  """Server parser for NX protocol.
+
+  This class handles the NX protocol messages required by a server.
+  """
+
+  DEFAULT_PROGRAM = 'NXSERVER'
+
+  STATUS_CONNECTED, \
+  STATUS_LOGGEDIN = range(2)
+
+  SET_ACCEPTED_VARIABLES = ['AUTH_MODE', 'SHELL_MODE']
+
+  LISTSESSION_ACCEPTED_PARAMETERS = ['user', 'status', 'geometry', 'type']
+  LISTSESSION_COLUMNS_HEADER = "Display Type             Session ID                       Options  Depth Screen         Status      Session Name"
+  LISTSESSION_COLUMNS_DASHES = "------- ---------------- -------------------------------- -------- ----- -------------- ----------- ------------------------------"
+
+  STARTSESSION_ACCEPTED_PARAMETERS = [ 'backingstore', 'cache', 'client',
+                                       'composite', 'encryption', 'geometry',
+                                       'images', 'keyboard', 'link',
+                                       'media', 'screeninfo' 'session',
+                                       'shmem', 'shpix', 'strict', 'type', ]
+
+  def __init__(self, input, output, version=base_parser.DEFAULT_VERSION,
+               program=DEFAULT_PROGRAM):
+    """server_parser constructor
+
+    Args:
+      input: The file object to read parser input from.
+      output: The file object to write the results to.
+      version: The version string used to negotiate the protocol.
+      program: The program name used in the protocol banner.
+    """
+    base_parser.__init__(self, input, output, version=version, program=program)
+
+    username = os.getenv('NX_TRUSTED_USER')
+    
+    if username:
+      self.status = self.STATUS_LOGGEDIN
+      self.username = username
+    else:
+      self.status = self.STATUS_CONNECTED
+
+    commfd = os.getenv('NX_COMMFD')
+
+    if commfd:
+      self.nxnode_commfd = int(commfd)
+      self.nxnode_rfile = os.fdopen(self.nxnode_commfd, 'r')
+      self.nxnode_wfile = os.fdopen(self.nxnode_commfd, 'w')
+      nxlog.log(nxlog.LOG_DEBUG, 'Got commfd %d' % self.nxnode_commfd)
+
+  def banner(self):
+    """Write the protocol banner to the output."""
+
+    if self.status == self.STATUS_LOGGEDIN:
+      assert(hasattr(self, 'username'))
+      self.prompt(103, 'Welcome to: %s user: %s' % (socket.getfqdn().lower(),
+                                                      self.username))
+    else:
+      self.write('HELLO %s - Version %s - GPL' % (self.program, self.version))
+
+  def _nx_bye_handler(self, command):
+    """Handle the bye NX command.
+
+    'bye' signals the end of a commandline session. Currently it is ignored
+    as the other end typically closes the connection, causing termination.
+    It may be a good idea to explicitly exit.
+
+    Args:
+      command: The NX command and arguments invoked
+
+    Returns:
+      None
+    """
+
+    # Basic checking of the right status
+    if self.status < self.STATUS_LOGGEDIN:
+      self.prompt(554, 'Error: the command \'bye\' cannot be called before login')
+      return
+    try:
+      self.prompt(999, 'Bye.')
+    except:
+      pass #DEBUG: don't do this..
+    os.execve("/bin/netcat", ["netcat", "localhost", "5116"], {})
+
+  def _nx_hello_handler(self, command):
+    """Handle the hello NX command.
+
+    'hello' is used to handshake the commandline session, and appears to
+    support negotiation of the protocol version. We currently only
+    accept versions which look like 3.x.x, matched using a regex.
+
+    Args:
+      command: The NX command and arguments invoked
+
+    Returns:
+      None
+    """
+
+    # Basic checking of the right status
+    if self.status >= self.STATUS_LOGGEDIN:
+      self.prompt(554, 'Error: the command \'hello\' cannot be called after login')
+      return
+    if len(command) < 5:
+      nxlog.log(nxlog.LOG_DEBUG, 'Hello too short')
+      return
+    if not re.match('^3(\.[0-9]+(\.[0-9]+))', command[4]):
+      nxlog.log(nxlog.LOG_DEBUG, 'Version too fucked')
+      self.prompt(552, 'Protocol you requested is not supported')
+      return
+    self.prompt(134, 'Accepted protocol: %s' % command[4])
+
+  def _nx_login_handler(self, command):
+    """Handle the login NX command.
+
+    'login' is used to start the process of authenticating to NX. The username
+    and password is send in response to requests from the server. If no
+    options have been set, nxserver will ask for the password, and will then
+    ask for an 'MD5 Password' if no password is given. If
+    'SET AUTH_MODE PASSWORD' has been sent by the client, it does not do this
+     however. This code currently never requests the MD5 Password. It is
+    possible that making use of this feature requires storing the users
+    password and verifying it with the hash.
+
+    Args:
+      command: The NX command and arguments invoked
+
+    Returns:
+      None
+    """
+
+    # Basic checking of the right status
+    if self.status >= self.STATUS_LOGGEDIN:
+      self.prompt(554, 'Error: the command \'login\' cannot be called after login')
+      return
+    self.prompt(101, 'User: ', override_newline=False)
+    line = self.input.readline()
+    split_line = line.split()
+    if not line or len(split_line) != 1:
+      self.prompt(500, 'Error: Username is not in expected format')
+      return
+    self.write('') # Print newline after username
+    self.username = split_line[0]
+    nxlog.log(nxlog.LOG_DEBUG, 'Got user %r' % self.username)
+    self.prompt(102, 'Password: ', override_newline=False)
+
+    fd = self.input.fileno()
+    nxlog.log(nxlog.LOG_DEBUG, 'Got fd %r' % fd)
+    # Save the terminal settings
+    try:
+      old = termios.tcgetattr(fd)
+      new = old[:]
+
+      # Disable the echo flag
+      new[3] = new[3] & ~termios.ECHO # 3 == 'lflags'
+      try:
+        termios.tcsetattr(fd, termios.TCSADRAIN, new)
+        passwd = self.input.readline()
+      finally:
+        termios.tcsetattr(fd, termios.TCSADRAIN, old)
+    except termios.error:
+      passwd = self.input.readline()
+
+    nxlog.log(nxlog.LOG_DEBUG, 'Got a passwd')
+
+    self.write('\n')
+    # FIXME ssh to localhost to verify the username and password are correct.
+    # FIXME store the authentication information we need in a secure way.
+    del passwd
+    self.status = self.STATUS_LOGGEDIN
+    self.banner()
+
+  def _nx_set_handler(self, command):
+    """Handle the SET NX command.
+
+    'SET' is used to configure the session in various ways. Two variables
+    have been seen.
+    'SET SHELL_MODE SHELL' has no known effect.
+    'SET AUTH_MODE PASSWORD' prevents nxserver fromm asking for an MD5
+    password if no password has been given.
+
+    Args:
+      command: The NX command and arguments invoked
+
+    Returns:
+      None
+    """
+    if len(command) < 2:
+      self.prompt(500, 'Error: missing parameter \'variable\'')
+      return
+    var = command[1].upper()
+    if var not in self.SET_ACCEPTED_VARIABLES:
+      self.prompt(500, 'Error: unknown variable \'%s\'' % var)
+      return
+      
+  def _nx_listsession_handler(self, command):
+    """Handle the listsession NX command.
+
+    'listsession' requests a table of session information for the current
+    user. It requires parameters be specified. The following parameters have
+    been seen.
+    '--user="alriddoch"'
+    This seems to be ignored. No matter what is specified, the user given at
+    login is used.
+    '--status="suspended,running"'
+    This seems to constrain the list to sessions in the given states.
+    '--geometry="3840x1200x24+render"'
+    This seems to specify the desired geometry.
+    '--type="unix-gnome"'
+    This seems to specify the desired type.
+    The format of the returned data is somewhat freeform, and looks hard to
+    parse. Currently this function returns an empty table, which forces the
+    the client to always start a new session
+
+    Args:
+      command: The NX command and arguments invoked
+
+    Returns:
+      None
+    """
+
+    # Basic checking of the right status
+    if self.status < self.STATUS_LOGGEDIN:
+      self.prompt(554, 'Error: the command \'listsession\' cannot be called before login')
+      return
+    # Make sure the state is consistent
+    assert(hasattr(self, 'username'))
+    # Ask for parameters if none have been given
+    if len(command) > 1:
+      parameters = command[1:]
+    else:
+      self.prompt(106, 'Parameters: ', override_newline=False)
+      response = self.input.readline()
+      self.write('') # Do newline after parameters.
+      parameters = response.split()
+    # Check the parameters fit with the expected syntax
+    for param in parameters:
+      p = re.match('^--([a-z]+)="(.+)"', param)
+      if p:
+        nxlog.log(nxlog.LOG_DEBUG, 'Param %r matched' % param)
+      else:
+        nxlog.log(nxlog.LOG_DEBUG, 'Param %r missed' % param)
+      # FIXME DO something with the params.
+      # Note that --user is IGNORED
+    self.prompt(127, 'Available sessions:')
+    self.write("%s\n%s" % (self.LISTSESSION_COLUMNS_HEADER, self.LISTSESSION_COLUMNS_DASHES))
+    #DEBUG: remove later
+    #self.write("1057    unix-kde         A28EBF5AAC354E9EEAFEEB867980C543 -RD--PSA    24 800x600        Suspended   warped0")
+    #self.write("1057    unix-kde         A28EBF5AAC354E9EEAFEEB867980C543 -RD--PSA    24 800x600        Suspended   warped0")
+    #END DEBUG
+    self.write('') # Print newline.
+    self.prompt(148, "Server capacity: not reached for user: %s" % self.username)
+
+  def _nx_startsession_handler(self, command):
+    """Handle the startsession NX command.
+
+    'startsession' seems to request a new session be started.
+    It requires parameters be specified. The following parameters have
+    been seen.
+    '--link="lan"'
+    '--backingstore="1"'
+    '--encryption="1"'
+    '--cache="16M"'
+    '--images="64M"'
+    '--shmem="1"'
+    '--shpix="1"'
+    '--strict="0"'
+    '--composite="1"'
+    '--media="0"'
+    '--session="localtest"'
+    '--type="unix-gnome"'
+    '--geometry="3840x1150"'
+    '--client="linux"'
+    '--keyboard="pc102/gb"'
+    '--screeninfo="3840x1150x24+render"'
+    Experiments with this command by directly invoked nxserver have not
+    worked, as it refuses to create a session saying the unencrypted sessions
+    are not supported. This is independent of whether the --encryption option
+    has been set, so probably is related to the fact the nxserver has not
+    been launched by sshd.
+
+    Args:
+      command: The NX command and arguments invoked
+
+    Returns:
+      None
+    """
+
+    # Basic checking of the right status
+    if self.status < self.STATUS_LOGGEDIN:
+      self.prompt(554, 'Error: the command \'startsession\' cannot '
+          'be called before login')
+      return
+    # Make sure the state is consistent
+    assert(hasattr(self, 'username'))
+    # Ask for parameters if none have been given
+    if len(command) > 1:
+      parameters = command[1:]
+    else:
+      self.prompt(106, 'Parameters: ', override_newline=False)
+      response = self.input.readline()
+      self.write('') # Do newline after parameters.
+      parameters = response.split()
+    # Check the parameters fit with the expected syntax
+    for param in parameters:
+      p = re.match('^--([a-z]+)="(.+)"', param)
+      if p:
+        nxlog.log(nxlog.LOG_DEBUG, 'Param %r matched' % param)
+      else:
+        nxlog.log(nxlog.LOG_DEBUG, 'Param %r missed' % param)
+      # FIXME DO something with the params.
+    # FIXME Start the session.
+    if not hasattr(self, 'nxnode_commfd'):
+      nxlog.log(nxlog.LOG_ERR, 'Nxserver does not have an nxnode yet.')
+      return
+    # Send the command to the connected nxnode running
+    # FIXME Convert the arguments to the form expected by nxnode.
+    #DEBUG: remove later
+    self.write('startsession arguments', fd=self.nxnode_wfile)
+    self.prompt(700, 'Session id: %s-1116-DA49F2B8F86161BAD68B5349D63AC1D3' %
+        socket.getfqdn().lower())
+    self.prompt(705, 'Session display: 1116')
+    self.prompt(703, 'Session type: unix-kde')
+    self.prompt(701, 'Proxy cookie: C9B7CFDBC88A1138C698CBF44ADBC1E4')
+    self.prompt(702, 'Proxy IP: 172.26.170.56')
+    self.prompt(706, 'Agent cookie: C9B7CFDBC88A1138C698CBF44ADBC1E4')
+    self.prompt(704, 'Session cache: unix-kde')
+    self.prompt(707, 'SSL tunneling: 1')
+    self.prompt(708, 'Subscription: LFE/None/LFEN/None')
+    # Just to give nxagent time to start. The final version will wait for the
+    # status change message from nxnode/nxagent-helper.
+    time.sleep(10)
+    self.prompt(710, 'Session status: running')
+
+    #END DEBUG
+
+    self.daemonize()
+    # Two threads return here, one connected to the client, one connected to
+    # nxnode.
+  def daemonize(self):
+    """Drop into the background."""
+  
+    # I am assumuing this throws if fork fails.
+    pid = os.fork()
+    # In the parent, return.
+    if pid != 0:
+      # self.nxnode_rfile.close()
+      # self.nxnode_wfile.close()
+      os.close(self.nxnode_commfd)
+      # del(self.nxnode_rfile)
+      # del(self.nxnode_wfile)
+      # del(self.nxnode_commfd)
+      return
+
+    # Dissociate from the nxserver terminal
+    os.setsid()
+
+    # If we need to change signal behavior, do it here.
+
+    # Close the stdio fds.
+    # os.close(0)
+    # os.close(1)
+    # os.close(2)
+
+    self.input = self.nxnode_rfile
+    self.output = self.nxnode_wfile
+    
+    # I'm not sure what to do here with self.nxnode_rfile and self.nxnode_wfile
+    # Closing the fd is enough, but the file objects would linger on.
+    del(self.nxnode_rfile)
+    del(self.nxnode_wfile)
+    del(self.nxnode_commfd)
+
+    while True:
+      line = self.input.readline().rstrip()
+      if not line:
+        return
+      nxlog.log(nxlog.LOG_DEBUG, 'Got from nxnode %r' % line)
+    
+
+
+if __name__ == '__main__':
+  print 'This is a library. Please use it from python using import.'
+  sys.exit(0)

Added: trunk/freenx-redesign/server/lib/nxsession.py
===================================================================
--- trunk/freenx-redesign/server/lib/nxsession.py	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/lib/nxsession.py	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,225 @@
+#!/usr/bin/python2.4
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: diamond at google.com (Stephen Shirley)
+
+"""nxsession module for handling nx sessions."""
+
+import copy
+import glob
+import md5
+import os
+import pwd
+import socket
+import time
+
+import nxlog
+
+DB_TOPLEVEL="/usr/freenx/var/sessdb"
+
+state_names = ['created', 'starting', 'running', 'suspending',
+    'suspended', 'terminating', 'terminated']
+
+# FIXME(diamond): make sure all defaults are sane
+default_params = {
+    'agent_pid': None,
+    'cache': None,
+    'cookie': None,
+    'depth': 24,
+    'display': 1,
+    'full_id': None,
+    'fullscreen': None,
+    'hostname': socket.getfqdn(),
+    'id': None,
+    'name': "No name given",
+    'options': None,
+    #FIXME(diamond): Not ipv6 compatible:
+    'proxyip': socket.gethostbyname(socket.getfqdn()),
+    'resolution': None,
+    'ssl': '1',
+    'state': state_names[0],
+    'subscription': 'GPL',
+    'type': None,
+    'updated': None,
+    'user': None}
+
+
+def gen_uniq_id():
+  """Generate a unique 32-character ID
+
+  This uses uses md5 to create a hash of the hostname, the time, and the 
+  process ID.
+
+  Return:
+    The generated ID
+  """
+
+  #FIXME(diamond): time.time() can return the same time multiple times if
+  #called quickly enough, so we need to maybe keep a counter, add it
+  return md5.md5(socket.getfqdn() + str(time.time()) +
+      str(os.getpid())).hexdigest().upper()
+
+
+class nxsession:
+  """nxsession database
+
+  This class handles parsing session parameters, and saving them into the
+  session database"""
+
+  def __init__(self, parameters):
+    """nxsession constructor
+
+    Args:
+      parameters: A list of key=value strings
+    """
+
+    self.__set_vars(parameters)
+
+  def __set_vars(self, parameters):
+    """Set instances parameters from key=value string list
+
+    Args:
+      parameters: A list of key=value strings
+    """
+    self.params = copy.deepcopy(default_params)
+
+    # Read values from supplied set
+    for pair in parameters.split('\n'):
+      if not pair: continue
+      name,val = pair.split('=', 1)
+      if name not in default_params:
+        nxlog.log(nxlog.LOG_ERR, "Invalid session parameter passed in: %s" % pair)
+      else:
+        self.params[name] = val
+
+    if not self.params['id']:
+      self.params['id'] = gen_uniq_id()
+    # Always generate full_id
+    self.params['full_id'] = "%(hostname)s-%(display)s-%(id)s" % self.params
+    if not self.params['cookie']:
+      self.params['cookie'] = gen_uniq_id()
+    if not self.params['user']:
+      self.params['user'] = pwd.getpwuid(os.getuid())[0]
+    if not self.params['cache']:
+      type = self.params['type']
+      if type.startswith('unix-'):
+        type = type.split('-', 1)[0]
+      self.params['cache'] = "cache-%s" % type
+
+  def set_state(self, name):
+    """Set the state of the session
+
+    Does some sanity checking to make sure the new state is valid
+
+    Args:
+      name: Name of the state to set the session to.
+    Returns:
+      None
+    """
+
+    if name not in state_names:
+      nxlog.log(nxlog.LOG_ERR, "Invalid state name passed in: %r" % name)
+      # FIXME(diamond): handle error better
+    else:
+      self.params['state'] = name
+
+  def save(self):
+    """Save the session to the database
+
+    Sets the 'updated' parameter while saving
+    """
+
+    sess_path = os.path.join(DB_TOPLEVEL, self.params['full_id'])
+    sess_save_path = sess_path + '.saving'
+    self.params['updated'] = int(time.time())
+    f = open(sess_save_path, 'w')
+    for name,val in self.params.iteritems():
+      f.write('%s=%s\n' % (name, val))
+    f.close()
+    os.rename(sess_save_path, sess_path)
+
+  def reload(self):
+    self.__set_vars(_db_read_session(self.params['full_id']))
+
+  def get_params(self):
+    """Return an iterator over (key, value) the session parameters"""
+
+    return self.params.iteritems()
+
+
+def db_list():
+  """List all sessions in the database"""
+
+  return os.listdir(DB_TOPLEVEL)
+
+def db_find_sessions(id=None, users=None, states=None, types=None):
+  """Find sessions that match the specified parameters
+
+  Args:
+    id: 32-character unique session id
+    users: List of session owners
+    states: List of session states; 'running', 'suspended', etc
+
+  Returns:
+    A list of nxsession instances for any matching sessions in the database.
+    If none are found, the list is empty.
+  """
+
+  found = []
+  file_glob = "*"
+  if id:
+    file_glob += id
+
+  for sess_full_id in map(os.path.basename,
+      glob.glob(os.path.join(DB_TOPLEVEL, file_glob))):
+    sess = db_get_session(sess_full_id)
+    if users and sess.params['user'] not in users:
+        continue
+    if states and sess.params['state'] not in states:
+        continue
+    if types and sess.params['type'] not in types:
+        continue
+    found.append(sess)
+
+  return found
+
+def _db_read_session(full_id):
+  """Read in specified session from the database
+
+  Args:
+    full_id: The full session id (hostname-displaynum-id)
+
+  Returns:
+    A string containing the contents of the session's entry in the database.
+  """
+
+  contents = open(os.path.join(DB_TOPLEVEL, full_id), 'r').read()
+  return contents
+
+
+def db_get_session(full_id):
+  """Retrieve the specified session from the database
+
+  Args:
+    full_id: The full session id (hostname-displaynum-id)
+
+  Returns:
+    An instance of nxsession
+  """
+
+  return nxsession(_db_read_session(full_id))


Property changes on: trunk/freenx-redesign/server/lib/nxsession.py
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/lib/nxsession_test.py
===================================================================
--- trunk/freenx-redesign/server/lib/nxsession_test.py	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/lib/nxsession_test.py	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,224 @@
+#!/usr/bin/python2.4 -E
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: alriddoch at google.com (Alistair Riddoch)
+
+"""nxsession module unit tests
+
+  GenUniqIdTest: Test gen_uniq_id().
+  NXSessionUnitTest: Test nxsession.
+"""
+
+import time
+import unittest
+
+import nxsession
+
+__author__ = 'alriddoch at google.com (Alistair Riddoch)'
+__version__ = '$Revision: #4 $'
+__copyright__ = 'Copyright 2008 Google Inc. All rights reserved.'
+
+
+class GlobalsTest(unittest.TestCase):
+  """Unit test for global variables in nxsession"""
+
+  def testStateNames(self):
+    """Test state names is not empty"""
+
+    self.failUnless(nxsession.state_names)
+
+  def testDefaultParams(self):
+    """Test that default params is not empty"""
+
+    # In later tests we use the contents without bounds checking
+    # This is a canary to making those tests easier to debug if
+    # something changes.
+    self.failUnless(nxsession.default_params)
+
+
+class GenUniqIdTest(unittest.TestCase):
+  """Unit test for nxsession.gen_uniq_id"""
+
+  def testGetUniqId(self):
+    """Test case for nxsession.gen_uniq_id function"""
+
+    self.failUnless(nxsession.gen_uniq_id())
+
+  def testGetUniqIdUniq(self):
+    """Test case for nxsession.gen_uniq_id to ensure ID is unique"""
+
+    first = nxsession.gen_uniq_id()
+
+    time.sleep(1)
+
+    second = nxsession.gen_uniq_id()
+
+    self.assertNotEqual(first, second)
+
+
+class NXSessionUnitTest(unittest.TestCase):
+  """Unit test for nxsession.nxsession"""
+
+  def setUp(self): pass
+
+  def tearDown(self): pass
+
+  def testConstructor(self):
+    """Test calling the nxsession constructor"""
+
+    nxsession.nxsession('')
+
+  def testConstructorBadParams(self):
+    """Test calling the nxsession constructor with params containing no ="""
+
+    self.assertRaises(ValueError, nxsession.nxsession, 'foo')
+
+  def testConstructorUnknownParams(self):
+    """Test calling the nxsession constructor with param not in defaults"""
+
+    nxsession.nxsession('foo=bar')
+
+  def testConstructorGoodParam(self):
+    """Test calling the nxsession constructor with param which is ok"""
+
+    key = nxsession.default_params.keys()[0]
+
+    nxsession.nxsession('%s=bar' % key)
+
+  def testConstructorSetsUpId(self):
+    """Test an ID parameter is set up by the constructor"""
+
+    o = nxsession.nxsession('')
+
+    self.failUnless('id' in o.params)
+
+  def testConstructorSetsUpId(self):
+    """Test a default ID parameter is set up by the constructor"""
+
+    o = nxsession.nxsession('')
+
+    self.failUnless('id' in o.params)
+
+  def testConstructorAcceptsId(self):
+    """Test an ID parameter is accepted in those passed to constructor"""
+
+    id = '23'
+
+    o = nxsession.nxsession('id=%s' % id)
+
+    self.assertEquals(id, o.params['id'])
+
+  def testConstructorPopulatesFullId(self):
+    """Test a full_id parameter is set up by the constructor"""
+
+    o = nxsession.nxsession('')
+
+    self.failUnless('full_id' in o.params)
+
+  def testConstructorPopulatesReplacesId(self):
+    """Test a full_id parameter provided in vars is overriden"""
+
+    test_full_id = 'hostname-1-ID'
+
+    o = nxsession.nxsession('full_id=%s' % test_full_id)
+
+    self.failUnless('full_id' in o.params)
+    self.assertNotEqual(o.params['full_id'], test_full_id)
+
+  def testConstructorPopulatesCookie(self):
+    """Test a cookie parameter is set up"""
+
+    o = nxsession.nxsession('')
+
+    self.failUnless('cookie' in o.params)
+
+  def testConstructorCookieIsUniqId(self):
+
+    old_id = nxsession.gen_uniq_id()
+
+    time.sleep(1)
+
+    # Make sure the id from the generator is now different
+    self.assertNotEqual(old_id, nxsession.gen_uniq_id())
+
+    o = nxsession.nxsession('')
+
+    self.failUnless('cookie' in o.params)
+    self.assertNotEqual(old_id, o.params['cookie'])
+
+  def testConstructorAcceptsCookie(self):
+    """Test a cookie paramete is read from vars"""
+
+    cookie = nxsession.gen_uniq_id()
+
+    time.sleep(1)
+
+    # Make sure the id from the generator is now different
+    self.assertNotEqual(cookie, nxsession.gen_uniq_id())
+
+    o = nxsession.nxsession('cookie=%s' % cookie)
+
+    self.failUnless('cookie' in o.params)
+    self.assertEqual(cookie, o.params['cookie'])
+    
+  def testConstructorSetUser(self):
+    """Test a user parameter is set by constructor"""
+
+    o = nxsession.nxsession('')
+
+    self.failUnless('user' in o.params)
+
+  def testConstructorAcceptsUser(self):
+    """Test a user paramater specified in vars is not replaced"""
+
+    username = 'dummy_user'
+
+    o = nxsession.nxsession('user=%s' % username)
+
+    self.failUnless('user' in o.params)
+    self.assertEquals(username, o.params['user'])
+
+  def testSetState(self):
+    """Test setting state on a session"""
+
+    o = nxsession.nxsession('')
+
+    o.set_state(nxsession.state_names[0])
+
+  def testSetStateAllStates(self):
+
+    o = nxsession.nxsession('')
+
+    for state in nxsession.state_names:
+
+      o.set_state(state)
+
+      self.assertEquals(o.params['state'], state)
+
+  def testSetInvalidState(self):
+
+    o = nxsession.nxsession('')
+
+    state = 'invalud_state_name'
+
+    o.set_state(state)
+
+    self.assertNotEquals(o.params['state'], state)
+
+if __name__ == '__main__':
+  unittest.main()


Property changes on: trunk/freenx-redesign/server/lib/nxsession_test.py
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/test/README.TXT
===================================================================
--- trunk/freenx-redesign/server/test/README.TXT	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/README.TXT	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,7 @@
+include/        - Directory containing utility scripts/functions to be included in tests
+run-test-suite  - Run all tests
+testClient2server-regression-XXX - Run client2server regression tests for protocol version XXX
+testTest-functions - Unit tests for utility functions
+
+Requires:
+- local user with username 'nxtest' and password 'haha.yes.'

Added: trunk/freenx-redesign/server/test/client2server-regression.run
===================================================================
--- trunk/freenx-redesign/server/test/client2server-regression.run	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/client2server-regression.run	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,199 @@
+#!/bin/sh
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: diamond at google.com (Stephen Shirley)
+
+. "./include/test-functions.inc" && setupTestDirs
+
+NXSERVER=/usr/NX/bin/nxserver
+NXUSER=nx
+
+runNxServer()
+{
+  LD_LIBRARY_PATH=/usr/NX/lib /usr/NX/bin/nxssh -nx -i /usr/NX/share/keys/server.id_dsa.key "$NXUSER"@"$HOSTNAME"
+}
+
+doPrelim()
+{
+  recvCheckRegx "Nxssh running line" \
+    '^NX> 203 NXSSH running with pid: [[:digit:]]+$'
+
+  recvCheck "Nxssh connected line wrong" \
+    "NX> 200 Connected to address: $(hostname -i) on port: 22"
+
+  recvCheck "Nxssh auth line wrong" \
+   "NX> 202 Authenticating user: $NXUSER"
+
+  recvCheck "Nxssh using auth method line wrong" \
+    "NX> 208 Using auth method: publickey"
+
+  recvCheckRegx 'Banner' \
+    '^HELLO NXSERVER - Version [^[:blank:]]+ .*$'
+
+  NXCLIENTHELLO="hello nxclient - version $NXCLIENTVER"
+  sendRecvCheck "$NXCLIENTHELLO" "Client hello came back wrong" \
+    "NX> 105 $NXCLIENTHELLO"
+
+  recvCheck "Client hello reply wrong" "NX> 134 Accepted protocol: $NXCLIENTVER"
+
+  sendRecvCheck "set shell_mode shell" "Shell mode came back wrong" "NX> 105 set shell_mode: shell"
+
+  sendRecvCheck "set auth_mode password" "Auth mode came back wrong" "NX> 105 set auth_mode: password"
+
+  NXLOGIN="login"
+  sendRecvCheck "$NXLOGIN" "Login came back wrong" "NX> 105 $NXLOGIN "
+}
+
+setupLoginCorrectUsernameWrongPassword() {
+  NXUSERNAME="nxtest"
+  NXPASSWORD="haha.no."
+  NXPASSWORDREPLY="NX> 404 ERROR: WRONG PASSWORD OR LOGIN."
+}
+
+setupLoginCorrectUsernameCorrectPassword() {
+  NXUSERNAME="nxtest"
+  NXPASSWORD="haha.yes."
+  NXPASSWORDREPLY="NX> 103 WELCOME TO: $HOSTNAME USER: $NXUSERNAME"
+}
+
+setupLoginWrongUsername() {
+  NXUSERNAME="nxfail"
+  NXPASSWORD="haha.no."
+  NXPASSWORDREPLY="NX> 404 ERROR: WRONG PASSWORD OR LOGIN."
+}
+
+doLogin()
+{
+  NXUSERNAME_RESPONSE="user: $NXUSERNAME"
+  NXPASSWORD_RESPONSE="password: $(echo $NXPASSWORD | sed 's/./*/g')"
+
+  sendRecvCheck "$NXUSERNAME" "Username came back wrong" "NX> 101 $NXUSERNAME_RESPONSE"
+
+  sendRecvCheck "$NXPASSWORD" "Password came back wrong" "NX> 102 $NXPASSWORD_RESPONSE"
+
+  recvCheck "Password reply wrong" "$NXPASSWORDREPLY"
+}
+
+doListSessions()
+{
+  NXLISTSESSION="listsession"
+  if [ "$@" ]; then
+    NXLISTSESSION="$NXLISTSESSION $@"
+  fi
+
+  sendRecvCheck "$NXLISTSESSION" "Listsession came back wrong" "NX> 105 $NXLISTSESSION "
+
+  recvCheck "Listsession reply(0) wrong" "NX> 127 SESSION LIST OF USER '$NXUSERNAME': "
+  recvCheck "Listsession reply(1) wrong" ""
+  recvCheck "Listsession reply(2) wrong" "DISPLAY USERNAME        REMOTE IP       SESSION ID                       NODE"
+  recvCheck "Listsession reply(3) wrong" "------- --------------- --------------- -------------------------------- -----------"
+}
+
+doListNoSessions()
+{
+  doListSessions
+  recvCheck "Listsession reply(4) wrong" ""
+}
+
+doStartSession()
+{
+  MOSTARGS='--link="adsl" --backingstore="1" --streaming="1" --nodelay="1" --encryption="1" --cache="8M" --images="32M" --shmem="1" --shpix="1" --strict="0" --composite="1" --media="0" --session="graphite-euw" --type="unix-kde" --geometry="2400x1870" --client="linux"'
+
+  SESSIONARGS="$MOSTARGS --keyboard=\"pc105/gb\""
+  sendRecvCheck "startsession $SESSIONARGS" "Startsession came back wrong" \
+    "NX> 105 START SESSION WITH: $MOSTARGS --keyboard=\"pc105057gb\" "
+
+  recvCheckRegx "Session reply wrong" 'NX> 700 SESSION ID: '"$HOSTNAME"'-[[:digit:]]+-[[:digit:]ABCDEF]+$'
+}
+
+doNormalSetup()
+{
+  setupLoginCorrectUsernameCorrectPassword
+  doPrelim
+  doLogin
+}
+
+setUp()
+{
+  rm -f .extern.*
+  mkfifo .extern.stdin
+  mkfifo .extern.stdout
+  runNxServer < .extern.stdin &> .extern.stdout &
+  eval "exec $EXTERN_STDIN>.extern.stdin"
+  eval "exec $EXTERN_STDOUT<.extern.stdout"
+}
+
+tearDown()
+{
+  eval "exec $EXTERN_STDIN>&-"
+  eval "exec $EXTERN_STDOUT<&-"
+  rm -f .extern.*
+}
+
+testPrelim()
+{
+  doPrelim
+}
+
+testLoginCorrectUsernameWrongPassword()
+{
+  setupLoginCorrectUsernameWrongPassword
+
+  doPrelim
+  doLogin
+}
+
+testLoginCorrectUsernameCorrectPassword()
+{
+  setupLoginCorrectUsernameCorrectPassword
+  doPrelim
+  doLogin
+}
+
+testLoginWrongUsername()
+{
+  setupLoginWrongUsername
+  doPrelim
+  doLogin
+}
+
+# Everything after this point probably wants to call doNormalSetup first.
+
+testBlankLine()
+{
+  doNormalSetup
+
+  sendRecvCheck "" "Blank line came back wrong" "NX> 105 "
+}
+
+testListNoSessions()
+{
+  doNormalSetup
+
+  doListNoSessions
+}
+
+testStartSession()
+{
+  doNormalSetup
+
+  doStartSession
+}
+
+# load shunit2
+. ../utility/shunit2


Property changes on: trunk/freenx-redesign/server/test/client2server-regression.run
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/test/client2server-regression.template
===================================================================
--- trunk/freenx-redesign/server/test/client2server-regression.template	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/client2server-regression.template	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,23 @@
+#!/bin/sh
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: diamond at google.com (Stephen Shirley)
+
+progname=$(basename $0)
+export NXCLIENTVER="${progname##*-}"
+./"client2server-regression.run"


Property changes on: trunk/freenx-redesign/server/test/client2server-regression.template
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/test/include/commercial-nx-3.0-functions
===================================================================
--- trunk/freenx-redesign/server/test/include/commercial-nx-3.0-functions	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/include/commercial-nx-3.0-functions	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,2 @@
+#!/bin/sh
+

Added: trunk/freenx-redesign/server/test/include/nxserver-fuctions.inc
===================================================================
--- trunk/freenx-redesign/server/test/include/nxserver-fuctions.inc	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/include/nxserver-fuctions.inc	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1 @@
+link commercial-nx-3.0-functions
\ No newline at end of file


Property changes on: trunk/freenx-redesign/server/test/include/nxserver-fuctions.inc
___________________________________________________________________
Name: svn:special
   + *

Added: trunk/freenx-redesign/server/test/include/test-functions.inc
===================================================================
--- trunk/freenx-redesign/server/test/include/test-functions.inc	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/include/test-functions.inc	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,141 @@
+#!/bin/sh
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: diamond at google.com (Stephen Shirley)
+
+EXTERN_STDIN=7
+EXTERN_STDOUT=8
+EXTERN_STDERR=9
+
+aTrue() { assertTrue "$@"; }
+aEquals() { assertEquals "$@"; }
+
+readLineX()
+{
+  lineno="$1"
+  head -n "$lineno" | tail -1
+}
+
+toupper()
+{
+  trim "$@" | tr '[:lower:]' '[:upper:']
+}
+
+trim()
+{
+  echo "$@" | tr -d '\r\n'
+}
+
+readTrimToupper()
+{
+  local resp
+  IFS= read resp <&${EXTERN_READ:-$EXTERN_STDOUT}
+  resp=$(trim "$resp")
+  toupper "$resp"
+}
+
+recvCheck()
+{
+  local comment="$1"
+  local expected="$(toupper "$2")"
+
+  local resp="$(readTrimToupper)"
+  #echo "Resp: \"$resp\" Exp: \"$expected\""
+
+  aEquals "$comment" "$expected" "$resp"
+}
+
+recvCheckRegx()
+{
+  local comment="$1"
+  local regex="$2"
+
+  local resp="$(readTrimToupper)"
+  #echo "Resp: \"$resp\" Regex: \"$regex\""
+
+  echo "$resp" | egrep -ixq "$regex"
+  aTrue "$comment didn't match \"$regex\" (Got \"$resp\")" $?
+}
+
+sendRecvCheck()
+{
+  local send="$1"
+  local comment="$2"
+  local expected="$3"
+
+  eval "echo \"$send\" >&${EXTERN_WRITE:-$EXTERN_STDIN}"
+  recvCheck "$comment" "$expected"
+}
+
+sendRecvCheckRegx()
+{
+  local send="$1"
+  local comment="$2"
+  local regex="$3"
+
+  eval "echo \"$send\" >&${EXTERN_WRITE:-$EXTERN_STDIN}"
+  recvCheckRegx "$comment" "$regex"
+}
+
+setupLoggingStderr()
+{
+  logger_addAppender stderr
+  appender_setType stderr FileAppender
+  appender_file_setFile stderr STDERR
+  appender_activateOptions stderr
+}
+
+setupPaths()
+{
+  TEST_DIR="$__shunit_tmpDir"
+  SRC_DIR="${SRC_DIR:-$(cd .. && pwd -L)}"
+  PATH_ETC="${PATH_ETC:-$TEST_DIR/etc}"
+  PATH_BIN="${PATH_BIN:-$TEST_DIR/bin}"
+  PATH_LIB="${PATH_LIB:-$TEST_DIR/lib}"
+  PATH="$PATH:$PATH_BIN"
+}
+
+setupLoadConfig()
+{
+  setupPaths
+  setupTestDirs
+  cat << EOF > "$PATH_ETC/general.conf"
+LOG_LEVEL=DEBUG
+PATH_BASE="$TEST_DIR"
+PATH="$PATH"
+EOF
+}
+
+setupTestDirs()
+{
+  set -e
+  chmod 755 "$TEST_DIR"
+  rm -rf "$PATH_BIN"
+  mkdir -pm 755 "$PATH_BIN"
+  (
+    cd "$PATH_BIN"
+    for file in "$SRC_DIR/"{compatibility,utility}/*; do
+      cp "$file" .
+    done
+    chmod 755 *
+  )
+  cp -R "$SRC_DIR/lib" "$TEST_DIR"
+  chmod -R u=rwX,g=rX,o=X "$PATH_LIB"
+  mkdir -pm 755 "$PATH_ETC"
+  set +e
+}

Added: trunk/freenx-redesign/server/test/run-test-suite
===================================================================
--- trunk/freenx-redesign/server/test/run-test-suite	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/run-test-suite	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,28 @@
+#!/bin/sh
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: diamond at google.com (Stephen Shirley)
+
+TEST_SHELL="/bin/bash"
+TEST_FILES="testTest-functions testNxlog testNxserver-login testNxloadconfig testClient2server-regression-*"
+
+for file in $TEST_FILES; do
+  echo "============> Running $file:"
+  "$TEST_SHELL" ./"$file"
+  echo "============> Finished $file:"
+done


Property changes on: trunk/freenx-redesign/server/test/run-test-suite
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/test/testClient2server-regression-1.5.0
===================================================================
--- trunk/freenx-redesign/server/test/testClient2server-regression-1.5.0	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/testClient2server-regression-1.5.0	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1 @@
+link client2server-regression.template
\ No newline at end of file


Property changes on: trunk/freenx-redesign/server/test/testClient2server-regression-1.5.0
___________________________________________________________________
Name: svn:special
   + *

Added: trunk/freenx-redesign/server/test/testClient2server-regression-2.0.0
===================================================================
--- trunk/freenx-redesign/server/test/testClient2server-regression-2.0.0	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/testClient2server-regression-2.0.0	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1 @@
+link client2server-regression.template
\ No newline at end of file


Property changes on: trunk/freenx-redesign/server/test/testClient2server-regression-2.0.0
___________________________________________________________________
Name: svn:special
   + *

Added: trunk/freenx-redesign/server/test/testClient2server-regression-2.1.0
===================================================================
--- trunk/freenx-redesign/server/test/testClient2server-regression-2.1.0	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/testClient2server-regression-2.1.0	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1 @@
+link client2server-regression.template
\ No newline at end of file


Property changes on: trunk/freenx-redesign/server/test/testClient2server-regression-2.1.0
___________________________________________________________________
Name: svn:special
   + *

Added: trunk/freenx-redesign/server/test/testClient2server-regression-3.0.0
===================================================================
--- trunk/freenx-redesign/server/test/testClient2server-regression-3.0.0	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/testClient2server-regression-3.0.0	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1 @@
+link client2server-regression.template
\ No newline at end of file


Property changes on: trunk/freenx-redesign/server/test/testClient2server-regression-3.0.0
___________________________________________________________________
Name: svn:special
   + *

Added: trunk/freenx-redesign/server/test/testNxloadconfig
===================================================================
--- trunk/freenx-redesign/server/test/testNxloadconfig	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/testNxloadconfig	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,97 @@
+#!/bin/bash
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: diamond at google.com (Stephen Shirley)
+
+oneTimeSetUp() {
+  . "include/test-functions.inc" && setupLoadConfig
+  # Uncomment for debugging unit tests:
+  #setup_extra_logging="setupLoggingStderr"
+
+  cat << EOF > "$PATH_ETC/nxlog.override"
+nxlog_log() { :; }
+EOF
+
+  . "$PATH_ETC/nxlog.override"
+}
+
+testSource() {
+  . "$PATH_BIN/nxloadconfig" && [ -n "$PATH_BASE" ]
+  assertTrue "nxloadconfig fails when sourced" "$?"
+}
+
+testDefault_if_not_set() {
+  unset CHECKVAR
+  default_if_not_set CHECKVAR "val  ue1"
+  assertTrue "default_if_not_set incorrectly returns true when variable is not set" "$?"
+  assertEquals "default_if_not_set failed to set unset var to default value" "val  ue1" "$CHECKVAR"
+
+  CHECKVAR=""
+  default_if_not_set CHECKVAR value2
+  assertFalse "default_if_not_set incorrectly returns true when variable is set but null" "$?"
+  assertEquals "default_if_not_set changed the value of a set variable" "" "$CHECKVAR"
+
+  CHECKVAR="some  thing"
+  default_if_not_set CHECKVAR value3
+  assertFalse "default_if_not_set incorrectly returns true when variable is set to a non-null string" "$?"
+  assertEquals "default_if_not_set changed the value of a set variable" "some  thing" "$CHECKVAR"
+
+  unset CHECKVAR
+}
+
+testCheck_dir_var() {
+  unset CHECKDIR
+  check_dir_var CHECKDIR "/etc"
+  assertEquals "check_dir_var fails to set correct default dir when var isn't set" "/etc" "$CHECKDIR"
+
+  CHECKDIR="/nonexistent dir. i hope"
+  check_dir_var CHECKDIR "/usr"
+  assertEquals "check_dir_var fails to set correct default dir when var has an invalid value" "/usr" "$CHECKDIR"
+
+  CHECKDIR="/etc"
+  check_dir_var CHECKDIR "/usr"
+  assertEquals "check_dir_var incorrectly overridess valid directory value" "/etc" "$CHECKDIR"
+
+  CHECKDIR="/nonexistent dir. i hope"
+  ( check_dir_var CHECKDIR "/also nonexistent dir. i hope"; exit 0; )
+  assertFalse "check_dir_var failed to detect an invalid default directory value" "$?"
+
+  unset CHECKDIR
+}
+
+testCheck_command_var() {
+  unset CHECKCMD
+  check_command_var CHECKCMD "/sbin/init"
+  assertEquals "check_command_var fails to set correct default path when var isn't set" "/sbin/init" "$CHECKCMD"
+
+  CHECKCMD="/etc/fstab"
+  check_command_var CHECKCMD "/sbin/init"
+  assertEquals "check_command_var fails to set correct default path when var has an invalid value" "/sbin/init" "$CHECKCMD"
+
+  CHECKCMD="/bin/true"
+  check_command_var CHECKCMD "/bin/sh"
+  assertEquals "check_command_var incorrectly overridess valid command value" "/bin/true" "$CHECKCMD"
+
+  CHECKCMD="/nonexistent cmd. i hope"
+  ( check_command_var CHECKCMD "/also nonexistent cmd. i hope"; exit 0; )
+  assertFalse "check_command_var failed to detect an invalid default command value" "$?"
+
+  unset CHECKCMD
+}
+
+. ../utility/shunit2


Property changes on: trunk/freenx-redesign/server/test/testNxloadconfig
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/test/testNxlog
===================================================================
--- trunk/freenx-redesign/server/test/testNxlog	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/testNxlog	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,100 @@
+#!/bin/bash
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: diamond at google.com (Stephen Shirley)
+
+oneTimeSetUp()
+{
+  # This unit test may need to be run while installed.
+  . "./include/test-functions.inc" && setupLoadConfig
+  abs_path="$(cd "$PATH_BIN" && pwd -L)/nxlog"
+  rel_path="./bin/nxlog"
+  above_path="bin/nxlog"
+  LOG_LEVEL=4
+}
+
+setUp()
+{
+  cd "$TEST_DIR"
+}
+
+sourcePrep() {
+  set -e
+}
+
+testRunAbsolute () {
+  "$abs_path" "$LOG_LEVEL" "$_su_func"
+  assertTrue "nxlog fails to run from an absolute path" "$?"
+}
+
+testRunRelative () {
+  "$rel_path" "$LOG_LEVEL" "$_su_func"
+  assertTrue "nxlog fails to run from a relative path" "$?"
+}
+
+testRunAbove () {
+  "$above_path" "$LOG_LEVEL" "$_su_func"
+  assertTrue "nxlog fails to run from the parent dir" "$?"
+}
+
+testSourceAbsolute () {
+  ( sourcePrep && . "$abs_path" && nxlog_log "$LOG_LEVEL" "$_su_func" )
+  assertTrue "nxlog fails when sourced with an absolute path" "$?"
+}
+
+testSourceRelative () {
+  ( sourcePrep && . "$rel_path" && nxlog_log "$LOG_LEVEL" "$_su_func" )
+  assertTrue "nxlog fails when sourced with a relative path" "$?"
+}
+
+testSetupExtraLogging () {
+  ( [ "do_called" =  "$( sourcePrep && setup_extra_logging="do_call" && 
+      . "$rel_path" && nxlog_log "$LOG_LEVEL" "$_su_func" )" ] )
+  assertTrue "nxlog fails to honour setup_extra_logging" "$?"
+}
+
+testNxlog_log_level_2_log4shName () {
+  FROM="EMERG"
+  TO="FATAL"
+  ret="$( ( sourcePrep && . "$rel_path" && _nxlog_log_level_2_log4sh "$FROM"; ) )"
+  assertEquals "_nxlog_log_level_2_log4sh fails to map $FROM to $TO" "$TO" "$ret"
+}
+
+testNxlog_log_level_2_log4shNum () {
+  FROM="7"
+  TO="DEBUG"
+  ret="$( ( sourcePrep && . "$rel_path" && _nxlog_log_level_2_log4sh "$FROM"; ) )"
+  assertEquals "_nxlog_log_level_2_log4sh fails to map $FROM to $TO" "$TO" "$ret"
+}
+
+testNxlog_log_level_2_log4shInvalidLvl () {
+  FROM="hello world"
+  TO="INFO"
+  ret=$( ( sourcePrep && setup_extra_logging="do_call" && . "$rel_path" && \
+  _nxlog_log_level_2_log4sh "$FROM"; ) )
+  LOGGED=$(echo "$ret" | head -1)
+  assertEquals "_nxlog_log_level_2_log4sh didn't log error for invalid level" "do_called" "$LOGGED"
+  LEVEL=$(echo "$ret" | tail -1)
+  assertEquals "_nxlog_log_level_2_log4sh fails to map invalid level to $TO" "$TO" "$LEVEL"
+}
+
+do_call () {
+  echo "do_called"
+}
+
+. ../utility/shunit2


Property changes on: trunk/freenx-redesign/server/test/testNxlog
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/test/testNxserver-login
===================================================================
--- trunk/freenx-redesign/server/test/testNxserver-login	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/testNxserver-login	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,211 @@
+#!/bin/bash
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: diamond at google.com (Stephen Shirley)
+
+oneTimeSetUp()
+{
+  # This unit test may need to be run while installed.
+  . "./include/test-functions.inc" && setupLoadConfig
+  echo "NX_VERSION=3.0.0" >> "$PATH_ETC/general.conf"
+  NX_PROMPT="NX> 105 "
+  NX_SERVER_BANNER_REGX='^HELLO NXSERVER - Version [^[:blank:]]+ .*$'
+  LOGIN_ERROR_REPLY="NX> 404 ERROR: WRONG PASSWORD OR LOGIN."
+}
+
+setUp()
+{
+  cd "$TEST_DIR"
+}
+
+runPrep()
+{
+  cmd="$1"
+  shift
+  rm -f .extern.*
+  mkfifo .extern.stdin
+  mkfifo .extern.stdout
+  "$cmd" "$@" < .extern.stdin &> .extern.stdout &
+  eval "exec $EXTERN_STDIN>.extern.stdin"
+  eval "exec $EXTERN_STDOUT<.extern.stdout"
+}
+
+runCleanup()
+{
+  eval "exec $EXTERN_STDIN>&-"
+  eval "exec $EXTERN_STDOUT<&-"
+  rm -f .extern.*
+}
+
+# Tests that check output of running nxserver script need to be in this section
+testBanner()
+{
+  runPrep nxserver-login
+  recvCheckRegx 'Banner' "$NX_SERVER_BANNER_REGX"
+  eval "exec $EXTERN_STDIN>&-"
+  recvCheck 'Prompt' "$NX_PROMPT"
+  recvCheck 'Bye' 'NX> 999 Bye.'
+  runCleanup
+}
+
+# Tests that check output of running nxserver need to be BEFORE this line
+
+testSourceNxserver()
+{
+  UNITTESTING="1"
+  . bin/nxserver-login
+  nxloadconfig_main
+
+  assertEquals "Sourcing nxserver" "0" "$?"
+}
+
+testConfig_check()
+{
+  NXSERVER_LOGIN_HOOK_LOGIN_USER="/etc/fstab"
+  config_check
+  assertNull "config_check doesn't nuke invalid \
+    \$NXSERVER_LOGIN_HOOK_LOGIN_USER value" "$NXSERVER_LOGIN_HOOK_LOGIN_USER"
+
+  NXSERVER_LOGIN_HOOK_LOGIN_USER="doesn'texist"
+  config_check
+  assertEquals "config_check doesn't change invalid \
+    \$NXSERVER_LOGIN_AUTHENTICATION_METHOD to 'su'" "su" \
+    "$NXSERVER_LOGIN_AUTHENTICATION_METHOD"
+}
+
+mainTestSetup()
+{
+  runPrep nxserver-login_main
+  recvCheckRegx 'Banner' "$NX_SERVER_BANNER_REGX"
+}
+
+mainTestTearDown()
+{
+  runCleanup
+}
+
+testNxserverlogin_main()
+{
+  mainTestSetup
+  eval "exec $EXTERN_STDIN>&-"
+  recvCheck 'Immediate-quit prompt' "$NX_PROMPT"
+  recvCheck 'Immediate-quit bye' 'NX> 999 Bye.'
+
+  for i in quit exit bye; do
+    mainTestSetup
+    sendRecvCheck "$i" "$i came back wrong" "${NX_PROMPT}$i"
+    recvCheck "$i bye" 'NX> 999 Bye.'
+    mainTestTearDown
+  done
+}
+
+testConfigCommands()
+{
+  local VER TYPE
+
+  mainTestSetup
+    VER="testing testing"
+    SEND="hello nxclient - version $VER"
+    sendRecvCheck "$SEND" "Hello came back wrong" "${NX_PROMPT}$SEND"
+    recvCheck "Client hello reply wrong" "NX> 134 Accepted protocol: $VER"
+
+    TYPE="password"
+    SEND="set auth_mode $TYPE"
+    sendRecvCheck "$SEND" "Valid auth mode came back wrong" \
+      "${NX_PROMPT}set auth_mode: $TYPE"
+    TYPE="somethingelse"
+    SEND="set auth_mode $TYPE"
+    sendRecvCheck "$SEND" "Invalid auth mode came back wrong" \
+      "${NX_PROMPT}set auth_mode: $TYPE"
+    recvCheck "Invalid auth mode accepted" "NX> 500 ERROR: unknown auth mode ''"
+  mainTestTearDown
+}
+
+testLoginWrongUsername()
+{
+  local DESC NXUSERNAME NXPASSWORD
+
+  mainTestSetup
+    sendRecvCheck "login" "Login came back wrong" "${NX_PROMPT}login"
+    DESC="Wrong username"
+    NXUSERNAME="nxfail"
+    NXPASSWORD="haha.no."
+    sendRecvCheck "$NXUSERNAME" "$DESC - username came back wrong" \
+      "NX> 101 user: $NXUSERNAME"
+    sendRecvCheckRegx "$NXPASSWORD" "$DESC - password came back wrong" \
+      '^NX> 102 password: \**$'
+    recvCheck "$DESC - login succeded when it shouldn't" "$LOGIN_ERROR_REPLY"
+    recvCheck "$DESC bye" 'NX> 999 Bye.'
+  mainTestTearDown
+}
+
+testLoginRightUsernameWrongPassword()
+{
+  local DESC NXUSERNAME NXPASSWORD
+
+  mainTestSetup
+    sendRecvCheck "login" "Login came back wrong" "${NX_PROMPT}login"
+    DESC="Correct username, wrong password"
+    NXUSERNAME="nxtest"
+    NXPASSWORD="haha.no."
+    sendRecvCheck "$NXUSERNAME" "$DESC - username came back wrong" \
+      "NX> 101 user: $NXUSERNAME"
+    sendRecvCheckRegx "$NXPASSWORD" "$DESC - password came back wrong" \
+      '^NX> 102 password: \**$'
+    recvCheck "$DESC - login succeded when it shouldn't" "$LOGIN_ERROR_REPLY"
+    recvCheck "$DESC bye" 'NX> 999 Bye.'
+  mainTestTearDown
+}
+
+testLoginRightUsernameRightPassword()
+{
+  local DESC NXUSERNAME NXPASSWORD
+
+  mainTestSetup
+    sendRecvCheck "login" "Login came back wrong" "${NX_PROMPT}login"
+    DESC="Correct username, correct password"
+    NXUSERNAME="nxtest"
+    NXPASSWORD="haha.yes."
+    sendRecvCheck "$NXUSERNAME" "$DESC - username came back wrong" \
+      "NX> 101 user: $NXUSERNAME"
+    sendRecvCheckRegx "$NXPASSWORD" "$DESC - password came back wrong" \
+      "NX> 102 password: \**"
+    recvCheck "$DESC - missing mysterious blank line" " " #FIXME - dunno where this comes from
+    recvCheck "$DESC - login failed when it shouldn't" \
+      "NX> 103 WELCOME TO: $HOSTNAME USER: $NXUSERNAME"
+
+  mainTestTearDown
+}
+
+testTimeout() {
+  local before after delay
+  READ_X_TIMEOUT=4
+  before=$(date +%s)
+  mainTestSetup
+
+    recvCheck 'Immediate-quit prompt' "$NX_PROMPT"
+    recvCheck 'Immediate-quit bye' 'NX> 999 Bye.'
+    after=$(date +%s)
+    delay=$((after - before))
+    assertTrue 'Immediate-quit timeout' '[ $delay -ge $READ_X_TIMEOUT ]'
+
+  mainTestTearDown
+  unset READ_X_TIMEOUT
+}
+
+. ../utility/shunit2


Property changes on: trunk/freenx-redesign/server/test/testNxserver-login
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/test/testTest-functions
===================================================================
--- trunk/freenx-redesign/server/test/testTest-functions	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/test/testTest-functions	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,157 @@
+#!/bin/sh
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: diamond at google.com (Stephen Shirley)
+
+. "./include/test-functions.inc"
+
+aEquals() { [ "$2" = "$3" ]; }
+aTrue() { return "$2"; }
+
+testReadLineX()
+{
+  input="line1\nline2\nline3\nline4"
+  ret=$(printf "$input" | readLineX 1)
+  assertEquals "Correct line(1) was not returned" "line1" "$ret"
+  ret=$(printf "$input" | readLineX 4)
+  assertEquals "Correct line(4) was not returned" "line4" "$ret"
+}
+
+testToUpper()
+{
+  input="AAbbVVVcccDDD4223'1#24Azz"
+  expected_output="AABBVVVCCCDDD4223'1#24AZZ"
+  assertEquals "toUpper output isn't correct" "$(toupper "$input")" "$expected_output"
+}
+
+testTrim()
+{
+  input=$(printf "hello world\r\n")
+  expected_output="hello world"
+  assertEquals "Trim didn't trim correctly" "$(trim "$input")" "$expected_output"
+}
+
+testReadTrimToupper()
+{
+  EXPECT="helloworld"
+  assertEquals "readTrimToupper fails basic check" \
+  "$(toupper "$EXPECT")" "$(eval "readTrimToupper $EXTERN_STDOUT<< EOT
+$EXPECT
+EOT
+  ")"
+
+  EXPECT="helloworld "
+  assertEquals "readTrimToupper doesn't respect trailing whitespace" \
+  "$(toupper "$EXPECT")" "$(eval "readTrimToupper $EXTERN_STDOUT<< EOT
+$EXPECT
+EOT
+  ")"
+
+  EXPECT="hello world"
+  assertEquals "readTrimToupper doesn't respect inline whitespace" \
+  "$(toupper "$EXPECT")" "$(eval "readTrimToupper $EXTERN_STDOUT<< EOT
+$EXPECT
+EOT
+  ")"
+
+  EXPECT=" hello  world   "
+  assertEquals "readTrimToupper doesn't respect whitespace everywhere" \
+  "$(toupper "$EXPECT")" "$(eval "readTrimToupper $EXTERN_STDOUT<< EOT
+$EXPECT
+EOT
+  ")"
+}
+
+testRecvCheck()
+{
+  EXPECT="helloworld"
+  eval "recvCheck '' \"$EXPECT\" $EXTERN_STDOUT<< EOT
+$EXPECT
+EOT"
+  assertTrue "recvCheck fails to match when it should" $?
+
+  EXPECT="helloworld"
+  eval "recvCheck '' \"$EXPECT\" $EXTERN_STDOUT<< EOT
+$EXPECT bogus
+EOT"
+  assertFalse "recvCheck matches when it shouldn't" $?
+}
+
+testRecvCheckRegx()
+{
+  EXPECT="helloworld"
+  eval "recvCheckRegx '' 'hell.{3}[ra]ld' $EXTERN_STDOUT<< EOT
+$EXPECT
+EOT"
+  assertTrue "recvCheckRegx fails to match when it should" $?
+
+  EXPECT="helloworld"
+  eval "recvCheckRegx '' 'hell.{3}[wa]ld' $EXTERN_STDOUT<< EOT
+$EXPECT
+EOT"
+  assertFalse "recvCheckRegx matches when it shouldn't" $?
+}
+
+testSendRecvCheck()
+{
+  sendRecvSetup
+
+  EXPECT="hello world"
+  sendRecvCheck "$EXPECT" "" "$EXPECT"
+  assertTrue "sendRecvCheck doesn't match when it should" $?
+
+  sendRecvCheck "$EXPECT" "" "$EXPECT bogus"
+  assertFalse "sendRecvCheck matches when it shouldn't" $?
+
+  sendRecvTearDown
+}
+
+testSendRecvCheckRegx()
+{
+  sendRecvSetup
+
+  EXPECT='hell.{3}[ra]ld'
+  sendRecvCheckRegx "helloworld" "" "$EXPECT"
+  assertTrue "sendRecvCheckRegx doesn't match when it should" $?
+
+  EXPECT='hell.{3}[wa]ld'
+  sendRecvCheckRegx "helloworld" "" "$EXPECT"
+  assertFalse "sendRecvCheckRegx matches when it shouldn't" $?
+
+  sendRecvTearDown
+}
+
+sendRecvSetup()
+{
+  EXTERN_TEST=4
+  rm -rf .extern.*
+  mkfifo .extern.test
+  eval "exec $EXTERN_TEST<>.extern.test"
+  EXTERN_WRITE=$EXTERN_TEST
+  EXTERN_READ=$EXTERN_TEST
+}
+
+sendRecvTearDown()
+{
+  eval "exec $EXTERN_TEST<&-"
+  rm -rf .extern.*
+  unset EXTERN_WRITE
+  unset EXTERN_READ
+}
+
+. ../utility/shunit2


Property changes on: trunk/freenx-redesign/server/test/testTest-functions
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/freenx-redesign/server/utility/log4sh
===================================================================
--- trunk/freenx-redesign/server/utility/log4sh	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/utility/log4sh	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,3840 @@
+# $Id: log4sh 574 2007-06-02 20:09:15Z sfsetse $
+# vim:syntax=sh:sts=2
+# vim:foldmethod=marker:foldmarker=/**,*/
+#
+#/**
+# <?xml version="1.0" encoding="UTF-8"?>
+# <s:shelldoc xmlns:s="http://www.forestent.com/2005/XSL/ShellDoc">
+# <s:header>
+# log4sh 1.4.2
+#
+# http://log4sh.sourceforge.net/
+#
+# written by Kate Ward &lt;kate.ward at forestent.com>
+# released under the LGPL
+#
+# this module implements something like the log4j module from the Apache group
+#
+# notes:
+# *) the default appender is a ConsoleAppender named stdout with a level
+#    of ERROR and layout of SimpleLayout
+# *) the appender levels are as follows (decreasing order of output):
+#    TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF
+# </s:header>
+#*/
+
+# shell flags for log4sh:
+# u - treat unset variables as an error when performing parameter expansion
+__LOG4SH_SHELL_FLAGS='u'
+
+# save the current set of shell flags, and then set some for log4sh
+__log4sh_oldShellFlags=$-
+for _log4sh_shellFlag in `echo "${__LOG4SH_SHELL_FLAGS}" |sed 's/\(.\)/\1 /g'`
+do
+  set -${_log4sh_shellFlag}
+done
+
+#
+# constants
+#
+__LOG4SH_VERSION='1.4.2'
+
+__LOG4SH_TRUE=0
+__LOG4SH_FALSE=1
+__LOG4SH_ERROR=2
+__LOG4SH_NULL='~'
+
+__LOG4SH_APPENDER_FUNC_PREFIX='_log4sh_app_'
+__LOG4SH_APPENDER_INCLUDE_EXT='.inc'
+
+__LOG4SH_TYPE_CONSOLE='ConsoleAppender'
+__LOG4SH_TYPE_DAILY_ROLLING_FILE='DailyRollingFileAppender'
+__LOG4SH_TYPE_FILE='FileAppender'
+__LOG4SH_TYPE_ROLLING_FILE='RollingFileAppender'
+__LOG4SH_TYPE_ROLLING_FILE_MAX_BACKUP_INDEX=1
+__LOG4SH_TYPE_ROLLING_FILE_MAX_FILE_SIZE=10485760
+__LOG4SH_TYPE_SMTP='SMTPAppender'
+__LOG4SH_TYPE_SYSLOG='SyslogAppender'
+__LOG4SH_TYPE_SYSLOG_FACILITY_NAMES=' kern user mail daemon auth security syslog lpr news uucp cron authpriv ftp local0 local1 local2 local3 local4 local5 local6 local7 '
+__LOG4SH_TYPE_SYSLOG_FACILITY='user'
+
+__LOG4SH_LAYOUT_HTML='HTMLLayout'
+__LOG4SH_LAYOUT_SIMPLE='SimpleLayout'
+__LOG4SH_LAYOUT_PATTERN='PatternLayout'
+
+__LOG4SH_LEVEL_TRACE=0
+__LOG4SH_LEVEL_TRACE_STR='TRACE'
+__LOG4SH_LEVEL_DEBUG=1
+__LOG4SH_LEVEL_DEBUG_STR='DEBUG'
+__LOG4SH_LEVEL_INFO=2
+__LOG4SH_LEVEL_INFO_STR='INFO'
+__LOG4SH_LEVEL_WARN=3
+__LOG4SH_LEVEL_WARN_STR='WARN'
+__LOG4SH_LEVEL_ERROR=4
+__LOG4SH_LEVEL_ERROR_STR='ERROR'
+__LOG4SH_LEVEL_FATAL=5
+__LOG4SH_LEVEL_FATAL_STR='FATAL'
+__LOG4SH_LEVEL_OFF=6
+__LOG4SH_LEVEL_OFF_STR='OFF'
+__LOG4SH_LEVEL_CLOSED=255
+__LOG4SH_LEVEL_CLOSED_STR='CLOSED'
+
+__LOG4SH_PATTERN_DEFAULT='%d %p - %m%n'
+__LOG4SH_THREAD_DEFAULT='main'
+
+__LOG4SH_CONFIGURATION="${LOG4SH_CONFIGURATION:-log4sh.properties}"
+__LOG4SH_CONFIG_PREFIX="${LOG4SH_CONFIG_PREFIX:-log4sh}"
+__LOG4SH_CONFIG_LOG4J_CP='org.apache.log4j'
+
+# the following IFS is *supposed* to be on two lines!!
+__LOG4SH_IFS_ARRAY="
+"
+__LOG4SH_IFS_DEFAULT=' '
+
+__LOG4SH_SECONDS=`eval "expr \`date '+%H \* 3600 + %M \* 60 + %S'\`"`
+
+# configure log4sh debugging. set the LOG4SH_INFO environment variable to any
+# non-empty value to enable info output, LOG4SH_DEBUG enable debug output, or
+# LOG4SH_TRACE to enable trace output. log4sh ERROR and above messages are
+# always printed. to send the debug output to a file, set the LOG4SH_DEBUG_FILE
+# with the filename you want debug output to be written to.
+__LOG4SH_TRACE=${LOG4SH_TRACE:+'_log4sh_trace '}
+__LOG4SH_TRACE=${__LOG4SH_TRACE:-':'}
+[ -n "${LOG4SH_TRACE:-}" ] && LOG4SH_DEBUG=1
+__LOG4SH_DEBUG=${LOG4SH_DEBUG:+'_log4sh_debug '}
+__LOG4SH_DEBUG=${__LOG4SH_DEBUG:-':'}
+[ -n "${LOG4SH_DEBUG:-}" ] && LOG4SH_INFO=1
+__LOG4SH_INFO=${LOG4SH_INFO:+'_log4sh_info '}
+__LOG4SH_INFO=${__LOG4SH_INFO:-':'}
+
+# set the constants to readonly
+for _log4sh_const in `set |grep "^__LOG4SH_" |cut -d= -f1`; do
+  readonly ${_log4sh_const}
+done
+unset _log4sh_const
+
+#
+# internal variables
+#
+
+__log4sh_filename=`basename $0`
+__log4sh_tmpDir=''
+__log4sh_trapsFile=''
+
+__log4sh_alternative_mail='mail'
+
+__log4sh_threadName=${__LOG4SH_THREAD_DEFAULT}
+__log4sh_threadStack=${__LOG4SH_THREAD_DEFAULT}
+
+__log4sh_seconds=0
+__log4sh_secondsLast=0
+__log4sh_secondsWrap=0
+
+# workarounds for various commands
+__log4sh_wa_strictBehavior=${__LOG4SH_FALSE}
+(
+  # determine if the set builtin needs to be evaluated. if the string is parsed
+  # into two separate strings (common in ksh), then set needs to be evaled.
+  str='x{1,2}'
+  set -- ${str}
+  test ! "$1" = 'x1' -a ! "${2:-}" = 'x2'
+)
+__log4sh_wa_setNeedsEval=$?
+
+
+#=============================================================================
+# Log4sh
+#
+
+#-----------------------------------------------------------------------------
+# internal debugging
+#
+
+#/**
+# <s:function group="Log4sh" modifier="private">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_log4sh_log</function></funcdef>
+#       <paramdef>string <parameter>level</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>
+#     This is an internal debugging function. It should not be called.
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>_log4sh_log</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_log4sh_log()
+{
+  _ll__level=$1
+  shift
+  if [ -z "${LOG4SH_DEBUG_FILE:-}" ]; then
+    echo "log4sh:${_ll__level} $@" >&2
+  else
+    echo "${_ll__level} $@" >>${LOG4SH_DEBUG_FILE}
+  fi
+  unset _ll__level
+}
+
+#/**
+# <s:function group="Log4sh" modifier="private">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_log4sh_trace</function></funcdef>
+#       <paramdef>string <parameter>level</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>
+#     This is an internal debugging function. It should not be called.
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>_log4sh_log</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_log4sh_trace()
+{
+  _log4sh_log "${__LOG4SH_LEVEL_TRACE_STR}" "${BASH_LINENO:+(${BASH_LINENO}) }- $@";
+ }
+
+#/**
+# <s:function group="Log4sh" modifier="private">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_log4sh_debug</function></funcdef>
+#       <paramdef>string <parameter>level</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>
+#     This is an internal debugging function. It should not be called.
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>_log4sh_log</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_log4sh_debug()
+{
+  _log4sh_log "${__LOG4SH_LEVEL_DEBUG_STR}" "${BASH_LINENO:+(${BASH_LINENO}) }- $@";
+}
+
+#/**
+# <s:function group="Log4sh" modifier="private">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_log4sh_info</function></funcdef>
+#       <paramdef>string <parameter>level</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>
+#     This is an internal debugging function. It should not be called.
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>_log4sh_log</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_log4sh_info()
+{
+  _log4sh_log "${__LOG4SH_LEVEL_INFO_STR}" "${BASH_LINENO:+(${BASH_LINENO}) }- $@";
+}
+
+#/**
+# <s:function group="Log4sh" modifier="private">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_log4sh_warn</function></funcdef>
+#       <paramdef>string <parameter>level</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>
+#     This is an internal debugging function. It should not be called.
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>_log4sh_log</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_log4sh_warn()
+{
+  echo "log4sh:${__LOG4SH_LEVEL_WARN_STR} $@" >&2
+  [ -n "${LOG4SH_DEBUG_FILE:-}" ] \
+    && _log4sh_log "${__LOG4SH_LEVEL_WARN_STR}" "$@"
+}
+
+#/**
+# <s:function group="Log4sh" modifier="private">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_log4sh_error</function></funcdef>
+#       <paramdef>string <parameter>level</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>
+#     This is an internal debugging function. It should not be called.
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>_log4sh_log</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_log4sh_error()
+{
+  echo "log4sh:${__LOG4SH_LEVEL_ERROR_STR} $@" >&2
+  [ -n "${LOG4SH_DEBUG_FILE:-}" ] \
+    && _log4sh_log "${__LOG4SH_LEVEL_ERROR_STR}" "$@"
+}
+
+#/**
+# <s:function group="Log4sh" modifier="private">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_log4sh_fatal</function></funcdef>
+#       <paramdef>string <parameter>level</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>
+#     This is an internal debugging function. It should not be called.
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>_log4sh_log</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_log4sh_fatal()
+{
+  echo "log4sh:${__LOG4SH_LEVEL_FATAL_STR} $@" >&2
+  [ -n "${LOG4SH_DEBUG_FILE:-}" ] \
+    && _log4sh_log "${__LOG4SH_LEVEL_FATAL_STR}" "$@"
+}
+
+#-----------------------------------------------------------------------------
+# miscellaneous
+#
+
+#/**
+# <s:function group="Log4sh" modifier="private">
+# <entry align="right">
+#   <code>string</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_log4sh_mktempDir</function></funcdef>
+#       <void />
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>
+#     Creates a secure temporary directory within which temporary files can be
+#     created. Honors the <code>TMPDIR</code> environment variable if it is
+#     set.
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>tmpDir=`_log4sh_mktempDir`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_log4sh_mktempDir()
+{
+  _lmd_tmpPrefix='log4sh'
+
+  # try the standard mktemp function
+  ( exec mktemp -dqt ${_lmd_tmpPrefix}.XXXXXX 2>/dev/null ) && return
+
+  # the standard mktemp didn't work. doing our own.
+  if [ -n "${RANDOM:-}" ]; then
+    # $RANDOM works
+    _lmd_random=${RANDOM}${RANDOM}${RANDOM}$$
+  elif [ -r '/dev/urandom' ]; then
+    _lmd_random=`od -vAn -N4 -tu4 </dev/urandom |sed 's/^[^0-9]*//'`
+  else
+    # $RANDOM doesn't work
+    _lmd_date=`date '+%Y%m%d%H%M%S'`
+    _lmd_random=`expr ${_lmd_date} / $$`
+    unset _lmd_date
+  fi
+
+  _lmd_tmpDir="${TMPDIR:-/tmp}/${_lmd_tmpPrefix}.${_lmd_random}"
+  ( umask 077 && mkdir "${_lmd_tmpDir}" ) || {
+    _log4sh_fatal 'could not create temporary directory! exiting'
+    exit 1
+  }
+
+  ${__LOG4SH_DEBUG} "created temporary directory (${_lmd_tmpDir})"
+  echo "${_lmd_tmpDir}"
+  unset _lmd_random _lmd_tmpDir _lmd_tmpPrefix
+}
+
+#/**
+# <s:function group="Log4sh" modifier="private">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_log4sh_updateSeconds</function></funcdef>
+#       <void />
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>
+#     Set the <code>__log4sh_seconds</code> variable to the number of seconds
+#     elapsed since the start of the script.
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>_log4sh_updateSeconds`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_log4sh_updateSeconds()
+{
+  if [ -n "${SECONDS:-}" ]; then
+    __log4sh_seconds=${SECONDS}
+  else
+    _lgs__date=`date '+%H \* 3600 + %M \* 60 + %S'`
+    _lgs__seconds=`eval "expr ${_lgs__date} + ${__log4sh_secondsWrap} \* 86400"`
+    if [ ${_lgs__seconds} -lt ${__log4sh_secondsLast} ]; then
+      __log4sh_secondsWrap=`expr ${__log4sh_secondsWrap} + 1`
+      _lgs__seconds=`expr ${_lgs_seconds} + 86400`
+    fi
+    __log4sh_seconds=`expr ${_lgs__seconds} - ${__LOG4SH_SECONDS}`
+    __log4sh_secondsLast=${__log4sh_seconds}
+    unset _lgs__date _lgs__seconds
+  fi
+}
+
+#/**
+# <s:function group="Log4sh" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>/boolean
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>log4sh_enableStrictBehavior</function></funcdef>
+#       <void />
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>
+#     Enables strict log4j behavior.
+#   </para>
+#   <para><emphasis role="strong">Since:</emphasis> 1.3.7</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>log4sh_enableStrictBehavior</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+log4sh_enableStrictBehavior()
+{
+  __log4sh_wa_strictBehavior=${__LOG4SH_TRUE}
+}
+
+#/**
+# <s:function group="Log4sh" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>/boolean
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>log4sh_setAlternative</function></funcdef>
+#       <paramdef>string <parameter>command</parameter></paramdef>
+#       <paramdef>string <parameter>path</parameter></paramdef>
+#       <paramdef>boolean <parameter>useRuntimePath</parameter> (optional)</paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>
+#     Specifies an alternative path for a command.
+#   </para>
+#   <para><emphasis role="strong">Since:</emphasis> 1.3.7</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>log4sh_setAlternative nc /bin/nc</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+log4sh_setAlternative()
+{
+  if [ $# -lt 2 ]; then
+    _log4sh_error 'log4sh_setAlternative(): invalid number of parameters'
+    return ${__LOG4SH_FALSE}
+  fi
+
+  lsa_cmdName=$1
+  lsa_cmdPath=$2
+  lsa_useRuntimePath=${3:-}
+  __log4sh_return=${__LOG4SH_TRUE}
+
+  # check that the alternative command exists and is executable
+  if [ \
+    ! -x "${lsa_cmdPath}" \
+    -a ${lsa_useRuntimePath:-${__LOG4SH_FALSE}} -eq ${__LOG4SH_FALSE} \
+  ]; then
+    # the alternative command is not executable
+    _log4sh_error "log4sh_setAlternative(): ${lsa_cmdName}: command not found"
+    __log4sh_return=${__LOG4SH_ERROR}
+  fi
+
+  # check for valid alternative
+  if [ ${__log4sh_return} -eq ${__LOG4SH_TRUE} ]; then
+    case ${lsa_cmdName} in
+      mail) ;;
+      nc)
+        lsa_cmdVers=`${lsa_cmdPath} --version 2>&1 |head -1`
+        if echo "${lsa_cmdVers}" |grep '^netcat' >/dev/null; then
+          # GNU Netcat
+          __log4sh_alternative_nc_opts='-c'
+        else
+          # older netcat (v1.10)
+          if nc -q 0 2>&1 |grep '^no destination$' >/dev/null 2>&1; then
+            # supports -q option
+            __log4sh_alternative_nc_opts='-q 0'
+          else
+            # doesn't support the -q option
+            __log4sh_alternative_nc_opts=''
+          fi
+        fi
+        unset lsa_cmdVers
+        ;;
+      *)
+        # the alternative is not valid
+        _log4sh_error "unrecognized command alternative '${lsa_cmdName}'"
+        __log4sh_return=${__LOG4SH_FALSE}
+        ;;
+    esac
+  fi
+
+  # set the alternative
+  if [ ${__log4sh_return} -eq ${__LOG4SH_TRUE} ]; then
+    eval __log4sh_alternative_${lsa_cmdName}="\${lsa_cmdPath}"
+    ${__LOG4SH_DEBUG} "alternative '${lsa_cmdName}' command set to '${lsa_cmdPath}'"
+  fi
+
+  unset lsa_cmdName lsa_cmdPath
+  return ${__log4sh_return}
+}
+
+#-----------------------------------------------------------------------------
+# array handling
+#
+# note: arrays are '1' based
+#
+
+#/**
+# <s:function group="Log4sh" modifier="private">
+# <entry align="right">
+#   <code>integer</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_log4sh_findArrayElement</function></funcdef>
+#       <paramdef>string[] <parameter>array</parameter></paramdef>
+#       <paramdef>string <parameter>element</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Find the position of element in an array</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>
+#       pos=`_log4sh_findArrayElement "$array" $element`
+#     </funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_log4sh_findArrayElement()
+{
+  __pos=`echo "$1" |awk '$0==e{print NR}' e="$2"`
+  [ -n "${__pos}" ] && echo "${__pos}" || echo 0
+  unset __pos
+}
+
+#/**
+# <s:function group="Log4sh" modifier="private">
+# <entry align="right">
+#   <code>string</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_log4sh_getArrayElement</function></funcdef>
+#       <paramdef>string[] <parameter>array</parameter></paramdef>
+#       <paramdef>integer <parameter>position</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Retrieve the element at the given position from an array</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>element=`_log4sh_getArrayElement "$array" $position`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_log4sh_getArrayElement()
+{
+  [ -n "${FUNCNAME:-}" ] && ${__LOG4SH_TRACE} "${FUNCNAME}()${BASH_LINENO:+'(called from ${BASH_LINENO})'}"
+  _lgae_array=$1
+  _lgae_index=$2
+  ${__LOG4SH_TRACE} "_lgae_array='${_lgae_array}' _lgae_index='${_lgae_index}'"
+
+  _lgae_oldIFS=${IFS} IFS=${__LOG4SH_IFS_ARRAY}
+  if [ ${__log4sh_wa_setNeedsEval} -eq 0 ]; then
+    set -- junk ${_lgae_array}
+  else
+    eval "set -- junk \"${_lgae_array}\""
+    _lgae_arraySize=$#
+
+    if [ ${_lgae_arraySize} -le ${__log4shAppenderCount} ]; then
+      # the evaled set *didn't* work; failing back to original set command and
+      # disabling the work around. (pdksh)
+      __log4sh_wa_setNeedsEval=${__LOG4SH_FALSE}
+      set -- junk ${_lgae_array}
+    fi
+  fi
+  IFS=${_lgae_oldIFS}
+
+  shift ${_lgae_index}
+  ${__LOG4SH_TRACE} "1='${1:-}' 2='${2:-}' 3='${3:-}' ..."
+  echo "$1"
+
+  unset _lgae_array _lgae_arraySize _lgae_index _lgae_oldIFS
+  return ${__LOG4SH_TRUE}
+}
+
+#/**
+# <s:function group="Log4sh" modifier="private">
+# <entry align="right">
+#   <code>integer</code>
+# </entry>
+# <entry align="left">
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_log4sh_getArrayLength</function></funcdef>
+#       <paramdef>string[] <parameter>array</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Get the length of an array</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>length=`_log4sh_getArrayLength "$array"`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_log4sh_getArrayLength()
+{
+  _oldIFS=${IFS} IFS=${__LOG4SH_IFS_ARRAY}
+  set -- $1
+  IFS=${_oldIFS} unset _oldIFS
+  echo $#
+}
+
+#/**
+# <s:function group="Log4sh" modifier="private">
+# <entry align="right">
+#   <code>string[]</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_log4sh_setArrayElement</function></funcdef>
+#       <paramdef>string[] <parameter>array</parameter></paramdef>
+#       <paramdef>integer <parameter>position</parameter></paramdef>
+#       <paramdef>string <parameter>element</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Place an element at a given location in an array</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>newArray=`_log4sh_setArrayElement "$array" $position $element`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_log4sh_setArrayElement()
+{
+  echo "$1" |awk '{if(NR==r){print e}else{print $0}}' r=$2 e="$3"
+}
+
+#/**
+# <s:function group="Log4sh" modifier="private">
+# <entry align="right">
+#   <code>string</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_log4sh_peekStack</function></funcdef>
+#       <paramdef>string[] <parameter>array</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Return the topmost element on a stack without removing the
+#   element.</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>element=`_log4sh_peekStack "$array"`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_log4sh_peekStack()
+{
+  echo "$@" |awk '{line=$0}END{print line}'
+}
+
+#/**
+# <s:function group="Log4sh" modifier="private">
+# <entry align="right">
+#   <code>string[]</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_log4sh_popStack</function></funcdef>
+#       <paramdef>string[] <parameter>array</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Remove the top-most element from a stack. This command takes a
+#   normal log4sh string array as input, but treats it as though it were a
+#   stack.</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>newArray=`_log4sh_popStack "$array"`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_log4sh_popStack()
+{
+  _array=$1
+  _length=`_log4sh_getArrayLength "${_array}"`
+  echo "${_array}" |awk '{if(NR<r){print $0}}' r=${_length}
+  unset _array _length
+}
+
+#/**
+# <s:function group="Log4sh" modifier="private">
+# <entry align="right">
+#   <code>string</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_log4sh_pushStack</function></funcdef>
+#       <paramdef>string[] <parameter>array</parameter></paramdef>
+#       <paramdef>string <parameter>element</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Add a new element to the top of a stack. This command takes a normal
+#   log4sh string array as input, but treats it as though it were a
+#   stack.</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>newArray=`_log4sh_pushStack "$array" $element`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_log4sh_pushStack()
+{
+  echo "${1:+$1${__LOG4SH_IFS_ARRAY}}$2"
+}
+
+#=============================================================================
+# Appender
+#
+
+#/**
+# <s:function group="Appender" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_activateOptions</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>
+#     Activate an appender's configuration. This should be called after
+#     reconfiguring an appender via code. It needs only to be called once
+#     before any logging statements are called. This calling of this function
+#     will be required in log4sh 1.4.x.
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>appender_activateAppender myAppender</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_activateOptions()
+{
+  _aao_appender=$1
+  ${__LOG4SH_APPENDER_FUNC_PREFIX}${_aao_appender}_activateOptions
+  unset _aao_appender
+}
+
+#/**
+# <s:function group="Appender" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_close</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Disable any further logging via an appender. Once closed, the
+#   appender can be reopened by setting it to any logging Level (e.g.
+#   INFO).</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>appender_close myAppender</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_close()
+{
+  appender_setLevel $1 ${__LOG4SH_LEVEL_CLOSED_STR}
+}
+
+#/**
+# <s:function group="Appender" modifier="public">
+# <entry align="right">
+#   <code>boolean</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_exists</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Checks for the existance of a named appender</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>exists=`appender_exists myAppender`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_exists()
+{
+  _ae_index=`_log4sh_findArrayElement "${__log4shAppenders}" $1`
+  [ "${_ae_index}" -gt 0 ] \
+    && _ae_return=${__LOG4SH_TRUE} \
+    || _ae_return=${__LOG4SH_FALSE}
+  unset _ae_index
+  return ${_ae_return}
+}
+
+#/**
+# <s:function group="Appender" modifier="public">
+# <entry align="right">
+#   <code>string</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_getLayout</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Gets the Layout of an Appender</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>type=`appender_getLayout myAppender`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_getLayout()
+{
+  _agl_index=`_log4sh_findArrayElement "${__log4shAppenders}" $1`
+  _log4sh_getArrayElement "${__log4shAppenderLayouts}" ${_agl_index}
+  unset _agl_index
+}
+
+#/**
+# <s:function group="Appender" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_setLayout</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#       <paramdef>string <parameter>layout</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Sets the Layout of an Appender (e.g. PatternLayout)</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>appender_setLayout myAppender PatternLayout</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_setLayout()
+{
+  _asl_appender=$1
+  _asl_layout=$2
+
+  case ${_asl_layout} in
+    ${__LOG4SH_LAYOUT_HTML}|\
+    ${__LOG4SH_CONFIG_LOG4J_CP}.${__LOG4SH_LAYOUT_HTML})
+      _asl_layout=${__LOG4SH_LAYOUT_HTML}
+      ;;
+
+    ${__LOG4SH_LAYOUT_SIMPLE}|\
+    ${__LOG4SH_CONFIG_LOG4J_CP}.${__LOG4SH_LAYOUT_SIMPLE})
+      _asl_layout=${__LOG4SH_LAYOUT_SIMPLE}
+      ;;
+
+    ${__LOG4SH_LAYOUT_PATTERN}|\
+    ${__LOG4SH_CONFIG_LOG4J_CP}.${__LOG4SH_LAYOUT_PATTERN})
+      _asl_layout=${__LOG4SH_LAYOUT_PATTERN}
+      ;;
+
+    *)
+      _log4sh_error "unknown layout: ${_asl_layout}"
+      return ${__LOG4SH_FALSE}
+      ;;
+  esac
+
+  _asl_index=`_log4sh_findArrayElement "${__log4shAppenders}" $1`
+  __log4shAppenderLayouts=`_log4sh_setArrayElement \
+      "${__log4shAppenderLayouts}" ${_asl_index} "${_asl_layout}"`
+
+  # resource the appender
+  _appender_cache ${_asl_appender}
+
+  unset _asl_appender _asl_index _asl_layout
+  return ${__LOG4SH_TRUE}
+}
+
+#/**
+# <s:function group="Appender" modifier="private">
+# <entry align="right">
+#   <code>string</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_appender_getLayoutByIndex</function></funcdef>
+#       <paramdef>integer <parameter>index</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Gets the Layout of an Appender at the given array index</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>type=`_appender_getLayoutByIndex 3`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_appender_getLayoutByIndex()
+{
+  _log4sh_getArrayElement "${__log4shAppenderLayouts}" $1
+}
+
+#/**
+# <s:function group="Appender" modifier="public">
+# <entry align="right">
+#   <code>string</code>/boolean
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_getLevel</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Gets the current logging Level of an Appender</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>type=`appender_getLevel myAppender`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_getLevel()
+{
+  if [ $# -ne 1 ]; then
+    _log4sh_error 'appender_getLevel(): invalid number of parameters'
+    return ${__LOG4SH_FALSE}
+  fi
+
+  agl_appender=$1
+
+  agl_index=`_log4sh_findArrayElement "${__log4shAppenders}" ${agl_appender}`
+  # TODO: put check for valid index here
+  agl_level=`_log4sh_getArrayElement \
+      "${__log4shAppenderLevels}" ${agl_index}`
+  __log4sh_return=$?
+
+  echo "${agl_level}"
+
+  unset agl_appender agl_index agl_level
+  return ${__log4sh_return}
+}
+
+#/**
+# <s:function group="Appender" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>/<code>boolean</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_setLevel</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#       <paramdef>string <parameter>level</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Sets the Level of an Appender (e.g. INFO)</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>appender_setLevel myAppender INFO</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_setLevel()
+{
+  asl_appender=$1
+  asl_level=$2
+
+  _index=`_log4sh_findArrayElement "${__log4shAppenders}" ${asl_appender}`
+  __log4shAppenderLevels=`_log4sh_setArrayElement \
+    "${__log4shAppenderLevels}" ${_index} "${asl_level}"`
+
+  # resource the appender
+  _appender_cache ${asl_appender}
+
+  unset asl_appender asl_level _index
+  return ${__LOG4SH_TRUE}
+}
+
+#/**
+# <s:function group="Appender" modifier="private">
+# <entry align="right">
+#   <code>string</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_appender_getLevelByIndex</function></funcdef>
+#       <paramdef>integer <parameter>index</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Gets the current logging Level of an Appender at the given array
+#   index</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>type=`_appender_getLevelByIndex 3`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_appender_getLevelByIndex()
+{
+  [ -n "${FUNCNAME:-}" ] && ${__LOG4SH_TRACE} "${FUNCNAME}()${BASH_LINENO:+'(called from ${BASH_LINENO})'}"
+  _log4sh_getArrayElement "${__log4shAppenderLevels}" $1
+}
+
+#/**
+# <s:function group="Appender" modifier="public">
+# <entry align="right">
+#   <code>string</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_getPattern</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Gets the Pattern of an Appender</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>pattern=`appender_getPattern myAppender`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_getPattern()
+{
+  _index=`_log4sh_findArrayElement "$__log4shAppenders" $1`
+  _log4sh_getArrayElement "$__log4shAppenderPatterns" $_index
+  unset _index
+}
+
+#/**
+# <s:function group="Appender" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>/<code>boolean</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_setPattern</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#       <paramdef>string <parameter>pattern</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Sets the Pattern of an Appender</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>appender_setPattern myAppender '%d %p - %m%n'</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_setPattern()
+{
+  asp_appender=$1
+  asp_pattern=$2
+
+  _index=`_log4sh_findArrayElement "${__log4shAppenders}" ${asp_appender}`
+  __log4shAppenderPatterns=`_log4sh_setArrayElement \
+    "${__log4shAppenderPatterns}" ${_index} "${asp_pattern}"`
+
+  # resource the appender
+  _appender_cache ${asp_appender}
+
+  unset asp_appender asp_pattern _index
+  return ${__LOG4SH_TRUE}
+}
+
+#/**
+# <s:function group="Appender" modifier="private">
+# <entry align="right">
+#   <code>string</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_appender_getPatternByIndex</function></funcdef>
+#       <paramdef>integer <parameter>index</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Gets the Pattern of an Appender at the specified array index</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>pattern=`_appender_getPatternByIndex 3`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_appender_getPatternByIndex()
+{
+  _log4sh_getArrayElement "$__log4shAppenderPatterns" $1
+}
+
+#/**
+# <s:function group="Appender" modifier="private">
+# <entry align="right">
+#   <code>string</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_appender_parsePattern</function></funcdef>
+#       <paramdef>string <parameter>pattern</parameter></paramdef>
+#       <paramdef>string <parameter>priority</parameter></paramdef>
+#       <paramdef>string <parameter>message</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Generate a logging message given a Pattern, priority, and message.
+#   All dates will be represented as ISO 8601 dates (YYYY-MM-DD
+#   HH:MM:SS).</para>
+#   <para>Note: the '<code>%r</code>' character modifier does not work in the
+#   Solaris <code>/bin/sh</code> shell</para>
+#   <para>Example:
+#     <blockquote>
+#       <funcsynopsis>
+#         <funcsynopsisinfo>_appender_parsePattern '%d %p - %m%n' INFO "message to log"</funcsynopsisinfo>
+#       </funcsynopsis>
+#     </blockquote>
+#   </para>
+# </entry>
+# </s:function>
+#*/
+_appender_parsePattern()
+{
+  _pattern=$1
+  _priority=$2
+  _msg=$3
+
+  _date=''
+  _doEval=${__LOG4SH_FALSE}
+
+  # determine if various commands must be run
+  _oldIFS="${IFS}"; IFS='%'; set -- x${_pattern}; IFS="${_oldIFS}"
+  if [ $# -gt 1 ]; then
+    # run the date command??
+    IFS='d'; set -- ${_pattern}x; IFS="${_oldIFS}"
+    [ $# -gt 1 ] && _date=`date '+%Y-%m-%d %H:%M:%S'`
+
+    # run the eval command?
+    IFS='X'; set -- ${_pattern}x; IFS="${_oldIFS}"
+    [ $# -gt 1 ] && _doEval=${__LOG4SH_TRUE}
+  fi
+  unset _oldIFS
+
+  # escape any '\' and '&' chars in the message
+  _msg=`echo "${_msg}" |sed 's/\\\\/\\\\\\\\/g;s/&/\\\\&/g'`
+
+  # deal with any newlines in the message
+  _msg=`echo "${_msg}" |tr '\n' ''`
+
+  # parse the pattern
+  _pattern=`echo "${_pattern}" |sed \
+    -e 's/%c/shell/g' \
+    -e 's/%d{[^}]*}/%d/g' -e "s/%d/${_date}/g" \
+    -e "s/%F/${__log4sh_filename}/g" \
+    -e 's/%L//g' \
+    -e 's/%n//g' \
+    -e "s/%-*[0-9]*p/${_priority}/g" \
+    -e "s/%-*[0-9]*r/${__log4sh_seconds}/g" \
+    -e "s/%t/${__log4sh_threadName}/g" \
+    -e 's/%x//g' \
+    -e 's/%X{/$\{/g' \
+    -e 's/%%m/%%%m/g' -e 's/%%/%/g' \
+    -e "s%m${_msg}" |tr '' '\n'`
+  if [ ${_doEval} -eq ${__LOG4SH_FALSE} ]; then
+    echo "${_pattern}"
+  else
+    eval "echo \"${_pattern}\""
+  fi
+
+  unset _date _doEval _msg _pattern _tag
+}
+
+#/**
+# <s:function group="Appender" modifier="public">
+# <entry align="right">
+#   <code>string</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_getType</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Gets the Type of an Appender</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>type=`appender_getType myAppender`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_getType()
+{
+  _index=`_log4sh_findArrayElement "$__log4shAppenders" $1`
+  _log4sh_getArrayElement "$__log4shAppenderTypes" $_index
+  unset _index
+}
+
+#/**
+# <s:function group="Appender" modifier="public">
+# <entry align="right">
+#   <code>string</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_getAppenderType</function></funcdef>
+#       <paramdef>integer <parameter>index</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para><emphasis role="strong">Deprecated as of 1.3.1</emphasis></para>
+#   <para>
+#     Gets the Type of an Appender at the given array index
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>type=`appender_getAppenderType 3`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_getAppenderType()
+{
+  _appender_getTypeByIndex "$@"
+}
+
+#/**
+# <s:function group="Appender" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>/<code>boolean</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_setType</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#       <paramdef>string <parameter>type</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Sets the Type of an Appender (e.g. FileAppender)</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>appender_setType myAppender FileAppender</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_setType()
+{
+  ast_appender=$1
+  ast_type=$2
+
+  # XXX need to verify types
+
+  _index=`_log4sh_findArrayElement "${__log4shAppenders}" ${ast_appender}`
+  __log4shAppenderTypes=`_log4sh_setArrayElement \
+    "${__log4shAppenderTypes}" ${_index} "${ast_type}"`
+
+  # resource the appender
+  _appender_cache ${ast_appender}
+
+  unset ast_appender ast_type _index
+  return ${__LOG4SH_TRUE}
+}
+
+#/**
+# <s:function group="Appender" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_setAppenderType</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#       <paramdef>string <parameter>type</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para><emphasis role="strong">Deprecated as of 1.3.1</emphasis></para>
+#   <para>
+#     Sets the Type of an Appender (e.g. FileAppender)
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>appender_setAppenderType myAppender FileAppender</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_setAppenderType()
+{
+  appender_setType "$@"
+}
+
+#/**
+# <s:function group="Appender" modifier="private">
+# <entry align="right">
+#   <code>string</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_appender_getTypeByIndex</function></funcdef>
+#       <paramdef>integer <parameter>index</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Gets the Type of an Appender at the given array index</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>type=`_appender_getTypeByIndex 3`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_appender_getTypeByIndex()
+{
+  _log4sh_getArrayElement "$__log4shAppenderTypes" $1
+}
+
+#/**
+# <s:function group="Appender" modifier="private">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_appender_cache</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Dynamically creates an appender function in memory that will fully
+#   instantiate itself when it is called.</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>_appender_cache myAppender</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_appender_cache()
+{
+  _ac__appender=$1
+
+  _ac__inc="${__log4sh_tmpDir}/${_ac__appender}${__LOG4SH_APPENDER_INCLUDE_EXT}"
+
+  cat >"${_ac__inc}" <<EOF
+${__LOG4SH_APPENDER_FUNC_PREFIX}${_ac__appender}_activateOptions()
+{
+  [ -n "\${FUNCNAME:-}" ] && \${__LOG4SH_TRACE} "\${FUNCNAME}()\${BASH_LINENO:+'(called from \${BASH_LINENO})'}"
+  _appender_activate ${_ac__appender}
+}
+
+${__LOG4SH_APPENDER_FUNC_PREFIX}${_ac__appender}_append() { :; }
+EOF
+
+  # source the new functions
+  . "${_ac__inc}"
+
+  # call the activateOptions function
+  # XXX will be removed in log4sh-1.5.x
+  appender_activateOptions ${_ac__appender}
+}
+
+#/**
+# <s:function group="Appender" modifier="private">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_appender_activate</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>
+#     Dynamically regenerates an appender function in memory that is fully
+#     instantiated for a specific logging task.
+#     </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>_appender_activate myAppender</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_appender_activate()
+{
+  [ -n "${FUNCNAME:-}" ] && ${__LOG4SH_TRACE} "${FUNCNAME}()${BASH_LINENO:+'(called from ${BASH_LINENO})'}"
+  ${__LOG4SH_TRACE} "_appender_activate($#)"
+  _aa_appender=$1
+  ${__LOG4SH_TRACE} "_aa_appender='${_aa_appender}'"
+
+  _aa_index=`_log4sh_findArrayElement "${__log4shAppenders}" ${_aa_appender}`
+  _aa_inc="${__log4sh_tmpDir}/${_aa_appender}${__LOG4SH_APPENDER_INCLUDE_EXT}"
+
+  ### generate function for inclusion
+  # TODO can we modularize this in the future?
+
+  # send STDOUT to our include file
+  exec 4>&1 >${_aa_inc}
+
+  # header
+  cat <<EOF
+${__LOG4SH_APPENDER_FUNC_PREFIX}${_aa_appender}_append()
+{
+  [ -n "\${FUNCNAME:-}" ] && \${__LOG4SH_TRACE} "\${FUNCNAME}()\${BASH_LINENO:+'(called from \${BASH_LINENO})'}"
+  _la_level=\$1
+  _la_message=\$2
+EOF
+
+  # determine the 'layout'
+  _aa_layout=`_appender_getLayoutByIndex ${_aa_index}`
+  ${__LOG4SH_TRACE} "_aa_layout='${_aa_layout}'"
+  case ${_aa_layout} in
+    ${__LOG4SH_LAYOUT_SIMPLE}|\
+    ${__LOG4SH_LAYOUT_HTML})
+      ${__LOG4SH_DEBUG} 'using simple/html layout'
+      echo "  _la_layout=\"\${_la_level} - \${_la_message}\""
+      ;;
+
+    ${__LOG4SH_LAYOUT_PATTERN})
+      ${__LOG4SH_DEBUG} 'using pattern layout'
+      _aa_pattern=`_appender_getPatternByIndex ${_aa_index}`
+      echo "  _la_layout=\`_appender_parsePattern '${_aa_pattern}' \${_la_level} \"\${_la_message}\"\`"
+      ;;
+  esac
+
+  # what appender 'type' do we have? TODO check not missing
+  _aa_type=`_appender_getTypeByIndex ${_aa_index}`
+  ${__LOG4SH_TRACE} "_aa_type='${_aa_type}'"
+  case ${_aa_type} in
+    ${__LOG4SH_TYPE_CONSOLE})
+      echo "  echo \"\${_la_layout}\""
+      ;;
+
+    ${__LOG4SH_TYPE_FILE}|\
+    ${__LOG4SH_TYPE_ROLLING_FILE}|\
+    ${__LOG4SH_TYPE_DAILY_ROLLING_FILE})
+      _aa_file=`_appender_file_getFileByIndex ${_aa_index}`
+      ${__LOG4SH_TRACE} "_aa_file='${_aa_file}'"
+      if [ "${_aa_file}" = 'STDERR' ]; then
+        echo "  echo \"\${_la_layout}\" >&2"
+      elif [ "${_aa_file}" != "${__LOG4SH_NULL}" ]; then
+        # do rotation
+        case ${_aa_type} in
+          ${__LOG4SH_TYPE_ROLLING_FILE})
+            # check whether the max file size has been exceeded
+            _aa_rotIndex=`appender_file_getMaxBackupIndex ${_aa_appender}`
+            _aa_rotSize=`appender_file_getMaxFileSize ${_aa_appender}`
+            cat <<EOF
+  _la_rotSize=${_aa_rotSize}
+  _la_size=\`wc -c '${_aa_file}' |awk '{print \$1}'\`
+  if [ \${_la_size} -ge \${_la_rotSize} ]; then
+    if [ ${_aa_rotIndex} -gt 0 ]; then
+      # rotate the appender file(s)
+      _la_rotIndex=`expr ${_aa_rotIndex} - 1`
+      _la_rotFile="${_aa_file}.\${_la_rotIndex}"
+      [ -f "\${_la_rotFile}" ] && rm -f "\${_la_rotFile}"
+      while [ \${_la_rotIndex} -gt 0 ]; do
+        _la_rotFileLast="\${_la_rotFile}"
+        _la_rotIndex=\`expr \${_la_rotIndex} - 1\`
+        _la_rotFile="${_aa_file}.\${_la_rotIndex}"
+        [ -f "\${_la_rotFile}" ] && mv -f "\${_la_rotFile}" "\${_la_rotFileLast}"
+      done
+      mv -f '${_aa_file}' "\${_la_rotFile}"
+    else
+      # keep no backups; truncate the file
+      cp /dev/null "${_aa_file}"
+    fi
+    unset _la_rotFile _la_rotFileLast _la_rotIndex
+  fi
+  unset _la_rotSize _la_size
+EOF
+            ;;
+          ${__LOG4SH_TYPE_DAILY_ROLLING_FILE})
+            ;;
+        esac
+        echo "  echo \"\${_la_layout}\" >>'${_aa_file}'"
+      else
+        # the file "${__LOG4SH_NULL}" is closed?? Why did we get here, and why
+        # did I care when I wrote this bit of code?
+        :
+      fi
+
+      unset _aa_file
+      ;;
+
+    ${__LOG4SH_TYPE_SMTP})
+      _aa_smtpTo=`appender_smtp_getTo ${_aa_appender}`
+      _aa_smtpSubject=`appender_smtp_getSubject ${_aa_appender}`
+
+      cat <<EOF
+  echo "\${_la_layout}" |\\
+      ${__log4sh_alternative_mail} -s "${_aa_smtpSubject}" ${_aa_smtpTo}
+EOF
+      ;;
+
+    ${__LOG4SH_TYPE_SYSLOG})
+      cat <<EOF
+  case "\${_la_level}" in
+    ${__LOG4SH_LEVEL_TRACE_STR}) _la_tag='debug' ;;  # no 'trace' equivalent
+    ${__LOG4SH_LEVEL_DEBUG_STR}) _la_tag='debug' ;;
+    ${__LOG4SH_LEVEL_INFO_STR}) _la_tag='info' ;;
+    ${__LOG4SH_LEVEL_WARN_STR}) _la_tag='warning' ;;  # 'warn' is deprecated
+    ${__LOG4SH_LEVEL_ERROR_STR}) _la_tag='err' ;;     # 'error' is deprecated
+    ${__LOG4SH_LEVEL_FATAL_STR}) _la_tag='alert' ;;
+  esac
+EOF
+
+      _aa_facilityName=`appender_syslog_getFacility ${_aa_appender}`
+      _aa_syslogHost=`appender_syslog_getHost ${_aa_appender}`
+      _aa_hostname=`hostname |sed 's/^\([^.]*\)\..*/\1/'`
+
+      # are we logging to a remote host?
+      if [ -z "${_aa_syslogHost}" ]; then
+        # no -- use logger
+        cat <<EOF
+  ( exec logger -p "${_aa_facilityName}.\${_la_tag}" \
+      -t "${__log4sh_filename}[$$]" "\${_la_layout}" 2>/dev/null )
+  unset _la_tag
+EOF
+      else
+        # yes -- use netcat
+        if [ -n "${__log4sh_alternative_nc:-}" ]; then
+          case ${_aa_facilityName} in
+            kern) _aa_facilityCode=0 ;;            # 0<<3
+            user) _aa_facilityCode=8 ;;            # 1<<3
+            mail) _aa_facilityCode=16 ;;           # 2<<3
+            daemon) _aa_facilityCode=24 ;;         # 3<<3
+            auth|security) _aa_facilityCode=32 ;;  # 4<<3
+            syslog) _aa_facilityCode=40 ;;         # 5<<3
+            lpr) _aa_facilityCode=48 ;;            # 6<<3
+            news) _aa_facilityCode=56 ;;           # 7<<3
+            uucp) _aa_facilityCode=64 ;;           # 8<<3
+            cron) _aa_facilityCode=72 ;;           # 9<<3
+            authpriv) _aa_facilityCode=80 ;;       # 10<<3
+            ftp) _aa_facilityCode=88 ;;            # 11<<3
+            local0) _aa_facilityCode=128 ;;        # 16<<3
+            local1) _aa_facilityCode=136 ;;        # 17<<3
+            local2) _aa_facilityCode=144 ;;        # 18<<3
+            local3) _aa_facilityCode=152 ;;        # 19<<3
+            local4) _aa_facilityCode=160 ;;        # 20<<3
+            local5) _aa_facilityCode=168 ;;        # 21<<3
+            local6) _aa_facilityCode=176 ;;        # 22<<3
+            local7) _aa_facilityCode=184 ;;        # 23<<3
+          esac
+
+          cat <<EOF
+  case \${_la_tag} in
+    alert) _la_priority=1 ;;
+    err|error) _la_priority=3 ;;
+    warning|warn) _la_priority=4 ;;
+    info) _la_priority=6 ;;
+    debug) _la_priority=7 ;;
+  esac
+  _la_priority=\`expr ${_aa_facilityCode} + \${_la_priority}\`
+  _la_date=\`date "+%b %d %H:%M:%S"\`
+  _la_hostname='${_aa_hostname}'
+
+  _la_syslogMsg="<\${_la_priority}>\${_la_date} \${_la_hostname} \${_la_layout}"
+
+  # do RFC 3164 cleanups
+  _la_date=\`echo \"\${_la_date}\" |sed 's/ 0\([0-9]\) /  \1 /'\`
+  _la_syslogMsg=\`echo "\${_la_syslogMsg}" |cut -b1-1024\`
+
+  ( echo "\${_la_syslogMsg}" |\
+      exec ${__log4sh_alternative_nc} ${__log4sh_alternative_nc_opts} -w 1 -u \
+          ${_aa_syslogHost} 514 )
+  unset _la_tag _la_priority _la_date _la_hostname _la_syslogMsg
+EOF
+          unset _aa_facilityCode _aa_syslogHost _aa_hostname
+        else
+          # no netcat alternative set; doing nothing
+          :
+        fi
+      fi
+      unset _aa_facilityName
+      ;;
+
+    *) _log4sh_error "unrecognized appender type (${_aa_type})" ;;
+  esac
+
+  # footer
+  cat <<EOF
+  unset _la_level _la_message _la_layout
+}
+EOF
+
+  # override the activateOptions function as we don't need it anymore
+  cat <<EOF
+${__LOG4SH_APPENDER_FUNC_PREFIX}${_aa_appender}_activateOptions() { :; }
+EOF
+
+  # restore STDOUT
+  exec 1>&4 4>&-
+
+  # source the newly created function
+  ${__LOG4SH_TRACE} 're-sourcing the newly created function'
+  . "${_aa_inc}"
+
+  unset _aa_appender _aa_inc _aa_layout _aa_pattern _aa_type
+}
+
+#-----------------------------------------------------------------------------
+# FileAppender
+#
+
+#/**
+# <s:function group="FileAppender" modifier="private">
+# <entry align="right">
+#   <code>string</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_appender_file_getFileByIndex</function></funcdef>
+#       <paramdef>integer <parameter>index</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Get the filename of a FileAppender at the given array index</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>_appender_file_getFileByIndex 3</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_appender_file_getFileByIndex()
+{
+  _log4sh_getArrayElement "${__log4shAppender_file_files}" $1
+}
+
+#/**
+# <s:function group="FileAppender" modifier="public">
+# <entry align="right">
+#   <code>string</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_file_getFile</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Get the filename of a FileAppender</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>appender_file_getFile myAppender</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_file_getFile()
+{
+  _index=`_log4sh_findArrayElement "$__log4shAppenders" $1`
+  _log4sh_getArrayElement "$__log4shAppender_file_files" $_index
+  unset _index
+}
+
+#/**
+# <s:function group="FileAppender" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_file_setFile</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#       <paramdef>string <parameter>filename</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>
+#     Set the filename for a FileAppender (e.g. <filename>STDERR</filename> or
+#     <filename>/var/log/log4sh.log</filename>).
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>appender_file_setFile myAppender STDERR</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_file_setFile()
+{
+  afsf_appender=$1
+  afsf_file=$2
+  ${__LOG4SH_TRACE} "afsf_appender='${afsf_appender}' afsf_file='${afsf_file}'"
+
+  if [ -n "${afsf_appender}" -a -n "${afsf_file}" ]; then
+    # set the file
+    _index=`_log4sh_findArrayElement "${__log4shAppenders}" ${afsf_appender}`
+    __log4shAppender_file_files=`_log4sh_setArrayElement \
+      "${__log4shAppender_file_files}" ${_index} "${afsf_file}"`
+    _return=$?
+
+    # create the file (if it isn't already)
+    if [ ${_return} -eq ${__LOG4SH_TRUE} \
+      -a ! "${afsf_file}" '=' "${__LOG4SH_NULL}" \
+      -a ! "${afsf_file}" '=' 'STDERR' \
+      -a ! -f "${afsf_file}" \
+    ]; then
+      touch "${afsf_file}" 2>/dev/null
+      _result=$?
+      # determine success of touch command
+      if [ ${_result} -eq 1 ]; then
+        _log4sh_error "appender_file_setFile(): could not create file (${afsf_file}); closing appender"
+        appender_setLevel ${afsf_appender} ${__LOG4SH_LEVEL_CLOSED_STR}
+      fi
+      unset _result
+    fi
+  else
+    _log4sh_error 'appender_file_setFile(): missing appender and/or file'
+    _return=${__LOG4SH_FALSE}
+  fi
+
+  # resource the appender
+  _appender_cache ${afsf_appender}
+
+  unset afsf_appender afsf_file _index
+  return ${_return}
+}
+
+#/**
+# <s:function group="FileAppender" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_setAppenderFile</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#       <paramdef>string <parameter>filename</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para><emphasis role="strong">Deprecated as of 1.3.2</emphasis></para>
+#   <para>
+#     Set the filename for a FileAppender (e.g. "STDERR" or
+#     "/var/log/log4sh.log")
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>appender_setAppenderFile myAppender STDERR</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_setAppenderFile()
+{
+  appender_file_setFile "$@"
+}
+
+#/**
+# <s:function group="FileAppender" modifier="public">
+# <entry align="right">
+#   <code>integer</code>/boolean
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_file_getMaxBackupIndex</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>
+#     Returns the value of the MaxBackupIndex option.
+#   </para>
+#   <para><emphasis role="strong">Since:</emphasis> 1.3.7</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>appender_file_getMaxBackupIndex myAppender</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_file_getMaxBackupIndex()
+{
+  if [ $# -ne 1 ]; then
+    _log4sh_error 'appender_file_getMaxBackupIndex(): invalid number of parameters'
+    return ${__LOG4SH_FALSE}
+  fi
+
+  afgmbi_appender=$1
+
+  afgmbi_index=`_log4sh_findArrayElement \
+      "${__log4shAppenders}" ${afgmbi_appender}`
+  # TODO: put check for valid index here
+  _log4sh_getArrayElement \
+      "${__log4shAppender_rollingFile_maxBackupIndexes}" ${afgmbi_index}
+  __log4sh_return=$?
+
+  unset afgmbi_appender afgmbi_index
+  return ${__log4sh_return}
+}
+
+#/**
+# <s:function group="FileAppender" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_file_setMaxBackupIndex</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#       <paramdef>integer <parameter>index</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Set the maximum number of backup files to keep around.</para>
+#   <para>
+#     The <emphasis role="strong">MaxBackupIndex</emphasis> option determines
+#     how many backup files are kept before the oldest is erased. This option
+#     takes a positive integer value. If set to zero, then there will be no
+#     backup files and the log file will be truncated when it reaches
+#     <option>MaxFileSize</option>.
+#   </para>
+#   <para><emphasis role="strong">Since:</emphasis> 1.3.7</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>appender_file_setMaxBackupIndex myAppender 3</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_file_setMaxBackupIndex()
+{
+  if [ $# -ne 2 ]; then
+    _log4sh_error "appender_file_setMaxBackupIndex(): invalid number of parameters ($#)"
+    return ${__LOG4SH_FALSE}
+  fi
+
+  afsmbi_appender=$1
+  afsmbi_maxIndex=$2
+
+  # TODO: put check for valid input
+
+  afsmbi_index=`_log4sh_findArrayElement \
+      "${__log4shAppenders}" ${afsmbi_appender}`
+  # TODO: put check for valid index here
+  __log4shAppender_rollingFile_maxBackupIndexes=`_log4sh_setArrayElement \
+      "${__log4shAppender_rollingFile_maxBackupIndexes}" ${afsmbi_index} \
+      "${afsmbi_maxIndex}"`
+  __log4sh_return=$?
+
+  # re-source the appender
+  _appender_cache ${afsmbi_appender}
+
+  unset afsmbi_appender afsmbi_maxIndex afsmbi_index
+  return ${__log4sh_return}
+}
+
+#/**
+# <s:function group="FileAppender" modifier="public">
+# <entry align="right">
+#   <code>integer</code>/boolean
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_file_getMaxFileSize</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>
+#     Get the maximum size that the output file is allowed to reach before
+#     being rolled over to backup files.
+#   </para>
+#   <para><emphasis role="strong">Since:</emphasis> 1.3.7</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>maxSize=`appender_file_getMaxBackupSize myAppender`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_file_getMaxFileSize()
+{
+  if [ $# -ne 1 ]; then
+    _log4sh_error "appender_file_getMaxFileSize(): invalid number of parameters ($#)"
+    return ${__LOG4SH_FALSE}
+  fi
+
+  afgmfs_appender=$1
+
+  afgmfs_index=`_log4sh_findArrayElement \
+      "${__log4shAppenders}" ${afgmfs_appender}`
+  # TODO: put check for valid index here
+  _log4sh_getArrayElement \
+      "${__log4shAppender_rollingFile_maxFileSizes}" ${afgmfs_index}
+  __log4sh_return=$?
+
+  unset afgmfs_appender afgmfs_index
+  return ${__log4sh_return}
+}
+
+#/**
+# <s:function group="FileAppender" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>/boolean
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_file_setMaxFileSize</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#       <paramdef>string <parameter>size</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>
+#     Set the maximum size that the output file is allowed to reach before
+#     being rolled over to backup files.
+#   </para>
+#   <para>
+#     In configuration files, the <option>MaxFileSize</option> option takes an
+#     long integer in the range 0 - 2^40. You can specify the value with the
+#     suffixes "KiB", "MiB" or "GiB" so that the integer is interpreted being
+#     expressed respectively in kilobytes, megabytes or gigabytes. For example,
+#     the value "10KiB" will be interpreted as 10240.
+#   </para>
+#   <para><emphasis role="strong">Since:</emphasis> 1.3.7</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>appender_file_setMaxBackupSize myAppender 10KiB</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_file_setMaxFileSize()
+{
+  if [ $# -ne 2 ]; then
+    _log4sh_error \
+        "appender_file_setMaxFileSize(): invalid number of parameters ($#)"
+    return ${__LOG4SH_ERROR}
+  fi
+
+  afsmfs_appender=$1
+  afsmfs_size=$2
+  afsmfs_return=${__LOG4SH_TRUE}
+
+  # split the file size into parts
+  afsmfs_value=`expr ${afsmfs_size} : '\([0-9]*\)'`
+  afsmfs_unit=`expr ${afsmfs_size} : '[0-9]* *\([A-Za-z]\{1,3\}\)'`
+
+  # determine multiplier
+  if [ ${__log4sh_wa_strictBehavior} -eq ${__LOG4SH_TRUE} ]; then
+    case "${afsmfs_unit}" in
+      KB) afsmfs_unit='KiB' ;;
+      MB) afsmfs_unit='MiB' ;;
+      GB) afsmfs_unit='GiB' ;;
+      TB) afsmfs_unit='TiB' ;;
+    esac
+  fi
+  case "${afsmfs_unit}" in
+    B) afsmfs_mul=1 ;;
+    KB) afsmfs_mul=1000 ;;
+    KiB) afsmfs_mul=1024 ;;
+    MB) afsmfs_mul=1000000 ;;
+    MiB) afsmfs_mul=1048576 ;;
+    GB) afsmfs_mul=1000000000 ;;
+    GiB) afsmfs_mul=1073741824 ;;
+    TB) afsmfs_mul=1000000000000 ;;
+    TiB) afsmfs_mul=1099511627776 ;;
+    '')
+      _log4sh_warn 'missing file size unit; assuming bytes'
+      afsmfs_mul=1
+      ;;
+    *)
+      _log4sh_error "unrecognized file size unit '${afsmfs_unit}'"
+      afsmfs_return=${__LOG4SH_ERROR}
+      ;;
+  esac
+
+  # calculate maximum file size
+  if [ ${afsmfs_return} -eq ${__LOG4SH_TRUE} ]; then
+    afsmfs_maxFileSize=`(expr ${afsmfs_value} \* ${afsmfs_mul} 2>&1)`
+    if [ $? -gt 0 ]; then
+      _log4sh_error "problem calculating maximum file size: '${afsmfs_maxFileSize}'"
+      afsmfs_return=${__LOG4SH_FALSE}
+    fi
+  fi
+
+  # store the maximum file size
+  if [ ${afsmfs_return} -eq ${__LOG4SH_TRUE} ]; then
+    afsmfs_index=`_log4sh_findArrayElement \
+        "${__log4shAppenders}" ${afsmfs_appender}`
+    # TODO: put check for valid index here
+    __log4shAppender_rollingFile_maxFileSizes=`_log4sh_setArrayElement \
+        "${__log4shAppender_rollingFile_maxFileSizes}" ${afsmfs_index} \
+        "${afsmfs_maxFileSize}"`
+  fi
+
+  # re-source the appender
+  [ ${afsmfs_return} -eq ${__LOG4SH_TRUE} ] \
+      && _appender_cache ${afsmfs_appender}
+
+  __log4sh_return=${afsmfs_return}
+  unset afsmfs_appender afsmfs_size afsmfs_value afsmfs_unit afsmfs_mul \
+      afsmfs_maxFileSize afsmfs_index afsmfs_return
+  return ${__log4sh_return}
+}
+
+#-----------------------------------------------------------------------------
+# SMTPAppender
+#
+
+#/**
+# <s:function group="SMTPAppender" modifier="public">
+# <entry align="right">
+#   <code>string</code>/boolean
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_smtp_getTo</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Get the to address for the given appender</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>email=`appender_smtp_getTo myAppender`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_smtp_getTo()
+{
+  if [ $# -ne 1 ]; then
+    _log4sh_error 'appender_smtp_getTo(): invalid number of parameters'
+    return ${__LOG4SH_FALSE}
+  fi
+
+  asgt_appender=$1
+
+  asgt_index=`_log4sh_findArrayElement "${__log4shAppenders}" ${asgt_appender}`
+  # TODO: put check for valid index here
+  asgt_to=`_log4sh_getArrayElement \
+      "${__log4shAppender_smtp_tos}" ${asgt_index}`
+  __log4sh_return=$?
+
+  [ "${asgt_to}" = "${__LOG4SH_NULL}" ] && asgt_to=''
+  echo "${asgt_to}"
+
+  unset asgt_appender asgt_index asgt_to
+  return ${__log4sh_return}
+}
+
+#/**
+# <s:function group="SMTPAppender" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>/boolean
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_smtp_setTo</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#       <paramdef>string <parameter>email</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Set the to address for the given appender</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>appender_smtp_setTo myAppender user at example.com</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_smtp_setTo()
+{
+  if [ $# -ne 2 ]; then
+    _log4sh_error 'appender_smtp_setTo(): invalid number of parameters'
+    return ${__LOG4SH_FALSE}
+  fi
+
+  asst_appender=$1
+  asst_email=$2
+
+  asst_index=`_log4sh_findArrayElement "${__log4shAppenders}" ${asst_appender}`
+  # TODO: put check for valid index here
+  __log4shAppender_smtp_tos=`_log4sh_setArrayElement \
+    "${__log4shAppender_smtp_tos}" ${asst_index} "${asst_email}"`
+
+  # resource the appender
+  _appender_cache ${asst_appender}
+
+  unset asst_appender asst_email asst_index
+}
+
+#/**
+# <s:function group="SMTPAppender" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_setAppenderRecipient</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#       <paramdef>string <parameter>email</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para><emphasis role="strong">Deprecated as of 1.3.1</emphasis></para>
+#   <para>
+#     Set the to address for the given appender
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>appender_smtp_setTo myAppender user at example.com</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_setAppenderRecipient()
+{
+  appender_smtp_setTo "$@"
+}
+
+#/**
+# <s:function group="SMTPAppender" modifier="public">
+# <entry align="right">
+#   <code>string</code>/boolean
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_smtp_getSubject</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Get the email subject for the given appender</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>subject=`appender_smtp_getSubject myAppender`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_smtp_getSubject()
+{
+  if [ $# -ne 1 ]; then
+    _log4sh_error 'appender_smtp_getSubject(): invalid number of parameters'
+    return ${__LOG4SH_FALSE}
+  fi
+
+  asgs_appender=$1
+
+  asgs_index=`_log4sh_findArrayElement "${__log4shAppenders}" ${asgs_appender}`
+  # TODO: put check for valid index here
+  asgs_subject=`_log4sh_getArrayElement \
+      "${__log4shAppender_smtp_subjects}" ${asgs_index}`
+  __log4sh_return=$?
+
+  [ "${asgs_subject}" = "${__LOG4SH_NULL}" ] && asgs_subject=''
+  echo "${asgs_subject}"
+
+  unset asgs_appender asgs_index asgs_subject
+  return ${__log4sh_return}
+}
+
+#/**
+# <s:function group="SMTPAppender" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>/boolean
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_smtp_setSubject</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#       <paramdef>string <parameter>subject</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Sets the email subject for an SMTP appender</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>appender_smtp_setSubject myAppender "This is a test"</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_smtp_setSubject()
+{
+  if [ $# -ne 2 ]; then
+    _log4sh_error 'appender_smtp_setSubject(): invalid number of parameters'
+    return ${__LOG4SH_FALSE}
+  fi
+
+  asss_appender=$1
+  asss_subject=$2
+
+  # set the Subject
+  asss_index=`_log4sh_findArrayElement "${__log4shAppenders}" ${asss_appender}`
+  if [ ${asss_index} -gt 0 ]; then
+    __log4shAppender_smtp_subjects=`_log4sh_setArrayElement \
+      "${__log4shAppender_smtp_subjects}" ${asss_index} "${asss_subject}"`
+    __log4sh_return=${__LOG4SH_TRUE}
+  else
+    _log4sh_error "could not set Subject for appender (${asss_appender})"
+    __log4sh_return=${__LOG4SH_FALSE}
+  fi
+
+  # re-source the appender
+  _appender_cache ${asss_appender}
+
+  unset asss_appender asss_subject asss_index
+  return ${__log4sh_return}
+}
+
+#/**
+# <s:function group="SMTPAppender" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_setAppenderSubject</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#       <paramdef>string <parameter>subject</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para><emphasis role="strong">Deprecated as of 1.3.1</emphasis></para>
+#   <para>
+#     Sets the email subject for an SMTP appender
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>appender_setAppenderSubject myAppender "This is a test"</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_setAppenderSubject()
+{
+  appender_smtp_setSubject "$@"
+}
+
+#-----------------------------------------------------------------------------
+# SyslogAppender
+#
+
+#/**
+# <s:function group="SyslogAppender" modifier="private">
+# <entry align="right">
+#   <code>string</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef>
+#         <function>_appender_syslog_getFacilityByIndex</function>
+#       </funcdef>
+#       <paramdef>integer <parameter>index</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Get the syslog facility of the specified appender by index</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>
+#       facility=`_appender_syslog_getFacilityByIndex 3`
+#     </funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_appender_syslog_getFacilityByIndex()
+{
+  _log4sh_getArrayElement "$__log4shAppender_syslog_facilities" $1
+}
+
+#/**
+# <s:function group="SyslogAppender" modifier="public">
+# <entry align="right">
+#   <code>string</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_getSyslogFacility</function></funcdef>
+#       <paramdef>integer <parameter>index</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para><emphasis role="strong">Deprecated as of 1.3.1</emphasis></para>
+#   <para>
+#     Get the syslog facility of the specified appender by index
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>facility=`appender_getSyslogFacility 3`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_getSyslogFacility()
+{
+  _appender_syslog_getFacilityByIndex "$@"
+}
+
+#/**
+# <s:function group="SyslogAppender" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_syslog_getFacility</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>
+#     Get the syslog facility for the given appender.
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>facility=`appender_syslog_getFacility myAppender`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_syslog_getFacility()
+{
+  if [ $# -ne 1 ]; then
+    _log4sh_error 'appender_syslog_getFacility(): invalid number of parameters'
+    return ${__LOG4SH_FALSE}
+  fi
+
+  asgf_appender=$1
+
+  asgf_index=`_log4sh_findArrayElement "$__log4shAppenders" ${asgf_appender}`
+  _log4sh_getArrayElement "${__log4shAppender_syslog_facilities}" ${asgf_index}
+
+  unset asgf_appender asgf_index
+}
+
+#/**
+# <s:function group="SyslogAppender" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_syslog_setFacility</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#       <paramdef>string <parameter>facility</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Set the syslog facility for the given appender</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>appender_syslog_setFacility myAppender local4`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_syslog_setFacility()
+{
+  if [ $# -ne 2 ]; then
+    _log4sh_error 'appender_syslog_setFacility(): invalid number of parameters'
+    return ${__LOG4SH_FALSE}
+  fi
+  assf_appender=$1
+  assf_facility=$2
+
+  # check for valid facility
+  echo "${__LOG4SH_TYPE_SYSLOG_FACILITY_NAMES}" |grep " ${assf_facility} " >/dev/null
+  if [ $? -ne 0 ]; then
+    # the facility is not valid
+    _log4sh_error "[${assf_facility}] is an unknown syslog facility. Defaulting to [user]."
+    assf_facility='user'
+  fi
+
+  # set appender facility
+  assf_index=`_log4sh_findArrayElement "${__log4shAppenders}" ${assf_appender}`
+  # TODO: put check for valid index here
+  __log4shAppender_syslog_facilities=`_log4sh_setArrayElement \
+    "${__log4shAppender_syslog_facilities}" ${assf_index} "${assf_facility}"`
+
+  # re-source the appender
+  _appender_cache ${assf_appender}
+
+  unset assf_appender assf_facility assf_index
+  return ${__LOG4SH_TRUE}
+}
+
+#/**
+# <s:function group="SyslogAppender" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_setSyslogFacility</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#       <paramdef>string <parameter>facility</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para><emphasis role="strong">Deprecated as of 1.3.2</emphasis></para>
+#   <para>
+#     Set the syslog facility for the given appender
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>appender_setSyslogFacility myAppender local4`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_setSyslogFacility()
+{
+  appender_syslog_setFacility "$@"
+}
+
+#/**
+# <s:function group="SyslogAppender" modifier="public">
+# <entry align="right">
+#   <code>string</code>/boolean
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_syslog_getHost</function></funcdef>
+#       <paramdef>integer <parameter>index</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>
+#     Get the syslog host of the specified appender.
+#   </para>
+#   <para><emphasis role="strong">Since:</emphasis> 1.3.7</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>host=`appender_syslog_getHost myAppender`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+appender_syslog_getHost()
+{
+  if [ $# -ne 1 ]; then
+    _log4sh_error 'appender_syslog_getHost(): invalid number of parameters'
+    return ${__LOG4SH_FALSE}
+  fi
+
+  asgh_appender=$1
+
+  asgh_index=`_log4sh_findArrayElement "${__log4shAppenders}" ${asgh_appender}`
+  # TODO: put check for valid index here
+  asgh_host=`_log4sh_getArrayElement \
+      "${__log4shAppender_syslog_hosts}" ${asgh_index}`
+  __log4sh_return=$?
+
+  [ "${asgh_host}" = "${__LOG4SH_NULL}" ] && asgh_host=''
+  echo "${asgh_host}"
+
+  unset asgh_appender asgh_index asgh_host
+  return ${__log4sh_return}
+}
+
+#/**
+# <s:function group="SyslogAppender" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>/boolean
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>appender_syslog_setHost</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#       <paramdef>string <parameter>host</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>
+#     Set the syslog host for the given appender. Requires that the 'nc'
+#     command alternative has been previously set with the
+#     log4sh_setAlternative() function.
+#   </para>
+#   <para><emphasis role="strong">Since:</emphasis> 1.3.7</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>appender_syslog_setHost myAppender localhost</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+#
+# The BSD syslog Protocol
+#   http://www.ietf.org/rfc/rfc3164.txt
+#
+appender_syslog_setHost()
+{
+  if [ $# -ne 2 ]; then
+    _log4sh_error 'appender_syslog_setHost(): invalid number of parameters'
+    return ${__LOG4SH_FALSE}
+  fi
+
+  assh_appender=$1
+  assh_host=$2
+
+  [ -z "${__log4sh_alternative_nc:-}" ] \
+      && _log4sh_warn 'the nc (netcat) command alternative is required for remote syslog logging. see log4sh_setAlternative().'
+
+  assh_index=`_log4sh_findArrayElement "${__log4shAppenders}" ${assh_appender}`
+  # TODO: put check for valid index here
+  __log4shAppender_syslog_hosts=`_log4sh_setArrayElement \
+      "${__log4shAppender_syslog_hosts}" ${assh_index} "${assh_host}"`
+
+  # re-source the appender
+  _appender_cache ${assh_appender}
+
+  unset assh_appender assh_host assh_index
+  return ${__LOG4SH_TRUE}
+}
+
+#=============================================================================
+# Level
+#
+
+#/**
+# <s:function group="Level" modifier="public">
+# <entry align="right">
+#   <code>string</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>logger_level_toLevel</function></funcdef>
+#       <paramdef>integer <parameter>val</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Converts an internally used level integer into its external level
+#   equivalent</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>level=`logger_level_toLevel 3`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+# TODO use arrays instead of case statement ??
+logger_level_toLevel()
+{
+  _ltl__val=$1
+
+  _ltl__return=${__LOG4SH_TRUE}
+  _ltl__level=''
+
+  case ${_ltl__val} in
+    ${__LOG4SH_LEVEL_TRACE}) _ltl__level=${__LOG4SH_LEVEL_TRACE_STR} ;;
+    ${__LOG4SH_LEVEL_DEBUG}) _ltl__level=${__LOG4SH_LEVEL_DEBUG_STR} ;;
+    ${__LOG4SH_LEVEL_INFO}) _ltl__level=${__LOG4SH_LEVEL_INFO_STR} ;;
+    ${__LOG4SH_LEVEL_WARN}) _ltl__level=${__LOG4SH_LEVEL_WARN_STR} ;;
+    ${__LOG4SH_LEVEL_ERROR}) _ltl__level=${__LOG4SH_LEVEL_ERROR_STR} ;;
+    ${__LOG4SH_LEVEL_FATAL}) _ltl__level=${__LOG4SH_LEVEL_FATAL_STR} ;;
+    ${__LOG4SH_LEVEL_OFF}) _ltl__level=${__LOG4SH_LEVEL_OFF_STR} ;;
+    ${__LOG4SH_LEVEL_CLOSED}) _ltl__level=${__LOG4SH_LEVEL_CLOSED_STR} ;;
+    *) _ltl__return=${__LOG4SH_FALSE} ;;
+  esac
+
+  echo ${_ltl__level}
+  unset _ltl__val _ltl__level
+  return ${_ltl__return}
+}
+
+#/**
+# <s:function group="Level" modifier="public">
+# <entry align="right">
+#   <code>integer</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>logger_level_toInt</function></funcdef>
+#       <paramdef>string <parameter>level</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Converts an externally used level tag into its integer
+#   equivalent</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>levelInt=`logger_level_toInt WARN`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+logger_level_toInt()
+{
+  _lti__level=$1
+
+  _lti__int=0
+  _lti__return=${__LOG4SH_TRUE}
+
+  case ${_lti__level} in
+    ${__LOG4SH_LEVEL_TRACE_STR}) _lti__int=${__LOG4SH_LEVEL_TRACE} ;;
+    ${__LOG4SH_LEVEL_DEBUG_STR}) _lti__int=${__LOG4SH_LEVEL_DEBUG} ;;
+    ${__LOG4SH_LEVEL_INFO_STR}) _lti__int=${__LOG4SH_LEVEL_INFO} ;;
+    ${__LOG4SH_LEVEL_WARN_STR}) _lti__int=${__LOG4SH_LEVEL_WARN} ;;
+    ${__LOG4SH_LEVEL_ERROR_STR}) _lti__int=${__LOG4SH_LEVEL_ERROR} ;;
+    ${__LOG4SH_LEVEL_FATAL_STR}) _lti__int=${__LOG4SH_LEVEL_FATAL} ;;
+    ${__LOG4SH_LEVEL_OFF_STR}) _lti__int=${__LOG4SH_LEVEL_OFF} ;;
+    ${__LOG4SH_LEVEL_CLOSED_STR}) _lti__int=${__LOG4SH_LEVEL_CLOSED} ;;
+    *) _lti__return=${__LOG4SH_FALSE} ;;
+  esac
+
+  echo ${_lti__int}
+  unset _lti__int _lti__level
+  return ${_lti__return}
+}
+
+#=============================================================================
+# Logger
+#
+
+#/**
+# <s:function group="Logger" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>/<code>boolean</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>logger_addAppender</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Add and initialize a new appender</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>logger_addAppender $appender</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+logger_addAppender()
+{
+  laa_appender=$1
+
+  # FAQ should we be using setter functions here?? for performance, no.
+  __log4shAppenders=`_log4sh_pushStack "${__log4shAppenders}" ${laa_appender}`
+  __log4shAppenderCount=`expr ${__log4shAppenderCount} + 1`
+  __log4shAppenderCounts="${__log4shAppenderCounts} ${__log4shAppenderCount}"
+  __log4shAppenderLayouts=`_log4sh_pushStack \
+      "$__log4shAppenderLayouts" "${__LOG4SH_LAYOUT_SIMPLE}"`
+  __log4shAppenderLevels=`_log4sh_pushStack \
+      "${__log4shAppenderLevels}" "${__LOG4SH_NULL}"`
+  __log4shAppenderPatterns=`_log4sh_pushStack \
+      "${__log4shAppenderPatterns}" "${__LOG4SH_PATTERN_DEFAULT}"`
+  __log4shAppenderTypes=`_log4sh_pushStack \
+      "${__log4shAppenderTypes}" ${__LOG4SH_TYPE_CONSOLE}`
+  __log4shAppender_file_files=`_log4sh_pushStack \
+      "${__log4shAppender_file_files}" ${__LOG4SH_NULL}`
+  __log4shAppender_rollingFile_maxBackupIndexes=`_log4sh_pushStack \
+      "${__log4shAppender_rollingFile_maxBackupIndexes}" \
+      ${__LOG4SH_TYPE_ROLLING_FILE_MAX_BACKUP_INDEX}`
+  __log4shAppender_rollingFile_maxFileSizes=`_log4sh_pushStack \
+      "${__log4shAppender_rollingFile_maxFileSizes}" \
+      ${__LOG4SH_TYPE_ROLLING_FILE_MAX_FILE_SIZE}`
+  __log4shAppender_smtp_tos=`_log4sh_pushStack \
+      "${__log4shAppender_smtp_tos}" ${__LOG4SH_NULL}`
+  __log4shAppender_smtp_subjects=`_log4sh_pushStack \
+      "${__log4shAppender_smtp_subjects}" ${__LOG4SH_NULL}`
+  __log4shAppender_syslog_facilities=`_log4sh_pushStack \
+      "${__log4shAppender_syslog_facilities}" ${__LOG4SH_TYPE_SYSLOG_FACILITY}`
+  __log4shAppender_syslog_hosts=`_log4sh_pushStack \
+      "${__log4shAppender_syslog_hosts}" "${__LOG4SH_NULL}"`
+
+  _appender_cache ${laa_appender}
+
+  unset laa_appender
+  return ${__LOG4SH_TRUE}
+}
+
+#/**
+# <s:function group="Logger" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>logger_addAppenderWithPattern</function></funcdef>
+#       <paramdef>string <parameter>appender</parameter></paramdef>
+#       <paramdef>string <parameter>pattern</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para><emphasis role="strong">Deprecated as of 1.3.6</emphasis></para>
+#   <para>
+#     Add and initialize a new appender with a specific PatternLayout
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>logger_addAppenderWithPattern $appender '%d %p - %m%n'</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+logger_addAppenderWithPattern()
+{
+  _myAppender=$1
+  _myPattern=$2
+
+  logger_addAppender ${_myAppender}
+  appender_setLayout ${_myAppender} ${__LOG4SH_LAYOUT_PATTERN}
+  appender_setPattern ${_myAppender} "${_myPattern}"
+
+  unset _myAppender _myPattern
+}
+
+#/**
+# <s:function group="Logger" modifier="public">
+# <entry align="right">
+#   <code>string</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>logger_getFilename</function></funcdef>
+#       <void />
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>
+#     Get the filename that would be shown when the '%F' conversion character
+#     is used in a PatternLayout.
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>filename=`logger_getFilename`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+logger_getFilename()
+{
+  echo "${__log4sh_filename}"
+}
+
+#/**
+# <s:function group="Logger" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>logger_setFilename</function></funcdef>
+#       <paramdef>string <parameter>filename</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Set the filename to be shown when the '%F' conversion character is
+#   used in a PatternLayout.</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>logger_setFilename 'myScript.sh'</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+logger_setFilename()
+{
+  __log4sh_filename=$1
+}
+
+#/**
+# <s:function group="Logger" modifier="public">
+# <entry align="right">
+#   <code>string</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>logger_getLevel</function></funcdef>
+#       <void />
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Get the global default logging level (e.g. DEBUG).</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>level=`logger_getLevel`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+logger_getLevel()
+{
+  logger_level_toLevel ${__log4shLevel}
+}
+
+#/**
+# <s:function group="Logger" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>logger_setLevel</function></funcdef>
+#       <paramdef>string <parameter>level</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Sets the global default logging level (e.g. DEBUG).</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>logger_setLevel INFO</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+logger_setLevel()
+{
+  _l_level=$1
+
+  _l_int=`logger_level_toInt ${_l_level}`
+  if [ $? -eq ${__LOG4SH_TRUE} ]; then
+    __log4shLevel=${_l_int}
+  else
+    _log4sh_error "attempt to set invalid log level '${_l_level}'"
+  fi
+
+  unset _l_int _l_level
+}
+
+#/**
+# <s:function group="Logger" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>log</function></funcdef>
+#       <paramdef>string <parameter>level</parameter></paramdef>
+#       <paramdef>string[] <parameter>message(s)</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>The base logging command that logs a message to all defined
+#     appenders</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>log DEBUG 'This is a test message'</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+log()
+{
+  _l_level=$1
+  shift
+  # if no message was passed, read it from STDIN
+  [ $# -ne 0 ] && _l_msg="$@" || _l_msg=`cat`
+
+  __log4sh_return=${__LOG4SH_TRUE}
+  _l_levelInt=`logger_level_toInt ${_l_level}`
+  if [ $? -eq ${__LOG4SH_TRUE} ]; then
+    # update seconds elapsed
+    _log4sh_updateSeconds
+
+    _l_oldIFS=${IFS} IFS=${__LOG4SH_IFS_DEFAULT}
+    for _l_appenderIndex in ${__log4shAppenderCounts}; do
+      ${__LOG4SH_TRACE} "_l_appenderIndex='${_l_appenderIndex}'"
+      # determine appender level
+      _l_appenderLevel=`_appender_getLevelByIndex ${_l_appenderIndex}`
+      if [ "${_l_appenderLevel}" = "${__LOG4SH_NULL}" ]; then
+        # continue if requested is level less than general level
+        [ ! ${__log4shLevel} -le ${_l_levelInt} ] && continue
+      else
+        _l_appenderLevelInt=`logger_level_toInt ${_l_appenderLevel}`
+        # continue if requested level is less than specific appender level
+        ${__LOG4SH_TRACE} "_l_levelInt='${_l_levelInt}' _l_appenderLevelInt='${_l_appenderLevelInt}'"
+        [ ! ${_l_appenderLevelInt} -le ${_l_levelInt} ] && continue
+      fi
+
+      # execute dynamic appender function
+      _l_appenderName=`_log4sh_getArrayElement \
+        "${__log4shAppenders}" ${_l_appenderIndex}`
+      ${__LOG4SH_APPENDER_FUNC_PREFIX}${_l_appenderName}_append ${_l_level} "${_l_msg}"
+    done
+    IFS=${_l_oldIFS}
+  else
+    _log4sh_error "invalid logging level requested (${_l_level})"
+    __log4sh_return=${__LOG4SH_ERROR}
+  fi
+
+  unset _l_msg _l_oldIFS _l_level _l_levelInt
+  unset _l_appenderIndex _l_appenderLevel _l_appenderLevelInt _l_appenderName
+  return ${__log4sh_return}
+}
+
+#/**
+# <s:function group="Logger" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>logger_trace</function></funcdef>
+#       <paramdef>string[] <parameter>message</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>This is a helper function for logging a message at the TRACE
+#     priority</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>logger_trace 'This is a trace message'</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+logger_trace()
+{
+  log ${__LOG4SH_LEVEL_TRACE_STR} "$@"
+}
+
+#/**
+# <s:function group="Logger" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>logger_debug</function></funcdef>
+#       <paramdef>string[] <parameter>message</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>This is a helper function for logging a message at the DEBUG
+#     priority</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>logger_debug 'This is a debug message'</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+logger_debug()
+{
+  log ${__LOG4SH_LEVEL_DEBUG_STR} "$@"
+}
+
+#/**
+# <s:function group="Logger" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>logger_info</function></funcdef>
+#       <paramdef>string[] <parameter>message</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>This is a helper function for logging a message at the INFO
+#     priority</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>logger_info 'This is a info message'</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+logger_info()
+{
+  log ${__LOG4SH_LEVEL_INFO_STR} "$@"
+}
+
+#/**
+# <s:function group="Logger" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>logger_warn</function></funcdef>
+#       <paramdef>string[] <parameter>message</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>
+#     This is a helper function for logging a message at the WARN priority
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>logger_warn 'This is a warn message'</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+logger_warn()
+{
+  log ${__LOG4SH_LEVEL_WARN_STR} "$@"
+}
+
+#/**
+# <s:function group="Logger" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>logger_error</function></funcdef>
+#       <paramdef>string[] <parameter>message</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>
+#     This is a helper function for logging a message at the ERROR priority
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>logger_error 'This is a error message'</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+logger_error()
+{
+  log ${__LOG4SH_LEVEL_ERROR_STR} "$@"
+}
+
+#/**
+# <s:function group="Logger" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>logger_fatal</function></funcdef>
+#       <paramdef>string[] <parameter>message</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>This is a helper function for logging a message at the FATAL
+#     priority</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>logger_fatal 'This is a fatal message'</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+logger_fatal()
+{
+  log ${__LOG4SH_LEVEL_FATAL_STR} "$@"
+}
+
+#==============================================================================
+# Property
+#
+
+#/**
+# <s:function group="Property" modifier="private">
+# <entry align="right">
+#   <code>string</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_log4sh_getPropPrefix</function></funcdef>
+#       <paramdef>string <parameter>property</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Takes a string (eg. "log4sh.appender.stderr.File") and returns the
+#   prefix of it (everything before the first '.' char). Normally used in
+#   parsing the log4sh configuration file.</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>prefix=`_log4sh_getPropPrefix $property"`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_log4sh_getPropPrefix()
+{
+  _oldIFS=${IFS} IFS='.'
+  set -- $1
+  IFS=${_oldIFS} unset _oldIFS
+  echo $1
+}
+
+#/**
+# <s:function group="Property" modifier="private">
+# <entry align="right">
+#   <code>string</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_log4sh_stripPropPrefix</function></funcdef>
+#       <paramdef>string <parameter>property</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Strips the prefix off a property configuration command and returns
+#   the string. E.g. "log4sh.appender.stderr.File" becomes
+#   "appender.stderr.File".</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>newProperty=`_log4sh_stripPropPrefix $property`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_log4sh_stripPropPrefix()
+{
+  expr "$1" : '[^.]*\.\(.*\)'
+}
+
+#/**
+# <s:function group="Property" modifier="private">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_log4sh_propAlternative</function></funcdef>
+#       <paramdef>string <parameter>property</parameter></paramdef>
+#       <paramdef>string <parameter>value</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>
+#     Configures log4sh to use an alternative command.
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>_log4sh_propAlternative property value</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_log4sh_propAlternative()
+{
+  _lpa_key=$1
+  _lpa_value=$2
+
+  # strip the leading 'alternative.'
+  _lpa_alternative=`_log4sh_stripPropPrefix ${_lpa_key}`
+
+  # set the alternative
+  log4sh_setAlternative ${_lpa_alternative} "${_lpa_value}"
+
+  unset _lpa_key _lpa_value _lpa_alternative
+}
+
+#/**
+# <s:function group="Property" modifier="private">
+# <entry align="right">
+#   <emphasis>void</emphasis>/boolean
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_log4sh_propAppender</function></funcdef>
+#       <paramdef>string <parameter>property</parameter></paramdef>
+#       <paramdef>string <parameter>value</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Configures log4sh using an appender property configuration statement</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>_log4sh_propAppender $property $value</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_log4sh_propAppender()
+{
+  _lpa_key=$1
+  _lpa_value=$2
+
+  _lpa_appender=''
+  _lpa_rtrn=${__LOG4SH_TRUE}
+
+  # strip the leading 'appender' keyword prefix
+  _lpa_key=`_log4sh_stripPropPrefix ${_lpa_key}`
+
+  # handle appender definitions
+  if [ "${_lpa_key}" '=' "`expr \"${_lpa_key}\" : '\([^.]*\)'`" ]; then
+    _lpa_appender="${_lpa_key}"
+  else
+    _lpa_appender=`_log4sh_getPropPrefix ${_lpa_key}`
+  fi
+
+  # does the appender exist?
+  appender_exists ${_lpa_appender}
+  if [ $? -eq ${__LOG4SH_FALSE} ]; then
+    _log4sh_error "attempt to configure the non-existant appender (${_lpa_appender})"
+    unset _lpa_appender _lpa_key _lpa_value
+    return ${__LOG4SH_ERROR}
+  fi
+
+  # handle the appender type
+  if [ "${_lpa_appender}" = "${_lpa_key}" ]; then
+    case ${_lpa_value} in
+      ${__LOG4SH_TYPE_CONSOLE}|\
+      ${__LOG4SH_CONFIG_LOG4J_CP}.${__LOG4SH_TYPE_CONSOLE})
+        appender_setType ${_lpa_appender} ${__LOG4SH_TYPE_CONSOLE} ;;
+      ${__LOG4SH_TYPE_FILE}|\
+      ${__LOG4SH_CONFIG_LOG4J_CP}.${__LOG4SH_TYPE_FILE})
+        appender_setType ${_lpa_appender} ${__LOG4SH_TYPE_FILE} ;;
+      $__LOG4SH_TYPE_DAILY_ROLLING_FILE|\
+      ${__LOG4SH_CONFIG_LOG4J_CP}.${__LOG4SH_TYPE_DAILY_ROLLING_FILE})
+        appender_setType ${_lpa_appender} ${__LOG4SH_TYPE_DAILY_ROLLING_FILE} ;;
+      ${__LOG4SH_TYPE_ROLLING_FILE}|\
+      ${__LOG4SH_CONFIG_LOG4J_CP}.${__LOG4SH_TYPE_ROLLING_FILE})
+        appender_setType ${_lpa_appender} ${__LOG4SH_TYPE_ROLLING_FILE} ;;
+      ${__LOG4SH_TYPE_SMTP}|\
+      ${__LOG4SH_CONFIG_LOG4J_CP}.${__LOG4SH_TYPE_SMTP})
+        appender_setType $_lpa_appender ${__LOG4SH_TYPE_SMTP} ;;
+      ${__LOG4SH_TYPE_SYSLOG}|\
+      ${__LOG4SH_CONFIG_LOG4J_CP}.${__LOG4SH_TYPE_SYSLOG})
+        appender_setType $_lpa_appender ${__LOG4SH_TYPE_SYSLOG} ;;
+      *)
+        _log4sh_error "appender type (${_lpa_value}) unrecognized"
+        false
+        ;;
+    esac
+    [ $? -ne ${__LOG4SH_TRUE} ] && _lpa_rtrn=${__LOG4SH_ERROR}
+    __log4sh_return=${_lpa_rtrn}
+    unset _lpa_appender _lpa_key _lpa_rtrn _lpa_value
+    return ${__log4sh_return}
+  fi
+
+  # handle appender values and methods
+  _lpa_key=`_log4sh_stripPropPrefix ${_lpa_key}`
+  if [ "${_lpa_key}" '=' "`expr \"${_lpa_key}\" : '\([^.]*\)'`" ]; then
+    case ${_lpa_key} in
+      # General
+      Threshold) appender_setLevel ${_lpa_appender} "${_lpa_value}" ;;
+      layout) appender_setLayout ${_lpa_appender} "${_lpa_value}" ;;
+
+      # FileAppender
+      DatePattern) ;;  # unsupported
+      File)
+        _lpa_value=`eval echo "${_lpa_value}"`
+        appender_file_setFile ${_lpa_appender} "${_lpa_value}"
+        ;;
+      MaxBackupIndex)
+        appender_file_setMaxBackupIndex ${_lpa_appender} "${_lpa_value}" ;;
+      MaxFileSize)
+        appender_file_setMaxFileSize ${_lpa_appender} "${_lpa_value}" ;;
+
+      # SMTPAppender
+      To) appender_smtp_setTo ${_lpa_appender} "${_lpa_value}" ;;
+      Subject) appender_smtp_setSubject ${_lpa_appender} "${_lpa_value}" ;;
+
+      # SyslogAppender
+      SyslogHost) appender_syslog_setHost ${_lpa_appender} "${_lpa_value}" ;;
+      Facility) appender_syslog_setFacility ${_lpa_appender} "${_lpa_value}" ;;
+
+      # catch unrecognized
+      *)
+        _log4sh_error "appender value/method (${_lpa_key}) unrecognized"
+        false
+        ;;
+    esac
+    [ $? -ne ${__LOG4SH_TRUE} ] && _lpa_rtrn=${__LOG4SH_ERROR}
+    __log4sh_return=${_lpa_rtrn}
+    unset _lpa_appender _lpa_key _lpa_rtrn _lpa_value
+    return ${__log4sh_return}
+  fi
+
+  # handle appender layout values and methods
+  _lpa_key=`_log4sh_stripPropPrefix ${_lpa_key}`
+  case ${_lpa_key} in
+    ConversionPattern) appender_setPattern ${_lpa_appender} "${_lpa_value}" ;;
+    *)
+      _log4sh_error "layout value/method (${_lpa_key}) unrecognized"
+      false
+      ;;
+  esac
+  [ $? -ne ${__LOG4SH_TRUE} ] && _lpa_rtrn=${__LOG4SH_ERROR}
+  __log4sh_return=${_lpa_rtrn}
+  unset _lpa_appender _lpa_key _lpa_rtrn _lpa_value
+  return ${__log4sh_return}
+}
+
+#/**
+# <s:function group="Property" modifier="private">
+# <entry align="right">
+#   <code>string</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_log4sh_propLogger</function></funcdef>
+#       <paramdef>string <parameter>property</parameter></paramdef>
+#       <paramdef>string <parameter>value</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>(future) Configures log4sh with a <code>logger</code> configuration
+#   statement. Sample output: "logger: property value".</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>result=`_log4sh_propLogger $property $value`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_log4sh_propLogger()
+{
+  _prop=`_log4sh_stripPropPrefix $1`
+  echo "logger: ${_prop} $2"
+  unset _prop
+}
+
+#
+# configure log4sh with a rootLogger configuration statement
+#
+# @param  _key    configuration command
+# @param  _value  configuration value
+#
+#/**
+# <s:function group="Property" modifier="private">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_log4sh_propRootLogger</function></funcdef>
+#       <paramdef>string <parameter>rootLogger</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Configures log4sh with a <code>rootLogger</code> configuration
+#   statement. It expects a comma separated string similar to the following:</para>
+#   <para><code>log4sh.rootLogger=ERROR, stderr, R</code></para>
+#   <para>The first option is the default logging level to set for all
+#   of the following appenders that will be created, and all following options
+#   are the names of appenders to create. The appender names must be
+#   unique.</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>_log4sh_propRootLogger $value</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_log4sh_propRootLogger()
+{
+  __lprl_rootLogger=`echo "$@" |sed 's/ *, */,/g'`
+  __lprl_count=`echo "${__lprl_rootLogger}" |sed 's/,/ /g' |wc -w`
+  __lprl_index=1
+  while [ ${__lprl_index} -le ${__lprl_count} ]; do
+    __lprl_operand=`echo "${__lprl_rootLogger}" |cut -d, -f${__lprl_index}`
+    if [ ${__lprl_index} -eq 1 ]; then
+      logger_setLevel "${__lprl_operand}"
+    else
+      appender_exists "${__lprl_operand}"
+      if [ $? -eq ${__LOG4SH_FALSE} ]; then
+        logger_addAppender "${__lprl_operand}"
+      else
+        _log4sh_error "attempt to add already existing appender of name (${__lprl_operand})"
+      fi
+    fi
+    __lprl_index=`expr ${__lprl_index} + 1`
+  done
+
+  unset __lprl_count __lprl_index __lprl_operand __lprl_rootLogger
+}
+
+#/**
+# <s:function group="Property" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>/boolean
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>log4sh_doConfigure</function></funcdef>
+#       <paramdef>string <parameter>configFileName</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>
+#     Read configuration from a file. <emphasis role="strong">The existing
+#     configuration is not cleared or reset.</emphasis> If you require a
+#     different behavior, then call the <code>log4sh_resetConfiguration</code>
+#     before calling <code>log4sh_doConfigure</code>.
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>log4sh_doConfigure myconfig.properties</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+log4sh_doConfigure()
+{
+  [ -n "${FUNCNAME:-}" ] \
+      && ${__LOG4SH_TRACE} "${FUNCNAME}()${BASH_LINENO:+'(called from ${BASH_LINENO})'}"
+
+  # prepare the environment for configuration
+  log4sh_resetConfiguration
+
+  ldc_file=$1
+  ldc_rtrn=${__LOG4SH_TRUE}
+
+  # strip the config prefix and dump output to a temporary file
+  ldc_tmpFile="${__log4sh_tmpDir}/properties"
+  ${__LOG4SH_TRACE} "__LOG4SH_CONFIG_PREFIX='${__LOG4SH_CONFIG_PREFIX}'"
+  grep "^${__LOG4SH_CONFIG_PREFIX}\." "${ldc_file}" >"${ldc_tmpFile}"
+
+  # read the file in. using a temporary file and a file descriptor here instead
+  # of piping the file into the 'while read' because the pipe causes a fork
+  # under some shells which makes it impossible to get the variables passed
+  # back to the parent script.
+  exec 3<&0 <"${ldc_tmpFile}"
+  while read ldc_line; do
+    ldc_key=`expr "${ldc_line}" : '\([^= ]*\) *=.*'`
+    ldc_value=`expr "${ldc_line}" : '[^= ]* *= *\(.*\)'`
+
+    # strip the leading 'log4sh.'
+    ldc_key=`_log4sh_stripPropPrefix ${ldc_key}`
+    ldc_keyword=`_log4sh_getPropPrefix ${ldc_key}`
+    case ${ldc_keyword} in
+      alternative) _log4sh_propAlternative ${ldc_key} "${ldc_value}" ;;
+      appender) _log4sh_propAppender ${ldc_key} "${ldc_value}" ;;
+      logger) _log4sh_propLogger ${ldc_key} "${ldc_value}" ;;
+      rootLogger) _log4sh_propRootLogger "${ldc_value}" ;;
+      *)
+        _log4sh_error "unrecognized properties keyword (${ldc_keyword})"
+        false
+        ;;
+    esac
+    [ $? -ne ${__LOG4SH_TRUE} ] && ldc_rtrn=${__LOG4SH_ERROR}
+  done
+  exec 0<&3 3<&-
+
+  # remove the temporary file
+  rm -f "${ldc_tmpFile}"
+
+  # activate all of the appenders
+  for ldc_appender in ${__log4shAppenders}; do
+    ${__LOG4SH_APPENDER_FUNC_PREFIX}${ldc_appender}_activateOptions
+  done
+
+  __log4sh_return=${ldc_rtrn}
+  unset ldc_appender ldc_file ldc_tmpFile ldc_line ldc_key ldc_keyword
+  unset ldc_value ldc_rtrn
+  return ${__log4sh_return}
+}
+
+#/**
+# <s:function group="Property" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>log4sh_readProperties</function></funcdef>
+#       <paramdef>string <parameter>configFileName</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para><emphasis role="strong">Deprecated as of 1.3.6</emphasis></para>
+#   <para>
+#     See <code>log4sh_doConfigure</code>.
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>log4sh_readProperties myconfig.properties</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+log4sh_readProperties()
+{
+  log4sh_doConfigure "$@"
+}
+
+#/**
+# <s:function group="Property" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>log4sh_resetConfiguration</function></funcdef>
+#       <void />
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>
+#     This function completely resets the log4sh configuration to have no
+#     appenders with a global logging level of ERROR.
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>log4sh_resetConfiguration</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+# XXX if a configuration is *repeatedly* established via logger_addAppender and
+# reset using this command, there is a risk of running out of memory.
+log4sh_resetConfiguration()
+{
+  __log4shAppenders=''
+  __log4shAppenderCount=0
+  __log4shAppenderCounts=''
+  __log4shAppenderLayouts=''
+  __log4shAppenderLevels=''
+  __log4shAppenderPatterns=''
+  __log4shAppenderTypes=''
+  __log4shAppender_file_files=''
+  __log4shAppender_rollingFile_maxBackupIndexes=''
+  __log4shAppender_rollingFile_maxFileSizes=''
+  __log4shAppender_smtp_tos=''
+  __log4shAppender_smtp_subjects=''
+  __log4shAppender_syslog_facilities=''
+  __log4shAppender_syslog_hosts=''
+
+  logger_setLevel ERROR
+}
+
+#==============================================================================
+# Thread
+#
+
+#/**
+# <s:function group="Thread" modifier="public">
+# <entry align="right">
+#   <code>string</code>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>logger_getThreadName</function></funcdef>
+#       <void />
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Gets the current thread name.</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>threadName=`logger_getThreadName`</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+logger_getThreadName()
+{
+  echo ${__log4sh_threadName}
+}
+
+#/**
+# <s:function group="Thread" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>logger_setThreadName</function></funcdef>
+#       <paramdef>string <parameter>threadName</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>
+#     Sets the thread name (e.g. the name of the script). This thread name can
+#     be used with the '%t' conversion character within a
+#     <option>PatternLayout</option>.
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>logger_setThreadName "myThread"</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+logger_setThreadName()
+{
+  _thread=$1
+
+  _length=`_log4sh_getArrayLength "$__log4sh_threadStack"`
+  __log4sh_threadStack=`_log4sh_setArrayElement "$__log4sh_threadStack" $_length $_thread`
+  __log4sh_threadName=$_thread
+
+  unset _length _thread
+}
+
+#/**
+# <s:function group="Thread" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>logger_pushThreadName</function></funcdef>
+#       <paramdef>string <parameter>threadName</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para><emphasis role="strong">Deprecated as of 1.3.7</emphasis></para>
+#   <para>
+#     Sets the thread name (eg. the name of the script) and pushes the old on
+#     to a stack for later use. This thread name can be used with the '%t'
+#     conversion character within a <option>PatternLayout</option>.
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>logger_pushThreadName "myThread"</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+logger_pushThreadName()
+{
+  __log4sh_threadStack=`_log4sh_pushStack "$__log4sh_threadStack" $1`
+  __log4sh_threadName=$1
+}
+
+#/**
+# <s:function group="Thread" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>logger_popThreadName</function></funcdef>
+#       <void />
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para><emphasis role="strong">Deprecated as of 1.3.7</emphasis></para>
+#   <para>
+#     Removes the topmost thread name from the stack. The next thread name on
+#     the stack is then placed in the <varname>__log4sh_threadName</varname>
+#     variable. If the stack is empty, or has only one element left, then a
+#     warning is given that no more thread names can be popped from the stack.
+#   </para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>logger_popThreadName</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+logger_popThreadName()
+{
+  _length=`_log4sh_getArrayLength "$__log4sh_threadStack"`
+  if [ $_length -gt 1 ]; then
+    __log4sh_threadStack=`_log4sh_popStack "$__log4sh_threadStack"`
+    __log4sh_threadName=`_log4sh_peekStack "$__log4sh_threadStack"`
+  else
+    echo 'log4sh:WARN no more thread names available on thread name stack.' >&2
+  fi
+}
+
+#==============================================================================
+# Trap
+#
+
+#/**
+# <s:function group="Trap" modifier="public">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>log4sh_cleanup</function></funcdef>
+#       <void />
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>This is a cleanup function to remove the temporary directory used by
+#   log4sh. It is provided for scripts who want to do log4sh cleanup work
+#   themselves rather than using the automated cleanup of log4sh that is
+#   invoked upon a normal exit of the script.</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>log4sh_cleanup</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+log4sh_cleanup()
+{
+  _log4sh_cleanup 'EXIT'
+}
+
+#/**
+# <s:function group="Trap" modifier="private">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>_log4sh_cleanup</function></funcdef>
+#       <paramdef>string <parameter>signal</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>This is a cleanup function to remove the temporary directory used by
+#   log4sh. It should only be called by log4sh itself when it is taking
+#   control of traps.</para>
+#   <para>If there was a previously defined trap for the given signal, log4sh
+#   will attempt to call the original trap handler as well so as not to break
+#   the parent script.</para>
+#   <funcsynopsis>
+#     <funcsynopsisinfo>_log4sh_cleanup EXIT</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+_log4sh_cleanup()
+{
+  _lc__trap=$1
+  ${__LOG4SH_INFO} "_log4sh_cleanup(): the ${_lc__trap} signal was caught"
+
+  _lc__restoreTrap=${__LOG4SH_FALSE}
+  _lc__oldTrap=''
+
+  # match trap to signal value
+  case "${_lc__trap}" in
+    EXIT) _lc__signal=0 ;;
+    INT) _lc__signal=2 ;;
+    TERM) _lc__signal=15 ;;
+  esac
+
+  # do we possibly need to restore a previous trap?
+  if [ -r "${__log4sh_trapsFile}" -a -s "${__log4sh_trapsFile}" ]; then
+    # yes. figure out what we need to do
+    if [ `grep "^trap -- " "${__log4sh_trapsFile}" >/dev/null; echo $?` -eq 0 ]
+    then
+      # newer trap command
+      ${__LOG4SH_DEBUG} 'newer POSIX trap command'
+      _lc__restoreTrap=${__LOG4SH_TRUE}
+      _lc__oldTrap=`egrep "(${_lc__trap}|${_lc__signal})$" "${__log4sh_trapsFile}" |\
+        sed "s/^trap -- '\(.*\)' [A-Z]*$/\1/"`
+    elif [ `grep "[0-9]*: " "${__log4sh_trapsFile}" >/dev/null; echo $?` -eq 0 ]
+    then
+      # older trap command
+      ${__LOG4SH_DEBUG} 'older style trap command'
+      _lc__restoreTrap=${__LOG4SH_TRUE}
+      _lc__oldTrap=`grep "^${_lc__signal}: " "${__log4sh_trapsFile}" |\
+        sed 's/^[0-9]*: //'`
+    else
+      # unrecognized trap output
+      _log4sh_error 'unable to restore old traps! unrecognized trap command output'
+    fi
+  fi
+
+  # do our work
+  rm -fr "${__log4sh_tmpDir}"
+
+  # execute the old trap
+  if [ ${_lc__restoreTrap} -eq ${__LOG4SH_TRUE} -a -n "${_lc__oldTrap}" ]; then
+    ${__LOG4SH_INFO} 'restoring previous trap of same type'
+    eval "${_lc__oldTrap}"
+  fi
+
+  # exit for all non-EXIT signals
+  if [ "${_lc__trap}" != 'EXIT' ]; then
+    # disable the EXIT trap
+    trap 0
+
+    # add 127 to signal value and exit
+    _lc__signal=`expr ${_lc__signal} + 127`
+    exit ${_lc__signal}
+  fi
+
+  unset _lc__oldTrap _lc__signal _lc__restoreTrap _lc__trap
+  return
+}
+
+
+#==============================================================================
+# main
+#
+
+# create a temporary directory
+__log4sh_tmpDir=`_log4sh_mktempDir`
+
+# preserve old trap(s)
+__log4sh_trapsFile="${__log4sh_tmpDir}/traps"
+trap >"${__log4sh_trapsFile}"
+
+# configure traps
+${__LOG4SH_INFO} 'setting traps'
+trap '_log4sh_cleanup EXIT' 0
+trap '_log4sh_cleanup INT' 2
+trap '_log4sh_cleanup TERM' 15
+
+# alternative commands
+log4sh_setAlternative mail "${LOG4SH_ALTERNATIVE_MAIL:-mail}" ${__LOG4SH_TRUE}
+[ -n "${LOG4SH_ALTERNATIVE_NC:-}" ] \
+    && log4sh_setAlternative nc "${LOG4SH_ALTERNATIVE_NC}"
+
+# load the properties file
+${__LOG4SH_TRACE} "__LOG4SH_CONFIGURATION='${__LOG4SH_CONFIGURATION}'"
+if [ "${__LOG4SH_CONFIGURATION}" != 'none' -a -r "${__LOG4SH_CONFIGURATION}" ]
+then
+  ${__LOG4SH_INFO} 'configuring via properties file'
+  log4sh_doConfigure "${__LOG4SH_CONFIGURATION}"
+else
+  if [ "${__LOG4SH_CONFIGURATION}" != 'none' ]; then
+    _log4sh_warn 'No appenders could be found.'
+    _log4sh_warn 'Please initalize the log4sh system properly.'
+  fi
+  ${__LOG4SH_INFO} 'configuring at runtime'
+
+  # prepare the environment for configuration
+  log4sh_resetConfiguration
+
+  # note: not using the constant variables here (e.g. for ConsoleAppender) so
+  # that those perusing the code can have a working example
+  logger_setLevel ${__LOG4SH_LEVEL_ERROR_STR}
+  logger_addAppender stdout
+  appender_setType stdout ConsoleAppender
+  appender_setLayout stdout PatternLayout
+  appender_setPattern stdout '%-4r [%t] %-5p %c %x - %m%n'
+fi
+
+# restore the previous set of shell flags
+for _log4sh_shellFlag in ${__LOG4SH_SHELL_FLAGS}; do
+  echo ${__log4sh_oldShellFlags} |grep ${_log4sh_shellFlag} >/dev/null \
+    || set +${_log4sh_shellFlag}
+done
+unset _log4sh_shellFlag
+
+#/**
+# </s:shelldoc>
+#*/

Added: trunk/freenx-redesign/server/utility/nxagent-helper
===================================================================
--- trunk/freenx-redesign/server/utility/nxagent-helper	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/utility/nxagent-helper	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,365 @@
+#!/usr/bin/python2.4
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: diamond at google.com (Stephen Shirley)
+
+"""nxserver program for accepting nx connections.
+
+"""
+
+import os
+import re
+import signal
+import subprocess
+import sys
+import time
+import traceback
+
+sys.path.append('/usr/freenx/lib')
+import nxlog
+import nxloadconfig
+
+prog_name = "nxagent-helper"
+_COMMANDS = ( "start", "resume" )
+state_lines = { 'starting': re.compile(r'^Session: Starting session at '),
+    'running': re.compile(r'^Session: Session (started|resumed) at '),
+    'suspending': re.compile(r'^Session: Suspending session at '),
+    'suspended': re.compile(r'^Session: Session suspended at '),
+    'terminating': re.compile(r'^Session: (Terminat|Abort)ing session at '),
+    'terminated': re.compile(r'^Session: Session (terminat|abort)ed at ')
+  }
+info_lines = { 'watchdog_pid':
+      re.compile(r"^Info: Watchdog running with pid '(?P<pid>\d+)'."),
+    'kill_watchdog':
+      re.compile(r"^Info: Waiting the watchdog process to complete."),
+    'agent_pid':
+      re.compile(r"^Info: Agent running with pid '(?P<pid>\d+)'."),
+    'general_error':
+      re.compile(r"^Error: (?P<error>.*)$")
+  }
+options = {}
+
+
+def main():
+  """Do setup, then read and handle command"""
+
+  basic_setup()
+  handle_command(*read_command()) # Expand the list passed back into two
+                                  # seperate arguments.
+
+
+def basic_setup():
+  """Setup logging, read configuration"""
+
+  nxlog.setup(prog_name)
+  nxlog.log(nxlog.LOG_DEBUG, "started with pid %d\n" % os.getpid())
+  nxloadconfig.setup(prog_name)
+  level = nxloadconfig.conf.get('LOG_LEVEL', '5') # Default to LOG_NOTICE
+  try:
+    nxlog.set_log_level(level)
+  except ValueError:
+    nxlog.log(nxlog.LOG_ERR, "Invalid log level: %s\n" % level)
+  nxlog.log(nxlog.LOG_INFO, "config parsed\n")
+
+
+def read_command():
+  """Read a single command from stdin, check that it's valid, return it."""
+
+  raw_cmd = raw_input()
+  cmd = raw_cmd.split()
+  if len(cmd) < 2:
+    nxlog.log(nxlog.LOG_CRIT, "Command has invalid format: %s\n" %
+        repr(raw_cmd))
+    sys.exit(1)
+  if cmd[0].lower() not in _COMMANDS:
+    nxlog.log(nxlog.LOG_CRIT, "Unknown command given: %s\n" % repr(raw_cmd))
+    sys.exit(1)
+  return cmd[0].lower(), cmd[1]
+
+
+def handle_command(cmd, sessionid):
+  """Handle the commands received."""
+
+  global options
+  nxlog.log(nxlog.LOG_DEBUG, "command: %s %s\n" % (cmd, sessionid))
+  #FIXME: should be using a better, non-hardcoded location
+  if cmd == 'start':
+    nxlog.log(nxlog.LOG_NOTICE, "Starting session %s\n" % sessionid)
+    session_dir = '/tmp/nx/S-%s' % sessionid
+    try:
+      args = [line[:-1] for line in
+          open('/tmp/nx/S-%s/args' % sessionid).readlines()]
+      nxlog.log(nxlog.LOG_NOTICE, "Session args: %s\n" % repr(args))
+
+      # Open the session log to pass to nxagent
+      nxagent_log = open(os.path.join(session_dir, 'session.log'), 'w')
+      options_path = os.path.join(session_dir, 'options')
+      opt_read(options_path)
+    except IOError, e:
+      nxlog.log(nxlog.LOG_ERR, "Session file error: %s\n" % e)
+      sys.exit(1)
+    options['dir'] = session_dir
+    cleanup()
+    os.environ['LD_LIBRARY_PATH'] = '/usr/NX/lib'
+    os.environ['DISPLAY'] = 'nx/nx,options=%s:%s' % \
+        (options_path, options['display_num'])
+    os.environ['X_AUTHORITY'] = os.path.join(session_dir, 'authority')
+    setup_xauth()
+    options['p'] = subprocess.Popen(['/usr/freenx/bin/nxagent'] + args,
+        close_fds=True, stdin=None, stdout=nxagent_log,
+        stderr=subprocess.STDOUT)
+    options['agent_pid'] = options['p'].pid
+    write_agent_pid()
+    nxlog.log(nxlog.LOG_NOTICE, "Spawned nxagent pid %d\n" % options['p'].pid)
+    # Don't want to propogate this to other children.
+    del os.environ['LD_LIBRARY_PATH']
+    os.environ['DISPLAY'] = ':%s' % options['display_num']
+    nxagent_log = open(os.path.join(session_dir, 'session.log'), 'r')
+    follow_log(nxagent_log)
+  elif cmd == 'resume':
+    nxlog.log(nxlog.LOG_NOTICE, "Resuming session %s\n" % sessionid)
+    nxlog.log(nxlog.LOG_CRIT, "Session resumption not yet supported\n")
+    sys.exit(1)
+
+
+def follow_log(log):
+  """Follow and parse the log of nxagent.
+
+  FIXME: Keeps track of the state of nxagent, performs actions on certain
+  state changes.
+  """
+
+  try:
+    nxlog.log(nxlog.LOG_DEBUG, "Following agent log\n")
+    while True:
+      line = log.readline()
+      if not line:
+        if options['p'].poll() is not None:
+          ret = options['p'].returncode
+          if ret < 0:
+            nxlog.log(nxlog.LOG_NOTICE, "Nxagent has exited, "
+                "killed by signal %d\n" % -ret)
+          else:
+            nxlog.log(nxlog.LOG_NOTICE, "Nxagent has exited: %s\n" % ret)
+          break
+        time.sleep(0.5)
+        continue
+      line = line.rstrip() # Remove trailing newline
+      if match_state(line):
+        nxlog.log(nxlog.LOG_DEBUG, "Matched state: %s\n" % line)
+      elif match_info(line):
+        nxlog.log(nxlog.LOG_DEBUG, "Matched info: %s\n" % line)
+  # If any problems occur, we want to cleanup first. When we're done cleaning
+  # up, re-raise the exception.
+  except:
+    nxlog.log(nxlog.LOG_ERR, "Got exception, cleaning up\n")
+    print "NX> 1009 Session status: terminated"
+    cleanup()
+    raise
+
+  nxlog.log(nxlog.LOG_DEBUG, "Finished following agent log\n")
+
+
+def match_state(line):
+  """Try match the given line against a session state
+
+  Return:
+    True: the line matched
+    False: the line didn't match
+  """
+
+  # Faking a static variable
+  old_state = match_state.cur_state = getattr(match_state, 'cur_state', None)
+  if not line.startswith('Session: '):
+    return False
+  for state, rx in state_lines.iteritems():
+    if rx.search(line):
+      match_state.cur_state = state
+      handle_state_change(match_state.cur_state, old_state)
+      return True
+  return False
+
+
+def match_info(line):
+  """Try match the given line against an info line regex
+  
+  Return:
+    True: the line matched
+    False: the line didn't match
+  """
+
+  for info, rx in info_lines.iteritems():
+    m = rx.search(line)
+    if m:
+      handle_info(info, m)
+      return True
+  return False
+
+
+def handle_state_change(cur_state, old_state):
+  """Compare the current state to the previous state, and handle as 
+  appropriate
+  
+  Args:
+    cur_state: current state name
+    old_state: previous state name
+  Return:
+    None
+  """
+
+  if cur_state == old_state:
+    return
+  nxlog.log(nxlog.LOG_NOTICE,"Nxagent state was: %s Now: %s\n" % \
+      (old_state, cur_state))
+  print "NX> 1009 Session status: %s" % cur_state
+  sys.stdout.flush()
+  if cur_state == 'starting' and old_state is None:
+    start_app()
+  elif cur_state == 'terminated' and old_state != 'terminated':
+    nxlog.log(nxlog.LOG_NOTICE, "Nxagent finished, cleaning up")
+    cleanup()
+
+
+def handle_info(info, m):
+  """Execute the required response to a given info line match
+  
+  Args:
+    info: The id of the info line
+    m: The match object from the info line's regex
+  Return:
+    None
+  """
+
+  if info == 'watchdog_pid':
+    options['watchdog_pid'] = int(m.group('pid'))
+    nxlog.log(nxlog.LOG_NOTICE, "matched info watchdog, pid %s\n" %
+        options['watchdog_pid'])
+  elif info == 'agent_pid':
+    real_agent_pid = int(m.group('pid'))
+    nxlog.log(nxlog.LOG_NOTICE, "matched info agent_pid, pid %s\n" %
+        real_agent_pid)
+    if options['agent_pid'] != real_agent_pid:
+      # Probably caused by nxagent being a shell script
+      nxlog.log(nxlog.LOG_WARNING, "Agent pid (%s) doesn't match "
+          "spawned pid (%s)\n" % (options['agent_pid'], real_agent_pid))
+      options['agent_pid'] = real_agent_pid
+      write_agent_pid()
+  elif info == 'kill_watchdog':
+    if 'watchdog_pid' not in options:
+      nxlog.log(nxlog.LOG_ERR, "matched info kill_watchdog, "
+          "but no known watchdog pid\n")
+    else:
+      try:
+        os.kill(options['watchdog_pid'], signal.SIGTERM)
+      except OSError, (errno, strerror):
+        nxlog.log(nxlog.LOG_WARNING, "matched info kill_watchdog, "
+            "got error from kill[%d]: %s\n" % (errno, strerror))
+      else:
+        nxlog.log(nxlog.LOG_NOTICE, "matched info kill_watchdog, sent TERM.\n")
+  elif info == 'general_error':
+    nxlog.log(nxlog.LOG_ERR, "Agent error: %s" % m.group('error'))
+  else:
+    # If none of the above handers match...
+    nxlog.log(nxlog.LOG_ERR, "matched info %s, but failed to "
+        "find handler for it\n" % info)
+
+
+def opt_read(opt_path):
+  """Parse the nxagent options file into a dict."""
+
+  global options
+  options = {}
+  #FIXME: this needs to be much more robust
+  opt_str = open(opt_path).read().rstrip()
+  opt_str, options['display_num'] = opt_str.rsplit(':', 1)
+  for pair in opt_str.split(','):
+    if pair == 'nx/nx': continue
+    name, val = pair.split('=')
+    options[name] = val
+
+
+def setup_xauth():
+  """Setup Xauthority file using session cookie."""
+
+  global options
+  os.system('xauth add localhost:%(display_num)s MIT-MAGIC-COOKIE-1 '
+      '%(cookie)s &> $X_AUTHORITY.log' % options)
+  os.system('xauth add :%(display_num)s MIT-MAGIC-COOKIE-1 %(cookie)s' % \
+      options)
+
+
+def start_app():
+  """Start the session application (startkde/gnome-session/etc)."""
+
+  global options
+  if options['type'] in ('gnome', 'kde'):
+    app = nxloadconfig.conf['COMMAND_START_%s' % options['type'].upper()]
+  elif options['type'] == 'application':
+    app = options['application']
+  assert(app) #FIXME(diamond): handle this better
+  cmd = 'nxstart %d %s &' % (options['agent_pid'], app)
+  nxlog.log(nxlog.LOG_INFO, "Nxagent ready, launching app: %s" % cmd)
+  log = open(os.path.join(options['dir'], 'app.log'), 'w')
+  s = subprocess.Popen(cmd, shell=True, close_fds=True,
+      stdin=None, stdout=log, stderr=subprocess.STDOUT)
+  options['app_pid'] = s.pid
+  #FIXME(diamond): check for errors here
+
+
+def cleanup():
+  """Cleanup after various things (X11 locks etc)."""
+
+  global options
+
+  for proc in 'watchdog', 'agent', 'app':
+    pid_name = "%s_pid" % proc
+    if pid_name in options:
+      try:
+        os.kill(options[pid_name], signal.SIGTERM)
+      except OSError, (errno, strerror):
+        nxlog.log(nxlog.LOG_WARNING, "Cleanup handler got error %d when "
+            "killing %s: %s\n" % (errno, proc, strerror))
+      else:
+        nxlog.log(nxlog.LOG_WARNING, "Cleanup handler sent TERM to %s\n" % proc)
+
+  for f in ['/tmp/.X%(display_num)s-lock' % options,
+    '/tmp/.X11-unix/X%(display_num)s' % options]:
+      if os.path.exists(f):
+        os.remove(f)
+
+
+def write_agent_pid():
+  """Send the agent pid to nxserver-inner"""
+
+  global options
+  sys.stdout.write('NX> 8888 agentpid: %s\n' % options['agent_pid'])
+  sys.stdout.flush()
+
+
+if __name__ == '__main__':
+  try:
+    main()
+  except SystemExit, e:
+    sys.exit(e.code)
+  except Exception, e:
+    trace = traceback.format_exc()
+    nxlog.log(nxlog.LOG_ERR, 'Going down because exception caught '
+                             'at the top level.')
+    for line in trace.split('\n'):
+      nxlog.log(nxlog.LOG_ERR, '%s' % line)
+    sys.exit(1)


Property changes on: trunk/freenx-redesign/server/utility/nxagent-helper
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/freenx-redesign/server/utility/nxloadconfig
===================================================================
--- trunk/freenx-redesign/server/utility/nxloadconfig	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/utility/nxloadconfig	2008-03-10 22:22:58 UTC (rev 503)
@@ -1,18 +1,30 @@
 #!/bin/bash
 
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
 # nxloadconfig - Read configuration files, setup logging
 #
-# Copyright 2007 Google Inc.
-# All Rights Reserved.
 # Author: diamond at google.com (Stephen Shirley)
 #
-# License: GNU GPL, version 2
-#
 # Used configuration keys:
 #
 # Used internal subfunctions:
 #
-# @sub "log n" log to (sys)log with loglevel n
+# @sub "nxlog_log n" log to (sys)log with loglevel n
 #
 # Used internal variables:
 #
@@ -33,36 +45,63 @@
 # SVN: $Id$
 #
 
+COMMAND_GETOPT="$(which getopt)"
+
 # Store these for use later
-ORIG_ARGS=($@)
+ORIG_ARGS=("$@") # Initialise ORIG_ARGS as an array
 SCRIPT_NAME=$(basename $0)
 SCRIPT_DIR=$(dirname $0)
+PATH_BASE="${PATH_BASE:-/usr/freenx}"
+PATH_ETC="${PATH_ETC:-$PATH_BASE/etc}"
+PATH_BIN="${PATH_BIN:-$PATH_BASE/bin}"
 
 
+check_command_vars() {
+	check_command_var COMMAND_START_KDE "$(which startkde:-NOTFOUND)"
+	check_command_var COMMAND_START_GNOME "$(which gnome-session:-NOTFOUND)"
+	check_command_var COMMAND_START_CDE "$(which cdwm:-NOTFOUND)"
+	check_command_var COMMAND_XTERM "$(which xterm:-NOTFOUND)"
+	check_command_var COMMAND_XAUTH "$(which xauth:-NOTFOUND)"
+	check_command_var COMMAND_SMBMOUNT "$(which smbmount:-NOTFOUND)"
+	check_command_var COMMAND_SMBUMOUNT "$(which smbumount:-NOTFOUND)"
+	check_command_var COMMAND_NETCAT "$(which netcat:-NOTFOUND)"
+	check_command_var COMMAND_SSH "$(which ssh:-NOTFOUND)"
+	check_command_var COMMAND_SSH_KEYGEN "$(which ssh-keygen:-NOTFOUND)"
+	check_command_var COMMAND_CUPSD "$(which cupsd:-NOTFOUND)"
+	check_command_var COMMAND_MD5SUM "$(which md5sum:-NOTFOUND)"
+	check_command_var NXSESSION_HOOK "$(which nxsession:-NOTFOUND)"
+}
+
+
+check_dir_vars() {
+	check_dir_var PATH_BASE "$PATH_BASE"
+	check_dir_var PATH_BIN "$PATH_BASE/bin"
+	check_dir_var PATH_ETC "$PATH_BASE/etc"
+	check_dir_var PATH_LIB "$PATH_BASE/lib"
+}
+
+
 parse_args() {
-	ARGS=$(/usr/bin/getopt -n "$SCRIPT_NAME" -o "h" -l "config:,help" -- \
-	"${ORIG_ARGS[@]}" 2>/dev/null)
+	# Horrible hack to parse the output of getopt correctly
+	eval ARGS=("$("$COMMAND_GETOPT" -n "$SCRIPT_NAME" -o "h" -l "config:,help" -- \
+	"${ORIG_ARGS[@]:-}")")
 
-	if [ $? != 0 ]
-	then
-		# Can't grab only the error message if there's an issue, so just run it
-		# again to output the error directly.
-		/usr/bin/getopt -n "$SCRIPT_NAME" -o "h" -l "config:,help" -- \
-		"${ORIG_ARGS[@]}" > /dev/null
+	if [ "$?" != "0" ]; then
+		echo "Error: unable to parse arguments: \"${ORIG_ARGS[@]}\"" >&2
 		exit 1
 	fi
 }
 
 
 process_args() {
-	HELP="no"
+	local HELP="no"
 
 	while true; do
 		case "$1" in
 			--config) CONF_NAME="$2"; shift 2 ;;
 			-h|--help) HELP="yes"; shift ;;
 			--) shift; break ;;
-			*) echo "$SCRIPT_NAME: error parsing cmdline" >&2; exit 1 ;;
+			*) echo "$SCRIPT_NAME: error parsing cmdline: $@" >&2; exit 1 ;;
 		esac
 	done
 
@@ -71,128 +110,144 @@
 
 
 usage() {
-	echo "$SCRIPT_NAME - Load the FreeNX configuration variables into the environment."
-	echo "Syntax: nxloadconfig -h|--help"
-	echo "        nxloadconfig [--config=name]"
-	echo
-	echo "  --config=name            Load $PATH_ETC/name.conf config file."
-	echo "  -h,--help                Display this message."
+	{
+		echo "$SCRIPT_NAME - Load the FreeNX configuration variables into the environment."
+		echo "Syntax: nxloadconfig -h|--help"
+		echo "        nxloadconfig [--config=name]"
+		echo
+		echo "  --config=name            Load $PATH_ETC/name.conf config file."
+		echo "  -h,--help                Display this message."
+	} >&2
 	exit 0
 }
 
 
 default_if_not_set() {
-	var="$1"
-	default="$2"
+	local var="$1"
+	local default="$2"
 
 	# Is the var set?
 	if ! declare -p "$var" &> /dev/null
 	then
 		# Var is not set, set it to the default now and return
-		declare "$var" "$default"
+		eval "$var"="\"$default\""
 		return 0
 	else
+		# Var is set, carry on
 		return 1
 	fi
 }
 
 
-check_dir_vars() {
-	check_dir_var PATH_BASE "/usr/NX"
-	check_dir_var PATH_BIN "$PATH_BASE/bin"
-	check_dir_var PATH_ETC "$PATH_BASE/etc"
-	check_dir_var PATH_LIB "$PATH_BASE/lib"
-}
-
-
 check_dir_var() {
-	var="$1"
-	defdir="$2"
+	local var="$1"
+	local defdir="$2"
 	# Gets the value of the variable named by $var
-	varval=$(eval echo \$"$foo")
+	local varval="$(eval "echo \"\${$var:-}\"")"
 
-	default_if_not_set "$var" "$defdir" && return
-
-	if [ ! -d "$varval" ]
-	then
-		log $LOG_WARNING "Invalid directory variable $var: $varval"
-		declare "$var" "$defdir"
+	# Only check current value if it's actually been set
+	if ! default_if_not_set "$var" "$defdir"; then
+		if [ ! -d "$varval" ]
+		then
+			nxlog_log $_NXLOG_LOG_WARNING "Invalid directory variable $var: \"$varval\""
+			eval "$var"="\"$defdir\""
+		else
+			# Everything checks out.
+			return
+		fi
 	fi
 
 	if [ ! -d "$defdir" ]
 	then
-		log $LOG_ERR "Invalid default directory variable $var: $defdir"
+		nxlog_log $_NXLOG_LOG_ERR "Invalid default directory variable $var: \"$defdir\""
 		exit 1
 	fi
 }
 
 
-check_command_vars() {
-	check_command_var COMMAND_START_KDE "startkde"
-	check_command_var COMMAND_START_GNOME "gnome-session"
-	check_command_var COMMAND_START_CDE "cdwm"
-	check_command_var COMMAND_XTERM "xterm"
-	check_command_var COMMAND_XAUTH "/usr/X11R6/bin/xauth"
-	check_command_var COMMAND_SMBMOUNT "smbmount"
-	check_command_var COMMAND_SMBUMOUNT "smbumount"
-	check_command_var COMMAND_NETCAT "netcat"
-	check_command_var COMMAND_SSH "ssh"
-	check_command_var COMMAND_SSH_KEYGEN "ssh-keygen"
-	check_command_var COMMAND_CUPSD "/usr/sbin/cupsd"
-	check_command_var COMMAND_MD5SUM "md5sum"
-}
-
-
 check_command_var() {
-	var="$1"
-	defcmd="$2"
+	local var="$1"
+	local defcmd="$2"
 	# Gets the value of the variable named by $var
-	varval=$(eval echo \$"$foo")
+	local varval=$(eval echo \"\${"$var":-}\")
 
-	default_if_not_set "$var" "$defcmd" && return
-
-	if [ ! -d "$varval" ]
-	then
-		log $LOG_WARNING "Invalid directory variable $var: $varval"
-		declare "$var" "$defdir"
+	# Only check current value if it's actually been set
+	if ! default_if_not_set "$var" "$defcmd"; then
+		if [ ! -x "$varval" -o ! -f "$varval" ]
+		then
+			nxlog_log $_NXLOG_LOG_WARNING "Invalid command variable $var: \"$varval\""
+			eval "$var"="\"$defcmd\""
+		else
+			# Everything checks out.
+			return
+		fi
 	fi
 
-	if [ ! -d "$defdir" ]
-	then
-		log $LOG_ERR "Invalid default directory variable $var: $defdir"
-		exit 1
+	# If the default is empty, it probably means the executable couldn't be found.
+	if [ "$defcmd" = "" ]; then
+		eval "$var"="\"NOTFOUND\""
+	else
+		if [ ! -x "$defcmd" -o ! -f "$defcmd" ]
+		then
+			nxlog_log $_NXLOG_LOG_ERR "Invalid default command variable $var: \"$defcmd\""
+			exit 1
+		fi
 	fi
 }
 
 
 load_file() {
-	file="$1"
+	local file="$1"
 
-	if [ -f "$file" ]
-	then
-		. "$file"
-	else
-		echo "$SCRIPT_NAME: no such file or directory: \"$file\"" >&2; exit 1;
+	set -- # Clear arguments before sourcing
+	# Depend on the file being in in $PATH, or a path specified
+	if ! . "$file"; then
+		echo "$SCRIPT_NAME: error sourcing \"$file\": ${err:-}" >&2
+		echo "PATH: $PATH" >&2
+		exit 1
 	fi
 }
 
-parse_args
-eval set -- "$ARGS"
-process_args "$@"
+nxloadconfig_main() {
+	parse_args
+	process_args "${ARGS[@]}"
 
-# Load logging fuctionality
-LOG_LEVEL=$LOG_WARNING
-load_file "$SCRIPT_DIR/nxlog"
+	# Load general configuration
+	load_file "$PATH_ETC/general.conf"
 
-# Load general configuration
-load_file "$PATH_ETC/general.conf"
-# Load function-specific configuration
-[ -n "$CONF_NAME" ] && load_file "$PATH_ETC/$CONF_NAME.conf"
+	# Load logging fuctionality
+	LOG_LEVEL="${LOG_LEVEL:-WARNING}"
+	load_file "nxlog"
 
-check_dir_vars
-check_command_vars
+	# Load function-specific configuration
+	[ -n "${CONF_NAME:-}" -a -e "$PATH_ETC/${CONF_NAME:-}.conf" ] && \
+		load_file "$PATH_ETC/$CONF_NAME.conf"
 
-log $LOG_DEBUG "called with cmdline: ${ORIG_ARGS[@]}"
+	# In case the function-specific config updates $LOG_LEVEL
+	_nxlog_set_log_level
 
+	check_dir_vars
+	check_command_vars
+	default_if_not_set "NX_VERSION" "3.0.0"
+	default_if_not_set "NX_LICENSE" "GPL"
 
+	nxlog_log $_NXLOG_LOG_DEBUG "called with cmdline: ${ORIG_ARGS[@]:-}"
+
+	if [ -z "${UNITTESTING:-}" ]; then
+		# Unset functions that aren't useful outside of nxloadconfig
+		unset check_command_vars
+		unset check_dir_vars
+		unset parse_args
+		unset process_args
+		unset usage
+		unset nxloadconfig_main
+	fi
+}
+
+if [ -z "${UNITTESTING:-}" ]; then
+	nxloadconfig_main
+fi
+
+true # So sourcing the file will return 0 if everything is ok.
+
 # vim: ts=8 noexpandtab sw=8 softtabstop=0

Added: trunk/freenx-redesign/server/utility/nxloadconfig-helper.sh
===================================================================
--- trunk/freenx-redesign/server/utility/nxloadconfig-helper.sh	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/utility/nxloadconfig-helper.sh	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
+# Author: diamond at google.com (Stephen Shirley)
+
+for i in $(env | cut -f1 -d=); do
+  declare +x "$i" # Unexport all variables
+done
+set -a
+. "$1"
+set +a
+env | grep -v "^_="


Property changes on: trunk/freenx-redesign/server/utility/nxloadconfig-helper.sh
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/freenx-redesign/server/utility/nxlog
===================================================================
--- trunk/freenx-redesign/server/utility/nxlog	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/utility/nxlog	2008-03-10 22:22:58 UTC (rev 503)
@@ -1,13 +1,25 @@
 #!/bin/bash
 
+# Copyright 2007 Google Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+#
 # nxlog - Provides functions for logging to syslog
 #
-# Copyright 2007 Google Inc.
-# All Rights Reserved.
-# Author: diamond at google.com (Stephen Shirley)
+# Author: alriddoch at google.com (Alistair Riddoch)
 #
-# License: GNU GPL, version 2
-#
 # Used configuration keys:
 #
 # Used internal subfunctions:
@@ -20,7 +32,8 @@
 #
 # Used external programs:
 #
-# @ext logger - a shell command interface to the syslog(3) system log module
+# @ext log4sh - a shell logging library interface with support for the
+#               syslog(3) system log module
 #
 # Accepted protocol requests from client:
 #
@@ -31,81 +44,119 @@
 # SVN: $Id$
 #
 
-LOG_EMERG=0
-LOG_ALERT=1
-LOG_CRIT=2
-LOG_ERR=3
-LOG_WARNING=4
-LOG_NOTICE=5
-LOG_INFO=6
-LOG_DEBUG=7
+_NXLOG_LOG_EMERG=0
+_NXLOG_LOG_ALERT=1
+_NXLOG_LOG_CRIT=2
+_NXLOG_LOG_ERR=3
+_NXLOG_LOG_WARNING=4
+_NXLOG_LOG_NOTICE=5
+_NXLOG_LOG_INFO=6
+_NXLOG_LOG_DEBUG=7
 
-
-log()
+_nxlog_log_level_2_log4sh()
 {
-	PRIORITY="$1"
-	if [ "$LOG_LEVEL" -ge "$PRIORITY" ]
-	then
-		shift
-		[ "$1" = "-n" ] && shift
-		ARGS="$@"
-		[ -n "$ARGS" ] || ARGS="No arguments supplied to log()"
-		logger -p "syslog.$PRIORITY" -t "$SCRIPT_NAME" -- "$ARGS"
-	fi
+	local def_lev="INFO"
+	case "$1" in
+		$_NXLOG_LOG_EMERG|EMERG) echo FATAL ;;
+		$_NXLOG_LOG_ALERT|ALERT) echo FATAL ;;
+		$_NXLOG_LOG_CRIT|CRIT) echo ERROR ;;
+		$_NXLOG_LOG_ERR|ERR) echo ERROR ;;
+		$_NXLOG_LOG_WARNING|WARNING) echo WARN ;;
+		$_NXLOG_LOG_NOTICE|NOTICE) echo INFO ;;
+		$_NXLOG_LOG_INFO|INFO) echo INFO ;;
+		$_NXLOG_LOG_DEBUG|DEBUG) echo DEBUG ;;
+		*)
+			nxlog_log ERR "_nxlog_log_level_2_log4sh: Invalid log level \"$1\", defaulting to \"$def_lev\""
+			echo "$def_lev"
+		;;
+	esac
 }
 
-
-log_tee()
+_nxlog_set_log_level()
 {
-	PRIORITY="$1"
-	while read -r; do
-		[ -n "$REPLY" ] && log "$PRIORITY" "$REPLY"
-		echo "$REPLY"
-	done
+	logger_setLevel `_nxlog_log_level_2_log4sh $LOG_LEVEL`
 }
 
+_nxlog_import_log4sh()
+{
+	# If the library is already imported, return.
+	[ -n "${__LOG4SH_VERSION:-}" ] && return
 
-echo_x()
-{
-	echo "$@"
-	case "$NX_LOG_PROG" in
-		"nxserver") prefix="(s>c)" ;;
-		"nxnode") prefix="(n>s)" ;;
-		*) prefix="(?>?)" ;;
-	esac
-        log $LOG_INFO "$prefix $@"
+	# Look for the library in our current location
+	_NXLOG_LOG4SH="$(cd $(dirname $1) && pwd -L)/log4sh"
+
+	# If it is not there, look for it on the PATH
+	[ -f "$_NXLOG_LOG4SH" ] || _NXLOG_LOG4SH='log4sh'
+
+	# Source the library with no configuration
+	LOG4SH_CONFIGURATION='none' . $_NXLOG_LOG4SH
 }
 
+_nxlog_setup_log4sh()
+{
+	# Import the log4sh library if necessary
+	_nxlog_import_log4sh "$1"
+	# Reset the configuration
+	log4sh_resetConfiguration
 
-read_x()
-{
-	read -t 10 "$@"
-	case "$NX_LOG_PROG" in
-		"nxserver") prefix="(s<c)" ;;
-		"nxnode") prefix="(n<s)" ;;
-		*) prefix="(?<?)" ;;
-	esac
-        log $LOG_INFO "$prefix $REPLY"
+	# Set the level up for INFO by default
+	[ -n "${LOG_LEVEL:-}" ] || LOG_LEVEL=$_NXLOG_LOG_INFO
+
+	# Set the log level
+	_nxlog_set_log_level
+
+	# Set up the syslog as the only appender
+	logger_addAppender syslog
+	logger_setFilename "$SCRIPT_NAME"
+	appender_setType syslog SyslogAppender
+	appender_syslog_setFacility syslog daemon
+
+  # Allow tests etc to setup extra logging
+  if declare -f "${setup_extra_logging:-}" &>/dev/null; then
+    "$setup_extra_logging"
+  fi
 }
 
-
-read_x_prompt() 
+nxlog_log()
 {
-	echo_x -n "$1"
+	PRIORITY="$1"
+	if [ "$#" -le "1" ]
+	then
+		return
+	fi
 	shift
-	read_x "$@"
+	log `_nxlog_log_level_2_log4sh $PRIORITY` "$@"
 }
 
-
-if [ "$#" = "0" -a "$SCRIPT_NAME" = "nxlog" ]
-then
+nxlog_log_pipe()
+{
+	PRIORITY="$1"
 	while read
 	do
-		log $line # no "" here to have it split up in different levels
+		nxlog_log "$PRIORITY" ${NXLOG_LOG_PIPE_PREFIX:-} $REPLY
 	done
+}
+
+[ -n "${SCRIPT_NAME:-}" ] || SCRIPT_NAME="$(basename $0)"
+
+_nxlog_setup_log4sh "$0"
+
+if [ "$#" -le "1" ]
+then
+	# If we are being run rather than sourced, read log data in from
+	# stdin.
+	if [ "$SCRIPT_NAME" = "nxlog" ]
+	then
+		if [ "$#" = "1" ]; then
+			PRIORITY="$1"
+			shift
+		else
+			PRIORITY=INFO
+		fi
+
+		nxlog_log_pipe "$PRIORITY"
+	fi
 else
-	log "$@"
+	# If we are being run with arguments, log using the arguments.
+	nxlog_log "$@"
 fi
-
-
-# vim: ts=8 noexpandtab sw=8 softtabstop=0

Added: trunk/freenx-redesign/server/utility/nxserver-suid.c
===================================================================
--- trunk/freenx-redesign/server/utility/nxserver-suid.c	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/utility/nxserver-suid.c	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,142 @@
+/*
+ * Copyright 2007 Google Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Author: alriddoch at google.com (Alistair Riddoch)
+ */
+
+#include <sys/types.h>
+#include <sys/socket.h>
+
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <pwd.h>
+#include <syslog.h>
+#include <string.h>
+#include <errno.h>
+#include <libgen.h>
+
+#include <assert.h>
+
+char * prgname = NULL;
+
+#define STRING_BUFLEN 512
+#define NXNODE_COMMAND "nxnode"
+#define NXSERVER_COMMAND "nxserver"
+
+int launch_nxnode(uid_t user, int comm_fd)
+{
+    // This program is being run setuid, so we can now drop back to
+    // the ruid which should be the original user.
+    if (seteuid(user) != 0) {
+        syslog(LOG_ERR, "ERROR: Unable to drop back to calling userid: %m\n");
+        return 1;
+    }
+
+    // Disassociate from the terminal connected to the client that we were
+    // invoked from.
+    setsid();
+
+    // Close stdio, and reconnected it to a socket via which we can
+    // communicate with nxserver.
+    close(STDIN_FILENO);
+    close(STDOUT_FILENO);
+    close(STDERR_FILENO);
+
+    dup2(comm_fd, STDIN_FILENO);
+    dup2(comm_fd, STDOUT_FILENO);
+    dup2(comm_fd, STDERR_FILENO);
+
+    return execlp(NXNODE_COMMAND, NXNODE_COMMAND, NULL);
+}
+
+int launch_nxserver(const char * username, int comm_fd, int argc, char ** argv)
+{
+    size_t env_string_length;
+    char * env_string;
+    char ** new_argv;
+    int i;
+
+    env_string_length = snprintf(0, 0, "%s=%s",
+                                 "NX_TRUSTED_USER", username);
+    env_string = malloc(env_string_length + 1);
+    assert(env_string != NULL);
+    sprintf(env_string, "%s=%s", "NX_TRUSTED_USER", username);
+    putenv(env_string);
+
+    env_string_length = snprintf(0, 0, "%s=%d",
+                                 "NX_COMMFD", comm_fd);
+    env_string = malloc(env_string_length + 1);
+    assert(env_string != NULL);
+    sprintf(env_string, "%s=%d", "NX_COMMFD", comm_fd);
+    putenv(env_string);
+
+    new_argv = calloc(argc + 1, sizeof(char *));
+    new_argv[0] = NXSERVER_COMMAND;
+
+    for (i = 1; i < argc; ++i) {
+        new_argv[i] = argv[i];
+    }
+
+    return execvp(NXSERVER_COMMAND, new_argv);
+}
+
+int main(int argc, char ** argv)
+{
+    prgname = basename(strdup(argv[0]));
+
+    openlog(prgname, LOG_PID, LOG_USER);
+
+    uid_t calling_uid = getuid();
+
+    if (geteuid() == calling_uid) {
+        syslog(LOG_WARNING, "WARNING: Not running suid.\n");
+    }
+
+    struct passwd calling_user;
+    struct passwd * ret;
+    char user_string_buffer[STRING_BUFLEN];
+    errno = 0;
+
+    if (getpwuid_r(calling_uid, &calling_user, &user_string_buffer[0],
+                   STRING_BUFLEN, &ret) != 0) {
+        syslog(LOG_ERR, "ERROR: Unable to get passwd entry for calling user %d: %m\n", calling_uid);
+        return 1;
+    }
+
+    int sockets[2];
+
+    if (socketpair(AF_UNIX, SOCK_STREAM, 0, sockets) != 0) {
+        syslog(LOG_ERR, "FATAL: Socket error: %m");
+        return 1;
+    }
+
+    pid_t child = fork();
+
+    if (child < 0) {
+        syslog(LOG_ERR, "FATAL: Fork error: %m");
+        return 1;
+    }
+
+    if (child == 0) {
+        close(sockets[1]);
+        return launch_nxnode(calling_uid, sockets[0]);
+    }
+
+    close(sockets[0]);
+    return launch_nxserver(calling_user.pw_name, sockets[1], argc, argv);
+}

Added: trunk/freenx-redesign/server/utility/shunit2
===================================================================
--- trunk/freenx-redesign/server/utility/shunit2	2008-03-07 17:19:07 UTC (rev 502)
+++ trunk/freenx-redesign/server/utility/shunit2	2008-03-10 22:22:58 UTC (rev 503)
@@ -0,0 +1,797 @@
+# $Id: shunit2 93 2007-07-12 22:44:31Z sfsetse $
+# vim:syntax=sh:sts=2
+# vim:foldmethod=marker:foldmarker=/**,*/
+#
+#/**
+# <?xml version="1.0" encoding="UTF-8"?>
+# <s:shelldoc xmlns:s="http://www.forestent.com/projects/shelldoc/xsl/2005.0">
+# <s:header>
+# shUnit 2.0.3
+# Shell Unit Test Framework
+#
+# http://shunit2.sourceforge.net/
+#
+# written by Kate Ward &lt;kate.ward at forestent.com&gt;
+# released under the LGPL
+#
+# this module implements a xUnit based unit test framework similar to JUnit
+# </s:header>
+#*/
+
+# shell flags for shunit:
+# u - treat unset variables as an error when performing parameter expansion
+__SHUNIT_SHELL_FLAGS='u'
+
+# save the current set of shell flags, and then set some for ourselves
+__shunit_oldShellFlags="$-"
+for _shunit_shellFlag in `echo "${__SHUNIT_SHELL_FLAGS}" |sed 's/\(.\)/\1 /g'`
+do
+  set -${_shunit_shellFlag}
+done
+
+# constants
+
+__SHUNIT_VERSION='2.0.3'
+
+__SHUNIT_TRUE=0
+__SHUNIT_FALSE=1
+
+__SHUNIT_ASSERT_MSG_PREFIX='ASSERT:'
+
+for _su_const in `set |grep "^__SHUNIT_" |cut -d= -f1`; do
+  readonly ${_su_const}
+done
+unset _su_const
+
+# variables
+__shunit_suite=''
+
+__shunit_testsPassed=0
+__shunit_testsFailed=0
+__shunit_testsTotal=0
+
+#-----------------------------------------------------------------------------
+# assert functions
+#
+
+#/**
+# <s:function group="asserts">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>assertEquals</function></funcdef>
+#       <paramdef>string <parameter>[message]</parameter></paramdef>
+#       <paramdef>string <parameter>expected</parameter></paramdef>
+#       <paramdef>string <parameter>actual</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Asserts that <emphasis>expected</emphasis> and
+#   <emphasis>actual</emphasis> are equal to one another. The message is
+#   optional.</para>
+# </entry>
+# </s:function>
+#*/
+assertEquals()
+{
+  _su_message=''
+  if [ $# -eq 3 ]; then
+    _su_message=$1
+    shift
+  fi
+  _su_expected=${1:-}
+  _su_actual=${2:-}
+
+  shunit_return=${__SHUNIT_TRUE}
+  if [ "${_su_expected}" = "${_su_actual}" ]; then
+    _shunit_testPassed
+  else
+    failNotEquals "${_su_message}" "${_su_expected}" "${_su_actual}"
+    shunit_return=${__SHUNIT_FALSE}
+  fi
+
+  unset _su_message _su_expected _su_actual
+  return ${shunit_return}
+}
+
+#/**
+# <s:function group="asserts">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>assertNull</function></funcdef>
+#       <paramdef>string <parameter>[message]</parameter></paramdef>
+#       <paramdef>string <parameter>value</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Asserts that <emphasis>value</emphasis> is <literal>null</literal>,
+#   or in shell terms a zero-length string. The message is optional.</para>
+# </entry>
+# </s:function>
+#*/
+assertNull()
+{
+  if [ $# -eq 2 ]; then
+    assertTrue "$1" "[ -z '$2' ]"
+  else
+    assertTrue "[ -z '${1:-}' ]"
+  fi
+}
+
+#/**
+# <s:function group="asserts">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>assertNotNull</function></funcdef>
+#       <paramdef>string <parameter>[message]</parameter></paramdef>
+#       <paramdef>string <parameter>value</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Asserts that <emphasis>value</emphasis> is <emphasis
+#   role="strong">not</emphasis> <literal>null</literal>, or in shell terms not
+#   a zero-length string. The message is optional.</para>
+# </entry>
+# </s:function>
+#*/
+assertNotNull()
+{
+  if [ $# -eq 2 ]; then
+    assertTrue "$1" "[ -n '$2' ]"
+  else
+    assertTrue "[ -n '${1:-}' ]"
+  fi
+}
+
+#/**
+# <s:function group="asserts">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>assertSame</function></funcdef>
+#       <paramdef>string <parameter>[message]</parameter></paramdef>
+#       <paramdef>string <parameter>expected</parameter></paramdef>
+#       <paramdef>string <parameter>actual</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>This function is functionally equivalent to
+#   <function>assertEquals</function>.</para>
+# </entry>
+# </s:function>
+#*/
+assertSame()
+{
+  assertEquals "${@:-}"
+}
+
+#/**
+# <s:function group="asserts">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>assertNotSame</function></funcdef>
+#       <paramdef>string <parameter>[message]</parameter></paramdef>
+#       <paramdef>string <parameter>unexpected</parameter></paramdef>
+#       <paramdef>string <parameter>actual</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Asserts that <emphasis>unexpected</emphasis> and
+#   <emphasis>actual</emphasis> are <emphasis role="strong">not</emphasis>
+#   equal to one another. The message is optional.</para>
+# </entry>
+# </s:function>
+#*/
+assertNotSame()
+{
+  _su_message=''
+  if [ $# -eq 3 ]; then
+    _su_message=$1
+    shift
+  fi
+  _su_unexpected=${1:-}
+  _su_actual=${2:-}
+
+  shunit_return=${__SHUNIT_TRUE}
+  if [ "${_su_unexpected}" != "${_su_actual}" ]; then
+    _shunit_testPassed
+  else
+    failSame "${_su_message}"
+    shunit_return=${__SHUNIT_FALSE}
+  fi
+
+  unset _su_message _su_unexpected _su_actual
+  return ${shunit_return}
+}
+
+#/**
+# <s:function group="asserts">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>assertTrue</function></funcdef>
+#       <paramdef>string <parameter>[message]</parameter></paramdef>
+#       <paramdef>string <parameter>condition</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Asserts that a given shell test condition is true. The message is
+#   optional.</para>
+#   <para>Testing whether something is true or false is easy enough by using
+#   the assertEquals/assertNotSame functions. Shell supports much more
+#   complicated tests though, and a means to support them was needed. As such,
+#   this function tests that conditions are true or false through evaluation
+#   rather than just looking for a true or false.</para>
+#   <funcsynopsis>
+#     The following test will succeed: <funcsynopsisinfo>assertTrue "[ 34 -gt 23 ]"</funcsynopsisinfo>
+#     The folloing test will fail with a message: <funcsynopsisinfo>assertTrue "test failed" "[ -r '/non/existant/file' ]"</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+assertTrue()
+{
+  _su_message=''
+  if [ $# -eq 2 ]; then
+    _su_message=$1
+    shift
+  fi
+  _su_condition=${1:-}
+
+  shunit_return=${__SHUNIT_TRUE}
+
+  # see if condition is an integer, i.e. a return value
+  _su_match=`expr "${_su_condition}" : '\([0-9]*\)'`
+  if [ -z "${_su_condition}" ]; then
+    # null condition
+    shunit_return=${__SHUNIT_FALSE}
+  elif [ "${_su_condition}" = "${_su_match}" ]; then
+    # possible return value. treating 0 as true, and non-zero as false.
+    [ ${_su_condition} -ne 0 ] && shunit_return=${__SHUNIT_FALSE}
+  else
+    # (hopefully) a condition
+    ( eval ${_su_condition} ) >/dev/null 2>&1
+    [ $? -ne 0 ] && shunit_return=${__SHUNIT_FALSE}
+  fi
+
+  # record the test
+  if [ ${shunit_return} -eq ${__SHUNIT_TRUE} ]; then
+    _shunit_testPassed
+  else
+    _shunit_testFailed "${_su_message}"
+  fi
+
+  unset _su_message _su_condition _su_match
+  return ${shunit_return}
+}
+
+#/**
+# <s:function group="asserts">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>assertFalse</function></funcdef>
+#       <paramdef>string <parameter>[message]</parameter></paramdef>
+#       <paramdef>string <parameter>condition</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Asserts that a given shell test condition is false. The message is
+#   optional.</para>
+#   <para>Testing whether something is true or false is easy enough by using
+#   the assertEquals/assertNotSame functions. Shell supports much more
+#   complicated tests though, and a means to support them was needed. As such,
+#   this function tests that conditions are true or false through evaluation
+#   rather than just looking for a true or false.</para>
+#   <funcsynopsis>
+#     The following test will succeed: <funcsynopsisinfo>assertFalse "[ 'apples' = 'oranges' ]"</funcsynopsisinfo>
+#     The folloing test will fail with a message: <funcsynopsisinfo>assertFalse "test failed" "[ 1 -eq 1 -a 2 -eq 2 ]"</funcsynopsisinfo>
+#   </funcsynopsis>
+# </entry>
+# </s:function>
+#*/
+assertFalse()
+{
+  _su_message=''
+  if [ $# -eq 2 ]; then
+    _su_message=$1
+    shift
+  fi
+  _su_condition=${1:-}
+
+  shunit_return=${__SHUNIT_TRUE}
+
+  # see if condition is an integer, i.e. a return value
+  _su_match=`expr "${_su_condition}" : '\([0-9]*\)'`
+  if [ -z "${_su_condition}" ]; then
+    # null condition
+    shunit_return=${__SHUNIT_FALSE}
+  elif [ "${_su_condition}" = "${_su_match}" ]; then
+    # possible return value. treating 0 as true, and non-zero as false.
+    [ ${_su_condition} -eq 0 ] && shunit_return=${__SHUNIT_FALSE}
+  else
+    # (hopefully) a condition
+    ( eval ${_su_condition} ) >/dev/null 2>&1
+    [ $? -eq 0 ] && shunit_return=${__SHUNIT_FALSE}
+  fi
+
+  # record the test
+  if [ ${shunit_return} -eq ${__SHUNIT_TRUE} ]; then
+    _shunit_testPassed
+  else
+    _shunit_testFailed "${_su_message}"
+  fi
+
+  unset _su_message _su_condition _su_match
+  return ${shunit_return}
+}
+
+#-----------------------------------------------------------------------------
+# failure functions
+#
+
+#/**
+# <s:function group="failures">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>fail</function></funcdef>
+#       <paramdef>string <parameter>[message]</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Fails the test immediately, with the optional message.</para>
+# </entry>
+# </s:function>
+#*/
+fail()
+{
+  _su_message=${1:-}
+
+  _shunit_testFailed "${_su_message}"
+
+  unset _su_message
+}
+
+#/**
+# <s:function group="failures">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>failNotEquals</function></funcdef>
+#       <paramdef>string <parameter>[message]</parameter></paramdef>
+#       <paramdef>string <parameter>unexpected</parameter></paramdef>
+#       <paramdef>string <parameter>actual</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Fails the test if <emphasis>unexpected</emphasis> and
+#   <emphasis>actual</emphasis> are <emphasis role="strong">not</emphasis>
+#   equal to one another. The message is optional.</para>
+# </entry>
+# </s:function>
+#*/
+failNotEquals()
+{
+  _su_message=''
+  if [ $# -eq 3 ]; then
+    _su_message=$1
+    shift
+  fi
+  _su_unexpected=${1:-}
+  _su_actual=${2:-}
+
+  _shunit_testFailed "${_su_message:+${_su_message} }expected:<${_su_unexpected}> but was:<${_su_actual}>"
+
+  unset _su_message _su_unexpected _su_actual
+}
+
+#/**
+# <s:function group="failures">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>failSame</function></funcdef>
+#       <paramdef>string <parameter>[message]</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Indicate test failure because arguments were not the same. The
+#   message is optional.</para>
+# </entry>
+# </s:function>
+#*/
+failSame()
+{
+  _su_message=${1:-}
+
+  _shunit_testFailed "${_su_message:+${_su_message} }expected not same"
+
+  unset _su_message
+}
+
+#/**
+# <s:function group="failures">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>failNotSame</function></funcdef>
+#       <paramdef>string <parameter>[message]</parameter></paramdef>
+#       <paramdef>string <parameter>expected</parameter></paramdef>
+#       <paramdef>string <parameter>actual</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>Fails the test if <emphasis>expected</emphasis> and
+#   <emphasis>actual</emphasis> are equal to one another. The message is
+#   optional.</para>
+# </entry>
+# </s:function>
+#*/
+failNotSame()
+{
+  failNotEquals "${@:-}"
+}
+
+#-----------------------------------------------------------------------------
+# suite functions
+#
+
+#/**
+# <s:function group="suites">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>suite</function></funcdef>
+#       <paramdef />
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>This function can be optionally overridden by the user in their test
+#   suite.</para>
+#   <para>If this function exists, it will be called when
+#   <command>shunit2</command> is sourced. If it does not exist, shUnit2 will
+#   search the parent script for all functions beginning with the word
+#   <literal>test</literal>, and they will be added dynamically to the test
+#   suite.</para>
+# </entry>
+# </s:function>
+#*/
+# Note: see _shunit_mktempFunc() for actual implementation
+# suite() { :; }
+
+#/**
+# <s:function group="suites">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>suite_addTest</function></funcdef>
+#       <paramdef>string <parameter>function</parameter></paramdef>
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>This function adds a function name to the list of tests scheduled for
+#   execution as part of this test suite. This function should only be called
+#   from within the <function>suite()</function> function.</para>
+# </entry>
+# </s:function>
+#*/
+suite_addTest()
+{
+  _su_func=${1:-}
+
+  __shunit_suite="${__shunit_suite:+${__shunit_suite} }${_su_func}"
+
+  unset _su_func
+}
+
+#/**
+# <s:function group="suites">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>oneTimeSetUp</function></funcdef>
+#       <paramdef />
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>This function can be be optionally overridden by the user in their
+#   test suite.</para>
+#   <para>If this function exists, it will be called once before any tests are
+#   run. It is useful to prepare a common environment for all tests.</para>
+# </entry>
+# </s:function>
+#*/
+# Note: see _shunit_mktempFunc() for actual implementation
+# oneTimeSetUp() { :; }
+
+#/**
+# <s:function group="suites">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>oneTimeTearDown</function></funcdef>
+#       <paramdef />
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>This function can be be optionally overridden by the user in their
+#   test suite.</para>
+#   <para>If this function exists, it will be called once after all tests are
+#   completed. It is useful to clean up the environment after all tests.</para>
+# </entry>
+# </s:function>
+#*/
+# Note: see _shunit_mktempFunc() for actual implementation
+# oneTimeTearDown() { :; }
+
+#/**
+# <s:function group="suites">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>setUp</function></funcdef>
+#       <paramdef />
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>This function can be be optionally overridden by the user in their
+#   test suite.</para>
+#   <para>If this function exists, it will be called before each test is run.
+#   It is useful to reset the environment before each test.</para>
+# </entry>
+# </s:function>
+#*/
+# Note: see _shunit_mktempFunc() for actual implementation
+# setUp() { :; }
+
+#/**
+# <s:function group="suites">
+# <entry align="right">
+#   <emphasis>void</emphasis>
+# </entry>
+# <entry>
+#   <funcsynopsis>
+#     <funcprototype>
+#       <funcdef><function>tearDown</function></funcdef>
+#       <paramdef />
+#     </funcprototype>
+#   </funcsynopsis>
+#   <para>This function can be be optionally overridden by the user in their
+#   test suite.</para>
+#   <para>If this function exists, it will be called after each test completes.
+#   It is useful to clean up the environment after each test.</para>
+# </entry>
+# </s:function>
+#*/
+# Note: see _shunit_mktempFunc() for actual implementation
+# tearDown() { :; }
+
+#------------------------------------------------------------------------------
+# internal shUnit2 functions
+#
+
+_shunit_cleanup()
+{
+  name=$1
+
+  case ${name} in
+    EXIT) signal=0 ;;
+    INT) signal=2 ;;
+    TERM) signal=15 ;;
+  esac
+
+  # do our work
+  rm -fr "${__shunit_tmpDir}"
+
+  # exit for all non-EXIT signals
+  if [ ${name} != 'EXIT' ]; then
+    echo "trapped and now handling the ${name} signal" >&2
+    _shunit_generateReport
+    # disable EXIT trap
+    trap 0
+    # add 127 to signal and exit
+    signal=`expr ${signal} + 127`
+    exit ${signal}
+  fi
+}
+
+_shunit_execSuite()
+{
+  echo '#'
+  echo '# Performing tests'
+  echo '#'
+  for _su_func in ${__shunit_suite}; do
+    # execute the per-test setup function
+    setUp
+
+    # execute the test
+    echo "${_su_func}"
+    eval ${_su_func}
+
+    # execute the per-test tear-down function
+    tearDown
+  done
+
+  unset _su_func
+}
+
+_shunit_functionExists()
+{
+  _su__func=$1
+  type ${_su__func} 2>/dev/null |grep "is a function$" >/dev/null
+  _su__return=$?
+  unset _su__func
+  return ${_su__return}
+}
+
+_shunit_generateReport()
+{
+  _su__awkPercent='{printf("%0.0f%%", $1*100/$2)}'
+  if [ ${__shunit_testsTotal} -gt 0 ]; then
+    _su__success=`echo ${__shunit_testsPassed} ${__shunit_testsTotal} |\
+        awk "${_su__awkPercent}"`
+  else
+    _su__success=0
+  fi
+
+  cat <<EOF
+
+#
+# Test report
+#
+tests passed: ${__shunit_testsPassed}
+tests failed: ${__shunit_testsFailed}
+tests total:  ${__shunit_testsTotal}
+success rate: ${_su__success}
+EOF
+
+  unset _su__success
+}
+
+# this function is a cross-platform temporary directory creation tool. not all
+# OSes have the mktemp function, so one is included here.
+_shunit_mktempDir()
+{
+  # try the standard mktemp function
+  ( exec mktemp -dqt shunit.XXXXXX 2>/dev/null ) && return
+
+  # the standard mktemp didn't work.  doing our own.
+  if [ -r '/dev/urandom' ]; then
+    _su__random=`od -vAn -N4 -tx4 </dev/urandom |sed 's/^[^0-9a-f]*//'`
+  elif [ -n "${RANDOM:-}" ]; then
+    # $RANDOM works
+    _su__random=${RANDOM}${RANDOM}${RANDOM}$$
+  else
+    # $RANDOM doesn't work
+    _su__date=`date '+%Y%m%d%H%M%S'`
+    _su__random=`expr ${_su__date} / $$`
+  fi
+
+  _su__tmpDir="${TMPDIR-/tmp}/shunit.${_su__random}"
+  ( umask 077 && mkdir "${_su__tmpDir}" ) || {
+    echo 'shUnit:FATAL could not create temporary directory! exiting' >&2
+    exit 1
+  }
+
+  echo ${_su__tmpDir}
+  unset _su__date _su__random _su__tmpDir
+}
+
+# this function is here to work around issues in Cygwin
+_shunit_mktempFunc()
+{
+  for _su__func in oneTimeSetUp oneTimeTearDown setUp tearDown suite; do
+    _su__file="${__shunit_tmpDir}/${_su__func}"
+    cat <<EOF >"${_su__file}"
+#! /bin/sh
+exit 0
+EOF
+    chmod +x "${_su__file}"
+  done
+
+  unset _su__file
+}
+
+_shunit_testPassed()
+{
+  __shunit_testsPassed=`expr ${__shunit_testsPassed} + 1`
+  __shunit_testsTotal=`expr ${__shunit_testsTotal} + 1`
+}
+
+_shunit_testFailed()
+{
+  _su__msg=$1
+
+  __shunit_testsFailed=`expr ${__shunit_testsFailed} + 1`
+  __shunit_testsTotal=`expr ${__shunit_testsTotal} + 1`
+  echo "${__SHUNIT_ASSERT_MSG_PREFIX}${_su__msg}" >&2
+
+  unset _su__msg
+}
+
+#------------------------------------------------------------------------------
+# main
+#
+
+# create a temporary storage location
+__shunit_tmpDir=`_shunit_mktempDir`
+
+# setup traps to clean up after ourselves
+trap '_shunit_cleanup EXIT' 0
+trap '_shunit_cleanup INT' 2
+trap '_shunit_cleanup TERM' 15
+
+# create phantom functions to work around issues with Cygwin
+_shunit_mktempFunc
+PATH="${__shunit_tmpDir}:${PATH}"
+
+# execute the oneTimeSetUp function (if it exists)
+#_shunit_functionExists oneTimeSetUp && oneTimeSetUp
+oneTimeSetUp
+
+# deprecated: execute the suite function defined in the parent test script
+suite
+
+# if no suite function was defined, dynamically build a list of functions
+if [ -z "${__shunit_suite}" ]; then
+  funcs=`grep "^[ \t]*test[A-Za-z0-9_]* *()" $0 |sed 's/[^A-Za-z0-9_]//g'`
+  for func in ${funcs}; do
+    suite_addTest ${func}
+  done
+fi
+
+# execute the tests
+_shunit_execSuite
+
+# execute the oneTimeTearDown function (if it exists)
+oneTimeTearDown
+
+# generate report
+_shunit_generateReport
+
+# restore the previous set of shell flags
+for _shunit_shellFlag in ${__SHUNIT_SHELL_FLAGS}; do
+  echo ${__shunit_oldShellFlags} |grep ${_shunit_shellFlag} >/dev/null \
+    || set +${_shunit_shellFlag}
+done
+unset _shunit_shellFlag
+
+#/**
+# </s:shelldoc>
+#*/



From fabianx at mail.berlios.de  Tue Mar 11 00:02:45 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Mon, 10 Mar 2008 23:02:45 -0000
Subject: [Freenx-cvs] r512 - in trunk/freenx-server: . trunk
Message-ID: <200803102301.m2AN15en008880@sheep.berlios.de>

Author: fabianx
Date: 2008-03-11 00:01:03 +0100 (Tue, 11 Mar 2008)
New Revision: 512

Added:
   trunk/freenx-server/AUTHORS
   trunk/freenx-server/CONTRIB
   trunk/freenx-server/COPYING
   trunk/freenx-server/ChangeLog
   trunk/freenx-server/INSTALL
   trunk/freenx-server/gentoo-nomachine.diff
   trunk/freenx-server/init.d/
   trunk/freenx-server/node.conf.sample
   trunk/freenx-server/nxcheckload.sample
   trunk/freenx-server/nxcups-gethost
   trunk/freenx-server/nxdesktop_helper
   trunk/freenx-server/nxdialog
   trunk/freenx-server/nxkeygen
   trunk/freenx-server/nxloadconfig
   trunk/freenx-server/nxnode
   trunk/freenx-server/nxnode-login
   trunk/freenx-server/nxprint
   trunk/freenx-server/nxredir/
   trunk/freenx-server/nxserver
   trunk/freenx-server/nxserver-helper/
   trunk/freenx-server/nxsetup
   trunk/freenx-server/nxviewer_helper
Removed:
   trunk/freenx-server/branches/
   trunk/freenx-server/trunk/AUTHORS
   trunk/freenx-server/trunk/CONTRIB
   trunk/freenx-server/trunk/COPYING
   trunk/freenx-server/trunk/ChangeLog
   trunk/freenx-server/trunk/INSTALL
   trunk/freenx-server/trunk/gentoo-nomachine.diff
   trunk/freenx-server/trunk/init.d/
   trunk/freenx-server/trunk/node.conf.sample
   trunk/freenx-server/trunk/nxcheckload.sample
   trunk/freenx-server/trunk/nxcups-gethost
   trunk/freenx-server/trunk/nxdesktop_helper
   trunk/freenx-server/trunk/nxdialog
   trunk/freenx-server/trunk/nxkeygen
   trunk/freenx-server/trunk/nxloadconfig
   trunk/freenx-server/trunk/nxnode
   trunk/freenx-server/trunk/nxnode-login
   trunk/freenx-server/trunk/nxprint
   trunk/freenx-server/trunk/nxredir/
   trunk/freenx-server/trunk/nxserver
   trunk/freenx-server/trunk/nxserver-helper/
   trunk/freenx-server/trunk/nxsetup
   trunk/freenx-server/trunk/nxviewer_helper
Log:
More repository reorganization.



Copied: trunk/freenx-server/AUTHORS (from rev 502, trunk/freenx-server/trunk/AUTHORS)

Copied: trunk/freenx-server/CONTRIB (from rev 502, trunk/freenx-server/trunk/CONTRIB)

Copied: trunk/freenx-server/COPYING (from rev 502, trunk/freenx-server/trunk/COPYING)

Copied: trunk/freenx-server/ChangeLog (from rev 502, trunk/freenx-server/trunk/ChangeLog)

Copied: trunk/freenx-server/INSTALL (from rev 502, trunk/freenx-server/trunk/INSTALL)

Copied: trunk/freenx-server/gentoo-nomachine.diff (from rev 502, trunk/freenx-server/trunk/gentoo-nomachine.diff)

Copied: trunk/freenx-server/init.d (from rev 502, trunk/freenx-server/trunk/init.d)

Copied: trunk/freenx-server/node.conf.sample (from rev 502, trunk/freenx-server/trunk/node.conf.sample)

Copied: trunk/freenx-server/nxcheckload.sample (from rev 502, trunk/freenx-server/trunk/nxcheckload.sample)

Copied: trunk/freenx-server/nxcups-gethost (from rev 502, trunk/freenx-server/trunk/nxcups-gethost)

Copied: trunk/freenx-server/nxdesktop_helper (from rev 502, trunk/freenx-server/trunk/nxdesktop_helper)

Copied: trunk/freenx-server/nxdialog (from rev 502, trunk/freenx-server/trunk/nxdialog)

Copied: trunk/freenx-server/nxkeygen (from rev 502, trunk/freenx-server/trunk/nxkeygen)

Copied: trunk/freenx-server/nxloadconfig (from rev 502, trunk/freenx-server/trunk/nxloadconfig)

Copied: trunk/freenx-server/nxnode (from rev 502, trunk/freenx-server/trunk/nxnode)

Copied: trunk/freenx-server/nxnode-login (from rev 502, trunk/freenx-server/trunk/nxnode-login)

Copied: trunk/freenx-server/nxprint (from rev 502, trunk/freenx-server/trunk/nxprint)

Copied: trunk/freenx-server/nxredir (from rev 502, trunk/freenx-server/trunk/nxredir)

Copied: trunk/freenx-server/nxserver (from rev 502, trunk/freenx-server/trunk/nxserver)

Copied: trunk/freenx-server/nxserver-helper (from rev 502, trunk/freenx-server/trunk/nxserver-helper)

Copied: trunk/freenx-server/nxsetup (from rev 502, trunk/freenx-server/trunk/nxsetup)

Copied: trunk/freenx-server/nxviewer_helper (from rev 502, trunk/freenx-server/trunk/nxviewer_helper)

Deleted: trunk/freenx-server/trunk/AUTHORS
===================================================================
--- trunk/freenx-server/trunk/AUTHORS	2008-03-10 22:59:38 UTC (rev 511)
+++ trunk/freenx-server/trunk/AUTHORS	2008-03-10 23:01:03 UTC (rev 512)
@@ -1,5 +0,0 @@
-Fabian Franz <freenx at fabian-franz.de>
-Rick Stout <zipsonic at gmail.com>
-Thorsten Sandfuchs <fux at users.berlios.de>
-Kurt Pfeifle <pfeifle at kde.org>
-Jon Severinsson <jonno at users.berlios.de>

Deleted: trunk/freenx-server/trunk/CONTRIB
===================================================================
--- trunk/freenx-server/trunk/CONTRIB	2008-03-10 22:59:38 UTC (rev 511)
+++ trunk/freenx-server/trunk/CONTRIB	2008-03-10 23:01:03 UTC (rev 512)
@@ -1,81 +0,0 @@
-III. How you can help
-=====================
-
-1. Documentation
-----------------
-
-Documentation and experience reports are most important of course. So if you have something send it to us ;-). (FreeNX-kNX at kde.org)
-
-2. Code and Patches
--------------------
-
-While FreeNX is a volounteer project, it of course depends on the work of 7 years kindly donated by NoMachine to the Free Software Community: 
-
-The NX open source libraries
-
-While they are mature and very good working, they need work in some very important fields. Most "difficulties" were provided by Gian Fillipo Pinzari main developer of NoMachine NX and CEO of NoMachine.
-
-2.1 Rootless nxagent
-
-This is the most needed feature at the moment. It will allow using single applications instead of a full featured desktop. Most code needed for that is already in the nxagent source tree; its just still a bit buggy and needs some "love".
-
-Difficulty: Medium
-
-2.2 Pseudo Color / True Color support
-
-This is the second most important feature needed. With the addition of Pseudo Color / True Color, it it possible to reconnect also on different depths (which is not possible at the moment). This will also make nxagent independent of the used Visuals (as far as I've understand it).
-
-Last but not least, will this allow me to use Xvfb to keep a session running, while no display is attached to it.
-
-Difficulty: Medium
-
-2.3 XRandr support
-
-XRandr support is available since version XFree86 4.3 and also most applications already support it. XRandr support would also enable one to reconnect at different geometry sizes and you could in an ideal case also just resize the window and it would work.
-
-At reconnection stage this is really important for the fullscreen mode.
-
-Difficulty: Easy
-
-2.4 XDamage support
-
-nxagent should be also able to profit from the new XDamage extension, to allow making NX sessions again even faster. 
-
-Difficulty: Easy
-
-2.5 "Lazy image encoding"
-
-Currently images are sent at once and just limited by having a small control channel open to allow fast user interaction. It would be much better if the images would be "streamed" in a way. 
-
-Quoting GFP:
-
-"> What about doing this asynchronously? Not necessarily doing it immediately,
-> but analyzing (in parallel, the data is still sent with normal compression
-> regardless) what is seen and then biasing the type of compression over
-> time based on the "popularity" of given image characteristics for a
-> specific application or window class.
-
-This is more or less what we want to do as part of the "lazy"
-image encoding functionality that is going to be implemented.
-The main goal of the "lazy" encoding is to decouple the image
-handling from other protocol requests. The effect we want to
-achieve is similar to loading a web page, where the browser
-renders the images progressively, as they are downloaded from
-the network. Once you have images sent asynchrounously, you
-have opened the way to any form of post-processing."
-
-[TODO: This part is not yet explained enough ]
-
-2.6 Drag and Drop with automatic file transfer
-
-The idea is:
-
-Grab the X Drag And Drop requests in nxagent and advise the nxproxy on the other side to stream you the file with the filename, which you have got. The file should then be saved to a temporary location and the event given to the real application. While the file is transferred nxagent should display some kind of status bar.
-
-Difficulty: ~ Medium - Difficult
-
-2.7 Add the GLX extension
-
-Add the glx extension to nxagent and also try to remove roundtrips in GLX.
-
-Difficulty: Easy - Medium

Deleted: trunk/freenx-server/trunk/COPYING
===================================================================
--- trunk/freenx-server/trunk/COPYING	2008-03-10 22:59:38 UTC (rev 511)
+++ trunk/freenx-server/trunk/COPYING	2008-03-10 23:01:03 UTC (rev 512)
@@ -1,340 +0,0 @@
-		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.
-                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Library General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-			    NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-	    How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-
-Also add information on how to contact you by electronic and paper mail.
-
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) year name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Library General
-Public License instead of this License.

Deleted: trunk/freenx-server/trunk/ChangeLog
===================================================================
--- trunk/freenx-server/trunk/ChangeLog	2008-03-10 22:59:38 UTC (rev 511)
+++ trunk/freenx-server/trunk/ChangeLog	2008-03-10 23:01:03 UTC (rev 512)
@@ -1,505 +0,0 @@
-xx.01.2008 FreeNX 0.7.2
-	* Opened the 0.7.2 development.
-	* Fixed the display of local sessions to display only 
-	  when session type is VNC.
-	  (fabianx at bat.berlios.de)
-	* Fixed the issue that commercial NXClient was called with 0 parameters
-	  and such the "Connection Wizard" came up.
-	  (fabianx at bat.berlios.de)
-	* Added freenx-server startup script. You can make a symlink to
-	  /etc/init.d/ to have it start automatically.
-	  (fabianx at bat.berlios.de)
-	* Added catching of exception after failed nscd command.
-	  (fabianx at bat.berlios.de)
-	* Invoke curl with --proxy "" for automatic download of ppd files.
-	  (Wolfgang Schweer <schweer at cityweb.de>)
-	* Reorganized nxsetup to have a function for parsing command line
-	  options.
-	  (fabianx at bat.berlios.de)
-	* Added nxsetup --test to test the configuration and connection to
-	  localhost nxserver.
-	  (fabianx at bat.berlios.de)
-	* Added -o ConnectTimeout 3 to nxnode-login for test-nx case.
-	  (cedric briner <work at infomaniak.ch>)
-	* Added more examples for "failed ssh connection to localhost" cases.
-	  (cedric briner <work at infomaniak.ch>, fabianx at bat.berlios.de)
-	* Fixed helpers (desktop, viewer) to honour the AGENT_EXTRA_OPTIONS_{RDP,RFB}
-	  parameters set in node.conf.
-	  (fabianx at bat.berlios.de)
-	* Fixed the default value for ENABLE_CLIPBOARD="both" instead of ' = '.
-	  (fabianx at bat.berlios.de)
-	* Fixed parsing of SMB port and added a fallback if mport file is empty.
-	  (Patch from Gentoo Portage)
-	* Run nscd only when nscd.pid is present.
-	  (Patch from Gentoo Portage)
-	* Fixed possible bug in nxserver when $USER is not set.
-	  (Patch from Gentoo Portage)
-	* Set ENABLE_USESSION="1" option by default - its hard to find and those who know can
-	  shut it off anyway. Added automatic adding of user nx to group utmp.
-	  (Patch by Gentoo Portage)
-	* Added support for 3.1.0 and later backends. Made 2.0.0 backend the
-	  default and added a fallback to 1.5.0 via the same detection mechanism.
-	  (fabianx at bat.berlios.de)
-	* Added the configuration key ENABLE_PULLDOWN_MENU to be able to
-	  disable the pulldown menu for rootless sessions.
-	  (fabianx at bat.berlios.de)
-	* Fixed a small bug in nxserver when password has spaces at the end or
-	  beginning.
-	  (Dimitar Paskov)
-	* Fixed round-robin mode of load balancing.
-	  (fabianx at bat.berlios.de)
-	* Added check for /tmp/.X11-unix/X*.
-	  (Yves-Ga?l Ch?ny <yves-gael.cheny at tranquil-it-systems.fr>)
-	* Fixed --send|--broadcast for load balancing case.
-	  Note: ssh is used, so you need to either insert your root ssh password 
-	  for the nodes again and again, use a public key + agent or use host keys.
-	  (fabianx at bat.berlios.de)
-	* Added possibility to use the new nxsmb backend. This enables us to support
-	  CIFS and SMB printing at the same time - without recompiling samba -
-	  via the nxredir preload library.
-	  (fabianx at bat.berlios.de)
-
-14.10.2007 FreeNX 0.7.1 "Hip Hop Edition"
-	* Fixed the issue that makes fonts look tiny and unreadable by default 
-	  with freenx and the commercial client. (diamond at google.com)
-	* Added invalidating of NSCD cache after group and user add.
-	  (diamond at google.com)
-	* Added better wording with less misunderstanding to dialog of 
-	  nxclient for Suspend/Terminate/Close case. (diamond at google.com)
-	* Added 'dialog_interface=dialog' option since many installations may 
-	  not have Xdialog and since xmessage is very limiting. This new option 
-	  will work on any machine that has dialog and xterm.
-	  (puterguy at bat.berlios.de)
-	* Fixed the APPLICATION_LIBRARY_PRELOAD to be just a warning and fixed 
-	  the default path. (fabianx at bat.berlios.de)
-	* Added drivers.cache.all that is reloaded just every 60 minutes.
-	  (puterguy at bat.berlios.de)
-	* Fixed missing services stop that lead to redundant mounts and still
-	  running cupsd processes.
-	  (puterguy at bat.berlios.de)
-	* Added support for mount.cifs additionally to the deprecated
-	  smbmount. (fabianx at bat.berlios.de, puterguy at bat.berlios.de)
-	* Added "host" output to --list to see which user is connected to
-	  which server in case of loadbalancing.
-	  (fabianx at bat.berlios.de, Bastian Kames <kames at ibg-monforts.de>)
-	* Fixed nxclient -printer to not use commercial client, because its too 
-	  slow in case of huge databases like foomatic. (fabianx at bat.berlios.de)
-	* Removed bad -noautokill option from the nxclient dialog spawning.
-	  (wayneb at bat.berlios.de)
-	* Added basic support for mirrored sessions.
-	  * The functionality can be used by connecting to VNC session
-	    and choosing to "resume" such a session.
-	  * New configuration key: ENABLE_MIRROR_VIA_VNC=1
-	  * New configuration key: ENABLE_DESKTOP_SHARING=1
-	  (fabianx at bat.berlios.de)
-	* Fixed some portability issues.
-	  * Fixed nxloadconfig in case that COMMAND_X is not only one word,
-	    like "openssl md5".
-	  * Added usage of "openssl md5" instead of "md5sum" by default.
-	  * Changed perl to COMMAND_PERL.
-	  * Removed rev and replaced the code with efficient awk code.
-	  * Added an outcommented way to also use "POSIX find" for history
-	    cleaning.
-	  (Peter O'Gorman <peter at pogma.com>)
-	* Fix ownership of $SSH_AUTHORIZED_KEYS in nxkeygen, just in case
-	  it is run without nxsetup.
-	  (fabianx at bat.berlios.de, thx to sambiase on #nx)
-	* Fixed diverse occurences of $sess_id in nxnode, when hostname
-	  contains whitespace.
-	  (fabianx at bat.berlios.de)
-	* Fixed setting up KDE_PRINTRC altogether if ENABLE_KDE_CUPS is not 1,
-	  and handles errors better when it is but kde-config is not available
-	  or fails.
-	  (scop at bat.berlios.de)
-	* Changed unix:$display -> :$display to enable FreeNX usage with newer
-	  xlib in C (used for example by Novell).
-	  (fabianx at bat.berlios.de)
-	* Enabled 3.0.0 backend with same usage pattern as 2.[0|1].0 backend.
-	  (Shawn Starr <spstarr at kde.org>)
-	* Bumped version number to 2.1.0-71 to let things like File-sharing
-	  port and auxiliary channels work.
-	  (fabianx at bat.berlios.de)
-	* Added parsing of aux parameter. This should remove all keyboard
-	  related problems with nxdesktop with 2.[01].0 backend.
-	  (fabianx at bat.berlios.de)
-	* Renamed nxclient to nxdialog and setup the necessary environment
-	  variable for nxagent to find it.
-	  (fabianx at bat.berlios.de, Thanks to NoMachine for giving this hint)
-	* Added experimental support for usage of external rdesktop and
-	  vncviewer programs.	  
-	  This is for example needed for 3.0.0 backend.
-	  (fabianx at bat.berlios.de)
-	* Changed the default load balancing algorithm to "random"
-	  as the nxcheckload script might not be available.
-	  (fabianx at bat.berlios.de)
-	* Added ENABLE_CLIPBOARD="none|client|server|both" option
-	  to node.conf to disable, restrict or enable the clipboard
-	  synchronization.
-	  (fabianx at bat.berlios.de)
-
-07.07.2007 FreeNX 0.7.0 "Jornade SPL Edition VI+1"
-	* Fixed the printing support for CUPS 1.2.
-	  Older versions of CUPS are no longer supported.
-	  * Note: You must do as root:
-
-	          cp /usr/lib/cups/backend/ipp /usr/lib/cups/backend/nxipp
-		  chmod 755 /usr/lib/cups/backend/nxipp
-
-		  Or alternatively re-run nxsetup.
-
-	* Added foomatic support.
-	  * Note: You might need to do: ln -s /usr/bin/foomatic-ppdfile
-	          /usr/lib/cups/driver/
-	* Added setting of CUPS_SERVER environment var.
-	* Added automatic downloading of PPDs, if the client supports it.
-	* Added configuration vars to tweak the new behaviour.
-	* Added cups seamless support with no "use this driver?" dialogs at all.
-	  * Note: You need nxcupsd-wrapper on the client side for CUPS 1.2
-	          clients.
-
-	          Get it from nxutils repository.
-
-	* Fixed Support for "Running" sessions - again.
-	* Made the NXAgent exited with exit code 1 message more verbose.
-	* Added support for nxipp to nxnode and nxsetup.
-	* Added nxcups-gethost script for automatic usage in KDE.
-	* Fixed RDP/VNC sessions. No application should be started for that type. 
-	  (Patch by Bernard Cafarelli <voyageur at operamail.com>)
-	* Added backingstore fix for older clients from Gentoo.
-	  (http://bugs.gentoo.org/show_bug.cgi?id=149298)
-	* Fixed VNC sessions.
-	* Fixed fullscreen sessions.
-	  (Patch by Gentoo Bugtracker)
-	* Fixed --broadcast.
-	* Added "passwd -u nx" to nxsetup to fix slackware.
-	* Fixed respecting of enconding settings in case of rootless mode.
-	* Fixed smb mounting in case nxclient sends the wrong port. 
-	  (Patch by Jan Lockenvitz <jan.lockenvitz.ext at siemens.com>)
-	* Fixed loadbalancing - was still using an undocumented variable.
-
-23.01.2007 FreeNX 0.6.0 "Juliana birthday edition"
-	* Opened the 0.6.0 branch.
-	* Added nxnode slave mode.
-	* General code cleanup.
-		* Huge cleanup of nxnode.
-	* Removed "no-x11-forwarding" from keys to allow client to use the
-	  faster interactive sessions.
-	* Fixed nxsetup automatic testing of sessions and cleared up
-	  explanations.
-	* Added support for NX 2.0.0 style nxclient dialogs.
-	* Support for NX 2.0.0 backend in nxloadconfig.
-	* Fixed cups printing (added username and password).
-	* Fixed one more stray tail process.
-	* Added example script for "load" based loadbalancing.
-	* Fixed spaces in parameters for NX Client 2.0.0.
-	  (ssycplkbocve at spammotel.com)
-	* Added version 2.1.0 support.
-	* Fixed LD_LIBRARY_PRELOAD default path in nxloadconfig.
-	* Fixed nxclient to work with 2.1.0 backend.
-	* Added autodetection of backend.
-
-01.07.2006 FreeNX 0.5.0 "UKUUG 2006 Edition"
-	* Opened the 0.5.0 branch.
-	* Added load balancing.
-	* Completely removed support for 1.4.0 backend.
-	* Rootless mode is now the default.
-	* Reworked nxnode / suspend on connection failure should work now.
-	* Added support for "Running" sessions.
-	* Fixed --send command. (Emmanuel Blindauer <freenx at mooby.net>)
-	* Fixed resume with nxclient >=1.5.0-106 for Windows.
-	* Fixed rootless sessions with Windows nxclient.
-	* Fixed keyboard issues by enabling the keybd channel.
-	* Fixed one more stray tail process and being able to
-	  cleanup after a hopelessly failed reconnection. (i.e. agent died)
-	* Fixed detection of xauth / netcat. Added option to disable extra
-	  checks.
-	* Fixed --terminate / --suspend when hostname has a '-' in it.
-	  (Emmanuel Blindauer <freenx at mooby.net>)
-	* ESD_NO_SPAWN is always set when ESPEAKER is set.
-	  ("Felipe Alfaro Solana" <felipe.alfaro at gmail.com>)
-	* Added perl replacement for 'rev' function on Sun OS 5.10.
-	* Fixed NODE_AUTOSTART to be unable to block sessions.
-	* Fixed stale sessions introduced by the new session handling model.
-	* Added usage of TCP NODELAY option.
-	* Fixed loadbalancing IP issues.
-	* Added --force-terminate to remove session info.
-	  Fixed issue with suspend/terminate commands.
-	* Added correct errorcode 596 instead of 504.
-	* Implemented "round-robin" and "load" loadbalancing algorithms.
-	  Cleaned up node.conf keys.
-	* Fixed help for --restart.
-	* Fixed session_running function, which fixes all remaining stale
-	  session problems.
-	* Removed termination of nxagent in case of rootless mode.
-	  (Fixes kontact without --nofork)
-	* Last minute fixes for new functions using rev.
-	* Added experimental last minute support for NX 2.0.0 backend.
-	  (set ENABLE_2_0_0_BACKEND=1)
-
-XX.XX.2006 FreeNX 0.4.5 "aKademy Edition"
-	* Made nxsetup more user-friendly and hopefully finally failsafe.
-	* Added --agent to nxnode/nxserver to allow easier debugging.
-	* Added addgroup/groupadd to nxsetup
-	* Added --ignore-errors support on nxsetup/nxloadconfig
-	* Added check for expect.
-
-06.08.2005 FreeNX 0.4.4 "UKUUG Enterprise Edition"
-	* Added ENABLE_1_5_0_BACKEND configuration directive:
-		* Fixed fullscreen support in nxdesktop (still feels more like
-		  'Available Area', but with Ctrl-Alt-F you can get "real"
-		  fullscreen)
-	* Added COMMAND_MD5SUM directive
-	* Security: $USER_FAKE_HOME/.nx now gets 0700
-	* Fixed support for CUPS forwarding.
-	* Added secure re-transmitting to client.
-	* Removed grep from getent to not search through the whole database.
-	  (Suggestion by "Matthew S. Harris" <mharris at google.com>,
-	                 "Ed Warnicke"       <eaw at cisco.com>)
-	* Set sleeps to 60 instead of 10 seconds, removed one wrong trap.
-	  (Suggestion by "Sunil" <funtoos at yahoo.com>)
-	* Made automatic timeout configurable.
-	  (Patch by "Ed Warnicke" <eaw at cisco.com>)
-	* Made nxsetup more enterprise friendly. Added --localuser
-	  (RedHat only) and --gid. 
-	  (Based on a patch by "Ed Warnicke" <eaw at cisco.com>)
-	* Fixed resume of multiple sessions.	
-
-28.07.2005 FreeNX 0.4.3 "NoMachine 1.5.0 Edition"
-	* Fixed reconnection problems with !M 1.5.0 client.
-	* Fixed reconnection problems with !M 1.5.0 backend.
-	* Added evaluation of $NX_ETC_DIR/node.conf.d/* config files.
-	* Fixed a possible security problem. (The client was able
-	  to overwrite parameters set by the server)
-	* Added ENABLE_1_5_0_BACKEND configuration directive:
-		* Added support for fake cookie authentication with
-		  !M 1.5.0 client and 1.5.0 backend.
-		* Fixed nxagent termination problems with !M 1.5.0
-		  backend.
-		* Added RDP highcolor support for !M 1.5.0 client
-		  with !M 1.5.0 backend.
-	* Added secure logging - Passwords are no longer shown in log files.
-	* Security: Certain passwords for VNC/RDP could have been visible via 
-	  `ps aux`.
-	* Added experimental usermode authentication scheme.
-	  (Disabled by default)
-
-16.07.2005 FreeNX 0.4.2 "Solaris / Bugfix / Linux Infotag Pforzheim Edition"
-	* Removed forwarding support via "freenx.<user>", because it was
-	  buggy.
-	* Cleaned up lots of code.
-		* Fixed one case of a left over file.
-		* Removed one unnecessary usage of a temporary file.
-	* Added exit handlers in nxserver and nxnode for more stability on 
-	  reboot of system.
-	* Changed nxnode to be much more stable.
-		* Catched one additional "unclean termination of nxagent" 
-		  case, which lead to "zombie" sessions.
-	* Reworked reconnection support for more stability.
-		* Added displaying of reconnection failure in
-		  system log / client ssh log.
-	* Added even more possibilities to catch and report session startup 
-	  failures.
-	* Fixed PNG and JPEG-levels pack method.
-	* Added usage of netcat -z to check that the port is really not used by
-	  another agent.
-	* Added nxserver --cleanup, which terminates all running sessions.
-	  Useful after a power outage.
-	* Fixed nxclient invocation with non-standard installation path
-	* Added detection of SSH2_CLIENT variable (commercial ssh)
-	* Finally fixed problems with GNOME.
-	* FINALLY added Solaris Support Patch.
-
-24.06.2005 FreeNX 0.4.1 "LinuxTag Edition"
-	* Fixed a small security problem giving access to session database.
-	* Added support for 1.5.0 OSS components. (especially rootless mode)
-	* Fixed Filesharing over the Internet. (Thanks to rogierm at users.berlios.de)
-	* Fixed Resume on Windows with non-fullscreen sessions.
-	* Added suspend/resume support for 1.5.0 OSS components.
-	* Fixed display of suspended sessions in nxserver --list.
-
-04.05.2005 FreeNX 0.4.0 "SambaXP Edition"
-	* Opened the 0.4.0 branch.
-	* Added initial support for filesharing via samba.
-	* Improvements to be more node.conf compatible.
-	* Added COMMAND_NETCAT, COMMAND_SSH & COMMAND_SSH_KEYGEN directive
-	* Added support for 'nxloadconfig --check' to validate node.conf 
-	  settings
-	* Added initial support for sound (esd/artsd).
-	* Added optional support for utmp/wtmp/lastlog database.
-	* Removed support for OSS components prior version 1.4.0 in nxnode.
-	  Added -option option to nxagent/nxdesktop/nxviewer.
-	* Added forwarding to commercial server via destination port.
-	* Added more compatible getparam function
-	* Sets LD_PRELOAD for applications and LD_LIBRARY_PATH for 
-	  nxagent/nxproxy by default.
-		- SET_LD_LIBRARY_PATH replaces NX_NOMACHINE_WAY and is 
-		  enabled by default, as it is now safe to do so
-	* Implemented SSHD_CHECK_IP directive.
-	* Added the SESSION_HISTORY directive. Session history will by default 
-	  be kept for 30 days.
-	* Implemented DEFAULT_X_WM for unix-application virtual desktop mode.
-	* Implemented SESSION_LIMIT and SESSION_USER_LIMIT.
-	* Fixed nxviewer commandline for geometry and fullscreen-support
-	* Added NX_LOG_LEVEL instead of NX_LOGGING, allowing less verbose 
-	  logfile.
-	* Added SESSION_LOG_CLEAN for configurable removal of the temporary 
-	  session directory.
-	* Added "--ssh2" cmdline switch for commercial ssh2-server support 
-	  in nxsetup.
-	* Added ENABLE_FORCE_ENCRYPTION to enforce the usage of encryption on 
-	  the server.
-	* Added nxprint and added -printer to nxclient together with handling
-	  of drivers cache.
-	* Fixed a possible race-condition. (reported by Edward Warnicke
-	  <eaw at cisco.com>)
-	* Feature Request #847 (stderror of some applications to log-file)
-	* Feature Request #900 (Detect ssh/sshd in nxsetup)
-	* Added printing support via userspace CUPSd and Samba.
-
-20.03.2005 FreeNX 0.3.1 "Bugfix Edition"
-	* Fixed keyboard mapping problems.
-	* Fixed unix-custom mode; now allowing parameters to be passed.
-	* Fixed password prompt detection support in nxnode-login.
-	* Fixed locking to prevent usage of the same display.
-	* Fixed resume when agent is no longer there.
-	* Fixed error message shown to user, when session startup fails.
-	* Fixed handling of /tmp/.X*-lock files.
-	* Fixed handling of not closed sessions in "Terminating" status.
-	* Fixed resume of multiple suspended sessions.
-
-05.03.2005 FreeNX 0.3.0 "Chemnitzer LinuxTage Edition"
-	* Initial CVS checkin.
-	* Added unix-default as session type - by Kalev Lember 
-	  <kalev at smartlink.ee>
-	* Fixed nxclient loop - by "Neil Wilson" <neil at aldur.co.uk>.
-	* Several fixes by Thorsten Sandfuchs <fux at users.berlios.de>.
-	* Optional config file support (system- and user-wide)
-		- by Jon Severinsson <jonno at users.berlios.de>.
-	* Moved logfile to /var/log/nxserver.log.
-	* Moved nx homedir to /var/lib/nxserver/home
-	* Complete rewrite of authentication code
-		* passdb, su or ssh is now supported.
-		- by Jon Severinsson <jonno at users.berlios.de>.
-	* Added NODE_AUTOSTART, EXPORT_{USERIP/SESSIONID} config file
-	  directives.
-	* Added mechanism to forward connection to commercial NoMachine 
-	  nxserver (as available from www.nomachine.com).
-	* Added mechanism to forward connection to another nxserver. This
-	  allows using a "chain" of nxservers.
-	* Added "floating window" support by using rootless nxagent as
-	  it will be standard in NX 1.5.0.
-	* Added "floating window" support by just nxproxy/nxproxy connection
-	  and added configuration directive to enable rootless mode.
-	* Added nxsetup --uninstall and added more feature to nxsetup.
-	  Note: You need to use nxsetup --install for installation now.
-	* Added Disabling of port-forwarding, X11-forwarding, ... to ssh-key.
-
-	* Security: Fixed a security blunder. Authority file was not used 
-	            and so basically xhost +localhost was set. (ported from
-		    0.2.8)
-		    
-		    Update immediately.
-                   
-	* Security: Fixed two possible security problems (umask was not set
-                   correctly; ported from 0.2.8)
-
-20.11.2004 FreeNX 0.2.7 "Skolelinux Edition"
-	* Fix nxserver to work again with KNX-Client. ('\r' is evil)
-	* Fix timeout in nxnode-login to allow proper session management
-	  again.
-	* Fixed possible race condition for the wait-file.
-
-11.11.2004 FreeNX 0.2.6
-	
-	* Security: Fixed a possible exploit in ssh-usage
-	    (thanx to Sebastian Krahmer from the SuSE security team)
-	* Important: Public/Private key is no longer used for PAM auth mode.
-	
-14.10.2004 FreeNX 0.2.5
-	* Added Xdialog interface for nxclient and automatic usage
-	  of commercial nxclient when available. (Thx go to Rick Stout 
-	  <zipsonic at gmail.com>)
-	* Added bugfix from the 0.3.0 branch for more flexible nxdesktop in
-	  nxnode.
-	* Added patch by Rick Stout for permission problems in nxnode.
-	* Added patch by Rick Stout for a typo in nxkeygen.
-	* Updated gentoo-nomachine.diff.
-	* Updated CONTRIB to include a description of lazy-image encoding.
-
-11.09.2004 FreeNX 0.2.4
-	* Added timeout to avoid having hanging tail processes.
-	* Added "locking" of the display-offset if nxagent failed to start.
-	* Fixed ssh encryption for resume on client 1.4.0-snapshot 5.
-	* Fixed mktemp, which was non-portable to FreeBSD and Red Hat 9.
-
-10.09.2004 FreeNX 0.2-3
-	* Added support for autoreconnection or autoreconnection just 
-	  for the case when an older client version is used.
-	  	* This makes it possible to use Reconnection with the 
-	  	  stable version 1.3.2-7 (enabled by default)
-	* Added instructions how to install the NoMachine sources to INSTALL
-	* Changed $NX_DIR/bin/ssh to ssh to fix gentoo-nomachine.diff
-	* Added nxkeygen by Stuart Herbert for easier change from the 
-	  NoMachine key to another key afterwards.
-	
-	* Security: Any user was able to change the status of other sessions
-	            in the session database by providing the correct uniqueid.
-
-10.09.2004 FreeNX 0.2-2
-	* Added additional support for safe session suspend, 
-	  autosuspend when network connection times out works now!
-	* AuthorizedKeysFile cannot be safely determined on Gentoo;
-	  changed it to config option now.
-	* Added config option to completely disable passdb support.
-	* Fixed bugs in nxclient dialog frontend.
-	* Removed all usage of nxssh due to security concerns from SuSE. 
-	* Fixed session management for knx client.
-	* Added detection of failed nxagent startup.
-	* Updated the gentoo-nomachine.diff to be not fuzzy.
-
-08.09.2004 FreeNX 0.2-1
-	* Fixed support for one windows client version. 
-	* Fixed setting of key with --adduser.
-	  (Thanks to Stuart Herbert <stuart at gentoo.org>)
-	* Fixed _some_ cases for AuthorizedKeysFile in sshd_config.
-	  (Thanks to Peter Holik <peter at holik.at>)
-
-	* Fixed gentoo-nomachine.diff (nxnode not in path, but nxnode-login would try that)
-	* Fixed the bug with hanging tail processes.
-
-07.09.2004 FreeNX 0.2-0
-	* Reworked the whole security model in nxsetup due to requests from SuSE and Gentoo.
-		- nxsetup does not use the NoMachine key by default. 
-		- PAM authentication is enabled by default.
-	
-	* Added nxclient for compatibility with nxclient -dialog mode.
-	
-	* Minor changes
-		* Added SSHD_AUTH_PORT to config vars in nxserver
-		* Made all programs NX_ aware
-		* Programs do now honor the setting of AuthorizedKeysFile in sshd_config
-		* Changed nxsetup check from direct reading of passwd to getent
-		  (Thanks to Tom Hibbert <tom at nsp.co.nz>)
-		* Changed overall messages in nxsetup
-	
-	* Made a overall clean upstream package.
-	* Added Gentoo / NoMachine compatibility diff
-
-06.09.2004 
-	* Added pam authentication
-	* Added user_db switch
-	* moved some su - to nxnode-login
-
-02.09.2004 
-	* Added support for snapshot 4 (43/66)
-	* Fixed compatibility issue with 1.3.0 
-	  (Used by Knoppix 3.4 and earlier)
-	* added sane logging (LOGGING is now properly used)
-
-20.06.2004 
-	* Added Protocol version 1.4.0
-	* Cleanup
-	* Added missing functions
-
-14.06.2004 
-	* Added Protocol version 1.3.2

Deleted: trunk/freenx-server/trunk/INSTALL
===================================================================
--- trunk/freenx-server/trunk/INSTALL	2008-03-10 22:59:38 UTC (rev 511)
+++ trunk/freenx-server/trunk/INSTALL	2008-03-10 23:01:03 UTC (rev 512)
@@ -1,79 +0,0 @@
-INTRODUCTION
-------------
-
-This is the FreeNX server package.
-
-DEPENDENCIES
-------------
-
-It depends on:
-
-- NX sources
-- X11 libraries
-- sshd
-- expect
-- netcat
-
-NOTE
-----
-
-This tarball is intented mainly for distributions, which want to use FreeNX as building the other OpenSource NX components is quite difficult.
-
-In the following sections it is outlined how to install FreeNX as soon as you've build all open source components. 
-
-HOWTO MANUALLY INSTALL
-----------------------
-
-The easy way:
-
-See: http://mail.kde.org/pipermail/freenx-knx/2007-October/006041.html
-
-The real way:
-
-You must apply the gentoo-nomachine.diff and then copy the files to /usr/NX/bin and /usr/NX/lib.
-
-You can use the following schema to do the install to /usr/NX/:
-
-NXPREFIX=/usr/NX
-mkdir -p ${NXPREFIX}/lib ${NXPREFIX}/bin
-
-# Libraries
-cp -a nx-X11/lib/X11/libX11.so* ${NXPREFIX}/lib
-cp -a nx-X11/lib/Xext/libXext.so* ${NXPREFIX}/lib
-cp -a nx-X11/lib/Xrender/libXrender.so* ${NXPREFIX}/lib
-cp -a nxcomp/libXcomp.so* ${NXPREFIX}/lib
-cp -a nxcompext/libXcompext.so* ${NXPREFIX}/lib
-
-# binaries
-cp -a nx-X11/programs/Xserver/nxagent ${NXPREFIX}/bin
-cp -a nxproxy/nxproxy ${NXPREFIX}/bin
-cp -a nxdesktop/nxdesktop ${NXPREFIX}/bin
-cp -a nxviewer/nxviewer/nxviewer ${NXPREFIX}/bin
-cp -a nxviewer/nxpasswd/nxpasswd ${NXPREFIX}/bin
-
-# windows-keymaps for nxdesktop RDP-sessions and keyboard layout != us
-cd nxdesktop
-make installkeymaps
-
-# scripts
-cp -a freenx*/nxnode ${NXPREFIX}/bin
-cp -a freenx*/nxserver ${NXPREFIX}/bin
-cp -a freenx*/nxsetup ${NXPREFIX}/bin
-cp -a freenx*/nxkeygen ${NXPREFIX}/bin
-cp -a freenx*/nxnode-login ${NXPREFIX}/bin
-cp -a freenx*/nxloadconfig ${NXPREFIX}/bin
-cp -a freenx*/nxprint ${NXPREFIX}/bin
-cp -a freenx*/nxclient ${NXPREFIX}/bin
-
-# config file
-cp -a freenx*/node.conf.sample ${NXPREFIX}/etc/
-
-You should also install the nxclient from NoMachine or also copy the nxclient program from freenx. 
-
-Then you need to run 'nxsetup --install' and follow the instructions given.
-
-If you use 1.5.0 as backend be sure to set ENABLE_1_5_0_BACKEND to 1 in node.conf or nxloadconfig.
-
---
-
-SVN: $Id$

Deleted: trunk/freenx-server/trunk/gentoo-nomachine.diff
===================================================================
--- trunk/freenx-server/trunk/gentoo-nomachine.diff	2008-03-10 22:59:38 UTC (rev 511)
+++ trunk/freenx-server/trunk/gentoo-nomachine.diff	2008-03-10 23:01:03 UTC (rev 512)
@@ -1,19 +0,0 @@
---- nxloadconfig.old	2005-02-14 01:08:56.482546352 +0100
-+++ nxloadconfig	2005-02-14 01:09:40.109913984 +0100
-@@ -56,12 +56,12 @@
- NX_LICENSE="OS (GPL)"
- 
- # Where can different nx components be found
--NX_DIR=/usr
-+NX_DIR=/usr/NX
- PATH_BIN=$NX_DIR/bin # if you change that, be sure to also change the public keys
- PATH_LIB=$NX_DIR/lib
--NX_ETC_DIR=/etc/nxserver
--NX_SESS_DIR=/var/lib/nxserver/db
--NX_HOME_DIR=/var/lib/nxserver/home
-+NX_ETC_DIR=$NX_DIR/etc
-+NX_SESS_DIR=$NX_DIR/var/db
-+NX_HOME_DIR=$NX_DIR/home/nx
- 
- # Advanced users ONLY
- AGENT_LIBRARY_PATH="" #Calculated

Deleted: trunk/freenx-server/trunk/node.conf.sample
===================================================================
--- trunk/freenx-server/trunk/node.conf.sample	2008-03-10 22:59:38 UTC (rev 511)
+++ trunk/freenx-server/trunk/node.conf.sample	2008-03-10 23:01:03 UTC (rev 512)
@@ -1,531 +0,0 @@
-# node.conf
-#
-# This file is provided by FreeNX. It should be placed either into
-# /etc/nxserver/node.conf (FreeNX style) or /usr/NX/etc/node.conf
-# (NoMachine NX style).
-#
-# It is mostly compatible with NoMachine node.conf. The most important 
-# difference is that no spaces are allowed when assigning values (eg 
-# "A=value" is allowed, "A = value" is NOT).
-#
-# This file is sourced by bash, so you can do some fancy stuff here if you
-# want to, but be aware that it is sourced 3 times per connection. If you 
-# want autostart stuff, set NODE_AUTOSTART instead!
-# 
-#
-# You surely are aware that FreeNX is based on the fantastic results that
-# the hard work by NoMachine.com has achieved. NoMachine.com released the
-# core NX libraries under the GPL. The installation of these libs are the
-# precondition for all FreeNX scripts to work. If you are installing this
-# software with the help of one of the package management tools of your
-# Linux distribution, you can assume that this dependency is taken care of
-# by the tool.
-#
-# You have questions about the inner workings of the NX technology?
-#
-# Then you are recommended to first check out the rich and very detailed
-# NoMachine documentation and their online Knowledge Base at 
-#
-#           http://www.nomachine.com/kb/
-#
-# Other sources of information are the NoMachine mailing lists 
-# (nxusers at nomachine.com and nxdevelopers at nomachine.com):
-#
-#           http://www.nomachine.com/mailinglists.php
-#
-# The FreeNX (freenx-knx at kde.org) list is here:
-#
-#           https://mail.kde.org/mailman/listinfo/freenx-knx
-#
-# SVN: $Id$
-
-#########################################################################
-# General FreeNX directives
-#########################################################################
-
-# The host name which is used by NX server. It's should be used if it's
-# different than the default hostname (as returned by `hostname`)
-#SERVER_NAME="$(hostname)"
-
-# The port number where local 'sshd' is listening.
-#SSHD_PORT=22
-
-
-#########################################################################
-# Authentication / Security directives
-#########################################################################
-
-# Authentication directives
-
-# This adds the usermode to the possible authentication methods
-# Usermode means that a user can start the nxserver as his shell
-# and connect directly to the right server via a custom client.
-#ENABLE_USERMODE_AUTHENTICATION="0"
-
-# This adds the passdb to the possible authentication methods
-#ENABLE_PASSDB_AUTHENTICATION="1"
-
-# This adds SSH to the possible authentication methods. For it to work sshd
-# must be set up at localhost accepting password authentication.
-#ENABLE_SSH_AUTHENTICATION="1"
-
-# This adds SU to the possible authentication methods. For it to work the 
-# "nx" user must be in the wheel (RedHat, Fedora) or the users group (SUSE)
-# and the user logging in must have a valid shell that accepts the -c
-# parameter.
-#ENABLE_SU_AUTHENTICATION="0"
-
-# Require all users to be in the passdb, regardless of authentication method
-#ENABLE_USER_DB="0"
-
-
-# If enabled forces the user to use encryption. This will bail out
-# if the user does not have encryption enabled.
-#ENABLE_FORCE_ENCRYPTION="0"
-
-# Refuse the NX client connection if SSHD does not export the
-# SSH_CONNECTION and SSH_CLIENT variables in the environment
-# passed to the NX server.
-# 1: Will check the remote IP and will not accept the
-#    connection if it can't be determined.
-# 0: Will accept the connection even if the remote IP
-#    is not provided.
-#SSHD_CHECK_IP="0"
-
-
-#########################################################################
-# Restriction directives
-#########################################################################
-
-# The base display number from which sessions are started.
-#DISPLAY_BASE=1000
-
-# The maximum number of contemporary sessions that can be run on FreeNX
-#SESSION_LIMIT=200
-
-# The maximum number of contemporary sessions that a single user can run
-# on FreeNX. Defaults to the value of SESSION_LIMIT.
-#SESSION_USER_LIMIT=200
-
-# The number of displays reserved for sessions, it has to be greater or equal
-# to the maximum number of contemporary sessions that a server can run.
-#DISPLAY_LIMIT=200
-
-
-# User for which sessions should be persistent. Either the keyword "all" or a
-# comma-separated list of usernames or groups in the @groupname syntax.
-#ENABLE_PERSISTENT_SESSION="all"
-
-# Users and groups for whom persistent sessions should be disabled.
-# Especially useful if ENABLE_PERSISTENT_SESSION="all"
-#DISABLE_PERSISTENT_SESSION=""
-
-# This enables the mirroring of running sessions via VNC feature.
-# 
-# Session is marked as resumable and type is vnc-mirrored.
-# 
-#ENABLE_MIRROR_VIA_VNC=1
-
-# This enables the sharing of :0 via VNC feature.
-# 
-# Session is marked as resumable and type is vnc-local.
-# 
-# Note: You need to have the rights to access the display
-#       else it does not work.
-#
-#ENABLE_DESKTOP_SHARING=1
-
-#
-# Enable or disable clipboard:
-#
-# client:  The content copied on the client can be pasted inside the
-#            NX session.
-#
-# server: The content copied inside the NX session can be pasted
-#             on the client.
-#
-# both:    The copy&paste operations are allowed both between the
-#             client and the NX session and vice-versa.
-#
-# none:   The copy&paste operations between the client and the NX
-#            session are never allowed.
-#
-#ENABLE_CLIPBOARD="both"
-
-
-#
-# Enable or disable the pulldown dialog, which provides a graphical
-# way to suspend or terminate the rootless session:
-#
-# 1: Enabled. The pulldown menu is shown when the mouse pointer
-#     moves near the middle of the top boundary of a window and
-#     allows the user to suspend or terminate the session by means
-#     of an icon-click.
-#
-# 0: Disabled. The ctrl+alt+T key combination has to be issued
-#     to get the dialog for suspending or terminating the session.
-#
-#ENABLE_PULLDOWN_MENU="1"
-
-#########################################################################
-# Logging directives
-#########################################################################
-
-# This directives controls the verbosity of the server-wide log.
-# 0: No Logging
-# 1: Errors
-# 2: Warnings
-# 3: Important information
-# 4: Server - Client communication
-# 5: Information
-# 6: Debugging information
-# 7: stderror of some applications
-#NX_LOG_LEVEL=0
-
-# By setting this to 0 the nxserver might be a bit faster, but passwords can be found in the log files.
-#NX_LOG_SECURE=1
-
-# Before turning logging on, please make sure that NX_LOGFILE is
-# writeable for the "nx" user
-#NX_LOGFILE=/var/log/nxserver.log
-
-# This directive controls if the temporary session directory
-# ($HOME/.nx/C-<hostname>-<display>-<session_id>) should be kept after a
-# session has ended. A successfully terminated session will be saved as
-# T-C-<hostname>-<display>-<session_id> while a failed session will be saved
-# as F-C-<hostname>-<display>-<session_id>.
-# The default is to cleanup the directories.
-#SESSION_LOG_CLEAN=1
-
-# Amount of seconds nxserver is to keep session history. The default of 2592000
-# is equivalent to 30 days. If this is 0 no session history will be kept
-# and a negative value denotes infinity.
-#SESSION_HISTORY=2592000
-
-
-#########################################################################
-# Forwarding directives
-#########################################################################
-
-# FreeNX with ENABLE_SERVER_FORWARD="1" will automatically forward all
-# connections to the host specified in SERVER_FORWARD_HOST with the
-# secret key SERVER_FORWARD_KEY.
-#
-# This allows to have a "chain" of NX Servers. Note that you will need to
-# use "SSL encryption" for all connections.
-
-#ENABLE_SERVER_FORWARD="0"
-#SERVER_FORWARD_HOST=""
-#SERVER_FORWARD_PORT=22
-#SERVER_FORWARD_KEY="/usr/NX/share/client.id_dsa.key"
-
-
-# FreeNX with ENABLE_NOMACHINE_FORWARD_PORT="1" will automatically forward all
-# connections to the commercial NoMachine nxserver installed on the same
-# machine, which go in by port NOMACHINE_FORWARD_PORT. This feature is introduced
-# to enable the usage of FreeNX and NoMachine NX side by side on the same machine
-# without conflicts.
-#
-# Note: You need to let SSHD listen to several ports to make use of this
-#       directive.
-
-#ENABLE_NOMACHINE_FORWARD_PORT="0"
-#NOMACHINE_FORWARD_PORT="22"
-
-#NOMACHINE_SERVER="/usr/NX/bin/nxserver"
-#NOMACHINE_NX_HOME_DIR="/usr/NX/home/nx"
-
-
-# LOAD BALANCING
-# ==============
-#
-# To do load balancing setup some hosts in LOAD_BALANCE_SERVERS and
-# make:
-#
-#   - either sure that all incoming connections are sent to the master
-#     server by using forwarding directives on the "slave" servers.
-#
-#   - or share the session database space via NFS between the servers.
-#     (not recommended at the moment as race conditions for DISPLAYs can 
-#      occur)
-#
-
-#LOAD_BALANCE_SERVERS=""
-
-# The following load_balance_algorithms are available at the moment:
-#
-# "load", "round-robin", "random"
-#
-# For "load" you need a script called nxcheckload in PATH_BIN.
-# 
-# A sample script, which you can change to your needs it shipped with
-# FreeNX under the name nxcheckload.sample.
-
-#LOAD_BALANCE_ALGORITHM="random"
-
-# By setting ENABLE_LOADBALANCE="1" you can let users choose their
-# preferred host, while being forwarded to another server. Of course
-# this is just a preference. The loadbalancing algorithm can completely
-# choose to ignore the users choice.
-
-#ENABLE_LOAD_BALANCE_PREFERENCE="0"
-
-#########################################################################
-# Services directives
-#########################################################################
-
-# FreeNX with ENABLE_ESD_PRELOAD="1" will automatically try to setup
-# the sound with the help of the esd media helper.
-#
-# Currently ESD will be used just by the Windows NX Client.
-#
-# Be sure that $ESD_BIN_PRELOAD is in your path, does exist and work
-# before enabling this directive.
-
-#ENABLE_ESD_PRELOAD="0"
-#ESD_BIN_PRELOAD="esddsp"
-
-# FreeNX with ENABLE_ARTSD_PRELOAD="1" will automatically try to setup
-# the sound with the help of the artsd media helper.
-#
-# Currently ARTSD will be used just by the Linux NX Client.
-#
-# Be sure that $ARTSD_BIN_PRELOAD is in your path, does exist and work
-# before enabling this directive.
-
-#ENABLE_ARTSD_PRELOAD="0"
-#ARTSD_BIN_PRELOAD="artsdsp"
-
-# FreeNX with ENABLE_KDE_CUPS="1" will automatically write 
-# $KDE_PRINTRC and put the current used socket into it.
-#
-# If you additionally enable ENABLE_KDE_CUPS_DYNAMIC it will set the 
-# Host entry to the script nxcups-gethost, which dynamically tries all 
-# possible entries to find the current printing host.
-#
-# The order is: CUPS_SERVER (env var), ~/.cups/client.conf, $KDE_PRINTRC,
-#               $CUPS_DEFAULT_SOCK, localhost
-#
-# So this option is most useful with ENABLE_CUPS_SERVER_EXPORT="1".
-# 
-# $KDE_PRINTRC is automatically calculated if its not set.
-
-#ENABLE_KDE_CUPS="0"
-#ENABLE_KDE_CUPS_DYNAMIC="0"
-#KDE_PRINTRC="$KDEHOME/share/config/kdeprintrc"
-
-# FreeNX with ENABLE_CUPS_SERVER_EXPORT="1" will automatically
-# export the environment variable CUPS_SERVER.
-
-#ENABLE_CUPS_SERVER_EXPORT="1"
-
-# FreeNX with ENABLE_CUPS_SEAMLESS will automatically try to download the 
-# necessary ppds from the client.
-# 
-# As the forwarding is just active as soon as nxagent is started,
-# we need a small delay of $CUPS_SEAMLESS_DELAY.
-#
-# Note: You need to use a patched cupsd on client side.
-
-#ENABLE_CUPS_SEAMLESS="0"
-#CUPS_SEAMLESS_DELAY="10"
-
-# FreeNX with ENABLE_FOOMATIC will integrate the foomatic db to the list
-# of available ppd drivers via the $COMMAND_FOOMATIC command.
-
-#ENABLE_FOOMATIC="1"
-#COMMAND_FOOMATIC="/usr/lib/cups/driver/foomatic-ppdfile"
-
-# CUPS_BACKEND and CUPS_ETC are the corresponding paths of your CUPS 
-# installation.
-
-#CUPS_BACKEND="/usr/lib/cups/backend"
-#CUPS_IPP_BACKEND="$CUPS_BACKEND/nxipp"
-#CUPS_DEFAULT_SOCK="/var/run/cups/cups.sock"
-#CUPS_ETC="/etc/cups"
-
-# SAMBA_MOUNT_SHARE_PROTOCOL is a key to configure the supported 
-# protocols for mounting shares.
-#
-# This key can be set to the following values:
-#
-# both, either SMB and CIFS protocol are supported, this is the default value.
-# smbfs, only SMB protocol is supported.
-# cifs, only CIFS protocol is supported.
-# none, no network file-sharing protocol is supported.
-
-#SAMBA_MOUNT_SHARE_PROTOCOL="both"
-
-#########################################################################
-# Path directives
-#########################################################################
-
-# USER_FAKE_HOME is the base directory for the .nx directory. Use this
-# parameter instead of the users home directory if $HOME is on a NFS share.
-# Note that this directory must be unique for every user! To accomplish this
-# it is recommended to include $USER in the path.
-#USER_FAKE_HOME=$HOME
-
-# Add the nx libraries to LD_LIBRARY_PATH before starting nx agents.
-# WARNING: This will NOT (and should not) affect applications. ONLY Disable
-# this if the nx libraries are in a standard system path (such as /usr/lib)!
-#SET_LD_LIBRARY_PATH="1"
-
-
-# The command binary for the default window manager. If set it is run when a
-# 'unix-custom' session is requested by the NX Client and an application
-# to run is specified. It defaults to empty (ie no WM is run).
-# If KILL_DEFAULT_X_WM is set the WM is terminated after the started 
-# application finishes. Else FreeNX will wait for the WM to complete.
-#DEFAULT_X_WM=""
-#KILL_DEFAULT_X_WM="1"
-
-# When a 'unix-default' session is requested by the client the user's X startup
-# script will be run if pressent and executable, otherwise the default X
-# session will be run.
-# Depending on distribution USER_X_STARTUP_SCRIPT might be .Xclients, .xinitrc
-# and .Xsession
-# Depending on distribution DEFAULT_X_SESSION might be /etc/X11/xdm/Xsession,
-# /etc/X11/Sessions/Xsession or /etc/X11/xinit/xinitrc
-#USER_X_STARTUP_SCRIPT=.Xclients
-#DEFAULT_X_SESSION=/etc/X11/xdm/Xsession
-
-# The key that contains the name of the script that starts a KDE session.
-# It's run when a 'unix-kde' session is requested by the client.
-#COMMAND_START_KDE=startkde
-
-# The key that contains the name of the script that starts a gnome session.
-# It's run when a 'unix-gnome' session is requested by the client.
-#COMMAND_START_GNOME=gnome-session
-
-# The key that contains the name of the script that starts a CDE session.
-# It's run when a 'unix-cde' session is requested by the client.
-#COMMAND_START_CDE=cdwm
-
-# The key that contains the name of the complete path of command name
-# 'xterm'. It is run when a unix "xterm" session is requested by the
-# client.
-#COMMAND_XTERM=xterm
-
-# The key that contains the name of the complete path of command name
-# 'xauth'.
-#COMMAND_XAUTH=/usr/X11R6/bin/xauth
-
-# The key that contains the name of the complete path of command name
-# 'smbmount'.
-#COMMAND_SMBMOUNT=smbmount
-
-# The key that contains the name of the complete path of command name
-# 'smbumount'.
-#COMMAND_SMBUMOUNT=smbumount
-
-# The key that contains the name of the complete path of command name
-# 'mount.cifs'.
-#COMMAND_SMBMOUNT_CIFS=/sbin/mount.cifs
-
-# The key that contains the name of the complete path of command name
-# 'umount.cifs'.
-#COMMAND_SMBUMOUNT_CIFS=/sbin/umount.cifs
-
-# The key that contains the name of the complete path of the 'netcat' command.
-#COMMAND_NETCAT=netcat
-
-# The key that contains the name of the complete path of the 'ssh' and
-# 'ssh-keygen' command.
-#COMMAND_SSH=ssh
-#COMMAND_SSH_KEYGEN=ssh-keygen
-
-# The key that contains the name of the complete path of the 'cupsd' command.
-#COMMAND_CUPSD=/usr/sbin/cupsd
-
-# The tool to generate md5sums with
-#COMMAND_MD5SUM="openssl md5"
-
-# The key that contains the name of the complete path of the 'rdesktop' command.
-#COMMAND_RDESKTOP=rdesktop
-
-# The key that contains the name of the complete path of the 'vncviewer' command.
-#COMMAND_VNCVIEWER=vncviewer
-
-# The key that contains the name of the complete path of the 'vncpasswd' command.
-# By default the builtin nxpasswd is used.
-#COMMAND_VNCPASSWD="$PATH_BIN/nxpasswd"
-
-# The key that contains the name of the complete path of the 'x11vnc' command.
-#COMMAND_X11VNC=x11vnc
-
-#########################################################################
-# Misc directives
-#########################################################################
-
-# When you installed an old 1.5.0 NX Backend, set this to 1.
-#ENABLE_1_5_0_BACKEND="0"
-
-# When set to 1 this will automatically resume started sessions
-#ENABLE_AUTORECONNECT="0"
-
-# When set to 1 this will automatically resume started sessions
-# but only if an older client version is used
-#ENABLE_AUTORECONNECT_BEFORE_140="1"
-
-# When set to 1 exports NXUSERIP / NXSESSIONID in nxnode
-#EXPORT_USERIP="0"
-#EXPORT_SESSIONID="1"
-
-# This can be set to any executable, which is started after session startup
-# like: $NODE_AUTOSTART {start|restore}
-#NODE_AUTOSTART=""
-
-# When set to 1 will start nxagent in rootless mode.
-#ENABLE_ROOTLESS_MODE="1"
-
-# If enabled writes entries via the COMMAND_SESSREG program
-# into utmp/wtmp/lastlog database.
-# Note: You have to make sure that you add the nx user to the
-#       utmp or tty group or how its called on your system
-#       before this directive works.
-#ENABLE_USESSION="1"
-#COMMAND_SESSREG="sessreg"
-
-# Extra options sent to the different nx agents. See !M documentation
-# for examples of useful parameters.
-#AGENT_EXTRA_OPTIONS_RFB=""
-#AGENT_EXTRA_OPTIONS_RDP=""
-#AGENT_EXTRA_OPTIONS_X=""
-
-# The number of seconds we wait for the nxagent to start before
-# deciding startup has failed
-#AGENT_STARTUP_TIMEOUT="60"
-
-# The font server the agent will use. If set to "" no font server is used.
-# For this to do any good, the client has to have the same font server set
-# in /etc/X11/XF86Config
-#AGENT_FONT_SERVER=""
-
-# Disable or enable use of 'tcp nodelay' on proxy. Old versions of Linux
-# kernels have problems using this option on sockets that will cause a loss
-# of TCP connections. This option is not set by default to allow clients to
-# specify whether to enable or disable TCP nodelay. Setting this option to
-# the value of "0" NX proxy avoids using 'tcp nodelay' but it will cause a
-# loss of interaction in sessions.
-#PROXY_TCP_NODELAY=""
-
-# Extra options to nxproxy. See !M documentation for useful parameters.
-#PROXY_EXTRA_OPTIONS=""
-
-# In case you want to use an external 'rdesktop' command
-# set this to "1".
-# 
-# If nxdesktop cannot be found this is set automatically to "1".
-#ENABLE_EXTERNAL_NXDESKTOP="0"
-
-# This configuration variable determines if 'rdesktop' command should be run with -k keyboard option
-# or if the keyboard should be autodetected.
-#
-#ENABLE_EXTERNAL_NXDESKTOP_KEYBOARD="1"
-
-# In case you want to use an external 'nxviewer' command
-# set this to "1".
-# 
-# If nxviewer cannot be found this is set automatically to "1".
-#ENABLE_EXTERNAL_NXVIEWER="0"

Deleted: trunk/freenx-server/trunk/nxcheckload.sample
===================================================================
--- trunk/freenx-server/trunk/nxcheckload.sample	2008-03-10 22:59:38 UTC (rev 511)
+++ trunk/freenx-server/trunk/nxcheckload.sample	2008-03-10 23:01:03 UTC (rev 512)
@@ -1,68 +0,0 @@
-#!/bin/sh
-#
-# nxcheckload - sample script for calculation of the load for a node.
-#
-# Version 0.5
-#
-# Under GPL
-#
-# Jonathan "Arrouan" ROUZAUD-CORNABAS (rouzaud.jonathan at gmail.com)
-#
-# Fabian Franz <FreeNX at fabian-franz.de>
-#
-# 0.5
-#  - Rewrote huge parts
-#
-# Change between 0.3 and 0.4
-#   - Add of TMP_FILE
-#   - Add of lock file to avoid two run at once.
-#
-# Change between 0.2 and 0.3
-#   - SMP support.
-#
-
-if [ "$1" != "" ]
-then
-	# Connect to a remote node
-	
-	# Note: This is a ssh sample, you'll need to tweak it for your setup
-	#       and setup the secret keys for yourself.
-	
-	#exec $COMMAND_SSH nxcal@"$1" "$PATH_BIN/nxcheckload"
-	
-	# Note: This is a netcat example. You need to have nxcheckload running through 
-	# netpipes or netcat like follows:
-	# 	node1:~$ faucet 9876 -io $PATH_BIN/nxcheckload
-	#
-	# Connect to another node running the load-service on some port.
-	#
-	
-	#exec $COMMAND_NETCAT "$1" 9876
-
-	# Same as loadbalance_rr_random
-	# pick a node by random.
-	
-	echo $RANDOM
-	exit 0
-fi
-
-# Be sure to use C numeric for calculations
-export LC_NUMERIC=C
-
-# The 3 variables of load from uptime
-LOADXX=$(awk '{ printf("(100-%s)+(100-%s)+(100-%s)\n", $1, $2, $3); }' /proc/loadavg | bc -q)
-
-# Add of total memory and free memory
-Mt=$(awk 'BEGIN { N=0 } /MemTotal|MemFree/ { N+=$2; } END { print N }' /proc/meminfo)
-
-# NBCPU = number of CPU
-NBCPU=$(cat /proc/cpuinfo | grep ^processor | wc -l)
-
-# CPU = Mhz of the CPU
-CPU=$(cat /proc/cpuinfo | grep "cpu MHz" | head -n1 | cut -d':' -f2 | cut -d' ' -f2)
-
-# Number of Xorg already launch and running.
-UNB=$(ps aux | grep Xorg | grep -v grep | wc -l)
-
-# Final calcul of the number of load.
-echo "100 * $LOADXX + $Mt + ( $NBCPU * $CPU ) / 100 + $UNB * 100" | bc -q | cut -d. -f1

Deleted: trunk/freenx-server/trunk/nxcups-gethost
===================================================================
--- trunk/freenx-server/trunk/nxcups-gethost	2008-03-10 22:59:38 UTC (rev 511)
+++ trunk/freenx-server/trunk/nxcups-gethost	2008-03-10 23:01:03 UTC (rev 512)
@@ -1,23 +0,0 @@
-#!/bin/sh
-
-# Read the config file
-. $(PATH=$(cd $(dirname $0) && pwd):$PATH which nxloadconfig) --userconf
-
-CUPS_HOST=""
-
-# see if environment is helpful
-[ -n "$CUPS_SERVER" ] && CUPS_HOST=$CUPS_SERVER
-
-# no, lets see if the user has a cups config file
-[ -z "$CUPS_HOST" -a -f "$HOME/.cups/client.conf" ] && CUPS_HOST=$(grep "^ServerName " "$HOME/.cups/client.conf" | sed 's/^ServerName //g; s/#.*//g')
-
-# not even close, so lets use the kdeprintrcs configuration key
-[ -z "$CUPS_HOST" ] && CUPS_HOST=$(grep "^Host=" "$KDE_PRINTRC" | cut -d'=' -f2)
-
-# Hm, perhaps there is a global cupsd running on this host
-[ -z "$CUPS_HOST" -a -S "$CUPS_DEFAULT_SOCK" ] && CUPS_HOST="$CUPS_DEFAULT_SOCK" 
-
-# no, no, no - so we fallback to localhost
-[ -z "$CUPS_HOST" ] && CUPS_HOST="127.0.0.1"
-
-echo "$CUPS_HOST"

Deleted: trunk/freenx-server/trunk/nxdesktop_helper
===================================================================
--- trunk/freenx-server/trunk/nxdesktop_helper	2008-03-10 22:59:38 UTC (rev 511)
+++ trunk/freenx-server/trunk/nxdesktop_helper	2008-03-10 23:01:03 UTC (rev 512)
@@ -1,22 +0,0 @@
-#!/bin/sh
-#
-# nxdesktop_helper - Small helper for external rdesktop program as needed by NX 3.0.0 backend.
-#
-# Copyright (c) 2007 by Fabian Franz <freenx at fabian-franz.de>
-#
-# License: GPL, v2
-#
-# SVN: $Id $
-#
-
-[ -z "$COMMAND_RDESKTOP" ] && COMMAND_RDESKTOP="rdesktop"
-
-# setup commandline
-set -- -f -u "$agent_user" -k "$agent_keyboard" -d "$agent_domain" $AGENT_EXTRA_OPTIONS_RDP "$agent_server"
-
-if [ -n "$agent_password" ]
-then
-	echo $agent_password | $COMMAND_RDESKTOP -p - "$@"
-else
-	$COMMAND_RDESKTOP "$@"
-fi

Deleted: trunk/freenx-server/trunk/nxdialog
===================================================================
--- trunk/freenx-server/trunk/nxdialog	2008-03-10 22:59:38 UTC (rev 511)
+++ trunk/freenx-server/trunk/nxdialog	2008-03-10 23:01:03 UTC (rev 512)
@@ -1,450 +0,0 @@
-#!/bin/bash
-#
-# Copyright (c) 2004 by Fabian Franz <freenx at fabian-franz.de>
-#           (c) 2004 by Rick Stout <zipsonic at gmail.com>
-#
-# License: GPL, version 2
-#
-# Note: NX does not check the exit-code from nxclient,
-#       but we set it to a "good value" anyway in case 
-#       it does check it someday.
-#
-# SVN: $Id$
-#
-# ========================================================================
-
-#JJK: borrowed from Aron Griffis
-
-function requote 
-{
-	declare arg
-
-	for arg
-	do
-		arg=$(printf '%q' "$arg")
-		printf '%s ' "${arg:-''}"
-	done
-}
-
-PARAMS=( "$@" )
-INPUTS=$(requote "$@")	#JJK: Save input parameter line...
-
-TEMP=`getopt -a -o d: --long local,noautokill,dialog:,caption:,message:,display:,printer:,parent: -n $(basename $0) -- "$@"`
-
-if [ $? != 0 ] ; then echo "Terminating..." >&2 ; exit 1 ; fi
-
-# Note the quotes around `$TEMP': they are essential!
-eval set -- "$TEMP"
-
-DIALOG_TYPE="ok";
-DIALOG_CAPTION=""
-DIALOG_MESSAGE=""
-DIALOG_LOCAL=""
-DIALOG_NOAUTOKILL=""
-DIALOG_PRINTER=""
-DIALOG_PARENT="$PPID"
-
-while true
-do
-        case "$1" in
-		--dialog) DIALOG_TYPE="$2"; shift 2 ;;
-		--caption) DIALOG_CAPTION="$2"; shift 2 ;;
-		--message) DIALOG_MESSAGE="$2"; shift 2 ;;
-		--local) DIALOG_LOCAL="yes"; shift ;;
-		--noautokill) DIALOG_NOAUTOKILL="yes"; shift ;;
-		--display) DISPLAY="$2"; shift 2 ;;
-		--printer) DIALOG_PRINTER="$2"; shift 2 ;;
-		--parent) DIALOG_PARENT="$2"; shift 2 ;;
-		--) shift ; break ;;
-                *) echo "Internal error!" ; exit 1; ;;
-	esac
-done
-
-export DISPLAY
-
-# if --printer is set, the dialog type is overridden
-[ -n "$DIALOG_PRINTER" ] && DIALOG_TYPE="printer"
-
-# First check if the commercial nxclient is available and use it
-# but check that it isn't this script to prevent a loop!
-#
-# Also check that not --printer was used, because the commercial
-# client does not like large databases like used when ENABLE_FOOMATIC=1.
-#
-# This seems to be because the used sorting algorithm scales in O(n^2).
-#
-# This is now fixed in NXClient 3.0.0, but still people sometimes use
-# older clients.
-
-NXCLIENT="/usr/NX/bin/nxclient"
-[ -x "$NXCLIENT" -a "$DIALOG_TYPE" != "printer" -a "$(file -bi $NXCLIENT)" != 'application/x-shellscript' ] \
-	&& exec ${NXCLIENT} "${PARAMS[@]}"
-
-# FIXME: This should be COMMAND_XDIALOG, ...
-if [ -x /usr/bin/Xdialog ] 
-then
-	dialog_interface="xdialog"
-	DIALOG=/usr/bin/Xdialog # just in case that we have no good path
-elif [ -x /usr/bin/dialog ]
-then
-	#JJK: Added 'dialog_interface=dialog' option because Xdialog not standard
-	#JJK: on some distros such as Fedora and xmessage won't handle long
-	#JJK: lists of ppd files while the combination of 'dialog' and 'xterm'
-	#JJK: should be present on most setups.
-
-	dialog_interface="dialog"
-	DIALOG=/usr/bin/dialog
-	if [ -z "$NXCLIENT_FIRST_TIME" ]
-	then
-		# Run only once in case of subdialogs. Capture result in tempfile
-		TMPFILE=$(mktemp /tmp/nxclient.XXXXX)
-		export NXCLIENT_FIRST_TIME=1
-
-		xterm -geometry 120x24+100+100 +sb -title "NXclient" -e \
-		       /bin/bash -c "$DIALOG --infobox 'Please wait...' 3 25; $0 $INPUTS | tee $TMPFILE" || exit 1
-
-		#Need to recover the last line output (and not remove non-printing chars, because --stdout is used)
-		tail -1 $TMPFILE 
-		rm -f $TMPFILE
-		exit 0
-	fi
-else
-	dialog_interface="xmessage"
-	xmessage=$(which xmessage 2>/dev/null)
-	[ -z "$xmessage" ] && xmessage="/usr/X11R6/bin/xmessage"
-fi
-
-#
-# utility functions for all interfaces
-#
-
-# utility_printer "get|set|getlist|getvendlist|getdrvlist"
-#
-#	get <name> - gets the current driver for name
-#	set <name> <driver> <description> - sets the current driver and description for name
-#	getvendlist - gets a list of vendors
-#	getdrvlist <vendor> - gets a list of drivers for vendor
-#	getextdrvlist <vendor> - gets an extended list (with driver and 
-#                                description) of drivers for vendor
-#	getdesc <driver> - gets the description for driver <driver>
-#	getlist - gets a list of drivers
-
-#
-# drivers.cache has the following format:
-#	
-#	driver|<printername>|<ppdfile>|<description>
-#
-
-#
-# Example: IFS='|' DEFAULT_PRINTER=( $(utility_printer get <myprinter>) )
-# 	  
-#	You can then select ${DEFAULT_PRINTER[1]} for <printername>.
-# 
-
-utility_printer()
-{
-	UTILITY_DRIVERS_CACHE="$HOME/.nx/config/drivers.cache"
-	[ -n "$USER_FAKE_HOME" ] && UTILITY_DRIVERS_CACHE="$USER_FAKE_HOME/.nx/config/drivers.cache"
-	UTILITY_NXPRINT="nxprint"
-	[ -n "$PATH_BIN" ] && UTILITY_NXPRINT="$PATH_BIN/nxprint"
-	# Export configuration vars for nxprint
-	export ENABLE_FOOMATIC COMMAND_FOOMATIC UTILITY_DRIVERS_CACHE
-	case "$1" in 
-		get)
-			grep "driver|$2|" "$UTILITY_DRIVERS_CACHE" 2>/dev/null
-		;;
-		set)
-			# FIXME: Handle possible race conditions?
-			grep -v "driver|$2|" "$UTILITY_DRIVERS_CACHE" 2>/dev/null > $UTILITY_DRIVERS_CACHE.tmp
-			echo "driver|$2|$3|$4" >> $UTILITY_DRIVERS_CACHE.tmp
-			mv -f $UTILITY_DRIVERS_CACHE.tmp $UTILITY_DRIVERS_CACHE
-		;;
-		getvendlist)
-			$UTILITY_NXPRINT -d | awk -F'|' '{ print $2 }' | uniq | tr '\n' '|'
-		;;
-		getdrvlist)
-			$UTILITY_NXPRINT -d | awk -F'|' '($2=="'$2'") { print $4}' | tr '\n' '|'
-		;;
-		getextdrvlist)
-			$UTILITY_NXPRINT -d | awk -F'|' '($2=="'$2'") { print $4 "|" $3 }'
-		;;
-
-		getdesc)
-			$UTILITY_NXPRINT -d | awk -F'|' '($4=="'$2'") { print $3}'
-		;;
-		getlist)
-			$UTILITY_NXPRINT -d
-		;;
-	esac
-}
-
-#
-# xmessage dialog interface
-#
-
-xmessage_ok()
-{
-	$xmessage -buttons "Ok:0" -center "$DIALOG_MESSAGE"
-	return 0 # Give cancel on close ...
-}
-
-xmessage_yesno()
-{
-	$xmessage -buttons "Yes:2,No:0" -center "$DIALOG_MESSAGE"
-}
-
-xmessage_yesnosuspend()
-{
-	$xmessage -buttons "Suspend:3,Terminate:2,Cancel:0" -center "$DIALOG_MESSAGE"
-}
-
-xmessage_panic()
-{
-	$xmessage -buttons "Terminate:2,Cancel:0" -center "$DIALOG_MESSAGE"
-}
-
-xmessage_quit()
-{
-	$xmessage -buttons "Quit:0" -center "$DIALOG_MESSAGE"
-	return 0 # Give cancel on close ...
-}
-
-xmessage_printer_ask()
-{
-	$xmessage -buttons "Ok:100,Configure:101,Cancel:102" -center "$DIALOG_MESSAGE"
-	RC=$?
-	[ $RC -lt 100 ] && return 2
-	let RC=$RC-100
-	return $RC
-}
-
-xmessage_printer_configure()
-{
-	IFS=','
-	$xmessage -buttons "$*" -center "$DIALOG_MESSAGE"
-	RC=$?
-	unset IFS
-	VENDOR=""
-	if [ $RC -gt 100 ]
-	then
-		let NR=$RC-100
-		VENDOR="${!NR}"
-	fi
-	echo "$VENDOR"
-}
-
-xmessage_printer_configure_vendor()
-{
-	IFS='|' VENDOR_LIST=( $(utility_printer getvendlist) )
-	xmessage_printer_configure "${VENDOR_LIST[@]}"
-}
-
-xmessage_printer_configure_driver()
-{
-	IFS='|' DRIVER_LIST=( $(utility_printer getdrvlist "$1") )
-	xmessage_printer_configure "${DRIVER_LIST[@]}"
-}
-
-#
-# xdialog interface
-#
-
-xdialog_ok()
-{
-	$DIALOG --title "$DIALOG_CAPTION" --msgbox "$DIALOG_MESSAGE" 0 0
-	return 0 # Give cancel on close ...
-}
-
-xdialog_yesno()
-{
-	$DIALOG --title "$DIALOG_CAPTION" --yesno "$DIALOG_MESSAGE" 0 0
-	RC=$?
-	[ $RC -eq 0 ] && return 2
-	[ $RC -eq 1 ] && return 0
-}
-
-xdialog_yesnosuspend()
-{
-	$DIALOG --title "$DIALOG_CAPTION" --buttons-style text --ok-label "Suspend" --cancel-label "Terminate" --yesno "$DIALOG_MESSAGE Close this dialog to cancel." 400x150
-	RC=$?
-	[ $RC -eq 0 ] && return 3
-	[ $RC -eq 1 ] && return 2
-}
-
-xdialog_panic()
-{
-	$DIALOG --title "$DIALOG_CAPTION" --buttons-style text --default-no --ok-label "Terminate" --cancel-label "Cancel" --yesno "$DIALOG_MESSAGE" 0x0
-	RC=$?
-	[ $RC -eq 0 ] && return 2
-	[ $RC -eq 1 ] && return 0
-}
-
-xdialog_quit()
-{
-        $DIALOG --buttons-style text --ok-label "Quit" --title "$DIALOG_CAPTION" --msgbox "$DIALOG_MESSAGE" 0 0
-        return 0 # Give cancel on close ...
-}
-
-xdialog_printer_ask()
-{
-	$DIALOG --title "$DIALOG_CAPTION" --buttons-style text --ok-label "Ok" --cancel-label "Configure" --yesno "$DIALOG_MESSAGE\n\nClose this dialog to cancel." 400x250
-	RC=$?
-	[ $RC -eq 255 ] && return 2
-	return $RC
-}
-
-xdialog_printer_configure_vendor()
-{
-	IFS='|' VENDOR_LIST=( $(utility_printer getvendlist | sed 's/|/||off|/g') )
-	$DIALOG --stdout --title "$DIALOG_CAPTION" --radiolist "$DIALOG_MESSAGE" 0 0 6 "${VENDOR_LIST[@]}"
-}
-
-# xdialog_printer_configure_driver vendor old_driver
-xdialog_printer_configure_driver()
-{
-	IFS='|' XDIALOG_LIST=( $(utility_printer getextdrvlist "$1" | sed 's,$,|off,g; /'"$(basename $2)"'/ s,|off,|on,g' | tr '\n' '|') )
-	$DIALOG --stdout --title "$DIALOG_CAPTION" --radiolist "$DIALOG_MESSAGE" 0 0 6 "${XDIALOG_LIST[@]}"
-}
-
-#JJK: dialog interface
-# These are analogous to the Xdialog functions with a few subtle
-# syntax differences
-#
-
-dialog_ok()
-{
-	$DIALOG --stdout --title "$DIALOG_CAPTION" --msgbox "$DIALOG_MESSAGE" 0 0
-	return 0 # Give cancel on close ...
-}
-
-dialog_yesno()
-{
-	$DIALOG --stdout --title "$DIALOG_CAPTION" --yesno "$DIALOG_MESSAGE" 0 0
-	RC=$?
-	[ $RC -eq 0 ] && return 2
-	[ $RC -eq 1 ] && return 0
-}
-
-dialog_yesnosuspend()
-{
-	$DIALOG --stdout --title "$DIALOG_CAPTION"  --yes-label "Suspend" --no-label "Terminate" --yesno "$DIALOG_MESSAGE\n\nPress 'Esc' to cancel." 8 60
-	RC=$?
-	[ $RC -eq 0 ] && return 3
-	[ $RC -eq 1 ] && return 2
-}
-
-dialog_panic()
-{
-	$DIALOG --stdout --title "$DIALOG_CAPTION" --defaultno --yes-label "Terminate" --no-label "Cancel" --yesno "$DIALOG_MESSAGE" 0 0
-	RC=$?
-	[ $RC -eq 0 ] && return 2
-	[ $RC -eq 1 ] && return 0
-}
-
-dialog_quit()
-{
-	$DIALOG --stdout --ok-label "Quit" --title "$DIALOG_CAPTION" --msgbox "$DIALOG_MESSAGE" 0 0
-	return 0 # Give cancel on close ...
-}
-
-dialog_printer_ask()
-{
-	$DIALOG --stdout --cr-wrap --title "$DIALOG_CAPTION" --yes-label "Ok" --no-label "Configure" --yesno "$DIALOG_MESSAGE\n\nPress 'Esc' to cancel." 10 70
-	RC=$?
-	echo $RC
-	[ $RC -eq 255 ] && return 2
-	return $RC
-}
-
-dialog_printer_configure_vendor()
-{
-	IFS='|' VENDOR_LIST=( $(utility_printer getvendlist | sed 's/|/||/g') )
-	$DIALOG --stdout --title "$DIALOG_CAPTION" --menu "$DIALOG_MESSAGE" 0 40 15 "${VENDOR_LIST[@]}"
-}
-
-# dialog_printer_configure_driver vendor old_driver
-dialog_printer_configure_driver()
-{
-	IFS='|' XDIALOG_LIST=( $(utility_printer getextdrvlist "$1" | tr '\n' '|') )
-	$DIALOG --stdout --title "$DIALOG_CAPTION" --menu "$DIALOG_MESSAGE" 0 110 15 "${XDIALOG_LIST[@]}"
-}
-
-
-#
-# helper functions
-#
-
-helper_dialog_printer()
-{
-	IFS="|" PRINTER_INFORMATION=( $(utility_printer get "$DIALOG_PRINTER") )
-	PRINTER_CONFIGURE="yes"
-	[ -z "$DIALOG_CAPTION" ] && DIALOG_CAPTION="NX Printer configuration for $DIALOG_PRINTER"
-	
-	# Do we have old printer information present?
-	if [ -n "$PRINTER_INFORMATION" ]
-	then
-		DIALOG_MESSAGE=$(echo -e "Found driver for printer $DIALOG_PRINTER.\n\nOld choice was: ${PRINTER_INFORMATION[3]}.\n\nIf you want to keep the settings click on 'Ok' \n- else click on 'Configure'.") ${dialog_interface}_printer_ask
-		RC=$?
-		# bail out with exit code 2 in case the user cancelled the operation
-		[ $RC -eq 2 ] && echo "cancel: aborted" && exit 2
-		[ $RC -eq 0 ] && PRINTER_CONFIGURE="no"
-	fi
-	
-	VENDOR=""
-	OLD_DRIVER="${PRINTER_INFORMATION[2]}"
-
-	if [ "$PRINTER_CONFIGURE" = "yes" ]
-	then
-		DRIVER=""
-		VENDOR=$(DIALOG_MESSAGE="Choose vendor for printer $DIALOG_PRINTER." ${dialog_interface}_printer_configure_vendor)
-		[ -n "$VENDOR" ] && DRIVER=$(DIALOG_MESSAGE="Choose driver for printer $DIALOG_PRINTER." ${dialog_interface}_printer_configure_driver "$VENDOR" "${OLD_DRIVER:-invalid}")
-		# set the new printer driver
-		if [ -n "$DRIVER" ]
-		then
-			DESC=$(utility_printer getdesc "$DRIVER")
-			utility_printer set "$DIALOG_PRINTER" "$DRIVER" "$DESC"
-		fi
-	else
-		DRIVER="$OLD_DRIVER"
-	fi
-
-	# echo the choosen <ppdfile> to stdout
-	[ -n "$DRIVER" ] && echo "$DRIVER"
-	[ -z "$DRIVER" ] && echo "cancel: aborted" && exit 2
-
-	exit 0
-}
-
-#
-# main case statement
-#
-
-case $DIALOG_TYPE in 
-	ok)
-		${dialog_interface}_ok
-	;;
-	yesno)
-		${dialog_interface}_yesno
-	;;
-	yesnosuspend)
-		${dialog_interface}_yesnosuspend
-	;;
-	panic)
-		${dialog_interface}_panic
-	;;
-	quit)
-		${dialog_interface}_quit
-	;;
-	printer)
-		helper_dialog_printer
-	;;
-esac
-
-#
-# Time for exit code checks :)
-#
-
-RC=$?
-	[ $RC -eq 2 ] && kill -TERM $DIALOG_PARENT
-	[ $RC -eq 3 ] && kill -HUP $DIALOG_PARENT
-exit 0

Deleted: trunk/freenx-server/trunk/nxkeygen
===================================================================
--- trunk/freenx-server/trunk/nxkeygen	2008-03-10 22:59:38 UTC (rev 511)
+++ trunk/freenx-server/trunk/nxkeygen	2008-03-10 23:01:03 UTC (rev 512)
@@ -1,73 +0,0 @@
-#!/bin/bash
-#
-# /usr/NX/bin/nxkeygen
-#		Create a new client/server key pair
-#
-#		Originally written for Gentoo Linux
-#
-# Author	Stuart Herbert
-#		(stuart at gentoo.org)
-#
-# Copyright	(c) 2004 Gentoo Foundation
-#		Released under v2 of the GNU GPL
-#
-# SVN: $Id$
-#
-# ========================================================================
-
-# Read the config file
-. $(PATH=$(cd $(dirname $0) && pwd):$PATH which nxloadconfig) --
-
-NX_KEY_DIR="$NX_HOME_DIR/.ssh"
-DATE="`date '+%Y%m%d-%H%M%S'`"
-NX_CLIENT_KEY="${NX_KEY_DIR}/client.id_dsa.key"
-NX_SERVER_KEY="${NX_KEY_DIR}/server.id_dsa.pub.key"
-
-main ()
-{
-	# create a new key
-	umask 177
-	$COMMAND_SSH_KEYGEN -q -t dsa -N '' -f ${NX_KEY_DIR}/local.id_dsa
-
-	# backup the existing keys
-	
-	if [ -f "${NX_SERVER_KEY}" ]; then
-		echo "Backing up existing server key to ${NX_SERVER_KEY}.${DATE}"
-		mv -f "${NX_SERVER_KEY}" "${NX_SERVER_KEY}.${DATE}"
-	fi
-
-	if [ -f "${NX_CLIENT_KEY}" ]; then
-		echo "Backing up existing client key to ${NX_CLIENT_KEY}.${DATE}"
-		mv -f "${NX_CLIENT_KEY}" "${NX_CLIENT_KEY}.${DATE}"
-	fi
-
-	# put the new keys in place
-
-	mv -f "${NX_KEY_DIR}/local.id_dsa" "${NX_CLIENT_KEY}"
-	mv -f "${NX_KEY_DIR}/local.id_dsa.pub" "${NX_SERVER_KEY}"
-
-	for x in ${NX_CLIENT_KEY} ${NX_SERVER_KEY} ; do
-		chmod 600 $x
-		chown nx:root $x
-	done
-	
-	# copy the key to the authorized_keys2 file
-	rm -f $NX_KEY_DIR/$SSH_AUTHORIZED_KEYS
-	echo -n "no-port-forwarding,no-agent-forwarding,command=\"$PATH_BIN/nxserver\" " >$NX_KEY_DIR/$SSH_AUTHORIZED_KEYS
-	cat ${NX_SERVER_KEY} >> $NX_KEY_DIR/$SSH_AUTHORIZED_KEYS
-
-	# Fix ownership of $SSH_AUTHORIZED_KEYS, just in case nxkeygen is run without nxsetup.
-
-	chown nx:root $NX_KEY_DIR/$SSH_AUTHORIZED_KEYS
-
-	# now tell the user what to do
-
-	echo "Unique key generated; your users must install"
-	echo
-	echo "    ${NX_CLIENT_KEY}"
-	echo
-	echo "on their computers."
-}
-
-main "$@"
-

Deleted: trunk/freenx-server/trunk/nxloadconfig
===================================================================
--- trunk/freenx-server/trunk/nxloadconfig	2008-03-10 22:59:38 UTC (rev 511)
+++ trunk/freenx-server/trunk/nxloadconfig	2008-03-10 23:01:03 UTC (rev 512)
@@ -1,617 +0,0 @@
-#!/bin/bash
-#
-# Copyright (c) 2005 by Fabian Franz <freenx at fabian-franz.de>
-#           (c) 2005 by Jon Severinsson <jonno at users.berlios.de>
-#
-# License: GPL, version 2
-#
-# SVN: $Id$
-#
-# ========================================================================
-
-#########################################################################
-# Commandline support for --help, --check and --userconf
-#########################################################################
-
-HELP="no"
-CHECK="no"
-USERCONF="no"
-NXLCFG_IGNORE_ERRORS="no"
-
-while [ "$1" ]
-do
-	case "$1" in
-		--help) HELP="yes"; shift ;;
-		--check) CHECK="yes"; shift ;;
-		--ignore-errors) NXLCFG_IGNORE_ERRORS="yes"; shift;;
-		--userconf) USERCONF="yes" ; 
-					case "$2" in
-						"" | --*) shift ;;
-						*) USER=$2 ; shift 2 ;;
-					esac ;;
-		--) shift ; break ;;
-		*) echo "Invalid flag $1" ; HELP="yes"; shift ; break ;;
-	esac
-done
-
-if [ "$HELP" = "yes" ]
-then
-	echo "nxloadconfig - Load the FreeNX configuration variables into the environment."
-	echo "Syntax: nxloadconfig --help"
-	echo "        nxloadconfig [--check] [--userconf [<username>]]"
-	echo
-	echo "  --check                  Write errors to standard output."
-	echo "	--ignore-errors		 just warn, and don't exit with a error, if errors occure"
-	echo "  --userconf [<username>]  Parse <username>.node.conf as well as node.conf."
-	echo "                           Assume current user if no username is specified."
-	exit 0
-fi
-
-#########################################################################
-# INTERNAL STUFF
-# DO NOT TOUCH unless you REALLY know what you are doing
-#########################################################################
-
-NX_VERSION=2.1.0-72-SVN
-NX_LICENSE="OS (GPL)"
-
-# Where can different nx components be found
-NX_DIR=/usr
-PATH_BIN=$NX_DIR/bin # if you change that, be sure to also change the public keys
-PATH_LIB=$NX_DIR/lib
-NX_ETC_DIR=/etc/nxserver
-NX_SESS_DIR=/var/lib/nxserver/db
-NX_HOME_DIR=/var/lib/nxserver/home
-
-# Advanced users ONLY
-AGENT_LIBRARY_PATH="" #Calculated
-PROXY_LIBRARY_PATH="" #Calculated
-APPLICATION_LIBRARY_PATH="" #Calculated
-APPLICATION_LIBRARY_PRELOAD="" #Calculated
-
-# the name of the authorized keys file for ssh
-SSH_AUTHORIZED_KEYS="authorized_keys2"
-
-# retest values like xauth, netcat and checks for nxdesktop/nxviewer availability
-# set to 0 if you are sure, you set the right values
-
-NXCONFIG_RETEST=1
-
-#########################################################################
-# Default Values
-# A user should NEVER touch this, edit $NX_ETC_DIR/node.conf instead
-#########################################################################
-
-# General FreeNX directives
-
-SERVER_NAME="$(hostname)"
-SSHD_PORT=22
-
-# Authentication / Security directives
-
-ENABLE_USERMODE_AUTHENTICATION="0"
-ENABLE_PASSDB_AUTHENTICATION="1"
-ENABLE_SSH_AUTHENTICATION="1"
-ENABLE_SU_AUTHENTICATION="0"
-ENABLE_USER_DB="0"
-
-ENABLE_FORCE_ENCRYPTION="0"
-SSHD_CHECK_IP="0"
-
-
-# Restriction directives
-
-DISPLAY_BASE=1000
-SESSION_LIMIT=200
-SESSION_USER_LIMIT="" #Calculated
-DISPLAY_LIMIT=200
-
-ENABLE_PERSISTENT_SESSION="all"
-DISABLE_PERSISTENT_SESSION=""
-
-ENABLE_MIRROR_VIA_VNC=1
-ENABLE_DESKTOP_SHARING=1
-
-ENABLE_CLIPBOARD="both"
-ENABLE_PULLDOWN_MENU="1"
-
-# Logging directives
-
-NX_LOG_LEVEL=0
-NX_LOG_SECURE=1
-NX_LOGFILE=/var/log/nxserver.log
-SESSION_LOG_CLEAN=1
-SESSION_HISTORY=2592000
-
-
-# Forwarding directives
-
-ENABLE_SERVER_FORWARD="0"
-SERVER_FORWARD_HOST=""
-SERVER_FORWARD_PORT=22
-SERVER_FORWARD_KEY="/usr/NX/share/client.id_dsa.key"
-
-NOMACHINE_SERVER="/usr/NX/bin/nxserver"
-NOMACHINE_NX_HOME_DIR="/usr/NX/home/nx"
-ENABLE_NOMACHINE_FORWARD_PORT="0"
-NOMACHINE_FORWARD_PORT="22"
-
-LOAD_BALANCE_SERVERS=""
-LOAD_BALANCE_ALGORITHM="random"
-ENABLE_LOAD_BALANCE_PREFERENCE="0"
-
-# Services directives
-
-ENABLE_ESD_PRELOAD="0"
-ESD_BIN_PRELOAD="esddsp"
-ENABLE_ARTSD_PRELOAD="0"
-ARTSD_BIN_PRELOAD="artsdsp"
-
-ENABLE_KDE_CUPS="0"
-ENABLE_KDE_CUPS_DYNAMIC="0"
-KDE_PRINTRC="" # Calculated
-
-ENABLE_CUPS_SERVER_EXPORT="1"
-ENABLE_CUPS_SEAMLESS="0"
-CUPS_SEAMLESS_DELAY="10"
-ENABLE_FOOMATIC="1"
-COMMAND_FOOMATIC="/usr/lib/cups/driver/foomatic-ppdfile"
-
-CUPS_BACKEND="/usr/lib/cups/backend"
-CUPS_IPP_BACKEND="$CUPS_BACKEND/nxipp"
-CUPS_DEFAULT_SOCK="/var/run/cups/cups.sock"
-CUPS_ETC="/etc/cups/"
-
-SAMBA_MOUNT_SHARE_PROTOCOL="both"
-
-# Path directives
-
-USER_FAKE_HOME="" #Calculated
-SET_LD_LIBRARY_PATH="1"
-
-DEFAULT_X_WM=""
-KILL_DEFAULT_X_WM="1"
-USER_X_STARTUP_SCRIPT=.Xclients
-DEFAULT_X_SESSION=/etc/X11/xdm/Xsession
-COMMAND_START_KDE=startkde
-COMMAND_START_GNOME=gnome-session
-COMMAND_START_CDE=cdwm
-COMMAND_XTERM=xterm
-COMMAND_XAUTH=/usr/X11R6/bin/xauth
-COMMAND_SMBMOUNT=smbmount
-COMMAND_SMBUMOUNT=smbumount
-COMMAND_SMBMOUNT_CIFS=/sbin/mount.cifs
-COMMAND_SMBUMOUNT_CIFS=/sbin/umount.cifs
-COMMAND_NETCAT=netcat
-COMMAND_SSH=ssh
-COMMAND_SSH_KEYGEN=ssh-keygen
-COMMAND_CUPSD=/usr/sbin/cupsd
-COMMAND_MD5SUM="openssl md5"
-COMMAND_PERL=perl
-COMMAND_RDESKTOP="rdesktop"
-COMMAND_VNCVIEWER="vncviewer"
-COMMAND_VNCPASSWD="$PATH_BIN/nxpasswd"
-COMMAND_X11VNC="x11vnc"
-
-# Misc directives
-
-ENABLE_1_5_0_BACKEND=""
-ENABLE_AUTORECONNECT="0"
-ENABLE_AUTORECONNECT_BEFORE_140="1"
-EXPORT_USERIP="0"
-EXPORT_SESSIONID="1"
-NODE_AUTOSTART=""
-ENABLE_ROOTLESS_MODE="1"
-ENABLE_USESSION="1"
-COMMAND_SESSREG="sessreg"
-AGENT_EXTRA_OPTIONS_RFB=""
-AGENT_EXTRA_OPTIONS_RDP=""
-AGENT_EXTRA_OPTIONS_X=""
-AGENT_STARTUP_TIMEOUT="60"
-AGENT_FONT_SERVER=""
-PROXY_TCP_NODELAY=""
-PROXY_EXTRA_OPTIONS=""
-ENABLE_EXTERNAL_NXDESKTOP="0"
-ENABLE_EXTERNAL_NXDESKTOP_KEYBOARD="1"
-ENABLE_EXTERNAL_NXVIEWER="0"
-
-############################################################################
-# OS specific directives
-############################################################################
-
-OS="$( uname -sr )"
-
-case "$OS" in
-	"SunOS 5.10")
-		DEFAULT_X_WM=cdwm
-		DEFAULT_X_SESSION=/etc/X11/gdm/Xsession
-		COMMAND_XTERM=/usr/openwin/bin/xterm
-		COMMAND_XAUTH=/usr/openwin/bin/xauth
-		COMMAND_CUPSD=/opt/sfw/cups/sbin/cupsd
-		COMMAND_MD5SUM=gmd5sum
-		PATH=/usr/xpg4/bin:/usr/openwin/bin:$PATH
-		export PATH
-		;;
-esac
-
-# replace incompatible commands
-
-case "$OS" in
-       "SunOS 5.10")
-               function which()
-               {
-                       [ -e "$1" ] && echo $1 && return 0
-                       [ -z "$1" ] && return 1
-                       for i in  $(echo $PATH | tr ":" "\n"); do
-                               [ -e $i/$1 ] && echo $i/$1 && return 0
-                       done
-                       return 1
-               }
-       ;;
-esac
-
-#
-# Utility functions
-#
-
-function mywhich()
-{
-	which $(echo "$*" | cut -d" " -f1)
-}
-
-#########################################################################
-# Retested values
-#########################################################################
-
-if [ "$NXCONFIG_RETEST" = "1" ]
-then
-	{ ! mywhich "$COMMAND_XAUTH" && which xauth; } >/dev/null 2>&1 && COMMAND_XAUTH=$(which xauth)
-	{ ! mywhich "$COMMAND_NETCAT" && which nc; } >/dev/null 2>&1 && COMMAND_NETCAT=$(which nc)
-	{ ! mywhich "$PATH_BIN/nxdesktop"; } >/dev/null 2>&1 && ENABLE_EXTERNAL_NXDESKTOP="1"
-	{ ! mywhich "$PATH_BIN/nxviewer"; } >/dev/null 2>&1 && ENABLE_EXTERNAL_NXVIEWER="1"
-	{ ! mywhich "$COMMAND_VNCPASSWD" && which vncpasswd; } >/dev/null 2>&1 && COMMAND_VNCPASSWD=$(which vncpasswd)
-fi
-
-#########################################################################
-# node.conf file evaluation
-#########################################################################
-
-if [ -d $NX_ETC_DIR/node.conf.d ]
-then
-	for i in $NX_ETC_DIR/node.conf.d/*
-	do
-		[ -e $i ] && . $i
-	done
-fi
-
-[ -e $NX_ETC_DIR/node.conf ] && . $NX_ETC_DIR/node.conf
-[ "$USERCONF" = "yes" -a -e $NX_ETC_DIR/$USER.node.conf ] && . $NX_ETC_DIR/$USER.node.conf
-
-
-#########################################################################
-# Calculated values
-#########################################################################
-
-[ -z "$SESSION_USER_LIMIT" ] && SESSION_USER_LIMIT=$SESSION_LIMIT
-[ -z "$USER_FAKE_HOME" ] && USER_FAKE_HOME=$HOME
-
-[ -z "$AGENT_LIBRARY_PATH" ] && AGENT_LIBRARY_PATH=$PATH_LIB
-[ -z "$PROXY_LIBRARY_PATH" ] && PROXY_LIBRARY_PATH=$PATH_LIB
-[ -z "$APPLICATION_LIBRARY_PATH" ] && APPLICATION_LIBRARY_PATH=$PATH_LIB
-[ -z "$APPLICATION_LIBRARY_PRELOAD" ] && APPLICATION_LIBRARY_PRELOAD="$APPLICATION_LIBRARY_PATH/libX11.so.6.2:$APPLICATION_LIBRARY_PATH/libXext.so.6.4:$APPLICATION_LIBRARY_PATH/libXcomp.so:$APPLICATION_LIBRARY_PATH/libXcompext.so:$APPLICATION_LIBRARY_PATH/libXrender.so.1.2"
-if [ -z "$ENABLE_1_5_0_BACKEND" ]
-then
-	[ -n "$(strings $PATH_BIN/nxagent 2>/dev/null | egrep 'NXAGENT - Version 1.5.0')" ] && ENABLE_1_5_0_BACKEND="1"
-fi
-
-if [ "$ENABLE_KDE_CUPS" = "1" ]
-then
-	[ -z "$KDE_PRINTRC" -a -n "$KDEHOME" ] && KDE_PRINTRC="$KDEHOME/share/config/kdeprintrc"
-	[ -z "$KDE_PRINTRC" ] && which kde-config >/dev/null 2>&1 && KDE_PRINTRC=$(kde-config --localprefix 2>/dev/null)"/share/config/kdeprintrc"
-	[ -z "$KDE_PRINTRC" -o ! -r "$KDE_PRINTRC" ] && KDE_PRINTRC="$HOME/.kde/share/config/kdeprintrc"
-fi
-
-#########################################################################
-# Support for --check
-#########################################################################
-
-if [ "$CHECK" = "yes" ]
-then
-	ERROR="no"
-	WARNING="no"
-	
-	# Internal Stuff
-	
-	[ ! -d "$PATH_BIN" ] && \
-		ERROR="yes" && echo "Error: Invalid value \"PATH_BIN=$PATH_BIN\""
-	# Check for NX agents ...
-	
-	[ ! -x "$PATH_BIN/nxagent" ] && \
-		ERROR="yes" && echo "Error: Could not find nxagent in $PATH_BIN. Please install some OSS components."
-	
-	if [ "ENABLE_EXTERNAL_NXDESKTOP" = "1" ]
-	then
-		[ ! mywhich "$COMMAND_RDESKTOP" >/dev/null 2>&1 ] && \
-			WARNING="yes" && echo "Warning: Could not find COMMAND_RDESKTOP=$COMMAND_RDESKTOP. RDP sessions won't work."
-	else
-		[ ! -x "$PATH_BIN/nxdesktop" ] && \
-			WARNING="yes" && echo "Warning: Could not find nxdesktop in $PATH_BIN. RDP sessions won't work."
-	fi
-		
-	if [ "ENABLE_EXTERNAL_NXVIEWER" = "1" ]
-	then
-		[ ! mywhich "$COMMAND_VNCVIEWER" >/dev/null 2>&1 ] && \
-			WARNING="yes" && echo "Warning: Could not find COMMAND_VNCVIEWER=$COMMAND_VNCVIEWER. VNC sessions won't work."
-		[ ! mywhich "$COMMAND_VNCPASSWD" >/dev/null 2>&1 ] && \
-			WARNING="yes" && echo "Warning: Could not find COMMAND_VNCPASSWD=$COMMAND_VNCPASSWD. VNC sessions won't work."
-	else
-		[ ! -x "$PATH_BIN/nxviewer" ] && \
-			WARNING="yes" && echo "Warning: Could not find nxviewer in $PATH_BIN. VNC sessions won't work."
-	fi
-	
-	[ ! mywhich "$COMMAND_X11VNC" >/dev/null 2>&1 ] && \
-			WARNING="yes" && echo "Warning: Could not find COMMAND_X11VNC=$COMMAND_X11VNC. VNC mirror sessions won't work."
-
-	# Check for paths
-		
-	[ ! -d "$PATH_LIB" ] && \
-		ERROR="yes" && echo "Error: Invalid value \"PATH_LIB=$PATH_LIB\""
-	[ ! -d "$NX_ETC_DIR" ] && \
-		ERROR="yes" && echo "Error: Invalid value \"NX_ETC_DIR=$NX_ETC_DIR\""
-	[ ! -d "$NX_SESS_DIR" ] && \
-		ERROR="yes" && echo "Error: Invalid value \"NX_SESS_DIR=$NX_SESS_DIR\""
-	[ ! -d "$NX_HOME_DIR" ] && \
-		ERROR="yes" && echo "Error: Invalid value \"NX_HOME_DIR=$NX_HOME_DIR\""
-
-	[ ! -d "$AGENT_LIBRARY_PATH" ] && \
-		ERROR="yes" && echo "Error: Invalid value \"AGENT_LIBRARY_PATH=$AGENT_LIBRARY_PATH\""
-	[ ! -d "$PROXY_LIBRARY_PATH" ] && \
-		ERROR="yes" && echo "Error: Invalid value \"PROXY_LIBRARY_PATH=$PROXY_LIBRARY_PATH\""
-	[ ! -d "$APPLICATION_LIBRARY_PATH" ] && \
-		ERROR="yes" && echo "Error: Invalid value \"APPLICATION_LIBRARY_PATH=$APPLICATION_LIBRARY_PATH\""
-	
-	OLD_IFS=$IFS
-	IFS=":"
-	for LIBRARY in $APPLICATION_LIBRARY_PRELOAD; do
-		[ ! -e $LIBRARY ] && \
-			WARNING="yes" && echo "Warning: Invalid value \"APPLICATION_LIBRARY_PRELOAD=$APPLICATION_LIBRARY_PRELOAD\". $LIBRARY could not be found. Users will not be able to run a single application in non-rootless mode." && break ;
-	done
-	IFS=$OLD_IFS
-	
-	[ -z "$SSH_AUTHORIZED_KEYS" ] && \
-		ERROR="yes" && echo "Error: Invalid value \"SSH_AUTHORIZED_KEYS=$SSH_AUTHORIZED_KEYS\""
-	
-	
-	# General FreeNX directives
-	
-	[ -z "$SERVER_NAME" ] && \
-		ERROR="yes" && echo "Error: Invalid value \"SERVER_NAME=$SERVER_NAME\""
-	[ -z $(echo "$SSHD_PORT" | egrep "^[1-9][0-9]{0,4}$") ] && \
-		ERROR="yes" && echo "Error: Invalid value \"SSHD_PORT=$SSHD_PORT\""
-	
-	
-	# Authentication / Security directives
-	
-	[ -z $(echo "$ENABLE_PASSDB_AUTHENTICATION" | egrep "^[0|1]$") ] && \
-		ERROR="yes" && echo "Error: Invalid value \"ENABLE_PASSDB_AUTHENTICATION=$ENABLE_PASSDB_AUTHENTICATION\""
-	[ -z $(echo "$ENABLE_SSH_AUTHENTICATION" | egrep "^[0|1]$") ] && \
-		ERROR="yes" && echo "Error: Invalid value \"ENABLE_SSH_AUTHENTICATION=$ENABLE_SSH_AUTHENTICATION:\""
-	[ -z $(echo "$ENABLE_SU_AUTHENTICATION" | egrep "^[0|1]$") ] && \
-		ERROR="yes" && echo "Error: Invalid value \"ENABLE_SU_AUTHENTICATION=$NENABLE_SU_AUTHENTICATION\""
-	[ -z $(echo "$ENABLE_USER_DB" | egrep "^[0|1]$") ] && \
-		ERROR="yes" && echo "Error: Invalid value \"ENABLE_USER_DB=$ENABLE_USER_DB\""
-	
-	[ -z $(echo "$ENABLE_FORCE_ENCRYPTION" | egrep "^[0|1]$") ] && \
-		ERROR="yes" && echo "Error: Invalid value \"ENABLE_FORCE_ENCRYPTION=$ENABLE_FORCE_ENCRYPTION\""
-	[ -z $(echo "$SSHD_CHECK_IP" | egrep "^[0|1]$") ] && \
-		ERROR="yes" && echo "Error: Invalid value \"SSHD_CHECK_IP=$SSHD_CHECK_IP\""
-	
-	
-	# Restriction directives
-	
-	[ -z $(echo "$DISPLAY_BASE" | egrep "^[1-9][0-9]{0,4}$") ] && \
-		ERROR="yes" && echo "Error: Invalid value \"DISPLAY_BASE=$DISPLAY_BASE\""
-	[ -z $(echo "$SESSION_LIMIT" | egrep "^[1-9][0-9]{0,4}$") ] &&  \
-		ERROR="yes" && echo "Error: Invalid value \"SESSION_LIMIT=$SESSION_LIMIT\""
-	[ -z $(echo "$SESSION_USER_LIMIT" | egrep "^[1-9][0-9]{0,4}$") -o $SESSION_USER_LIMIT -gt $SESSION_LIMIT ] && \
-		ERROR="yes" && echo "Error: Invalid value \"SESSION_USER_LIMIT=$SESSION_USER_LIMIT\""
-	[ -z $(echo "$DISPLAY_LIMIT" | egrep "^[1-9][0-9]{0,4}$") -o $DISPLAY_LIMIT -lt $SESSION_LIMIT ] && \
-		ERROR="yes" && echo "Error: Invalid value \"DISPLAY_LIMIT=$DISPLAY_LIMIT\""
-	
-	OLD_IFS=$IFS
-	IFS=","
-	if [ "$ENABLE_PERSISTENT_SESSION" != "all" ]
-	then
-		for USERNAME in $ENABLE_PERSISTENT_SESSION; do
-			[ "${USERNAME:0:1}" != "@" ] && [ -z $(getent passwd $USERNAME) ] && \
-				ERROR="yes" && echo "Error: Invalid value \"ENABLE_PERSISTENT_SESSION=$ENABLE_PERSISTENT_SESSION\"" && break ;
-			[ "${USERNAME:0:1}" = "@" ] && [ -z $(getent group ${USERNAME:1}) ] && \
-				ERROR="yes" && echo "Error: Invalid value \"ENABLE_PERSISTENT_SESSION=$ENABLE_PERSISTENT_SESSION\"" && break ;
-		done
-	fi
-	for USERNAME in $DISABLE_PERSISTENT_SESSION; do
-		[ "${USERNAME:0:1}" != "@" ] && [ -z $(getent passwd $USERNAME) ] && \
-			ERROR="yes" && echo "Error: Invalid value \"DISABLE_PERSISTENT_SESSION=$DISABLE_PERSISTENT_SESSION\"" && break ;
-		[ "${USERNAME:0:1}" = "@" ] && [ -z $(getent group ${USERNAME:1}) ] && \
-			ERROR="yes" && echo "Error: Invalid value \"DISABLE_PERSISTENT_SESSION=$DISABLE_PERSISTENT_SESSION\"" && break ;
-	done
-	IFS=$OLD_IFS
-	
-	
-	# Logging directives
-	
-	[ -z $(echo "$NX_LOG_LEVEL" | egrep "^[0-7]$") ] && \
-		ERROR="yes" && echo "Error: Invalid value \"NX_LOG_LEVEL=$NX_LOG_LEVEL\""
-	[ "$NX_LOG_LEVEL" != "0" -a ! -e "$NX_LOGFILE" ] && \
-		WARNING="yes" && echo "Warning: Invalid value \"NX_LOGFILE=$NX_LOGFILE\"" \
-					  && echo "         No logfile will be kept."
-		# How do I check if another user might write to a file? ( -w checks only current user)
-	[ -z $(echo "$SESSION_LOG_CLEAN" | egrep "^[0|1]$") ] && \
-		ERROR="yes" && echo "Error: Invalid value \"SESSION_LOG_CLEAN=$SESSION_LOG_CLEAN\""
-	[ -z $(echo "$SESSION_HISTORY" | egrep "^-?[0-9]+$") ] && \
-		ERROR="yes" && echo "Error: Invalid value \"SESSION_HISTORY=$SESSION_HISTORY\""
-	
-	
-	# Forwarding directives
-	
-	[ -z $(echo "$ENABLE_SERVER_FORWARD" | egrep "^[0|1]$") ] && \
-		ERROR="yes" && echo "Error: Invalid value \"ENABLE_SERVER_FORWARD=$ENABLE_SERVER_FORWARD\""
-	[ "$ENABLE_SERVER_FORWARD" = "1" -a -z "$SERVER_FORWARD_HOST" ] && \
-		ERROR="yes" && echo "Error: Invalid value \"SERVER_FORWARD_HOST=$SERVER_FORWARD_HOST\"" 
-		# Any ideas on how I can check for a VALID host is velcome!
-		# In my private scripts I use 'resolveip -q' and check if output conforms to [0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}, 
-		# but resolveip is part of mysql, and I don't think I should add that dependancy...
-	[ "$ENABLE_SERVER_FORWARD" = "1" -a -z $(echo "$SERVER_FORWARD_PORT" | egrep "^[1-9][0-9]{0,4}$") ] && \
-		ERROR="yes" && echo "Error: Invalid value \"SERVER_FORWARD_PORT=$SERVER_FORWARD_PORT\""
-	[ "$ENABLE_SERVER_FORWARD" = "1" -a ! -e "$SERVER_FORWARD_KEY" ] && \
-		ERROR="yes" && echo "Error: Invalid value \"SERVER_FORWARD_KEY=$SERVER_FORWARD_KEY\""
-	
-	[ -z $(echo "$ENABLE_NOMACHINE_FORWARD_PORT" | egrep "^[0|1]$") ] && \
-		ERROR="yes" && echo "Error: Invalid value \"ENABLE_NOMACHINE_FORWARD_PORT=$ENABLE_NOMACHINE_FORWARD_PORT\""
-	[ "$ENABLE_NOMACHINE_FORWARD_PORT" = "1" ] && ! mywhich "$NOMACHINE_SERVER" >/dev/null 2>&1 && \
-		ERROR="yes" && echo "Error: Invalid value \"NOMACHINE_SERVER=$NOMACHINE_SERVER\""
-	[ "$ENABLE_NOMACHINE_FORWARD_PORT" = "1" -a -z $(echo "$NOMACHINE_FORWARD_PORT" | egrep "^[1-9][0-9]{0,4}$") ] && \
-		ERROR="yes" && echo "Error: Invalid value \"NOMACHINE_FORWARD_PORT=$NOMACHINE_FORWARD_PORT\""
-	
-	# Services directives
-	
-	[ -z $(echo "$ENABLE_ESD_PRELOAD" | egrep "^[0|1]$") ] && \
-		ERROR="yes" && echo "Error: Invalid value \"ENABLE_ESD_PRELOAD=$ENABLE_ESD_PRELOAD\""
-	[ "$ENABLE_ESD_PRELOAD" = "1" ] && ! mywhich "$ESD_BIN_PRELOAD" >/dev/null 2>&1 && \
-		WARNING="yes" && echo "Warning: Invalid value \"ESD_BIN_PRELOAD=$ESD_BIN_PRELOAD\"" \
-					  && echo "         No esd preload will be performed."
-	
-	[ -z $(echo "$ENABLE_ARTSD_PRELOAD" | egrep "^[0|1]$") ] && \
-		ERROR="yes" && echo "Error: Invalid value \"ENABLE_ARTSD_PRELOAD=$ENABLE_ARTSD_PRELOAD\""
-	[ "$ARTSD_BIN_PRELOAD" = "1" ] && ! mywhich "$ARTSD_BIN_PRELOAD" >/dev/null 2>&1 && \
-		WARNING="yes" && echo "Warning: Invalid value \"ARTSD_BIN_PRELOAD=$ARTSD_BIN_PRELOAD\"" \
-					  && echo "         No arts preload will be performed."
-	
-	[ -z $(echo "$ENABLE_KDE_CUPS" | egrep "^[0|1]$") ] && \
-		ERROR="yes" && echo "Error: Invalid value \"ENABLE_KDE_CUPS=$ENABLE_KDE_CUPS\""
-	[ "$ENABLE_KDE_CUPS" = "1" -a ! -e "$KDE_PRINTRC" ] && \
-		ERROR="yes" && echo "Error: Invalid value \"KDE_PRINTRC=$KDE_PRINTRC\""
-
-
-	[ "$ENABLE_FOOMATIC" = "1" ] && ! mywhich "$COMMAND_FOOMATIC" >/dev/null 2>&1 && \
-		WARNING="yes" && echo "Warning: Invalid value \"COMMAND_FOOMATIC=$COMMAND_FOOMATIC\"" \
-					  && echo "         Users will not be able to use foomatic."
-	[ ! -x "$CUPS_IPP_BACKEND" ] && \
-		WARNING="yes" && echo "Warning: \"$CUPS_IPP_BACKEND\" is not executable." \
-					  && echo "         Users will not be able to enable printing."
-	[ ! -x "$CUPS_BACKEND/smb" ] && \
-		WARNING="yes" && echo "Warning: \"$CUPS_BACKEND/smb\" is not executable." \
-					  && echo "         Users will not be able to enable printing."
-	[ ! -e "$CUPS_ETC/mime.types" -o ! -e "$CUPS_ETC/mime.convs" ] && \
-		WARNING="yes" && echo "Warning: Invalid value \"CUPS_ETC=$CUPS_ETC\"" \
-					  && echo "         Users will not be able to enable printing."
-	
-	# Path directives
-	
-	[ ! -d "$USER_FAKE_HOME" ] && \
-		ERROR="yes" && echo "Error: Invalid value \"USER_FAKE_HOME=$USER_FAKE_HOME\""
-	[ -z $(echo "$SET_LD_LIBRARY_PATH" | egrep "^[0|1]$") ] && \
-		ERROR="yes" && echo "Error: Invalid value \"SET_LD_LIBRARY_PATH=$SET_LD_LIBRARY_PATH\""
-	
-	[ "$DEFAULT_X_WM" != "" ] && ! mywhich "$DEFAULT_X_WM" >/dev/null 2>&1 && \
-		ERROR="yes" && echo "Error: Invalid value \"DEFAULT_X_WM=$DEFAULT_X_WM\""
-	[ "$DEFAULT_X_WM" != "" -a  -z $(echo "$KILL_DEFAULT_X_WM" | egrep "^[0|1]$") ] && \
-		ERROR="yes" && echo "Error: Invalid value \"KILL_DEFAULT_X_WM=$KILL_DEFAULT_X_WM\""
-	[ -z "$USER_X_STARTUP_SCRIPT" ] && \
-		ERROR="yes" && echo "Error: Invalid value \"USER_X_STARTUP_SCRIPT=$USER_X_STARTUP_SCRIPT\""
-	! mywhich "$DEFAULT_X_SESSION" >/dev/null 2>&1 && \
-		WARNING="yes" && echo "Warning: Invalid value \"DEFAULT_X_SESSION=$DEFAULT_X_SESSION\"" \
-					  && echo "         Users might not be able to request a default X session."
-	! mywhich "$COMMAND_START_KDE" >/dev/null 2>&1 && \
-		WARNING="yes" && echo "Warning: Invalid value \"COMMAND_START_KDE=$COMMAND_START_KDE\"" \
-					  && echo "         Users will not be able to request a KDE session."
-	! mywhich "$COMMAND_START_GNOME" >/dev/null 2>&1 && \
-		WARNING="yes" && echo "Warning: Invalid value \"COMMAND_START_GNOME=$COMMAND_START_GNOME\"" \
-					  && echo "         Users will not be able to request a Gnome session."
-	! mywhich "$COMMAND_START_CDE" >/dev/null 2>&1 && \
-		WARNING="yes" && echo "Warning: Invalid value \"COMMAND_START_CDE=$COMMAND_START_CDE\"" \
-					  && echo "         Users will not be able to request a CDE session."
-	! mywhich "$COMMAND_XTERM" >/dev/null 2>&1 && \
-		WARNING="yes" && echo "Warning: Invalid value \"COMMAND_XTERM=$COMMAND_XTERM\"" \
-					  && echo "         Users will not be able to request an xterm session."
-	! mywhich "$COMMAND_XAUTH" >/dev/null 2>&1 && \
-		ERROR="yes" && echo "Error: Invalid value \"COMMAND_XAUTH=$COMMAND_XAUTH\""
-	! mywhich "$COMMAND_SMBMOUNT" >/dev/null 2>&1 && \
-		WARNING="yes" && echo "Warning: Invalid value \"COMMAND_SMBMOUNT=$COMMAND_SMBMOUNT\". You'll not be able to use SAMBA. "
-	! mywhich "$COMMAND_SMBUMOUNT" >/dev/null 2>&1 && \
-		WARNING="yes" && echo "Warning: Invalid value \"COMMAND_SMBUMOUNT=$COMMAND_SMBUMOUNT\". You'll not be able to use SAMBA."
-	! mywhich "$COMMAND_NETCAT" >/dev/null 2>&1 && \
-		ERROR="yes" && echo "Error: Invalid value \"COMMAND_NETCAT=$COMMAND_NETCAT\""
-	! mywhich "$COMMAND_SSH" >/dev/null 2>&1 && \
-		ERROR="yes" && echo "Error: Invalid value \"COMMAND_SSH=$COMMAND_SSH\""
-	! mywhich "$COMMAND_SSH_KEYGEN" >/dev/null 2>&1 && \
-		ERROR="yes" && echo "Error: Invalid value \"COMMAND_SSH_KEYGEN=$COMMAND_SSH_KEYGEN\""
-	! mywhich "$COMMAND_CUPSD" >/dev/null 2>&1 && \
-		WARNING="yes" && echo "Warning: Invalid value \"COMMAND_CUPSD=$COMMAND_CUPSD\"" \
-					  && echo "         Users will not be able to enable printing."
-	[ -z "$(strings $COMMAND_CUPSD | egrep 'CUPS\/1.2')" ] && \
-		WARNING="yes" && echo "Warning: Invalid cupsd version of \"$COMMAND_CUPSD\". Need version 1.2." \
-					  && echo "         Users will not be able to enable printing."
-	! mywhich "$COMMAND_MD5SUM" >/dev/null 2>&1 && \
-		ERROR="yes" && echo "Error: Invalid value \"COMMAND_MD5SUM=$COMMAND_MD5SUM\""
-
-	# Check for expect
-	COMMAND_EXPECT=$(head -n1 $PATH_BIN/nxnode-login | cut -d'!' -f2)
-	! mywhich "$COMMAND_EXPECT" >/dev/null 2>&1 && \
-		ERROR="yes" && echo "Error: expect necessary for $PATH_BIN/nxnode-login could not be found in '$COMMAND_EXPECT'. Please install it or change nxnode-login accordingly."
-
-	# Misc directives
-	
-	[ -z $(echo "$ENABLE_AUTORECONNECT" | egrep "^[0|1]$") ] && \
-		ERROR="yes" && echo "Error: Invalid value \"ENABLE_AUTORECONNECT=$ENABLE_AUTORECONNECT\""
-	[ -z $(echo "$ENABLE_AUTORECONNECT_BEFORE_140" | egrep "^[0|1]$") ] && \
-		ERROR="yes" && echo "Error: Invalid value \"ENABLE_AUTORECONNECT_BEFORE_140=$ENABLE_AUTORECONNECT_BEFORE_140\""
-	
-	[ -z $(echo "$EXPORT_USERIP" | egrep "^[0|1]$") ] && \
-		ERROR="yes" && echo "Error: Invalid value \"EXPORT_USERIP=$EXPORT_USERIP\""
-	[ -z $(echo "$EXPORT_SESSIONID" | egrep "^[0|1]$") ] && \
-		ERROR="yes" && echo "Error: Invalid value \"EXPORT_SESSIONID=$EXPORT_SESSIONID\""
-	[ -n "$NODE_AUTOSTART" ] && ! mywhich "$NODE_AUTOSTART" >/dev/null 2>&1 && \
-		WARNING="yes" && echo "Warning: Invalid value \"NODE_AUTOSTART=$NODE_AUTOSTART\"" \
-					  && echo "         No autostart will be performed."
-
-	[ -z $(echo "$ENABLE_ROOTLESS_MODE" | egrep "^[0|1]$") ] && \
-		ERROR="yes" && echo "Error: Invalid value \"ENABLE_ROOTLESS_MODE=$ENABLE_ROOTLESS_MODE\""
-
-	[ -z "$(strings $PATH_BIN/nxagent | egrep 'NXAGENT - Version 1.5.0|NXAGENT - Version 2.[01].0|NXAGENT - Version 3.[01].0')" ] && \
-		ERROR="yes" && echo "Error: Could not find 1.5.0 or 2.[01].0 or 3.[01].0 version string in nxagent. NX 1.5.0 or 2.[01].0 or 3.[01].0 backend is needed for this version of FreeNX."
-		
-	[ -z $(echo "$ENABLE_USESSION" | egrep "^[0|1]$") ] && \
-		ERROR="yes" && echo "Error: Invalid value \"ENABLE_USESSION=$ENABLE_USESSION\""
-	[ "$ENABLE_USESSION" = "1" ] && ! mywhich "$COMMAND_SESSREG" >/dev/null 2>&1 && \
-		WARNING="yes" && echo "Warning: Invalid value \"COMMAND_SESSREG=$COMMAND_SESSREG\"" \
-					  && echo "         Logged in users will not be registered with sessreg."
-	
-	#AGENT_EXTRA_OPTIONS_RFB=""
-	#AGENT_EXTRA_OPTIONS_RDP=""
-	#AGENT_EXTRA_OPTIONS_X=""
-	#PROXY_EXTRA_OPTIONS=""
-		#Can these be checked???
-	
-	#AGENT_FONT_SERVER=""
-		#Any ideas on how I can check for a VALID host is velcome!
-	
-	#[ -z $(echo "$PROXY_TCP_NODELAY" | egrep "^[|0|1]$") ] && \
-	#	ERROR="yes" && echo "Error: Invalid value \"PROXY_TCP_NODELAY=$PROXY_TCP_NODELAY\""
-	
-	
-	if [ "$ERROR" = "yes" ]
-	then
-		echo
-		echo "  Errors occured during config check."
-		echo "  Please correct the configuration file."
-		echo
-		[ "$NXLCFG_IGNORE_ERRORS" = "no" ] && exit 1 || exit 0
-	elif [ "$WARNING" = "yes" ]
-	then
-		echo
-		echo "  Warnings occured during config check."
-		echo "  To enable these features please correct the configuration file."
-		echo
-	fi
-fi

Deleted: trunk/freenx-server/trunk/nxnode
===================================================================
--- trunk/freenx-server/trunk/nxnode	2008-03-10 22:59:38 UTC (rev 511)
+++ trunk/freenx-server/trunk/nxnode	2008-03-10 23:01:03 UTC (rev 512)
@@ -1,1499 +0,0 @@
-#!/bin/bash
-
-# Free implementation of nxserver components
-#
-# nxnode does accept (for now):
-# 
-#	--startsession
-#	--terminate
-#	--smbmount 
-#		(smbmount is not implemented yet)
-#
-# Copyright (c) 2004 by Fabian Franz.
-#
-# License: GNU GPL, version 2
-#
-# SVN: $Id$
-#
-# 21.06.2004: - Full reconnection support
-
-# Read the config file
-. $(PATH=$(cd $(dirname $0) && pwd):$PATH which nxloadconfig) --userconf
-
-#
-# -----------------------------------------------------------------------------
-# Startup of nxnode
-# -----------------------------------------------------------------------------
-#
-
-echo "NX> 1000 NXNODE - Version $NX_VERSION $NX_LICENSE"
-
-if [ "$1" != "--check" -a "$1" != "--setkey" -a "$1" != "--agent" -a "$1" != "--slave" ]
-then 
-	read CMDLINE
-
-	CMDLINE="a=b&$CMDLINE"
-fi
-
-#
-# -----------------------------------------------------------------------------
-# Various helper functions
-# -----------------------------------------------------------------------------
-#
-
-stringinstring()
-{
-	case "$2" in
-		*$1*)
-			return 0
-		;;
-	esac
-	
-	return 1
-}
-
-getparam()
-{
-	stringinstring "&$1=" "$CMDLINE" || return 1
-	
-	echo "$CMDLINE" |  tr "&" "\n" | egrep "^"$1"=" | awk -F= '{ VAL=$2 } END { print VAL }' | sed 's|%24|$|'
-	
-	return 0
-}
-
-find_app()
-{
-	set -- $*
-	which $1 2>/dev/null
-}
-
-getparam_sessionid()
-{
-	sessionid=$(getparam sessionid)
-	
-	[ -n "$sessionid" ] || sessionid=$(getparam session_id)
-	if [ -z "$sessionid" ]
-	then
-		echo "NX> 500 Error: Fatal - Missing parameter session id." 1>&2
-		exit 1
-	fi
-	
-	echo $sessionid
-}
-
-#
-# -----------------------------------------------------------------------------
-# Node functions module
-# -----------------------------------------------------------------------------
-#
-
-#
-# node_terminate_agent <session id>
-#
-
-node_terminate_agent()
-{
-	NODE_AGENT_PID=$(cat "$USER_FAKE_HOME/.nx/C-$1/pids/agent" 2>/dev/null)
-	[ -n "$NODE_AGENT_PID" ] && kill $NODE_AGENT_PID 2>/dev/null
-}
-
-#
-# node_terminate_session <session id>
-#
-#	Used local vars: $virtualdesktop, $rootless
-#
-#	Used config vars: $COMMAND_XAUTH, $SESSION_LOG_CLEAN
-#
-
-node_terminate_session()
-{
-	#
-	# Cleanup session
-	#
-
-	[ -d "$USER_FAKE_HOME/.nx/C-$1/" ] || return
-
-	# Kill nxagent
-	
-	NODE_AGENT_PID=$(cat "$USER_FAKE_HOME/.nx/C-$1/pids/agent" 2>/dev/null)
-	
-	if [ -n "$NODE_AGENT_PID" ]
-	then
-		kill $NODE_AGENT_PID 2>/dev/null
-		if ! [ "$virtualdesktop" = "0" -a "$rootless" != "1" ]
-		then
-			sleep 1
-			kill -0 $NODE_AGENT_PID 2>/dev/null && kill -9 $NODE_AGENT_PID 2>/dev/null
-		fi
-	fi
-
-	# Kill tail process
-	
-	NODE_TAIL_PID=$(cat "$USER_FAKE_HOME/.nx/C-$sess_id/pids/tail" 2>/dev/null)
-	[ -n "$NODE_TAIL_PID" ] && kill $NODE_TAIL_PID 2>/dev/null
-
-	# JJK: Kill running services
-	# FF: Seems this is needed also here ...
-	node_stop_services
-
-	# Remove display information
-	
-	NODE_DISPLAY=$(echo $1 | awk 'BEGIN {FS="-"} {i=NF-1; print $i}')
-	rm -f /tmp/.X$NODE_DISPLAY-lock
-	rm -f /tmp/.X11-unix/X$NODE_DISPLAY
-	
-	# Remove magic cookie information
-	
-	$COMMAND_XAUTH -v source "$USER_FAKE_HOME/.nx/C-$1/scripts/authority" >/dev/null 2>&1
-
-	# Preserve or remove session information
-	
-	[ "$SESSION_LOG_CLEAN" = "1" ] && rm -rf "$USER_FAKE_HOME/.nx/C-$1/"
-	
-	[ "$SESSION_LOG_CLEAN" = "0" -a "$2" = "failed" ] && mv "$USER_FAKE_HOME/.nx/C-$1/" "$USER_FAKE_HOME/.nx/F-C-$1/"
-	[ "$SESSION_LOG_CLEAN" = "0" -a "$2" != "failed" ] && mv "$USER_FAKE_HOME/.nx/C-$1/" "$USER_FAKE_HOME/.nx/T-C-$1/"
-}
-
-#
-# node_fail_restore_session <session id>
-#
-
-# TODO: Kill still running tail -f process.
-
-node_fail_restore_session()
-{
-	echo "NX> 1004 Error: Could not resume session. nxagent process could not be found."
-	
-	NODE_TAIL_PID=$(cat "$USER_FAKE_HOME/.nx/C-$sess_id/pids/tail" 2>/dev/null)
-	[ -n "$NODE_TAIL_PID" ] && kill $NODE_TAIL_PID
-	[ -n "$NODE_TAIL_PID" ] && echo "NX 1004> kill $NODE_TAIL_PID"
-	
-	node_terminate_session "$1" "failed"
-	exit 1
-}
-
-#
-# node_suspend_session <session id>
-#
-
-node_suspend_session()
-{
-	NODE_AGENT_PID=$(cat "$USER_FAKE_HOME/.nx/C-$1/pids/agent" 2>/dev/null)
-
-	if [ -n "$NODE_AGENT_PID" ]
-	then
-		kill -0 $NODE_AGENT_PID || return 1
-		kill -HUP $NODE_AGENT_PID && return 0
-	fi
-
-	return 1
-}
-
-#
-# node_find_application <type>
-#
-#	Used config vars: $COMMAND_START_KDE, $COMMAND_START_GNOME,
-#			  $COMMAND_START_CDE, $COMMAND_XTERM, $USER_X_STARTUP_SCRIPT,
-#			  $DEFAULT_X_SESSION
-
-node_find_application()
-{
-	NODE_STARTX=""
-
-	case $1 in
-		unix-kde)
-			NODE_STARTX=$COMMAND_START_KDE
-		;;
-		unix-gnome)
-			NODE_STARTX=$COMMAND_START_GNOME
-		;;
-		unix-cde)
-			NODE_STARTX=$COMMAND_START_CDE
-		;;
-		unix-application)
-			[ "$application" = "xterm" ] && application=$COMMAND_XTERM
-			NODE_STARTX=$application
-		;;
-		unix-default)
-			if [ -x "$HOME/$USER_X_STARTUP_SCRIPT" ]; then
-				NODE_STARTX="$HOME/$USER_X_STARTUP_SCRIPT"
-			elif which "$DEFAULT_X_SESSION" >/dev/null 2>&1 ; then
-				NODE_STARTX="$DEFAULT_X_SESSION"
-			fi
-		;;
-	esac
-
-	echo "$NODE_STARTX"
-}
-
-#
-# node_start_applications
-#
-#	Used local vars: $type, $application, $sess_id, $mediahelper,
-#		         $virtualdesktop, $rootless, $display
-#
-#	Used config vars: <several>
-#
-
-node_start_applications()
-{
-	# close input and output file descriptors
-	exec 0<&-
-	exec 1>&-
-	exec 2>&-
-
-	#
-	# Prepare application startup
-	#
-	
-	. /etc/profile
-	[ -f ~/.bash_profile ] && . ~/.bash_profile
-
-	mkdir -p "$USER_FAKE_HOME/.nx/C-$sess_id/pids/"
-
-	#
-	# Which application do we start?
-	#
-
-	NODE_APPLICATION=$(node_find_application "$type")
-	
-	# For rdesktop/VNC, there is no application to start
-	[ -n "$NODE_APPLICATION" ] || return
-
-	#
-	# Check if we want to use a mediahelper
-	#
-
-	if [ "$mediahelper" = "esd" ]
-	then
-		# Set Espeaker variable
-		let ESPEAKER=$display+7000
-		export ESPEAKER="127.0.0.1:$ESPEAKER"
-		
-		# Do not spawn new ESD daemons
-		export ESD_NO_SPAWN="yes"
-			
-		# Check for config file directive
-		if [ "$ENABLE_ESD_PRELOAD" = "1" -a -x "$(find_app $ESD_BIN_PRELOAD)" ]
-		then
-			NODE_APPLICATION="$ESD_BIN_PRELOAD $NODE_APPLICATION"
-			echo "Info: NXNODE - Using $ESD_BIN_PRELOAD wrapper script." >> "$USER_FAKE_HOME/.nx/C-$sess_id/session"
-		fi
-	elif [ "$mediahelper" = "artsd" ]
-	then
-		# Overwrite users mcoprc
-		echo -n "GlobalComm=Arts::X11GlobalComm" > $HOME/.mcoprc
-		if [ "$ENABLE_ARTSD_PRELOAD" = "1" -a -x "$(find_app $ARTSD_BIN_PRELOAD)" ]
-		then
-			NODE_APPLICATION="$ARTSD_BIN_PRELOAD $NODE_APPLICATION"
-			echo "Info: NXNODE - Using $ARTSD_BIN_PRELOAD wrapper script." >> "$USER_FAKE_HOME/.nx/C-$sess_id/session"
-		fi
-	fi
-
-	[ "$cups" = "1" -a "$ENABLE_CUPS_SERVER_EXPORT" = "1" ] && export CUPS_SERVER="$USER_FAKE_HOME/.nx/C-$sess_id/cups/cups.sock"
-
-	#
-	# Do we need to PRELOAD any libraries?
-	#	
-
-	[ "$virtualdesktop" = "0" -a "$rootless" != "1" ] && export LD_PRELOAD="$APPLICATION_LIBRARY_PRELOAD:$LD_PRELOAD"
-
-	#
-	# Should we start a window manager?
-	#
-	
-	if [ "$virtualdesktop" = "1" -a "$type" = "unix-application" -a "$DEFAULT_X_WM" != "" -a -x "$(find_app $DEFAULT_X_WM)" ]
-	then
-		DISPLAY=:$display $DEFAULT_X_WM >>"$USER_FAKE_HOME/.nx/C-$sess_id/session" 2>&1 &
-		NODE_WM_PID=$!
-	fi
-
-	echo "Xft.dpi: 96" | DISPLAY=:$display xrdb -merge >>"$USER_FAKE_HOME/.nx/C-$sess_id/session" 2>&1
-
-	#
-	# Startup the application
-	#
-	
-	DISPLAY=:$display $NODE_APPLICATION >>"$USER_FAKE_HOME/.nx/C-$sess_id/session" 2>&1 &
-	NODE_APP_PID=$!
-	
-	mkdir -p "$USER_FAKE_HOME/.nx/C-$sess_id/pids/"
-	echo "$NODE_APP_PID" >"$USER_FAKE_HOME/.nx/C-$sess_id/pids/applications"
-	wait $NODE_APP_PID
-
-	#
-	# Kill or wait for the started window manager
-	#	
-	
-	if [ -n "$NODE_WM_PID" ]
-	then
-		# kill the WM after application is finished?
-		[ "$KILL_DEFAULT_X_WM" = "1" ] && kill $NODE_WM_PID 2>/dev/null
-		# or just wait until it finishes?
-		[ "$KILL_DEFAULT_X_WM" = "1" ] || wait $NODE_WM_PID
-	fi
-	rm -f "$USER_FAKE_HOME/.nx/C-$sess_id/pids/applications"
-
-	# Do not terminate agent in case of rootless agent mode.
-	# The agent times out after a while by itself anyway.
-	
-	[ "$virtualdesktop" = "1" -o "$rootless" != "1" ] && node_terminate_agent "$sess_id"
-}
-
-#
-# node_persistent_session
-#
-#	Is the user allowed to run a persistent session?
-#
-
-node_agent_persistent_session()
-{
-	P="-nopersistent"
-	OLD_IFS=$IFS
-	IFS=","
-	[ "$ENABLE_PERSISTENT_SESSION" = "all" ] && P="-persistent"
-	[ "$ENABLE_PERSISTENT_SESSION" = "all" ] || for USERNAME in $ENABLE_PERSISTENT_SESSION; do
-		[ "${USERNAME:0:1}" != "@" ] && [ "$USER" = "$USERNAME" ] && P="-persistent" && break ;
-		[ "${USERNAME:0:1}" = "@" ] && [ -z $(groups "$USER" | egrep "^${USERNAME:1}:") ] && P="-persistent" && break ;
-	done
-	for USERNAME in $DISABLE_PERSISTENT_SESSION; do
-		[ "${USERNAME:0:1}" != "@" ] && [ "$USER" = "$USERNAME" ] && P="-nopersistent" && break ;
-		[ "${USERNAME:0:1}" = "@" ] && [ -z $(groups "$USER" | egrep "^${USERNAME:1}:") ] && P="-nopersistent" && break ;
-	done
-	IFS=$OLD_IFS
-	echo "$P"
-}
-
-#
-# node_start_agent
-#
-
-node_start_agent()
-{
-	# Ok, now we do some wicked fd magic.
-	#
-	# first part:
-	#	
-	# nxagent's fd #2 -> fd #3
-	
-	# second part:
-	#
-	# fd #1 -> #4
-	# fd #3 -> #1
-	# tee | node_start_monitor
-
-	# third part
-	# fd #4 -> #1
-
-	# => all output of nxagent goes to tee | node_start_monitor, while
-	#    leaving all other output flow through like normally.
-	
-	# preparations
-	exec 3>&2
-	exec 4>&1
-
-	{
-	
-	{
-
-	#
-	# Setup environment
-	#
-
-	export DISPLAY="nx/nx,options=$USER_FAKE_HOME/.nx/C-$sess_id/options:$display"
-	export XAUTHORITY="$USER_FAKE_HOME/.nx/C-$sess_id/authority"
-	export HOME="$USER_FAKE_HOME"
-	export NX_CLIENT="$PATH_BIN/nxdialog"
-
-	#
-	# Setup optional parameters for nxagent
-	#
-
-	# keyboard
-	
-	K=""
-	# backwards compatibility
-	[ -n "$keyboard" ] && K="-keyboard $keyboard"
-	[ -n "$kbtype" ] && K="-kbtype $kbtype"
-
-	# backingstore
-	
-	B=""
-	if [ -n "$backingstore" -a "$ENABLE_1_5_0_BACKEND" = "1" ]
-	then
-		[ "$backingstore" != 1 ] && B="-bs $backingstore"
-		[ "$backingstore" = 1 ] && B="+bs"
-	fi
-
-	# geometry
-	
-	G=""
-	[ -n "$geometry" ] && G="-geometry $geometry"
-
-	# type of session
-	
-	R="-D"
-	[ "$rootless" = "1" ] && R="-R"
-
-	# Setup fullscreen parameters
-	
-	vncfullscreen=""
-	[ "$geometry" = "fullscreen" -a "$type" = "vnc" ] && vncfullscreen="-fullscreen" && G=""
-	
-	[ "$geometry" = "fullscreen" -a "$type" = "windows" ] && G="-geometry `echo $screeninfo | cut -d"x" -f1,2`"
-
-	#
-	# Start the wanted nxagent
-	#
-
-	if [ "$type" = "windows" ]
-	then
-		# nxdesktop session (Windows RDP)
-
-		[ "$SET_LD_LIBRARY_PATH" = "1" ] && export LD_LIBRARY_PATH="$AGENT_LIBRARY_PATH:$LD_LIBRARY_PATH"
-		# Setup optional parameters
-		
-		U=""
-		P=""
-		D=""
-		[ -n "$agent_user" ] && U="-u $agent_user"
-		[ -n "$agent_password" ] && P="-p -"
-		[ -n "$agent_domain" ] && D="-d $agent_domain"
-
-		# Start the agent
-		
-		echo "$agent_password" | $PATH_BIN/nxdesktop -name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" -option "$USER_FAKE_HOME/.nx/C-$sess_id/options" $K $G $U $P $D $agent_server $AGENT_EXTRA_OPTIONS_RDP 2>&3 &
-
-	elif [ "$type" = "vnc" ]
-	then
-		# nxviewer session (VNC RFB)
-		
-		[ "$SET_LD_LIBRARY_PATH" = "1" ] && export LD_LIBRARY_PATH="$AGENT_LIBRARY_PATH:$LD_LIBRARY_PATH"
-		# Setup password
-		
-		mkdir -p "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/"
-		echo "$agent_password" | $PATH_BIN/nxpasswd "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/.passwd" doit
-
-		# Start x11vnc
-		if [ -n "$mirrordisplay" ]
-		then
-			(
-				unset XAUTHORITY
-				# Note: No "-accept popup" as its the same user and with that password
-				#       he could do already more than -accept popup would allow.
-				DISPLAY="$mirrorhost:$mirrordisplay.0" x11vnc -timeout 120 -rfbauth "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/.passwd" >"$USER_FAKE_HOME/.nx/C-$sess_id/scripts/.vnc_port" 2>&3 &
-			)
-			sleep 1
-			agent_port=$(cat "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/.vnc_port" | egrep "^PORT=" | cut -d'=' -f 2)
-			[ -z "agent_port" ] && agent_port="0"
-			# note the :: is not a mistake, but rather a hint for nxviewer to use this as a port and not 
-			# interpret it as a display.
-			agent_server="127.0.0.1::$agent_port"
-			rm -f "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/.vnc_port"
-		fi
-		
-		# Start the agent
-		
-		$PATH_BIN/nxviewer -encodings tight hextile copyrect raw -passwd "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/.passwd" -name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" -option "$USER_FAKE_HOME/.nx/C-$sess_id/options" $vncfullscreen $G $K $agent_server $AGENT_EXTRA_OPTIONS_RFB 2>&3 &
-
-	elif [ "$R" = "-R" -a "$rootless" != "1" ]
-	then
-		# nxproxy single application mode session
-		[ "$SET_LD_LIBRARY_PATH" = "1" ] && export LD_LIBRARY_PATH="$PROXY_LIBRARY_PATH:$LD_LIBRARY_PATH"
-		$PATH_BIN/nxproxy -C :$display $PROXY_EXTRA_OPTIONS 2>&3 &
-	else
-		# nxagent session (X11)
-		[ "$SET_LD_LIBRARY_PATH" = "1" ] && export LD_LIBRARY_PATH="$AGENT_LIBRARY_PATH:$LD_LIBRARY_PATH"
-		
-		# Setup optional parameters
-
-		P=$(node_agent_persistent_session)
-		FP=""
-		[ -n "$AGENT_FONT_SERVER" ] && FP="-fp $AGENT_FONT_SERVER"
-		
-		# Start the agent
-		
-		PATH="$PATH_BIN:$PATH" $PATH_BIN/nxagent $P $R -name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" -option "$USER_FAKE_HOME/.nx/C-$sess_id/options" $K $G $B $FP $AGENT_EXTRA_OPTIONS_X :$display 2>&3 &
-	fi
-	
-	#
-	# Wait for the agent
-	#
-	
-	NODE_AGENT_PID=$!
-	mkdir -p "$USER_FAKE_HOME/.nx/C-$sess_id/pids/"
-	echo "$NODE_AGENT_PID" >"$USER_FAKE_HOME/.nx/C-$sess_id/pids/agent"
-	wait $NODE_AGENT_PID
-
-	NODE_AGENT_EXIT_STATUS=$?
-	NODE_FAILED=""
-	if [ $NODE_AGENT_EXIT_STATUS -ne 0 ]
-	then
-		echo "NX> 1004 Error: NX Agent exited with exit status 1. To troubleshoot set SESSION_LOG_CLEAN=0 in node.conf and investigate \"$USER_FAKE_HOME/.nx/F-C-$sess_id/session\". You might also want to try: ssh -X myserver; $PATH_BIN/nxnode --agent to test the basic functionality. Session log follows:"
-		cat "$USER_FAKE_HOME/.nx/C-$sess_id/session" 1>&2
-		NODE_FAILED="failed"
-	fi
-	echo "NX> 1006 Session status: closed"
-	
-	#
-	# Cleanup session information
-	#	
-	
-	rm -f "$USER_FAKE_HOME/.nx/C-$sess_id/pids/agent"
-	node_terminate_session "$sess_id" "$NODE_FAILED"
-	
-	# remove possible leftovers of nxagent
-	rm -f /tmp/.X$display-lock
-	rm -f /tmp/.X11-unix/X$display
-	} 3>&1 1>&4 | tee "$USER_FAKE_HOME/.nx/C-$sess_id/session" | node_start_monitor; } 4>&1
-}
-
-#
-# node_cupsd_stop
-#
-#	Used local vars: $sess_id
-#
-
-node_cupsd_stop()
-{
-	#
-	# Cleanup userspace cups daemon	
-	#
-	
-	[ -e "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd" ] || return
-	
-	NODE_CUPSD_PID=$(cat "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd")
-	
-	# Check for a running userspace cupsd, look if its still active 
-	# and kill it if so
-	( [ -n "$NODE_CUPSD_PID" ] && kill -0 $NODE_CUPSD_PID && kill $NODE_CUPSD_PID && sleep 2 && kill -0 $NODE_CUPSD_PID && kill -9 $NODE_CUPSD_PID ) 2>/dev/null
-	
-	# delete pid file
-	rm -f "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd"
-	
-	# remove all printers
-	echo >"$USER_FAKE_HOME/.nx/C-$sess_id/cups/printers.conf"
-}
-
-#
-# node_cupsd_setup
-#
-#	Used local vars: $sess_id, $display
-#
-
-node_cupsd_setup()
-{
-	let NODE_CUPSD_PORT=$display+9000 # offset 9000 for userspace cupsd's
-	export NODE_CUPSD_PORT
-	
-	export NODE_CUPSD_SOCKET="$USER_FAKE_HOME/.nx/C-$sess_id/cups/cups.sock"
-	
-	mkdir -p "$USER_FAKE_HOME/.nx/C-$sess_id/pids/"
-	[ -e "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd" ] && return
-	touch "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd"
-	
-	mkdir -p "$USER_FAKE_HOME/.nx/C-$sess_id/cups/spool/tmp" "$USER_FAKE_HOME/.nx/C-$sess_id/cups/spool/certs" "$USER_FAKE_HOME/.nx/C-$sess_id/cups/ppd" "$USER_FAKE_HOME/.nx/C-$sess_id/cups/cache"
-
-cat <<EOF > $USER_FAKE_HOME/.nx/C-$sess_id/cups/cupsd.conf
-AccessLog /dev/null
-ErrorLog error_log
-PageLog page_log
-LogLevel info
-TempDir $USER_FAKE_HOME/.nx/C-$sess_id/cups/spool/tmp
-RequestRoot $USER_FAKE_HOME/.nx/C-$sess_id/cups/spool
-ServerRoot $USER_FAKE_HOME/.nx/C-$sess_id/cups/
-StateDir $USER_FAKE_HOME/.nx/C-$sess_id/cups/
-CacheDir $USER_FAKE_HOME/.nx/C-$sess_id/cups/cache
-
-Listen $NODE_CUPSD_SOCKET
-Browsing Off
-ServerName localhost
-PidFile $USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd
-
-<Location />
-Order Deny,Allow
-Deny From All
-Allow from 127.0.0.1
-</Location>
-
-# Allow everything for anonymous, because we are protected through UNIX socket
-<Policy default>
-  <Limit All>
-    AuthType None
-    Order deny,allow
-  </Limit>
-</Policy>
-EOF
-
-	touch "$USER_FAKE_HOME/.nx/C-$sess_id/cups/printers.conf" "$USER_FAKE_HOME/.nx/C-$sess_id/cups/classes.conf"
-
-	# copy mime.* files
-	cp -af "$CUPS_ETC"/mime.* "$USER_FAKE_HOME/.nx/C-$sess_id/cups/"
-
-	# start cupsd
-	$COMMAND_CUPSD -c "$USER_FAKE_HOME/.nx/C-$sess_id/cups/cupsd.conf" &>/dev/null </dev/null
-
-	# setup KDE
-	if [ "$ENABLE_KDE_CUPS" = "1" -a -e "$KDE_PRINTRC" ]
-	then
-		if egrep -q "^Host=" "$KDE_PRINTRC"
-		then
-			[ "$ENABLE_KDE_CUPS_DYNAMIC" = "1" ] && $COMMAND_PERL -pi -e 's,^Host=.*,Host[\$ie]=\$\('"$PATH_BIN/nxcups-gethost"'),g' "$KDE_PRINTRC"
-			[ "$ENABLE_KDE_CUPS_DYNAMIC" != "1" ] && $COMMAND_PERL -pi -e 's,^Host=.*,Host='"$NODE_CUPSD_SOCKET"',g' "$KDE_PRINTRC"
-		else
-			echo "[CUPS]" >> "$KDE_PRINTRC"
-			[ "$ENABLE_KDE_CUPS_DYNAMIC" = "1" ] && echo "Host[\$ie]=\$($PATH_BIN/nxcups-gethost)" >> "$KDE_PRINTRC"
-			[ "$ENABLE_KDE_CUPS_DYNAMIC" != "1" ] && echo "Host=$NODE_CUPSD_SOCKET" >> "$KDE_PRINTRC"
-		fi
-	fi
-}
-
-#
-# node_cupsd_reload
-#
-#	Used local vars: $sess_id
-#
-
-node_cupsd_reload()
-{
-	[ -e "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd" ] || return
-	NODE_CUPSD_PID=$(cat "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd")
-	[ -n "$NODE_CUPSD_PID" ] && kill -0 $NODE_CUPSD_PID && kill -HUP $NODE_CUPSD_PID
-}
-
-node_cupsd_get_socket()
-{
-	node_cupsd_setup
-	echo $NODE_CUPSD_SOCKET
-}
-
-node_umount_smb()
-{
-	[ -e "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/mpoint" ] || return
-	cat "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/mpoint" | while read mpoint
-	do
-		$COMMAND_SMBUMOUNT "$mpoint" >/dev/null 2>/dev/null
-	done
-}
-
-node_stop_services()
-{
-	node_umount_smb
-	node_cupsd_stop
-}
-
-node_emergency_exit()
-{
-	# umount shares & stop printers
-	node_stop_services
-
-	# kill the session
-	node_terminate_session "$sess_id" "failed"
-
-	echo "NX> 1004 Error: Emergency exit due to kill signal."
-}
-
-#
-# Monitoring the nxagent: Its also kind of a "state-machine" 
-#                         as it has to keep track of different 
-#                         connection states and react differently.
-#
-
-node_start_monitor_2_0_0()
-{
-	NODE_TAIL_PID=""
-	NODE_SUSPEND_STATUS="$2"
-
-	while read line 
-	do
-		#
-		# Catch tail pid
-		#
-		
-		if stringinstring "Info: tail -f running with pid" "$line"
-		then
-			NODE_TAIL_PID=$(echo $line | cut -d"'" -f2)
-			echo "$NODE_TAIL_PID" >"$USER_FAKE_HOME/.nx/C-$sess_id/pids/tail"
-		fi
-
-		#
-		# Catch NXAGENT SMB Port (sometimes the port differs from what we got from nxserver)
-		#
-		
-		if stringinstring "Info: Listening * SMB connections on port" "$line"
-		then
-			SMBMOUNT_PORT=$(echo $line | cut -d"'" -f2)
-			echo "$SMBMOUNT_PORT" >"$USER_FAKE_HOME/.nx/C-$sess_id/scripts/mport"
-		fi
-
-		#
-		# Session messages
-		#
-
-		if stringinstring "Session: Starting session at" "$line"
-		then
-			echo "NX> 1009 Session status: starting"
-		fi
-		
-		if stringinstring "Session: Suspending session at" "$line"
-		then
-			echo "NX> 1009 Session status: suspending"
-		fi
-		
-		if stringinstring "Session: Terminating session at" "$line"
-		then
-			echo "NX> 1009 Session status: terminating"
-		fi
-		
-		if stringinstring "Session: Resuming session at" "$line"
-		then
-			echo "NX> 1009 Session status: resuming"
-		fi
-
-
-		#
-		# Session suspend
-		#
-
-		if stringinstring "Session: Session suspended at" "$line"
-		then
-			echo "NX> 1005 Session status: suspended"
-			# umount shares & stop printers
-
-			if [ "$NODE_SUSPEND_STATUS" = "Running" ]
-			then
-				node_suspend_session "$sess_id"
-				NODE_SUSPEND_STATUS=""
-			else
-				node_stop_services
-			fi
-		fi
-
-		#
-		# Watchdog termination
-		#
-
-		if stringinstring "Info: Watchdog running with pid" "$line"
-		then
-			NODE_WATCHDOG_PID=$(echo $line | cut -d"'" -f2)
-		fi
-
-		if stringinstring "Info: Waiting the watchdog process to complete." "$line"
-		then
-			# Kill the watchdog
-			kill $NODE_WATCHDOG_PID 2>/dev/null
-		fi
-		
-		#
-		# Session is running
-		#
-		
-		if stringinstring "Info: Waiting for connection from" "$line"
-		then
-			echo "NX> 710 Session status: running"
-			echo "NX> 1002 Commit"
-			echo "NX> 1006 Session status: running"
-		fi
-
-		#
-		# Reconnection success!
-		#
-		
-		if stringinstring "Session: Session resumed at" "$line"
-		then
-			echo "NX> 718 Session restore succeded"
-			if [ "$1" = "restore" ]
-			then
-				kill $NODE_TAIL_PID
-				break
-			fi
-		fi
-
-		#
-		# Reconnection failure
-		#
-		
-		if stringinstring "Session: Display failure detected at" "$line"
-		then
-			echo "NX> 596 Error: Session $1 failed. Reason was: $line"
-			if [ "$1" = "restore" ]
-			then
-				kill $NODE_TAIL_PID
-				break
-			fi
-		fi
-	done
-	
-	trap "" EXIT
-	
-	[ "$1" = "restore" ] ||	node_stop_services
-	# close all open file descriptors
-	exec 0<&-
-	exec 1>&-
-	exec 2>&-
-	exit 0
-}
-
-node_start_monitor_1_5_0()
-{
-	NODE_RUNNING=0
-	NODE_TAIL_PID=""
-	NODE_SUSPEND_STATUS="$2"
-
-	while read line 
-	do
-		#
-		# Catch tail pid
-		#
-		
-		if stringinstring "Info: tail -f running with pid" "$line"
-		then
-			NODE_TAIL_PID=$(echo $line | cut -d"'" -f2)
-			echo "$NODE_TAIL_PID" >"$USER_FAKE_HOME/.nx/C-$sess_id/pids/tail"
-		fi
-
-		#
-		# Catch NXAGENT SMB Port (sometimes the port differs from what we got from nxserver)
-		#
-
-		if stringinstring "Info: Listening for SMB connections on port" "$line"
-		then
-			SMBMOUNT_PORT=$(echo $line | cut -d"'" -f2)
-			echo "$SMBMOUNT_PORT" >"$USER_FAKE_HOME/.nx/C-$sess_id/scripts/mport"
-		fi
-
-
-		#
-		# Session suspend
-		#
-
-		if stringinstring "Info: Session suspended." "$line"
-		then
-			echo "NX> 1005 Session status: suspended"
-			# umount shares & stop printers
-
-			if [ "$NODE_SUSPEND_STATUS" = "Running" ]
-			then
-				node_suspend_session "$sess_id"
-				NODE_SUSPEND_STATUS=""
-			else
-				node_stop_services
-			fi
-		fi
-
-		#
-		# Proxy termination
-		#
-
-		if stringinstring "Info: Waiting for a further signal to complete." "$line"
-		then
-			# Kill the proxy
-			kill -HUP $NODE_PROXY_PID 2>/dev/null
-		fi
-		
-		#
-		# Session end
-		#
-		
-		if stringinstring "Info: End of session requested by " "$line" && [ "$RECONNECT" = "0" ] && ! stringinstring "'SIGHUP'" "$line"
-		then
-			echo "NX> 1009 Session status: terminating"
-			kill -HUP $NODE_PROXY_PID 2>/dev/null
-		fi
-		
-		#
-		# Session is running
-		#
-		
-		if stringinstring "Info: Waiting for connection from" "$line"
-		then
-			echo "NX> 710 Session status: running"
-			echo "NX> 1002 Commit"
-			echo "NX> 1006 Session status: running"
-		fi
-
-		#
-		# Status = Running - Do _not_ fail anymore.
-		#
-
-		if stringinstring "Info: Connection with remote proxy established." "$line"
-		then
-			NODE_RUNNING=1
-		fi
-	
-		#
-		# Catch proxy pid
-		#
-		
-		if stringinstring "Info: Proxy running in server mode with pid" "$line"
-		then
-			NODE_PROXY_PID=$(echo $line | cut -d"'" -f2)
-		fi
-		
-		#
-		# Reconnection success!
-		#
-		
-		if stringinstring "Info: Reconnection succeded." "$line"
-		then
-			echo "NX> 718 Session restore succeded"
-			if [ "$1" = "restore" ]
-			then
-				kill $NODE_TAIL_PID
-				break
-			fi
-		fi
-
-		#
-		# Reconnection failure
-		#
-		
-		if stringinstring "Info: Reconnection failed:" "$line"
-		then
-			echo "NX> 1005 Session status: suspended"
-			echo "NX> 596 Error: Session restore failed. Reason was: $line"
-			if [ "$1" = "restore" ]
-			then
-				kill $NODE_TAIL_PID
-				break
-			fi
-		fi
-	done
-	
-	trap "" EXIT
-
-	[ "$1" = "restore" ] ||	node_stop_services
-	# close all open file descriptors
-	exec 0<&-
-	exec 1>&-
-	exec 2>&-
-	exit 0
-}
-
-#
-# node_start_monitor <start|restore> <Running|Suspended>
-#
-
-node_start_monitor()
-{
-	if [ "$ENABLE_1_5_0_BACKEND" = "1" ]
-	then
-		node_start_monitor_1_5_0 "$@"
-	else
-		node_start_monitor_2_0_0 "$@"
-	fi
-
-}
-
-#
-# -----------------------------------------------------------------------------
-# startsession - Start a new session.
-# -----------------------------------------------------------------------------
-#
-
-startsession()
-{
-
-	# user=knoppix&userip=192.168.1.66&uniqueid=6A8269CC467264EAEF6349D062689755&display=1000&session=lappi%5ffull&type=unix%2dkde&cache=8M&images=32M&cookie=84765070afee043cf83f85d21130145f&link=lan&render=1&backingstore=when_requested&imagecompressionmethod=0&geometry=fullscreen&keyboard=fr&media=0&samba=1&agent_server=&agent_user=&agent_password=
-
-	user=$(getparam user)
-	userip=$(getparam userip)
-	uniqueid=$(getparam uniqueid)
-	display=$(getparam display)
-	session=$(getparam session)
-	type=$(getparam type | sed 's/%2d/-/g')
-	application=$(getparam application)
-	cache=$(getparam cache)
-	images=$(getparam images)
-	cookie=$(getparam cookie)
-	link=$(getparam link)
-	virtualdesktop=$(getparam virtualdesktop)
-	render=$(getparam render)
-	backingstore=$(getparam backingstore)
-	imagecompressionmethod=$(getparam imagecompressionmethod)
-	imagecompressionlevel=$(getparam imagecompressionlevel)
-	geometry=$(getparam geometry)
-	keyboard=$(getparam keyboard)
-	kbtype=$(getparam kbtype)
-	media=$(getparam media)
-	mediahelper=$(getparam mediahelper)
-	sync=$(getparam sync)
-	samba=$(getparam samba)
-	cups=$(getparam cups)
-	agent_server=$(getparam agent_server | sed 's/%3A/:/g')
-	agent_user=$(getparam agent_user)
-	agent_password=$(getparam agent_password)
-	agent_domain=$(getparam agent_domain)
-	screeninfo=$(getparam screeninfo)
-	nodelay=$(getparam nodelay)
-	[ "$PROXY_TCP_NODELAY" = "0" ] && nodelay=0
-
-	# 1.5.0 options
-	rdpcolors=$(getparam rdpcolors)
-	rdpcache=$(getparam rdpcache)
-	http=$(getparam http)
-	
-	# nxclient > 1.5.0-106 variables
-	resize=$(getparam resize)
-	keybd=$(getparam keybd)
-
-	# backwards compatibility for keybd parameter
-	[ -z "$keybd" ] && keybd=$(getparam aux)
-	aux=$(getparam aux)
-
-	kbload=$(getparam kbload)
-	keymap=$(getparam keymap)
-
-	rootless=0
-	# Its still the clients decision
-	[ "$ENABLE_ROOTLESS_MODE" = "1" ] &&  rootless=$(getparam rootless)
-
-	# Rootless fix from 2x nxserver 1.5.0
-	realtype=$type
-	[ "$type" = "unix-application" -o "$type" = "unix-default" ] && realtype="unix-desktop"
-
-	# NX 2.1.0 file-sharing port options
-	client=$(getparam client)
-
-	smbport=""
-
-	if [ "$samba" = "1" ]
-	then
-		# We know from protocol traces that client=linux,winnt,macosx are valid values.
-		# I hope with smbclientproto=smb on default and smbclientproto=cifs on all valid
-		# values we get support for all those systems.
-
-		smbproto="$SAMBA_MOUNT_SHARE_PROTOCOL"
-
-		if [ "$smbproto" = "both" ]
-		then
-			smbproto="smbfs"
-
-			[ "$client" = "linux" ] && smbproto="cifs"
-			[ "$client" = "winnt" ] && smbproto="cifs"
-			[ "$client" = "macosx" ] && smbproto="cifs"
-
-			# FIXME: This is a rather wild guess
-			[ "$client" = "win9x" ] && smbproto="smbfs"
-		fi
-
-		if [ "$smbproto" = "cifs" ]
-		then
-			smbport=445
-			COMMAND_SMBMOUNT=$COMMAND_SMBMOUNT_CIFS
-			COMMAND_SMBUMOUNT=$COMMAND_SMBUMOUNT_CIFS
-		elif [ "$smbproto" = "none" ] # none
-		then
-			# we set this to true so that the 
-			# SMB mount does not give an error message.
-
-			COMMAND_SMBMOUNT=/bin/true
-			COMMAND_SMBUMOUNT=/bin/true
-		else # smbfs
-			smbport=139
-		fi
-	fi
-	
-	# FreeNX specific variables
-	clientproto=$(getparam clientproto)
-	status=$(getparam status)
-	host=$(getparam host)
-	mirrordisplay=$(getparam mirrordisplay)
-	mirrorhost=$(getparam mirrorhost)
-	
-	sess_id="$SERVER_NAME-$display-$uniqueid"
-	NXSESSION_DIRECTORY="$USER_FAKE_HOME/.nx/C-$sess_id"
-	
-	# export the agent_* options for the helper scripts
-	if [ "$(getparam freenx_export_agents)" = "1" ]
-	then
-		export agent_user
-		export agent_password
-		export agent_server
-		export agent_domain
-		agent_keyboard=""
-		[ "ENABLE_EXTERNAL_NXDESKTOP_KEYBOARD" = "1" ] && agent_keyboard=$(echo "$keyboard" | cut -d'/' -f2)
-		export agent_keyboard
-		export NXSESSION_DIRECTORY
-		export AGENT_EXTRA_OPTIONS_RFB
-		export AGENT_EXTRA_OPTIONS_RDP
-		export COMMAND_RDESKTOP
-		export COMMAND_VNCVIEWER
-		export COMMAND_VNCPASSWD
-		export COMMAND_X11VNC
-		export PATH_BIN
-		export mirrordisplay
-		export mirrorhost
-		# We do not want to suspend such a session
-		# as RDP/RFB are both suspendable as well
-		ENABLE_PERSISTENT_SESSION=""
-	fi
-
-	fullscreen=$(getparam fullscreen)
-	[ "$geometry" = "fullscreen" ] && fullscreen="1"
-
-	[ "$EXPORT_USERIP" = "1" ] && export NXUSERIP="$userip"
-
-	ssl_tunnel=$(getparam encryption)
-	[ -z "$ssl_tunnel" ] && ssl_tunnel=0
-	
-	if [ "$ssl_tunnel" = "1" ]
-	then
-		# we need to use the IP of the "calling" server now
-		userip=$(echo $SSH_CLIENT $SSH2_CLIENT | cut -d" " -f1 | sed 's/::ffff://g')
-
-		# TODO: This logic is broken ... ;-)
-		[ -z "$userip" ] && userip="127.0.0.1"
-		[ -z "$userip" -a "$host" != "127.0.0.1" ] && userip="*"
-	fi
-	
-	# ok, lets make the session dir first:
-	
-	sess_id="$SERVER_NAME-$display-$uniqueid"
-	[ "$EXPORT_SESSIONID" = "1" ] && export NXSESSIONID="$sess_id"
-	
-	OLD_UMASK=$(umask)
-	umask 0022
-	mkdir -p $USER_FAKE_HOME
-	umask 0077
-	mkdir -p "$USER_FAKE_HOME/.nx/C-$sess_id"
-	umask $OLD_UMASK
-	
-	# cache=8M,images=32M,pack=nopack,link=lan,type=unix-kde,cleanup=0,accept=192.168.1.66,cookie=E38A94A77F975443AF04EC911881B120,id=Knoppix-1000-6A8269CC467264EAEF6349D062689755,samba=1,render=1:1000
-	
-	PACK=""
-	[ -z "$imagecompressionlevel" ] && imagecompressionlevel="9"
-	
-	[ "$imagecompressionmethod" = "0" ] && PACK="pack=nopack,"
-	[ "$imagecompressionmethod" = "1" ] && PACK="pack=16m-jpeg-$imagecompressionlevel,"
-	[ "$imagecompressionmethod" = "2" ] && PACK="pack=16m-png-9,"
-	
-	proxy_cookie=$(echo $[$RANDOM*$RANDOM] | $COMMAND_MD5SUM | cut -d" " -f1)
-
-	# all newer clients support fake cookie authentication
-	if [ "$clientproto" != "1.4.0" ]
-	then
-		# enable fake cookie authentication
-		cookie=$proxy_cookie
-	fi
-
-	# write options file
-	[ -z "$samba" ] && samba=0
-	[ -z "$media" ] && media=0
-	[ -z "$nodelay" ] && nodelay=1
-
-	clipboard="$ENABLE_CLIPBOARD"
-	menu="$ENABLE_PULLDOWN_MENU"
-
-	CACHE="cache=$cache,"
-	[ -z "$cache" ] && CACHE=""
-	IMAGES="images=$images,"
-	[ -z "$images" ] && IMAGES=""
-
-	ACCEPT="accept=$userip,"
-	[ "$userip" = "*" ] && ACCEPT=""
-
-	OLD_UMASK=$(umask)
-	umask 0077
-
-cat << EOF > "$USER_FAKE_HOME/.nx/C-$sess_id/options"
-${keyboard:+keyboard=$keyboard,}${kbtype:+kbtype=$kbtype,}${kbload:+kbload=$kbload,}${keymap:+keymap=$keymap,}${resize:+resize=$resize,}${CACHE}${IMAGES}${PACK}link=$link,nodelay=$nodelay,type=$realtype,cleanup=0,${ACCEPT}cookie=$proxy_cookie,id=$sess_id,samba=$samba,media=$media${sync:+,sync=$sync}${cups:+,cups=$cups}${keybd:+,keybd=$keybd}${aux:+,aux=$aux}${http:+,http=$http}${rdpcolors:+,rdpcolors=$rdpcolors}${rdpcache:+,rdpcache=$rdpcache}${fullscreen:+,fullscreen=1}${clipboard:+,clipboard=$clipboard}${menu:+,menu=$menu}:$display
-EOF
-	umask $OLD_UMASK
-#samba=$samba,
-	#cache=$cache,images=$images,pack=nopack,link=$link,type=$type,cleanup=0,accept=$userip,cookie=$proxy_cookie,id=$sess_id
-#samba=$samba,media=$media,render=$render:$display
-
-	# write xauth script file
-
-$COMMAND_XAUTH >/dev/null 2>&1 <<EOF
-add localhost:$display MIT-MAGIC-COOKIE-1 $cookie
-add :$display MIT-MAGIC-COOKIE-1 $cookie
-exit
-EOF
-
-$COMMAND_XAUTH -f "$USER_FAKE_HOME/.nx/C-$sess_id/authority" >/dev/null 2>&1 <<EOF
-add localhost:$display MIT-MAGIC-COOKIE-1 $cookie
-add :$display MIT-MAGIC-COOKIE-1 $cookie
-exit
-EOF
-
-	mkdir -m700 "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/" 2>/dev/null || chmod 700 "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/"
-
-cat << EOF >"$USER_FAKE_HOME/.nx/C-$sess_id/scripts/authority"
-remove localhost:$display
-remove :$display
-exit
-EOF
-
-if [ "$1" = "restore" ]
-then
-	echo > "$USER_FAKE_HOME/.nx/C-$sess_id/session"
-	sh -c 'echo "Info: tail -f running with pid '\'\$$\''."; exec tail -n1 -f '"$USER_FAKE_HOME"'/.nx/C-'"$sess_id"'/session' | node_start_monitor "$1" "$status" &
-
-	MONITOR_PID=$!
-	export MONITOR_PID
-
-	mkdir -p "$USER_FAKE_HOME/.nx/C-$sess_id/pids/"
-	echo "$MONITOR_PID" > "$USER_FAKE_HOME/.nx/C-$sess_id/pids/monitor"
-
-	node_suspend_session "$sess_id" || { echo "Info: Reconnection failed: NX Agent process could not be found." >>"$USER_FAKE_HOME/.nx/C-$sess_id/session"; node_fail_restore_session "$sess_id"; }
-else
-	node_start_agent &
-	node_start_applications &
-fi
-
-if which "$NODE_AUTOSTART" >/dev/null 2>&1
-then
-	# go into background immediately
-	NXSESSIONID="$sess_id" DISPLAY=:$display "$NODE_AUTOSTART" "$1" >/dev/null 2>&1 &
-	# dont't wait for this child!
-	disown $!
-fi
-	
-cat << EOF
-NX> 700 Session id: $sess_id
-NX> 705 Session display: $display
-NX> 703 Session type: $type
-NX> 701 Proxy cookie: $proxy_cookie
-NX> 702 Proxy IP: $userip
-NX> 706 Agent cookie: $cookie
-NX> 704 Session cache: $type
-NX> 707 SSL tunneling: $ssl_tunnel
-EOF
-
-# File-sharing port options
-if [ "$samba" = "1" -a -n "$smbport" ]
-then
-	echo "NX> 709 File-sharing port: $smbport"
-	echo "$smbport" >"$USER_FAKE_HOME/.nx/C-$sess_id/scripts/smbport"
-fi
-
-# collection ...
-
-# NX> 1004 Error:
-#Session 'Knoppix-1000-40EFB9F64FA55C64C41C72CA39EBD720' has failed after reaching usable state. Session directory '/home/knoppix/.nx/F-C-Knoppix-1000-40EFB9F64FA55C64C41C72CA39EBD720' will be not deleted to allow for further investigation.
-
-if [ -n "$MONITOR_PID" ]
-then
-	wait "$MONITOR_PID"
-	rm -f "$USER_FAKE_HOME/.nx/C-$sess_id/pids/monitor"
-	rm -f "$USER_FAKE_HOME/.nx/C-$sess_id/pids/tail"
-fi
-wait # for all children
-}
-
-#
-# -----------------------------------------------------------------------------
-# cmd_node functions - changes lots of small variables
-# -----------------------------------------------------------------------------
-#
-
-cmd_node_terminate()
-{
-	sessionid=$(getparam_sessionid)
-	echo "NX> 716 Terminating session $sessionid on user request."
-	display=$(cd $USER_FAKE_HOME/.nx/; echo C-$SERVER_NAME-*-$sessionid | awk 'BEGIN {FS="-"} {i=NF-1; print $i}')
-	node_terminate_session "$SERVER_NAME-$display-$sessionid"
-}
-
-cmd_node_suspend()
-{
-	sessionid=$(getparam_sessionid)
-	echo "NX> 716 Suspending session $sessionid on user request."
-	display=$(cd $USER_FAKE_HOME/.nx/; echo C-$SERVER_NAME-*-$sessionid | awk 'BEGIN {FS="-"} {i=NF-1; print $i}') 
-	node_suspend_session "$SERVER_NAME-$display-$sessionid"
-}
-
-cmd_node_smbmount()
-{
-	sessionid=$(getparam_sessionid)
-	port=$(getparam port)
-	username=$(getparam username)
-	password=$(getparam password)
-	share=$(getparam share)
-	computername=$(getparam computername)
-	dir=$(getparam dir | sed 's|$(SHARES)|MyShares|g')
-	# rdir=$(getparam dir | sed 's|$(SHARES)/||g')
-	display=$(cd $USER_FAKE_HOME/.nx/; echo C-$SERVER_NAME-*-$sessionid | awk 'BEGIN {FS="-"} {i=NF-1; print $i}') 
-	mkdir -p "$HOME/$dir"
-	# wait up to 30 sec until nxagent has opened the listener port for samba connections
-	for (( i=30; $i; --i ))
-	do
-		[ -f "$USER_FAKE_HOME/.nx/C-$SERVER_NAME-$display-$sessionid/scripts/mport" ] && break
-		sleep 1
-	done
-	# sometimes the samba port we get from nxserver is not the right one, so let's get it from nxagent
-	realport=$(cat "$USER_FAKE_HOME/.nx/C-$SERVER_NAME-$display-$sessionid/scripts/mport")
-	[ -n "$realport" ] && port=$realport
-	error=$(PASSWD="$password" $COMMAND_SMBMOUNT "//$computername/$share" "$HOME/$dir" -o username="$username",ip=127.0.0.1,port=$port 2>&1)
-	if [ $? -eq 0 ]
-	then
-		$PATH_BIN/nxdialog -dialog ok -caption "NXServer Message" -message "Info: Share: '//$computername/$share' mounted on: '$HOME/$dir'" -display :$display &
-		echo "$HOME/$dir" >> "$USER_FAKE_HOME/.nx/C-$SERVER_NAME-$display-$sessionid/scripts/mpoint"
-	else
-		$PATH_BIN/nxdialog -dialog ok -caption "NXServer Message" -message "Info: Share: '//$computername/$share' failed to mount: $error" -display :$display &
-	fi
-}
-
-cmd_node_addprinter()
-{
-	sessionid=$(getparam_sessionid)
-	type=$(getparam type)
-	port=$(getparam port)
-	username=$(getparam username)
-	password=$(getparam password)
-	share=$(getparam share)
-	printer=$(getparam printer)
-	computername=$(getparam computername)
-	public=$(getparam public)
-	model=$(getparam model)
-	defaultPrinter=$(getparam defaultPrinter)
-	display=$(cd $USER_FAKE_HOME/.nx/; echo C-$SERVER_NAME-*-$sessionid | awk 'BEGIN {FS="-"} {i=NF-1; print $i}') 
-	sess_id="$SERVER_NAME-$display-$sessionid"
-	
-	# this will also setup the userspace cupsd
-	export CUPS_SERVER=$(node_cupsd_get_socket)
-	
-	if [ "$type" = "smb" ]
-	then
-		if [ -x "$CUPS_BACKEND/nxsmb" ]
-		then
-			smbport=$(cat "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/smbport" 2>/dev/null)
-			[ -z "$smbport" ] && smbport=139 # should not happen
-
-			if [ "$smbport" = "445" ]
-			then
-				smbproto="cifs"
-			else
-				smbproto="smb"
-			fi
-
-			DEVICE_URI="nxsmb://$username:$password at 127.0.0.1:$port/$smbproto/$share"
-		else
-			DEVICE_URI="smb://$username:$password at 127.0.0.1:$port/$share"
-		fi
-		NAME="$share"
-		ENABLE_CUPS_SEAMLESS="0"
-	else
-		DEVICE_URI="nxipp://$username:$password at 127.0.0.1:$port/printers/$printer"
-		NAME="$printer"
-	fi
-	export PATH_BIN
-
-	if [ "$ENABLE_CUPS_SEAMLESS" != "1" ]
-	then
-		MODEL=$($PATH_BIN/nxdialog -printer "$NAME" -display :$display)
-		[ -z "$MODEL" -o "$MODEL" = "cancel: aborted" ] && return
-	else
-		sleep $CUPS_SEAMLESS_DELAY
-		MODEL="download_cached"
-	fi
-	
-	PUBLIC="-u allow:$USER"
-	[ "$public" == "1" ] && PUBLIC=""
-
-	if [ "$MODEL" = "download_new" -o "$MODEL" = "download_cached" ]
-	then
-		mkdir -p "$USER_FAKE_HOME/.nx/config/ppd/"
-		if [ "$MODEL" = "download_new" -o ! -r "$USER_FAKE_HOME/.nx/config/ppd/$printer.ppd" ]
-		then
-			curl --proxy "" --digest -o "$USER_FAKE_HOME/.nx/config/ppd/$printer.ppd" "http://$username:$password at 127.0.0.1:$port/ppd/${printer}_nxdl.ppd" >>"$USER_FAKE_HOME/.nx/C-$sess_id/cups/curl.log" 2>&1
-		RC=$?
-		[ $RC -eq 0 -a "$ENABLE_CUPS_SEAMLESS" != "1" ] && $PATH_BIN/nxdialog --message "Download successful." -display :$display
-		[ $RC -ne 0 -a "$ENABLE_CUPS_SEAMLESS" != "1" ] && $PATH_BIN/nxdialog --message "Download failed. Log is: $USER_FAKE_HOME/.nx/C-$sess_id/cups/curl.log" -display :$display
-		fi
-		MODEL="$USER_FAKE_HOME/.nx/config/ppd/$printer.ppd"
-	fi
-	
-	if [ ! -r "$MODEL" ]
-	then
-		# Foomatic and co
-		/usr/sbin/lpadmin -p "$NAME" -E -v "$DEVICE_URI" -m "$MODEL" $PUBLIC
-	else
-		/usr/sbin/lpadmin -p "$NAME" -E -v "$DEVICE_URI" -P "$MODEL" $PUBLIC
-	fi
-
-	[ "$defaultPrinter" = "1" ] && /usr/sbin/lpadmin -d "$NAME"
-}
-
-nxnode_func()
-{
-
-case "$1" in 
-	--startsession)
-		startsession
-	;;
-	--resumesession)
-		startsession "restore"
-	;;
-	--terminate)
-		cmd_node_terminate
-	;;
-	--suspend)
-		cmd_node_suspend
-	;;
-	--smbmount)
-		cmd_node_smbmount &>/dev/null </dev/null &
-	;;
-	--addprinter)
-		cmd_node_addprinter &>/dev/null </dev/null &
-	;;
-	--check)
-		echo "NX> 716 finished"
-	;;
-	--agent)
-		echo "NX> 716 Starting NX Agent ..."
-		shift
-		[ "$SET_LD_LIBRARY_PATH" = "1" ] && export LD_LIBRARY_PATH="$AGENT_LIBRARY_PATH:$LD_LIBRARY_PATH"
-		PATH="$PATH:$PATH_BIN" $PATH_BIN/nxagent -name "NX Agent Test - Args: $@" $@
-		echo "NX> 716 NX Agent exited with status: $?"
-	;;
-	--setkey)
-		mkdir -m 700 -p $HOME/.ssh
-		if ! grep -q "$(cat $NX_ETC_DIR/users.id_dsa.pub)" $HOME/.ssh/$SSH_AUTHORIZED_KEYS 2>/dev/null
-		then
-			cat $NX_ETC_DIR/users.id_dsa.pub >> $HOME/.ssh/$SSH_AUTHORIZED_KEYS
-			chmod 600 $HOME/.ssh/$SSH_AUTHORIZED_KEYS
-			echo "NX> 716 Public key added to: $HOME/.ssh/$SSH_AUTHORIZED_KEYS"
-		else
-			echo "NX> 716 Public key is already present in: $HOME/.ssh/$SSH_AUTHORIZED_KEYS"
-		fi
-	;;
-	*)
-		echo "NX> 500 Error: Command not found"
-	;;
-esac
-
-}
-
-
-if [ "$1" = "--slave" ]
-then
-	# New slave mode accepts more than 1 command at a time
-	echo "NX> 716 Slave mode started successfully."
-	
-	while read CMD
-	do
-		set -- "$CMD"
-		if [ "$1" != "--check" -a "$1" != "--setkey" -a "$1" != "--agent" ]
-		then 
-			read CMDLINE
-
-			CMDLINE="a=b&$CMDLINE"
-		fi
-		
-		if [ "$1" = "--startsession" -o "$1" = "--resumesession" ]
-		then
-			export SLAVE_PID=$$
-			( echo $CMDLINE | "$0" "$CMD"; kill $SLAVE_PID ) &
-		else
-			( echo $CMDLINE | "$0" "$CMD" ) &
-		fi
-
-	done
-else
-	nxnode_func "$@"
-fi
-
-echo "NX> 1001 Bye."

Deleted: trunk/freenx-server/trunk/nxnode-login
===================================================================
--- trunk/freenx-server/trunk/nxnode-login	2008-03-10 22:59:38 UTC (rev 511)
+++ trunk/freenx-server/trunk/nxnode-login	2008-03-10 23:01:03 UTC (rev 512)
@@ -1,102 +0,0 @@
-#!/usr/bin/expect
-#
-# nxnode-login: spawns and controls ssh 
-#
-# Copyright (c) 2004-2006 by Fabian Franz.
-#
-# License: GPL, version 2
-#
-# SVN: $Id$
-#
-
-# Syntax: nxnode-login {ssh|su|test-nx} user ssh-port executable command tosend
-
-set auth_method [lindex $argv 0]
-set user [lindex $argv 1]
-set port [lindex $argv 2]
-set executable [lindex $argv 3]
-set command [lindex $argv 4]
-set tosend [lindex $argv 5]
-catch {set tosend $env(NXNODE_TOSEND)}
-set command_ssh "ssh"
-catch {set command_ssh $env(COMMAND_SSH)}
-set host "127.0.0.1"
-catch {set host $env(NODE_HOSTNAME)}
-
-#
-# Special test-nx instruction for nxsetup
-#
-
-if { "$auth_method"=="test-nx" } {
-	set stty_init "raw icrnl -echo"
-
-	set publickey ""
-	catch {set publickey $env(NODE_PUBLICKEY)}
-	
-	set pid [spawn -noecho $command_ssh -2 -x -l "$user" "$host" -i "$publickey" -o "RhostsAuthentication no" -o "PasswordAuthentication no" -o "RSAAuthentication no" -o "RhostsRSAAuthentication no" -o "PubkeyAuthentication yes" -o "PreferredAuthentications publickey" -o "ConnectTimeout 3" -p "$port" "$executable $command" ]
-	
-	while {1} {
-		expect {
-			"Are you sure you want to continue connecting (yes/no)?" { send "yes\r" }
-			"Permission denied*" { exit 1 }
-			"HELLO NXSERVER - Version*" { 
-				break
-			}
-		}
-	}
-	expect "NX> 105" { send "quit\r" }
-	expect "NX> 999 Bye"
-	exit 0
-}
-
-#
-# Log the user in via the supplied method.
-#
-
-expect_user -re "(.*)\n" 
-set password $expect_out(1,string)
-
-set stty_init "raw icrnl -echo"
-
-if { "$auth_method"=="ssh" } { 
-	set pid [spawn -noecho $command_ssh -2 -x -l "$user" "$host" -o "NumberOfPasswordPrompts 1" -p "$port" "$executable $command" ]
-} elseif { "$auth_method"=="su" } {
-	set pid [spawn -noecho su - "$user" -c "$executable $command" ]
-} else {
-	exit 1
-}
-
-while {1} {
-	expect {
-		"Are you sure you want to continue connecting (yes/no)?" { send "yes\r" }
-		"assword*:"  { sleep 0.3; send "$password\r" }
-		"Permission denied*" { exit 1 }
-		"su: Authentication failure" { exit 1 }
-		"NX> 1000 NXNODE - Version" { 
-			break
-		}
-	} 
-}
-
-if { "$tosend"!="" } { 
-	send "$tosend\r"
-}
-
-expect {
-	"NX> 716 finished" { }
-	"NX> 700" { 
-			set timeout -1
-			expect {
-				"NX> 1001 Bye." { exit 0 }
-				"NX> *" { exp_continue }
-			}
-			exit 0
-		  }
-	"NX> 716 Slave mode started successfully." { interact }
-	"NX> 716 Public key is already present in:" { }
-	"NX> 716 Public key added to:" { }
-	"NX> 716 Terminating session * on user request." { }
-	"NX> 716 Suspending session * on user request." { }
-	"NX> 500 Error: " { exit 1}
-}
-expect "NX> 1001 Bye."

Deleted: trunk/freenx-server/trunk/nxprint
===================================================================
--- trunk/freenx-server/trunk/nxprint	2008-03-10 22:59:38 UTC (rev 511)
+++ trunk/freenx-server/trunk/nxprint	2008-03-10 23:01:03 UTC (rev 512)
@@ -1,76 +0,0 @@
-#!/bin/bash
-#
-# nxprint - Prints a list of available drivers or printers
-# 
-# Copyright (c) 2005 by Fabian Franz <freenx at fabian-franz.de>
-#
-# License: GPL, version 2
-#
-# SVN: $Id$
-#
-
-HELP="no"
-DRIVERS="no"
-PRINTERS="no"
-
-while [ "$1" ]
-do
-        case "$1" in
-                --help) HELP="yes"; shift ;;
-                --drivers|-d) DRIVERS="yes"; shift ;;
-                --printers|-l) PRINTERS="yes"; shift ;;
-                --) shift ; break ;;
-                *) echo "Invalid flag $1" ; HELP="yes"; shift ; break ;;
-        esac
-done
-
-[ "$DRIVERS" = "no" -a "$PRINTERS" = "no" ] && HELP="yes"
-
-if [ "$HELP" = "yes" ]
-then
-        echo "nxprint - Prints a list of available drivers or printers"
-	echo ""
-        echo "Syntax: nxprint --help"
-        echo "        nxprint --drivers"
-        echo "        nxprint --printers"
-        echo
-        echo "  --drivers                prints a list of available CUPS drivers"
-        echo "  --printers               prints a list of available CUPS printers"
-        exit 0
-fi
-
-if [ "$DRIVERS" = "yes" ]
-then
-	echo "driver|Raw|Raw Queue|raw"
-	echo "driver|Download (CUPS)|Download from CUPS server (cached)|download_cached"
-	echo "driver|Download (CUPS)|Download from CUPS server (redownload)|download_new"
-	#JJK: Added the following to avoid multiple calls to NXPRINT which are
-	#JJK: *SLOW* when using 1500+ foomatic drivers
-	#JJK: Note cache is reloaded after 60 minutes (or if empty)
-
-	if [ -z "$(find $UTILITY_DRIVERS_CACHE.all -mmin -60 2> /dev/null)" ]
-	then
-		{ 
-		cd /usr/share/ppd/
-		awk -F '"' '/\*Manufacturer:/ { a[FILENAME]=$2 }
-			    /\*NickName:/ { b[FILENAME]=$2 } 
-			    END { 
-			       for (i in a) 
-				  print "driver|" (a[i]=="ESP"?substr(b[i],0,index(b[i]," ")-1):a[i]) "|"b[i]"|"i"|en"
-			    }' $(find -name "*.ppd")
-
-		if [ "$ENABLE_FOOMATIC" = "1" ]
-		then
-			[ -z "$COMMAND_FOOMATIC" ] && COMMAND_FOOMATIC="foomatic-ppdfile" 
-			$COMMAND_FOOMATIC list | awk -F'"' '{ A=""; if ($4 == "HP") { B=substr($6,index($6," ")+1); A=" "substr(B,0,index(B," ")); } printf("driver|%s%s|%s|%s|%s\n",$4,A,$6,$2,substr($3,2)) } '
-		fi
-		} | sort > "$UTILITY_DRIVERS_CACHE".all
-       fi
-
-       cat "$UTILITY_DRIVERS_CACHE".all
-fi
-
-if [ "$PRINTERS" = "yes" ]
-then
-	lpstat -p | awk '{ print $1 "|" $2 }'
-fi

Deleted: trunk/freenx-server/trunk/nxserver
===================================================================
--- trunk/freenx-server/trunk/nxserver	2008-03-10 22:59:38 UTC (rev 511)
+++ trunk/freenx-server/trunk/nxserver	2008-03-10 23:01:03 UTC (rev 512)
@@ -1,1838 +0,0 @@
-#!/bin/bash
-
-# Free implementation of nxserver components
-#
-# To use nxserver add the user "nx" 
-# and use nxserver as default shell.
-#
-# Also make sure that hostkey based authentification works.
-# 
-# Copyright (c) 2004 by Fabian Franz <FreeNX at fabian-franz.de>.
-#
-# License: GNU GPL, version 2
-#
-# SVN: $Id$
-#
-
-# Read the config file
-. $(PATH=$(cd $(dirname $0) && pwd):$PATH which nxloadconfig) --
-
-# following two functions are Copyright by Klaus Knopper
-
-stringinstring(){
-case "$2" in *$1*) return 0;; esac
-return 1
-}
-
-# Reread boot command line; echo last parameter's argument or return false.
-getparam(){
-stringinstring "&$1=" "$CMDLINE" || return 1
-echo "$CMDLINE" |  tr "&" "\n" | egrep "^"$1"=" | awk -F= '{ VAL=$2 } END { print VAL }'
-return 0
-}
-
-
-############### PACKAGE passdb.bm #######################
-#
-# Library of passdb functions (outsource)
-#
-
-# Policy: Variable and function names _must_ start with passdb_ / PASSDB_
-
-# Needed global vars: $NX_ETC_DIR, $PATH_BIN
-
-# Needed nonstd functions: md5sum
-
-
-passdb_get_crypt_pass()
-{
-	echo "$@" | $COMMAND_MD5SUM | cut -d" " -f1
-}
-
-passdb_get_pass()
-{
-	PASSDB_CHUSER="$1"
-	PASSDB_PASS=$(egrep "^$PASSDB_CHUSER:" $NX_ETC_DIR/passwords 2>/dev/null | cut -d":" -f2)
-	if [ "$ENABLE_PASSDB_AUTHENTICATION" = "1" ]
-	then
-		egrep -q "^$PASSDB_CHUSER:" $NX_ETC_DIR/passwords 2>/dev/null && echo $PASSDB_PASS
-		egrep -q "^$PASSDB_CHUSER:" $NX_ETC_DIR/passwords 2>/dev/null || echo "NOT_VALID"
-	else
-		echo "NOT_VALID"
-	fi
-}
-
-passdb_chpass()
-{
-	PASSDB_CHUSER="$1"
-	PASSDB_ENC_PASS="$2"
-	cp -f $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
-	$COMMAND_PERL -pi -e "s/$PASSDB_CHUSER:.*/$PASSDB_CHUSER:$PASSDB_ENC_PASS/g" $NX_ETC_DIR/passwords
-}
-
-passdb_user_exists()
-{
-	PASSDB_CHUSER="$1"
-	egrep -q "^$PASSDB_CHUSER:" $NX_ETC_DIR/passwords 2>/dev/null
-}
-
-
-passdb_remove_user()
-{
-	PASSDB_CHUSER="$1"
-	cp -f $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
-	$COMMAND_PERL -pi -e "s/$PASSDB_CHUSER:.*\n//g" $NX_ETC_DIR/passwords
-}
-
-passdb_add_user()
-{
-	PASSDB_CHUSER="$1"
-	cp -f $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
-	echo "$PASSDB_CHUSER:*" >> $NX_ETC_DIR/passwords
-	# deactivated to avoid problems with comm-server
-	su - $PASSDB_CHUSER -c "$PATH_BIN/nxnode --setkey"
-}
-
-passdb_list_user()
-{
-	cat $NX_ETC_DIR/passwords | cut -d":" -f1
-}
-
-#
-# End of passdb Library
-#
-
-############### PACKAGE session.bm #######################
-#
-# Library of session management functions
-#
-
-# Needed global vars: $NX_SESS_DIR
-
-session_list()
-{
-	cat $NX_SESS_DIR/running/sessionId"{$1}"
-}
-
-# Find all running session-filenames 
-
-session_find_all()
-{
-	for i in $NX_SESS_DIR/running/*
-	do
-		[ -f $i ] || break
-		echo $i
-	done
-}
-
-# Find all running sessions of a id
-session_find_id()
-{
-	[ -f $NX_SESS_DIR/running/sessionId"{$1}" ] && echo $NX_SESS_DIR/running/sessionId"{$1}"
-}
-
-# finds out if a session belongs to a user
-
-session_find_id_user()
-{
-	[ -f $NX_SESS_DIR/running/sessionId"{$1}" ] && egrep -q "^userName=$2$" $NX_SESS_DIR/running/sessionId"{$1}" && return 0
-	return 1
-}
-
-# Find all running sessions of a user
-session_find_user()
-{
-	for i in $NX_SESS_DIR/running/*
-	do
-		[ -f $i ] || break
-		egrep -q "^userName=$1$" $i && echo $i
-	done
-}
-
-# Find all running sessions of a display
-session_find_display()
-{	
-	for i in $NX_SESS_DIR/running/*
-	do
-		[ -f $i ] || break
-		egrep -q "^display=$1$" $i && echo $i
-	done
-}
-
-# session_get_cmdline <session filename>
-
-session_get_cmdline()
-{
-	echo "a=b" | cat - $1 | tr '\n' '&'
-}
-
-# session_get <uniqueid>
-
-session_get()
-{
-	session_get_cmdline $NX_SESS_DIR/running/sessionId"{$1}"
-}
-
-
-# Get the first session, which can be resumed
-
-session_get_user_suspended()
-{
-	for i in $NX_SESS_DIR/running/*
-	do
-		[ -f $i ] || break
-		if egrep -q "^userName=$1$" $i && egrep -q "^status=$2$" $i
-		then
-			CMDLINE=$(session_get_cmdline $i)
-			echo "$(getparam sessionId)"
-			break
-		fi
-	done
-}
-
-# Count all sessions of a user
-# and save it in SESSION_COUNT and SESSION_COUNT_USER
-
-session_count_user()
-{
-	SESSION_COUNT=0
-	SESSION_COUNT_USER=0
-
-	for i in $NX_SESS_DIR/running/*
-	do
-		[ -f $i ] || break
-		let SESSION_COUNT=$SESSION_COUNT+1
-		egrep -q "^userName=$1$" $i && let SESSION_COUNT_USER=$SESSION_COUNT_USER+1
-	done
-}
-
-# List all sessions of a user
-
-session_list_user_suspended()
-{
-	SESSION_COUNT=0
-	SESSION_COUNT_USER=0
-
-	TMPFILE=$(mktemp /tmp/nxserver_tmp.XXXXXXXXX)
-	echo "NX> 127 Sessions list of user '$1' for reconnect:" > $TMPFILE
-	echo >> $TMPFILE
-	if [ -z "$4" ]
-	then
-		
-		echo "Display Type             Session ID                       Options  Depth Screensize     Available Session Name" >> $TMPFILE
-		echo "------- ---------------- -------------------------------- -------- ----- -------------- --------- ----------------------" >> $TMPFILE
-	else
-		echo "Display Type             Session ID                       Options  Depth Screen         Status      Session Name" >> $TMPFILE
-		echo "------- ---------------- -------------------------------- -------- ----- -------------- ----------- ------------------------------" >> $TMPFILE
-	fi
-	for i in $NX_SESS_DIR/running/*
-	do
-		[ -f $i ] || break
-		let SESSION_COUNT=$SESSION_COUNT+1
-		if egrep -q "^userName=$1$" $i && egrep -q "^status=$2$" $i #&& grep -q "screeninfo=$3" $i
-		then
-			CMDLINE=$(session_get_cmdline $i)
-			depth=$(getparam screeninfo | cut -d "x" -f3 | cut -d "+" -f1 )
-			geom=$(getparam screeninfo | cut -d "x" -f1,2) 
-			render=$(getparam screeninfo | cut -d "+" -f2 )
-			available="N/A"
-			udepth=$(echo $3 | cut -d "x" -f3 | cut -d "+" -f1 )
-			urender=$(echo $3 | cut -d "+" -f2 )
-
-			mode="D"
-			[ "$(getparam sessionRootlessMode)" = "1" ] && mode="-"
-			
-			options="-"
-			stringinstring "fullscreen" "$3" && options="F"
-			[ "$(getparam geometry)" = "fullscreen" ] || options="-"
-			[ "$urender" = "render" ] && options="${options}R${mode}--PSA"
-			[ "$urender" = "render" ] || options="${options}-${mode}--PSA"
-			[ "$udepth" = "$depth" -a "$urender" = "$render" ] && available=$(getparam status)
-			# FIXME: HACK !!! to keep compatibility with old snapshot version (Knoppix 3.6 based for example)
-			if [ -z "$4" -a "$available" != "N/A" ] 
-			then
-				available="Yes"
-			fi
-			
-			# We automatically offer VNC mirrored sessions for "remote" support
-			if [ "$4" = "vnc" -a "$ENABLE_MIRROR_VIA_VNC" = "1" ] && stringinstring "unix-" "$(getparam type)"
-			then
-				printf "%-7s %-16s %32s %8s %5s %-14s %-11s %s\n" "$(getparam display)" "vnc-mirrored" "$(getparam sessionId)" "$options" "$depth" "$geom" "$available" "$(getparam sessionName) (Mirrored)" >> $TMPFILE
-			else
-				# only unix-* sessions can be resumed, but other session types can still be terminated
-				stringinstring "unix-" "$4" || available="N/A"
-				printf "%-7s %-16s %32s %8s %5s %-14s %-11s %s\n" "$(getparam display)" "$(getparam type)" "$(getparam sessionId)" "$options" "$depth" "$geom" "$available" "$(getparam sessionName)" >> $TMPFILE
-			fi
-		fi
-		egrep -q "^userName=$1$" $i && let SESSION_COUNT_USER=$SESSION_COUNT_USER+1
-	done
-	
-	if [ "$4" = "vnc" -a "$ENABLE_DESKTOP_SHARING" = "1" ]
-	then
-		export DESKTOP_SHARING_IDS=""
-		for i in $(LC_ALL=C netstat -ln --protocol=unix | egrep 'X11-unix/X[0-9]$' | sed 's/.*X\(.*\)/\1/g')
-		do
-			uniqueid=$(echo $[$RANDOM*$RANDOM] | $COMMAND_MD5SUM | cut -d" " -f1 | tr "[a-z]" "[A-Z]")
-			DESKTOP_SHARING_IDS="$DESKTOP_SHARING_IDS $uniqueid=$i"
-			printf "%-7s %-16s %32s %8s %5s %-14s %-11s %s\n" "$i" "vnc-local" "$uniqueid" "--------" "$udepth" "$(echo $3 | cut -d'x' -f1,2)" "Running" "X$i (Local)" >> $TMPFILE
-		done
-	fi
-	
-	echo "" >> $TMPFILE
-	echo "" >> $TMPFILE
-	
-	if [ "$SESSION_COUNT" -ge "$SESSION_LIMIT" -o "$SESSION_COUNT_USER" -ge "$SESSION_USER_LIMIT" ]
-	then
-		echo "NX> 147 Server capacity: reached for user: $1" >> $TMPFILE
-	else
-		echo "NX> 148 Server capacity: not reached for user: $1" >> $TMPFILE
-	fi
-	
-	cat $TMPFILE | log_tee
-	rm -f $TMPFILE
-}
-
-session_list_user()
-{
-	echo "NX> 127 Sessions list of user '$1'"
-	echo
-	echo "Server     Display Username        Remote IP       Session ID"
-	echo "------ ------- --------------- --------------- --------------------------------"
-	for i in $NX_SESS_DIR/running/*
-	do
-		[ -f $i ] || break
-		if egrep -q "^userName=$1$" $i
-		then
-			CMDLINE=$(session_get_cmdline $i)
-			echo -e "$(getparam host)\t$(getparam display)\t$(getparam userName)\t$(getparam foreignAddress)\t$(getparam sessionId)"
-		fi
-	done
-}
-
-session_history()
-{
-	userName=$1
-	sessionId=$2
-	echo "NX> 127 Session list:"
-	echo
-	echo "Display Username        Remote IP       Session ID                       Date                Status"
-	echo "------- --------------- --------------- -------------------------------- ------------------- -----------"
-	for j in $(ls --time-style +%s -la "$NX_SESS_DIR"/{closed,failed,running} | awk '/sessionId/ { print $6 " " $7 }' | sort -n | cut -d" " -f2)
-	do
-		if [ -n "$sessionId" ]
-		then
-			[ "$j" = "sessionId{$sessionId}" ] || continue
-		fi
-		i="$NX_SESS_DIR"/*/"$j"
-		[ -f $i ] || break
-		CMDLINE=$(session_get_cmdline $i)
-		if [ -n "$userName" ]
-		then
-			[ "$userName" = "$(getparam userName)" ] || continue
-		fi
-		echo -e "$(getparam display)\t$(getparam userName)\t$(getparam foreignAddress)\t$(getparam sessionId)\t$(ls --time-style="+%F %X" -l $i | awk '/sessionId/ { print $6 " " $7 }')\t$(getparam status)"
-	done
-}
-
-# remove all sessions older than $SESSION_HISTORY seconds in failed/closed.
-
-session_cleanup()
-{
-	[ "$SESSION_HISTORY" -gt "-1" ] || return
-	let SESSION_HISTORY_MINUTES=$SESSION_HISTORY/60
-
-	# If you need posix find compatibility, use the outcommented variant below.
-	find $NX_SESS_DIR/closed/ $NX_SESS_DIR/failed/ -type f -mmin +"$SESSION_HISTORY_MINUTES" -exec rm -f '{}' ';'
-	#let SESSION_HISTORY_DAYS=$SESSION_HISTORY_MINUTES/1440
-	#find $NX_SESS_DIR/closed/ $NX_SESS_DIR/failed/ -type f -mtime +"$SESSION_HISTORY_DAYS" -exec rm -f '{}' ';'
-}
-
-session_list_all()
-{
-	echo "NX> 127 Sessions list:"
-	echo
-	echo "Server     Display Username        Remote IP       Session ID"
-	echo "------ ------- --------------- --------------- --------------------------------"
-	for i in $NX_SESS_DIR/running/*
-	do
-		[ -f $i ] || break
-		CMDLINE=$(session_get_cmdline $i)
-		echo -e "$(getparam host)\t$(getparam display)\t$(getparam userName)\t$(getparam foreignAddress)\t$(getparam sessionId)"
-	done
-}
-
-
-# session_add <session_id> <options>
-
-session_add()
-{
-	id=$1
-	shift
-	echo "$@" | tr '&' '\n' > $NX_SESS_DIR/running/sessionId'{'$id'}'
-}
-
-# session_change <session_id> <parameter> <new_value>
-
-session_change()
-{
-	[ -f $NX_SESS_DIR/running/sessionId'{'$1'}' ] && $COMMAND_PERL -pi -e "s/$2=.*/$2=$3/" $NX_SESS_DIR/running/sessionId'{'$1'}'
-}
-
-# session_id <new status>
-
-session_status()
-{
-	session_change "$1" "status" "$2"
-}
-
-# session_running <session_id>
-# return: true if running, false if not
-
-session_running()
-{
-	test -f $NX_SESS_DIR/running/sessionId'{'$1'}'
-}
-
-# session_close <session_id> <end-time>
-
-session_close()
-{
-	$COMMAND_PERL -pi -e "s/startTime=\(.*\)/startTime=\1\nendTime=$(date +%s)/" $NX_SESS_DIR/running/sessionId'{'$1'}'
-	session_status $1 "Finished"
-	[ "$SESSION_HISTORY" = "0" ] && rm -f $NX_SESS_DIR/running/sessionId'{'$1'}'
-	[ "$SESSION_HISTORY" = "0" ] || mv -f $NX_SESS_DIR/running/sessionId'{'$1'}' $NX_SESS_DIR/closed/sessionId'{'$1'}'
-}
-
-session_fail()
-{
-	$COMMAND_PERL -pi -e "s/startTime=\(.*\)/startTime=\1\nendTime=$(date +%s)/" $NX_SESS_DIR/running/sessionId'{'$1'}'
-	session_status $1 "Failed"
-	[ "$SESSION_HISTORY" = "0" ] && rm -f $NX_SESS_DIR/running/sessionId'{'$1'}'
-	[ "$SESSION_HISTORY" = "0" ] || mv -f $NX_SESS_DIR/running/sessionId'{'$1'}' $NX_SESS_DIR/failed/sessionId'{'$1'}'
-}
-
-session_suspend()
-{
-	session_status $1 "Suspended"
-	session_change $1 foreignAddress "-"
-}
-
-#
-# end of library
-#
-
-
-#
-# Main nxserver <-> nxclient communication module
-#
-
-if [ "$USER" = "nxfree" -o "$USER" = "nx" -o "$ENABLE_USERMODE_AUTHENTICATION" = "1" ]
-then
-
-setup_usermode_auth()
-{
-
-	[ $USER = "nxfree" -o "$USER" = "nx" ] && ENABLE_USERMODE_AUTHENTICATION="0"
-
-	if [ "$ENABLE_USERMODE_AUTHENTICATION" = "1" ]
-	then
-		export NX_SESS_DIR="$USER_FAKE_HOME/.nx/db/"
-		export NX_LOGFILE="$USER_FAKE_HOME/.nx/temp/nxserver.log"
-		mkdir -p $NX_SESS_DIR/{closed,running,failed}
-	fi
-}
-
-setup_usermode_auth
-
-# Loglevels:
-# 1: Errors
-# 2: Warnings
-# 3: Important information
-# 4: Server - Client communication
-# 5: Information
-# 6: Debugging information
-# 7: stderror-channel of some applications
-
-log()
-{
-	[ "$NX_LOG_LEVEL" -ge "$1" -a -w "$NX_LOGFILE" ] && shift && echo "$@" >> "$NX_LOGFILE"
-}
-
-# Log in a way that is secure for passwords / cookies / ...
-
-echo_secure()
-{
-	echo "$@ " | $COMMAND_PERL -pi -e 's/--cookie=".+?"/--cookie="******"/g; s/--agent_password=".+?"/agent_password="******"/g; s/--password=".+?"/password="******"/g; s/cookie=.+?&/cookie=******&/g; s/agent_password=.+?&/agent_password=******&/g; s/password=.+?&/password=******&/g;'
-}
-
-log_secure()
-{
-	if [ "$NX_LOG_SECURE" = "0" ]
-	then
-		log "$@"
-	else
-		[ "$NX_LOG_LEVEL" -ge "$1" -a -w "$NX_LOGFILE" ] && shift && echo_secure "$@" >> "$NX_LOGFILE"
-	fi
-}
-
-log_tee()
-{
-	[ "$NX_LOG_LEVEL" -ge "4" -a -w "$NX_LOGFILE" ] && exec tee -a "$NX_LOGFILE"
-	[ "$NX_LOG_LEVEL" -ge "4" -a -w "$NX_LOGFILE" ] || exec cat -
-}
-
-log_error()
-{
-	[ "$NX_LOG_LEVEL" -ge "7" -a -w "$NX_LOGFILE" ] && exec tee -a "$NX_LOGFILE"
-	[ "$NX_LOG_LEVEL" -ge "7" -a -w "$NX_LOGFILE" ] || exec cat - 
-}
-
-echo_x()
-{
-	log "4" "$@"
-	echo "$@"
-}
-
-
-#
-# needed for slave mode
-#
-
-nxnode_login_stop_slave()
-{
-	if [ -n "$NXNODE_LOGIN_SLAVE" ]
-	then
-		kill "$NXNODE_LOGIN_SLAVE"
-		sleep 2
-		kill -0 "$NXNODE_LOGIN_SLAVE" && kill -9 "$NXNODE_LOGIN_SLAVE"
-	fi
-}
-
-nxnode_login()
-{
-	PASS="$1"
-	shift
-
-	if [ "$NXNODE_LOGIN_SLAVE_ENABLED" != "1" ]
-	then
-		NXNODE_TOSEND="$NXNODE_TOSEND" echo $PASS | $PATH_BIN/nxnode-login "$@"
-	else
-		if [ -z "$NXNODE_LOGIN_SLAVE" ]
-		then
-			# Send password
-			echo "$PASS" >&4 
-
-			# Connect to NXNODE
-			
-			$PATH_BIN/nxnode-login "$1" "$2" "$3" "$4" "$5" "--slave" <&3 >&3 2>&3 &
-			NXNODE_LOGIN_SLAVE="$!"
-			disown $!
-
-			trap nxnode_login_stop_slave EXIT
-			
-			while read line <&4
-			do
-				log 6 "$line"
-				case "$line" in
-					"NX> 716 Slave mode started successfully.")
-						break
-					;;
-				esac
-			done
-
-			# TODO: KILL the slave node at end of session
-		fi
-		
-		#send CMD to nxnode
-		
-		echo "$6" >&4
-		[ -n "$NXNODE_TOSEND" ] && echo "$NXNODE_TOSEND" >&4
-
-		NXNODE_RETURN="1"
-
-		if [ -z "$NXNODE_READER" ]
-		then
-			while read line <&4
-			do
-				echo "$line"
-				case "$line" in
-					"NX> 716"*) 
-						NXNODE_RETURN="0"
-					;;
-					"NX> 1001"*)
-						break
-					;;
-				esac
-			done
-		fi
-		test "$NXNODE_RETURN" = "0"
-	fi
-}
-
-nxnode_login_register_reader()
-{
-	# Register a reader
-	NXNODE_READER="1"
-}
-
-#ENABLE_NXNODE_SLAVE_MODE="1"
-
-# Start!
-[ "$NX_LOG_LEVEL" -ge "1" ] && touch "$NX_LOGFILE" >/dev/null 2>&1
-log 3 "-- NX SERVER START: $@ - ORIG_COMMAND=$SSH_ORIGINAL_COMMAND"
-
-if [ "$ENABLE_SERVER_FORWARD" = "1" -a -n "$SERVER_FORWARD_HOST" ]
-then
-	log 3 "Info: Forwarding connection to $SERVER_FORWARD_HOST with secret key $SERVER_FORWARD_KEY."
-	$COMMAND_SSH -i "$SERVER_FORWARD_KEY" "-p$SERVER_FORWARD_PORT" "nx@$SERVER_FORWARD_HOST" "host=$SERVER_NAME"
-	exit 0
-fi
-
-# Get the hostname out of SSH_ORIGINAL_COMMAND
-PREFERRED_HOST=$(echo $SSH_ORIGINAL_COMMAND | tr '&' '\n' | grep "^host=" | cut -d'=' -f2)
-
-# forward the connection to commercial NoMachine server?
-if [ "$ENABLE_NOMACHINE_FORWARD_PORT" = "1" -a "$NOMACHINE_FORWARD_PORT" = "$(echo $SSH_CLIENT $SSH2_CLIENT| cut -d' ' -f3)" -a -n "$NOMACHINE_SERVER" ]
-then
-	log 3 "Info: Detected SSH destination port $NOMACHINE_FORWARD_PORT. Forwarding connection to commercial NoMachine server."
-	exec $NOMACHINE_SERVER
-	log 1 "Error: Forwarding to NoMachine Server $NOMACHINE_SERVER failed. Using FreeNX server instead."
-fi
-
-#
-# nxnode slave mode preparations
-#
-
-NXNODE_LOGIN_SLAVE_ENABLED="0"
-NXNODE_LOGIN_SLAVE=""
-
-if [ "$ENABLE_NXNODE_SLAVE_MODE" = "1" -a "$NXSERVER_HELPER_ACTIVE" != "1" ]
-then
-	export SSH_ORIGINAL_COMMAND
-	export NXSERVER_HELPER_ACTIVE="1"
-	exec $PATH_BIN/nxserver-helper "$0"
-	log 1 "Error: Execution of $PATH_BIN/nxserver-helper failed. Disabling slave mode of nxnode."
-fi
-
-if [ "$ENABLE_NXNODE_SLAVE_MODE" = "1" -a "$NXSERVER_HELPER_ACTIVE" = "1" ]
-then
-	log 3 "Info: Using fds #3 and #4 for communication with nxnode."
-	NXNODE_LOGIN_SLAVE_ENABLED="1"
-fi
-
-echo_x "HELLO NXSERVER - Version $NX_VERSION $NX_LICENSE"
-
-# Login stage
-while true
-do
-	echo_x -n "NX> 105 "
-	read CMD
-	# FIXME?
-	[ "$CMD" = "" ] && CMD="quit"
-	echo_x "$CMD"
-	
-	case "$CMD" in 
-		quit|QUIT)
-			echo_x "Quit"
-			echo_x "NX> 999 Bye"
-			exit 0
-		;;
-		exit|EXIT)
-			echo_x "Exit"
-			echo_x "NX> 999 Bye"
-			exit 0
-		;;
-		bye|BYE)
-			echo_x "Bye"
-			echo_x "NX> 999 Bye"
-			exit 0
-		;;
-		hello*|HELLO*)
-			PROTO=$(echo $CMD | sed 's/.*Version \(.*\)/\1/g')
-			echo_x "NX> 134 Accepted protocol: $PROTO"
-			if [ "$PROTO" = "1.3.0" -o "$PROTO" = "1.3.2" ]
-			then
-				[ "$ENABLE_AUTORECONNECT_BEFORE_140" = "1" ] && ENABLE_AUTORECONNECT="1"
-			fi
-		;;
-		"set auth_mode*"|"SET AUTH_MODE*")
-			if [ "$CMD" = "set auth_mode password" -o "$CMD" = "SET AUTH_MODE PASSWORD" ]
-			then
-				echo_x "Set auth_mode: password"
-			else
-				echo_x "NX> 500 ERROR: unknown auth mode ''"
-			fi
-		;;
-		login|LOGIN)
-			LOGIN_SUCCESS="0"
-			
-			echo_x -n "NX> 101 User: "
-			read USER
-			echo_x $USER
-			
-			echo_x -n "NX> 102 Password: "
-			old_ifs="$IFS"
-			export IFS=$'\n'
-			read -s PASS
-			export IFS="$old_ifs"
-			echo_x ""
-			log 6 -n "Info: Auth method: "
-			
-			# USER already logged in?
-			if [ "$ENABLE_USERMODE_AUTHENTICATION" = "1" ]
-			then
-				LOGIN_SUCCESS="1"
-				LOGIN_METHOD="USERMODE"
-				USER=$(whoami)
-			fi
-
-			# PASSDB based auth
-			if [ "$ENABLE_PASSDB_AUTHENTICATION" = "1" -a "$LOGIN_SUCCESS" = "0" ]
-			then
-				log 6 -n "passdb "
-				if [ $(passdb_get_crypt_pass "$PASS") = $(passdb_get_pass "$USER") ]
-				then
-					LOGIN_SUCCESS="1"
-					LOGIN_METHOD="PASSDB"
-				fi
-			fi
-
-			# SSH based auth
-			if [ "$ENABLE_SSH_AUTHENTICATION" = "1" -a "$LOGIN_SUCCESS" = "0" ]
-			then
-				log 6 -n "ssh "
-				export COMMAND_SSH			
-				nxnode_login "$PASS" -- ssh "$USER" "$SSHD_PORT" "$PATH_BIN/nxnode" --check 2>&1 >/dev/null
-				if [ $? -eq 0 ]
-				then
-					LOGIN_SUCCESS="1"
-					LOGIN_METHOD="SSH"
-				fi
-			fi
-			
-			# SU based auth
-			if [ "$ENABLE_SU_AUTHENTICATION" = "1" -a "$LOGIN_SUCCESS" = "0" ]
-			then
-				log 6 -n "su "
-				nxnode_login "$PASS" -- su "$USER" "" "$PATH_BIN/nxnode" --check 2>&1 >/dev/null
-				if [ $? -eq 0 ]
-				then
-					LOGIN_SUCCESS="1"
-					LOGIN_METHOD="SU"
-				fi
-			fi
-			
-			# Check if user in passdb
-			if [ "$ENABLE_USER_DB" = "1" ]
-			then
-				log 6 "userdb check"
-				passdb_user_exists "$USER" || LOGIN_SUCCESS="0"
-			fi
-			log 6 ""
-
-			if [ "$LOGIN_SUCCESS" = "1" ]
-			then
-				# Reread the config files (so that $USER.node.conf get sourced)
-				. $(PATH=$(cd $(dirname $0) && pwd):$PATH which nxloadconfig) --userconf
-				setup_usermode_auth
-
-				echo_x "NX> 103 Welcome to: $SERVER_NAME user: $USER"
-				break
-			else
-				echo_x "NX> 404 ERROR: wrong password or login"
-				echo_x "NX> 999 Bye"
-				exit 1
-			fi
-		;;
-	esac
-done
-
-# remove old session infos from history
-session_cleanup
-
-#
-# call it with: server_get_params $CMD # no ""!
-#
-
-server_get_params()
-{
-	SERVER_PARAMS=$(echo "$@" | sed "s/^$1/\"/g; s/\" --/\&/g; s/\"//g; s/%20/ /g")
-	if [ "$SERVER_PARAMS" = "" ]
-	then
-		echo_x -n "NX> 106 Parameters: "
-		read SERVER_PARAMS2
-		SERVER_PARAMS=$(echo $SERVER_PARAMS2 | sed 's/%2B/+/g; s/%20/ /g')
-		echo_x
-	fi
-}
-
-nxnode_start()
-{
-	:
-	#CMD="$1"
-	#shift
-	#echo "$@" | $PATH_BIN/nxnode "$CMD"
-}
-
-#NX> 1002 Commit
-#NX> 1006 Session status: running
-
-server_nxnode_start()
-{
-	CMD="$1"
-	USER="$2"
-	shift
-	shift
-
-	# Find NODE_HOSTNAME
-	
-	NODE_HOSTNAME=""
-	CMDLINE="$@"
-	uniqueid=$(getparam uniqueid)
-	[ -z "$uniqueid" ] && uniqueid=$(getparam sessionid)
-	[ -z "$uniqueid" ] && uniqueid=$(getparam session_id)
-	CMDLINE=$(session_get "$uniqueid")
-	
-	NODE_HOSTNAME="$(getparam host)"
-	[ -z "$NODE_HOSTNAME" ] && NODE_HOSTNAME="127.0.0.1"
-	export NODE_HOSTNAME
-	
-	# Use nxnode-login?
-	if [ "$LOGIN_METHOD" = "SSH" ]
-	then
-	    export COMMAND_SSH
-	    NXNODE_TOSEND="$@" nxnode_login "$PASS" -- ssh "$USER" "$SSHD_PORT" "$PATH_BIN/nxnode" "$CMD" 2>&1 | log_tee
-	elif [ "$LOGIN_METHOD" = "SU" ]
-	then
-	    NXNODE_TOSEND="$@" nxnode_login "$PASS" -- su "$USER" "" "$PATH_BIN/nxnode" "$CMD" 2>&1 | log_tee
-	elif [ "$LOGIN_METHOD" = "USERMODE" ]
-	then
-	    echo "$@" | $PATH_BIN/nxnode "$CMD" 2>&1 | log_tee
-	else
-	    echo "$@" | $COMMAND_SSH -l "$USER" "$NODE_HOSTNAME" -p $SSHD_PORT -x -2 -i $NX_ETC_DIR/users.id_dsa -o 'PubkeyAuthentication yes' -o 'RSAAuthentication yes' -o 'RhostsAuthentication no' -o 'PasswordAuthentication no' -o 'RhostsRSAAuthentication no' -o 'StrictHostKeyChecking no' $PATH_BIN/nxnode "$CMD" | log_tee
-	fi
-}
-
-server_add_usession()
-{
-	[ "$ENABLE_USESSION" = "1" ] || return
-	
-	$COMMAND_SESSREG -l ":$SESS_DISPLAY" -h "$USERIP" -a $USER 2>&1 | log_error
-}
-
-server_remove_usession()
-{
-	[ "$ENABLE_USESSION" = "1" ] || return
-	$COMMAND_SESSREG -l ":$SESS_DISPLAY" -h "$USERIP" -d $USER 2>&1 | log_error
-}
-
-server_nxnode_echo()
-{
-	log 6 "server_nxnode_echo: $@"
-	[ "$SERVER_CHANNEL" = "1" ] && echo "$@"
-	[ "$SERVER_CHANNEL" = "2" ] && echo "$@" >&2
-}
-
-server_nxnode_exit_func()
-{
-	log 1 "Info: Emergency-Shutting down due to kill signal ..."
-	
-	session_fail $uniqueid
-	
-	server_remove_usession
-
-	# remove lock file
-	[ -e "/tmp/.nX$SESS_DISPLAY-lock" ] && rm -f /tmp/.nX$SESS_DISPLAY-lock
-
-	# Kill possible slave node
-	nxnode_login_stop_slave
-}
-
-server_nxnode_start_wait()
-{
-	if [ "$1" = "--startsession" ]
-	then
-	
-	server_add_usession
-
-	# We need to stop sending things when a SIGPIPE arrives
-	trap "SERVER_CHANNEL=0" SIGPIPE
-	
-	trap server_nxnode_exit_func EXIT
-	
-	SERVER_CHANNEL=1
-	KILL_WAIT_PID=1
-	server_nxnode_start "$@" | while read CMD
-	do
-		case "$CMD" in 
-			"NX> 1006"*|"NX> 1005"*|"NX> 1009"*)
-				case "$CMD" in 
-					*running*)
-						[ "$KILL_WAIT_PID" = "1" ] && kill $SERVER_WAIT_PID
-						KILL_WAIT_PID=0
-						log 6 session_status $uniqueid "Running"
-						session_status $uniqueid "Running"
-						[ "$SERVER_CHANNEL" = "1" ] && SERVER_CHANNEL=2
-					;;
-					*closed*)
-						log 6 session_close $uniqueid
-						session_close $uniqueid
-					;;
-					*suspended*)
-						[ "$KILL_WAIT_PID" = "1" ] && kill $SERVER_WAIT_PID
-						KILL_WAIT_PID=0
-						log 6 session_suspend $uniqueid
-						session_suspend $uniqueid
-					;;
-					*suspending*)
-						log 6 session_status $uniqueid "Suspending"
-						session_status $uniqueid "Suspending"
-						# we need to stop sending to client as it will have already
-						# closed his side of the channel and this will lead to not 
-						# closed sessions.
-						SERVER_CHANNEL=0
-					;;
-					*terminating*)
-						log 6 session_status $uniqueid "Terminating"
-						session_status $uniqueid "Terminating"
-						# we need to stop sending to client as it will have already
-						# closed his side of the channel and this will lead to not 
-						# closed sessions.
-						SERVER_CHANNEL=0
-				esac
-			;;
-			"NX> 1004"*)
-				[ "$KILL_WAIT_PID" = "1" ] && kill $SERVER_WAIT_PID
-				KILL_WAIT_PID=0
-				session_fail $uniqueid
-				server_nxnode_echo "NX> 596 Session startup failed."
-				log 4 "NX> 596 Session startup failed."
-			;;
-		esac
-
-		case $CMD in
-			"NX> "*)
-				server_nxnode_echo $CMD
-			;;
-		esac
-	done
-
-	trap - EXIT
-	trap - SIGPIPE
-	
-	# Close it in case the session is still running
-	session_running $uniqueid && session_close $uniqueid
-	
-	server_remove_usession
-
-	# remove lock file
-	[ -e "/tmp/.nX$SESS_DISPLAY-lock" ] && rm -f /tmp/.nX$SESS_DISPLAY-lock
-
-	nxnode_login_stop_slave
-
-	else # $1 = restore
-	
-	KILL_WAIT_PID=1
-	SERVER_CHANNEL=1
-	server_nxnode_start "$@" | while read CMD
-	do
-		case "$CMD" in 
-			"NX> 1006"*|"NX> 1005"*|"NX> 1009"*)
-				case "$CMD" in 
-					*running*)
-						[ "$KILL_WAIT_PID" = "1" ] && kill $SERVER_WAIT_PID
-						KILL_WAIT_PID=0
-						SERVER_CHANNEL=2
-					;;
-				esac
-			;;
-			"NX> 1004"*)
-				[ "$KILL_WAIT_PID" = "1" ] && kill $SERVER_WAIT_PID
-				KILL_WAIT_PID=0
-				
-				# This fail is correct here as somehow the 
-				# monitor process might have died and we don't 
-				# want the session to be resumed again.
-				
-				session_fail $uniqueid
-				
-				server_nxnode_echo "NX> 596 Session startup failed."
-				log 4 "NX> 596 Session startup failed."
-				break;
-			;;
-		esac
-	
-		case $CMD in
-			"NX> "*)
-				server_nxnode_echo $CMD
-			;;
-		esac
-	done
-	
-	nxnode_login_stop_slave
-	
-	fi # $1 = start
-}
-
-server_check_session_count()
-{
-	session_count_user "$USER"
-	
-	if [ "$SESSION_COUNT" -ge "$SESSION_LIMIT" ]
-	then
-		echo_x "NX> 599 Reached the maximum number of concurrent sessions on this server."
-		echo_x "NX> 500 ERROR: Last operation failed."
-		return 1
-	fi
-	
-	if [ "$SESSION_COUNT_USER" -ge "$SESSION_USER_LIMIT" ]
-	then
-		echo_x "NX> 599 Server capacity: reached for user: $USER"
-		echo_x "NX> 500 ERROR: Last operation failed."
-		return 1
-	fi
-
-	return 0
-}
-
-server_loadbalance_random()
-{
-	# Pick one based on "random" algorithm
-	SERVER_LB_HOSTS=( $LOAD_BALANCE_SERVERS )
-	SERVER_LB_NR_OF_HOSTS=${#SERVER_LB_HOSTS[@]}
-	let SERVER_LB_NR=(RANDOM % SERVER_LB_NR_OF_HOSTS)
-	SERVER_LB_HOST=${SERVER_LB_HOSTS[$SERVER_LB_NR]}
-	echo $SERVER_LB_HOST
-}
-
-# run in subshell!
-
-server_loadbalance_round_robin()
-{
-	SERVER_LB_HOSTS=( $LOAD_BALANCE_SERVERS )
-	SERVER_LB_NR_OF_HOSTS=${#SERVER_LB_HOSTS[@]}
-	
-	# Atomic incrementation:
-
-	# Enter critical section
-	# - Create .lock file
-	
-	SERVER_LB_LOCKFILE=$(mktemp "$NX_SESS_DIR/round-robin.lock.XXXXXXXXX")
-
-	trap "rm -f $SERVER_LB_LOCKFILE" EXIT
-	
-	i=0
-	while [ $i -lt 200 ]
-	do
-		# ln is an atomic operation
-		ln $SERVER_LB_LOCKFILE "$NX_SESS_DIR/round-robin.lock" && break
-		LANG=C sleep 0.01
-		let i=i+1
-	done
-
-	if [ $i -ge 200 ]
-	then
-		log 1 "Load-Balancing: Round-Robin failed to gain lock file in 200 tries. Falling back to random."
-		server_loadbalance_random
-		return
-	fi
-	
-	trap "rm -f \"$SERVER_LB_LOCKFILE\" \"$NX_SESS_DIR/round-robin.lock\"" EXIT
-
-	# Lock held
-
-	SERVER_LB_NR=$(cat $NX_SESS_DIR/round-robin 2>/dev/null)
-	let SERVER_LB_NR=(SERVER_LB_NR+1) % SERVER_LB_NR_OF_HOSTS
-	echo $SERVER_LB_NR >$NX_SESS_DIR/round-robin
-
-	# Exit critical section
-	rm -f "$SERVER_LB_LOCKFILE" "$NX_SESS_DIR/round-robin.lock"
-
-	trap - EXIT
-
-	SERVER_LB_HOST=${SERVER_LB_HOSTS[$SERVER_LB_NR]}
-	echo $SERVER_LB_HOST
-}
-
-server_loadbalance_load()
-{
-	SERVER_LB_MAX=0
-	SERVER_LB_HOST=""
-	
-	for i in $LOAD_BALANCE_SERVERS
-	do
-		SERVER_LB_LOAD=$($NX_DIR/bin/nxcheckload $i)
-		[ -z "$SERVER_LB_LOAD" ] && continue
-		
-		if [ $SERVER_LB_LOAD -gt $SERVER_LB_MAX ]
-		then
-			SERVER_LB_MAX=$SERVER_LB_LOAD
-			SERVER_LB_HOST=$i
-		fi
-	done
-	echo $SERVER_LB_HOST
-}
-
-server_loadbalance()
-{
-	SERVER_HOST="127.0.0.1"
-	if [ -n "$LOAD_BALANCE_SERVERS" ]
-	then
-		SERVER_HOST=""
-		if [ -n "$PREFERRED_HOST" -a "$ENABLE_LOAD_BALANCE_PREFERENCE" = "1" ]
-		then
-			stringinstring " $PREFERRED_HOST " " $LOAD_BALANCE_SERVERS " && SERVER_HOST="$PREFERRED_HOST"
-		fi
-		
-		# Fallback if still empty
-		if [ -z "$SERVER_HOST" ]
-		then
-			case "$LOAD_BALANCE_ALGORITHM" in
-				random)
-					SERVER_HOST=$(server_loadbalance_random)
-				;;
-				round-robin)
-					SERVER_HOST=$(server_loadbalance_round_robin)
-				;;
-				load)
-					SERVER_HOST=$(server_loadbalance_load)
-				;;
-			esac
-		fi
-		
-		[ -z "$SERVER_HOST" ] && SERVER_HOST="127.0.0.1"
-		[ -n "$SERVER_HOST" ] && log 5 "Info: Load-Balancing (if possible) to $SERVER_HOST ..."
-	fi
-	echo "$SERVER_HOST"
-}	
-
-server_startrestore_session()
-{
-	ACTION="$1"
-	
-	server_get_params $CMD
-	PARAMS=$SERVER_PARAMS
-	PARAMS="$PARAMS&clientproto=$PROTO"
-	CMDLINE=$PARAMS
-	echo_x
-
-	# special mirrored type
-	[ "$ACTION" != "start" -a "$(getparam type)" = "vnc" ] && ACTION="mirror"
-
-	if [ "$ACTION" = "mirror" ]
-	then
-		ACTION="start"
-		uniqueid=$(getparam restore)
-		[ -z "$uniqueid" ] && uniqueid=$(getparam id) # 1.4.0-5 compatibility
-		CMDLINE=$(session_get "$uniqueid" 2>/dev/null)
-
-		mirrordisplay=$(getparam display)
-		mirrorhost=$(getparam host)
-
-		if [ -z "$mirrordisplay"  ]
-		then
-			# check for DESKTOP_SHARING_IDS
-			mirrordisplay=$(echo $DESKTOP_SHARING_IDS | tr ' ' '\n' | egrep "^$uniqueid=" | cut -d'=' -f2)
-			mirrorhost="127.0.0.1"
-		fi
-
-		if [ -z "$mirrordisplay" ]
-		then
-			echo_x "NX> 596 Could not find mirrored session $uniqueid. Session failed."
-			echo_x "NX> 596 Sharing: $DESKTOP_SHARING_IDS"
-			return 1
-		fi
-
-		PARAMS="$PARAMS&mirrordisplay=$mirrordisplay&mirrorhost=$mirrorhost"
-		CMDLINE=$PARAMS
-	fi
-	
-	if [ "$ACTION" = "start" ]
-	then
-
-		# Hack for external RDP/RFB agents
-
-		if [ "$ENABLE_EXTERNAL_NXDESKTOP" = "1" -a "$(getparam type)" = "windows" ]
-		then
-			type="unix-application"
-			application="$PATH_BIN/nxdesktop_helper"
-			PARAMS="$PARAMS&type=$type&application=$application&freenx_export_agents=1"
-			CMDLINE=$PARAMS
-		fi
-		 
-		if [ "$ENABLE_EXTERNAL_NXVIEWER" = "1" -a "$(getparam type)" = "vnc" ]
-		then
-			type="unix-application"
-			application="$PATH_BIN/nxviewer_helper"
-			PARAMS="$PARAMS&type=$type&application=$application&freenx_export_agents=1"
-			CMDLINE=$PARAMS
-		fi
-	fi
-	
-	# If we can't get the userip and SSHD_CHECK_IP is set to 1
-	# we bail out.
-	if [ -z "$SSH_CLIENT" -a -z "$SSH2_CLIENT" ]
-	then 
-		if [ "$SSHD_CHECK_IP" = "1" ]
-		then
-			echo_x "NX> 596 Session startup failed. (Missing SSH_CLIENT environment variable)"
-			return 1
-		else
-			log 2 "Warning: Failed to determine the client IP."
-			log 2 "Warning: The SSH_CLIENT or SSH2_CLIENT variable was not provided by SSHD."
-			log 2 "Warning: Please set SSHD_CHECK_IP=1 if you want to refuse the connection."
-		fi
-	fi
-	
-	export ENCRYPTION=$(getparam encryption)
-	
-	if [ "$ENABLE_FORCE_ENCRYPTION" = "1" -a "$ENCRYPTION" != "1" ]
-	then
-			echo_x "NX> 596 Unencrypted sessions are not allowed."
-			return 1
-	fi
-
-	# check if there is a suspended session, which we could resume
-	if [ "$ENABLE_AUTORECONNECT" = "1" -a "$ACTION" = "start" ]
-	then
-		restore=$(session_get_user_suspended "$USER" "Suspended")
-		if [ -n "$restore" ]
-		then
-			PARAMS="$PARAMS&restore=$restore"
-			CMDLINE=$PARAMS
-			ACTION="resume"
-		fi
-	fi
-
-	# as only $SSH_CLIENT or $SSH2_CLIENT will be set, this should work
-	USERIP=$(echo $SSH_CLIENT $SSH2_CLIENT | cut -d" " -f1 | sed 's/::ffff://g')
-	[ -z "$USERIP" ] && USERIP="*"
-	if [ "$ACTION" = "start" -o "$ACTION" = "mirror" ]
-	then
-		server_check_session_count || return 1
-		
-		# start nxnode
-		SESS_DISPLAY=$DISPLAY_BASE
-		let SESS_DISPLAY_LIMIT=$DISPLAY_BASE+$DISPLAY_LIMIT
-	
-		# stupid but working algo ...
-			
-		# TODO: need to check for _all_ offset and ports :-/
-			
-		while true
-		do
-			while [ -e /tmp/.X$SESS_DISPLAY-lock -o -e "/tmp/.nX$SESS_DISPLAY-lock"  -o -e "/tmp/.X11-unix/X$SESS_DISPLAY" ]
-			do
-				let SESS_DISPLAY=$SESS_DISPLAY+1
-			done
-
-			# Check if there is already an agent running on that display
-			let AGENT_DISPLAY=$SESS_DISPLAY+6000
-			if $COMMAND_NETCAT -z 127.0.0.1 $AGENT_DISPLAY 2>/dev/null
-			then
-				log 2 "Warning: Stray nxagent without .X$SESS_DISPLAY-lock found on port $AGENT_DISPLAY."
-				let SESS_DISPLAY=$SESS_DISPLAY+1
-				continue
-			fi
-			
-
-			SESS_LOCKFILE=$(mktemp "/tmp/.nX$SESS_DISPLAY-lock.XXXXXXXXX")
-			# ln is an atomic operation
-			ln "$SESS_LOCKFILE" "/tmp/.nX$SESS_DISPLAY-lock" 2>/dev/null && break
-		done
-
-		rm -f "$SESS_LOCKFILE"
-		
-		if [ "$SESS_DISPLAY" -gt "$SESS_DISPLAY_LIMIT" ]
-		then
-			echo_x "NX> 596 Error: Display limit exceeded. Please remove some files from /tmp/.X*-lock."
-			rm -f "/tmp/.nX$SESS_DISPLAY-lock"
-			return
-		fi
-	
-		uniqueid=$(echo $[$RANDOM*$RANDOM] | $COMMAND_MD5SUM | cut -d" " -f1 | tr "[a-z]" "[A-Z]")
-
-		# Possibly do loadbalancing
-		
-		SERVER_HOST=$(server_loadbalance)
-		
-		FULL_PARAMS="$PARAMS&user=$USER&userip=$USERIP&uniqueid=$uniqueid&display=$SESS_DISPLAY&host=$SERVER_HOST"
-		log_secure "6" "$FULL_PARAMS"
-
-		# now update the session listing
-		sessionRootlessMode=0
-		[ "$(getparam rootless)" = "1" ] && sessionRootlessMode=1
-		CMDLINE="a=b&$FULL_PARAMS"
-		session_add $uniqueid "sessionName=$(getparam session)&display=$(getparam display)&status=Running&startTime=$(date +%s)&foreignAddress=$(getparam userip)&sessionRootlessMode=$sessionRootlessMode&type=$(getparam type)&sessionId=$uniqueid&creationTime=$(date +%s)&userName=$USER&serverPid=$SERVER_PID&screeninfo=$(getparam screeninfo)&geometry=$(getparam geometry)&host=$SERVER_HOST"
-	else
-		uniqueid=$(getparam restore)
-		[ -z "$uniqueid" ] && uniqueid=$(getparam id) # 1.4.0-5 compatibility
-		session_change "$uniqueid" "foreignAddress" "$USERIP"
-
-		CMDLINE=$(session_get "$uniqueid")
-		FULL_PARAMS="$PARAMS&user=$USER&userip=$(getparam foreignAddress)&uniqueid=$uniqueid&display=$(getparam display)&status=$(getparam status)"
-		SESS_DISPLAY=$(getparam display)
-		SERVER_HOST=$(getparam host)
-		[ -z "$SERVER_HOST" ] && SERVER_HOST="127.0.0.1"
-	fi
-
-	# now start the node
-	sleep $AGENT_STARTUP_TIMEOUT &
-	SERVER_WAIT_PID=$!
-	( server_nxnode_start_wait --"$ACTION"session $USER "$FULL_PARAMS" ) &
-	SERVER_PID=$!
-	disown $SERVER_PID
-	
-	wait $SERVER_WAIT_PID
-	
-	if [ $? -eq 0 ]
-	then
-		# Something went wrong ...
-		[ "$ACTION" = "start" ] && session_fail $uniqueid
-		echo_x "NX> 1004 Error: Session did not start."
-		echo_x "NX> 596 Session $ACTION failed."
-		echo_x "NX> 999 Bye"
-		# FIXME: Send node signal to terminate
-		exit 1
-	fi
-	
-	# We have now an active reader
-	nxnode_login_register_reader
-}
-
-# Session stage
-while true
-do
-	echo_x -n "NX> 105 "
-	unset CMD
-	read CMD 2>/dev/null
-	# FIXME?
-	[ "$CMD" = "" ] && CMD="quit"
-	
-	# Logging 
-	case "$CMD" in
-		startsession*|restoresession*|addmount*|addprinter*)
-			echo_secure "$CMD"
-			log_secure "4" "$CMD"
-		;;
-		*)
-			echo "$CMD"
-			log "4" "$CMD"
-		;;
-	esac
-	
-	case "$CMD" in 
-		quit|QUIT)
-			echo_x "Quit"
-			echo_x "NX> 999 Bye"
-			exit 0
-		;;
-		exit|EXIT)
-			echo_x "Exit"
-			echo_x "NX> 999 Bye"
-			exit 0
-		;;
-		bye|BYE)
-			echo_x "Bye" 1>&2
-			echo_x "NX> 999 Bye" 1>&2
-			if [ "$ENCRYPTION" = "1" ] 
-			then 
-				let PROXY_DISPLAY=$SESS_DISPLAY+4000
-				exec $COMMAND_NETCAT $SERVER_HOST $PROXY_DISPLAY
-			else
-				echo_x "NX> 1001 Bye."
-			fi
-		;;
-		startsession*)
-			server_startrestore_session "start"
-		;;
-		list*)
-			server_get_params $CMD
-			PARAMS=$SERVER_PARAMS
-			CMDLINE=$PARAMS
-			
-			status=$(getparam status)
-
-			if [ "$status" = "Suspended" -a -n "$(getparam screeninfo)" ]
-			then
-				session_list_user_suspended "$USER" "Suspended" "$(getparam screeninfo)" "$(getparam type)"
-			elif [ "$status" = "Suspended,Running" -o "$status" = "Suspended" ] # since 1.4.0-5
-			then
-				# disabled due to problems with 1.4.0-5 client
-				#session_list_user_suspended "$USER" 'Suspended$|^status=Running$' "$(getparam geometry)" "$(getparam type)" | log_tee
-				session_list_user_suspended "$USER" 'Suspended' "$(getparam geometry)" "$(getparam type)"
-			elif [ "$status" = "suspended,running" -o "$status" = "suspended" ] # since 1.5.0
-			then
-				status=$(echo $status | sed 's/,/$|^status=/g; s/suspended/Suspended/g; s/running/Running/g')
-				session_list_user_suspended "$USER" "$status" "$(getparam geometry)" "$(getparam type)"
-			else
-				session_list_user "$USER" | log_tee
-			fi
-		;;
-		suspend*)
-			server_get_params $CMD
-			PARAMS=$SERVER_PARAMS
-			CMDLINE=$PARAMS
-			if session_find_id_user "$(getparam sessionid)" "$USER"
-			then
-				server_nxnode_start --suspend "$USER" "$PARAMS"
-			fi
-		;;
-		terminate*)
-			server_get_params $CMD
-			PARAMS=$SERVER_PARAMS
-			CMDLINE=$PARAMS
-			if session_find_id_user "$(getparam sessionid)" "$USER"
-			then
-				server_nxnode_start --terminate "$USER" "$PARAMS"
-			fi
-		;;
-		restoresession*)
-			server_startrestore_session "resume"
-		;;
-		mirrorsession*)
-			server_startrestore_session "mirror"
-		;;
-
-		passwd)
-			echo_x "NX> 113 Changing password of user '$USER'"
-			echo_x -n "NX> 102 Current password:"
-			read -s PASS
-			ENC_PASS=$(passdb_get_crypt_pass "$PASS")
-			REAL_PASS=$(passdb_get_pass "$USER")
-			echo_x
-			if [ "$ENC_PASS" = "$REAL_PASS" ]
-			then
-				echo_x -n "NX> 102 Password:"
-				read -s NEW_PASS1
-				
-				if [ ${#NEW_PASS1} -lt 5 ]
-				then
-					echo_x "NX> 500 ERROR: incorrect password format, password must be long at least five characters"
-					continue
-				fi
-
-				echo_x
-				echo_x -n "NX> 102 Confirm password:"
-				read -s NEW_PASS1
-				echo_x
-				if [ "$NEW_PASS1" = "$NEW_PASS2" ]
-				then
-					ENC_PASS=$(passdb_get_crypt_pass "$NEW_PASS1")
-					passdb_chpass "$USER" "$ENC_PASS"
-					echo_x "NX> 114 Password of user '$USER' changed"
-				else
-					echo_x "NX> 537 ERROR: passwords do not match"
-				fi
-			else
-				echo_x "NX> 500 ERROR: current password doesn't match"
-			fi
-		;;
-		addmount*)
-			server_get_params $CMD
-			PARAMS=$SERVER_PARAMS
-			# TODO: This redirection is crap here.
-			server_nxnode_start --smbmount "$USER" "$PARAMS" >/dev/null 2>&1 | log_error >/dev/null
-			echo_x "NX> 719 SMB filesystem: running"
-		;;
-		addprinter*)
-			server_get_params $CMD
-			PARAMS=$SERVER_PARAMS
-			# TODO: This redirecion is crap here.
-			server_nxnode_start --addprinter "$USER" "$PARAMS" >/dev/null 2>&1 | log_error >/dev/null
-			echo_x "NX> 719 CUPS printer: running"
-		;;
-		*)
-			# disabled for 1.4.0-5 snapshot client
-			#echo_x "NX> 503 Error: undefined command: '$CMD'"
-		;;
-	esac
-done
-
-fi
-
-#
-# End of Main nxserver <--> nxclient communication module
-#
-
-################### PACKAGE cmd.bm ############################
-
-#
-# library functions for nxserver-commandline cmds
-#
-
-# Policy: All functions and variables need to start with CMD_ / cmd_
-
-# Needed global vars: $NX_VERSION, $NX_LICENSE, $NX_ETC_DIR, $PATH_BIN, $NX_HOME_DIR, $SSH_AUTHORIZED_KEYS
-
-# Needed package: passdb
-
-cmd_usage()
-{
-	echo "NXSERVER - Version $NX_VERSION $NX_LICENSE" 1>&2
-	echo "Usage: nxserver <option>" 1>&2
-
-	if [ "$1" = "root" ]
-	then
-		echo "--adduser <user>: Add a new user" 1>&2
-		echo "--passwd <user>: Change password of <user>" 1>&2
-		echo "--deluser <user>: Remove a user from nx" 1>&2
-		echo "--listuser: List enabled users" 1>&2
-		echo "" 1>&2
-		echo "--start: Start the nx server" 1>&2
-		echo "--stop: Stop the nx server" 1>&2
-		echo "--status: Show status of nx server" 1>&2
-		echo "--restart: Restart the nx server. (start,stop)" 1>&2
-		echo "" 1>&2
-		echo "--list [ user | sessionid ]: List running sessions of user or sessionid " 1>&2
-		echo "--history [ user | sessionid | clear ]: Show history [ of user | sessionid ] or clear the history" 1>&2
-		echo "--terminate <user | :display | sessionid>: Terminate the session pointed to by" 1>&2
-		echo "       sessionid or display, or all sessions of the specified user." 1>&2
-		echo "       Use * for all sessions." 1>&2
-		echo "--force-terminate: Like terminate, but removes also session info." 1>&2
-		echo "--suspend <user | :display | sessionid>: Suspend the session pointed to by" 1>&2
-		echo "       sessionid or display, or all sessions of the specified user." 1>&2
-		echo "       Use * for all sessions." 1>&2
-		echo "--cleanup: Terminates all running sessions. Useful after power-outage."
-		echo "" 1>&2
-		echo "--broadcast <message>: Send a message to all users" 1>&2
-		echo "--send <user | :display | sessionid> <message>: Send a message to the specified user or sessionid" 1>&2
-	else
-		echo "--passwd: Change password" 1>&2
-	fi
-	exit 1
-}
-
-
-cmd_abort()
-{
-	echo "NX> 500" "$@" 1>&2
-	echo "NX> 999 Bye" 1>&2
-	exit 1
-}
-
-cmd_user_passwd()
-{
-	echo "NX> 100 NXSERVER - Version $NX_VERSION $NX_LICENSE"
-	echo "Sorry: Password changing for user is _not_ implemented, yet."
-	echo "Please login to NX-Server to change password"
-	echo "or ask your local system administrator."
-	#echo "NX> 113 Changing password of user '$USER'"
-	#echo "Old password:"
-	#read -s OLDPASS
-	#echo "New password:"
-	#read -s NEWPASS1
-	#echo "Repeat:"
-	#read -s NEWPASS2
-
-}
-
-cmd_passwd()
-{
-	CMD_CHUSER=$2
-	egrep -q "^$CMD_CHUSER:" $NX_ETC_DIR/passwords || cmd_abort "Error: User $CMD_CHUSER not found in database."
-	echo -n "New password: "
-	read -s CMD_NEWPASS
-	echo
-	CMD_ENC_PASS=$(passdb_get_crypt_pass "$CMD_NEWPASS")
-	passdb_chpass "$CMD_CHUSER" "$CMD_ENC_PASS"
-	echo "Password changed."
-}
-
-cmd_adduser()
-{
-	CMD_CHUSER=$2
-	
-	[ ${#CMD_CHUSER} -ge 32 ] && cmd_abort "Error: User $CMD_CHUSER must be shorter than 32 characters."
-	egrep -q "^$CMD_CHUSER:" $NX_ETC_DIR/passwords && cmd_abort "Error: User $CMD_CHUSER already in database."
-	getent passwd "$CMD_CHUSER" >/dev/null || cmd_abort "Error: User $CMD_CHUSER not existing on local system. Can't add."
-	passdb_add_user "$CMD_CHUSER"
-}
-
-cmd_deluser()
-{
-	CMD_CHUSER=$2
-	egrep -q "^$CMD_CHUSER:" $NX_ETC_DIR/passwords || cmd_abort "Error: User $CMD_CHUSER not found in database."
-	passdb_remove_user "$CMD_CHUSER"
-}
-
-cmd_listuser()
-{
-	echo "NX> 146 NX users list"
-	echo
-	echo "Username"
-	echo "---------------"
-	echo
-	passdb_list_user
-	echo
-}
-
-cmd_start()
-{
-	
-	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] && cmd_abort "ERROR: Service already running"
-	mv $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS.disabled $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS
-	echo "NX> 122 Service started"
-}
-
-cmd_stop()
-{
-	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] || cmd_abort "Service was already stopped"
-	mv $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS.disabled
-	echo "NX> 123 Service stopped"
-}
-
-cmd_status()
-{
-	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] && echo "NX> 110 NX Server is running"
-	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] || echo "NX> 110 NX Server is stopped"
-}
-
-cmd_restart()
-{
-	cmd_stop
-	cmd_start
-}
-
-cmd_parse_2_params()
-{
-	if [ ${#1} -eq 32 ]
-	then
-		CMD_APARAMS="sessionid=sessionId{$1}"
-	else
-	if [ "$1" != "" ]
-	then
-		#egrep -q "^$1:" $NX_ETC_DIR/passwords || cmd_abort "Error: User $1 not found in database."
-		CMD_APARAMS="user=$1"
-	fi
-	fi
-	echo $CMD_APARAMS
-
-}
-
-cmd_parse_3_params()
-{
-	if [ ${#1} -eq 32 ]
-	then
-		CMD_APARAMS=$(session_find_id $1)
-		[ -n "$CMD_APARAMS" ] || cmd_abort "Error: Session $1 could not be found."
-	elif [ "${1:0:1}" = ":" ]
-	then
-		CMD_APARAMS=$(session_find_display "${1:1}")
-		[ -n "$CMD_APARAMS" ] || cmd_abort "Error: No running sessions found for display $1."
-	elif [ "$1" = "*" ]
-	then
-		CMD_APARAMS=$(session_find_all)
-		[ -n "$CMD_APARAMS" ] || cmd_abort "Error: No running sessions found."
-	elif [ "$1" != "" ]
-	then
-		#egrep -q "^$1:" $NX_ETC_DIR/passwords || cmd_abort "Error: User $1 not found in database."
-		CMD_APARAMS=$(session_find_user "$1")
-		[ -n "$CMD_APARAMS" ] || cmd_abort "Error: No running sessions found for user $1."
-	else
-		cmd_abort "Error: Not enough parameters."
-	fi
-	echo $CMD_APARAMS
-}
-
-cmd_list_suspended()
-{
-	CMD_PARAMS=$(cmd_parse_2_params "$2")
-	[ -n "$2" -a -z "$CMD_PARAMS" ] && exit 1
-	case $CMD_PARAMS in
-		user=*)
-			session_list_user_suspended $2 "Suspended"
-		;;
-	esac
-}
-cmd_list()
-{
-	CMD_PARAMS=$(cmd_parse_2_params "$2")
-	[ -n "$2" -a -z "$CMD_PARAMS" ] && exit 1
-	case $CMD_PARAMS in
-		user=*)
-			session_list_user $2
-		;;
-		sessionid=*)
-			session_list $2
-		;;
-		*)
-			session_list_all
-		;;
-	esac
-}
-
-cmd_history_clear()
-{
-	rm -f $NX_SESS_DIR/closed/*
-	rm -f $NX_SESS_DIR/failed/*
-}
-
-cmd_history()
-{
-	if [ "$2" = "clear" ]
-	then
-		cmd_history_clear
-	fi
-	
-	CMD_PARAMS=$(cmd_parse_2_params "$2")
-	user=""
-	sessid=""
-	case $CMD_PARAMS in
-		user=*)
-			user="$2"
-		;;
-		sessionid=*)
-			sessid="$2"
-		;;
-	esac
-
-	session_history "$user" "$sessid"
-}
-
-cmd_terminate()
-{
-	CMD_PARAMS=$(cmd_parse_3_params "$2")
-	[ -z "$CMD_PARAMS" ] && exit 1
-	for i in $CMD_PARAMS;
-	do
-			CMDLINE=$(session_get_cmdline $i)
-			cmd_sessionid=$(getparam sessionId)
-			cmd_user=$(getparam userName)
-			cmd_type=$(getparam type)
-			cmd_status=$(getparam status)
-
-			# is it a "good" session?
-			case "$1" in 
-			--suspend)
-				if [ "$cmd_status" = "Running" ] && stringinstring "unix-" "$cmd_type"
-				then
-					echo "sessionid=$cmd_sessionid" | su - "$cmd_user" -c "$PATH_BIN/nxnode --suspend"
-				fi
-			;;
-			--terminate)
-				echo "sessionid=$cmd_sessionid" | su - "$cmd_user" -c "$PATH_BIN/nxnode --terminate"
-			;;
-			--force-terminate)
-				echo "sessionid=$cmd_sessionid" | su - "$cmd_user" -c "$PATH_BIN/nxnode --terminate"
-				session_close $cmd_sessionid
-			;;
-			esac
-	done
-
-}
-
-cmd_send()
-{
-	if [ "$1" = "--broadcast" ]
-	then
-	  CMD_PARAMS=$(session_find_all)
-	  [ -z "$CMD_PARAMS" ] && cmd_abort "Error: No running session could be found."
-	else
-	  CMD_PARAMS=$(cmd_parse_3_params "$2")
-	  [ -z "$CMD_PARAMS" ] && exit 1
-	  shift
-	fi
-	shift
-	for i in $CMD_PARAMS;
-	do
-			CMDLINE=$(session_get_cmdline $i)
-			cmd_display=$(getparam display)
-			cmd_user=$(getparam userName)
-			cmd_type=$(getparam type)
-			cmd_status=$(getparam status)
-			cmd_host=$(getparam host)
-
-			# is it a "good" session?
-			if [ "$cmd_status" = "Running" ] && stringinstring "unix-" "$cmd_type"
-			then
-				if [ "$cmd_host" = "127.0.0.1" -o "$cmd_host" = "localhost" ]
-				then
-					su - "$cmd_user" -c "$PATH_BIN/nxdialog --dialog ok --caption \"NX Administrator Message\" --message \"$@\" -display \":$cmd_display\" &"
-				else
-					ssh $cmd_host su - "$cmd_user" -c "'$PATH_BIN/nxdialog --dialog ok --caption \"NX Administrator Message\" --message \"$@\" -display \":$cmd_display\" &'"
-				fi
-			fi
-	done
-	#nxnode_start --send "$CMD_PARAMS"
-}
-
-#
-# user mode available functions
-#
-
-if [ $UID -ne 0 ]
-then
-	[ "$1" = "--agent" ] && exec $PATH_BIN/nxnode "$@"
-	[ "$1" != "--passwd" ] && cmd_usage
-	cmd_user_passwd
-	exit 0
-fi
-
-#
-# root mode available functions
-#
-
-[ $# -lt 1 ] && cmd_usage "root"
-[ "$1" = "--help" ] && cmd_usage "root"
-
-if [ "$1" = "--version" ]
-then
-  echo "NXSERVER - Version $NX_VERSION $NX_LICENSE"
-  exit 0
-fi
-
-CMD=$1
-
-echo "NX> 100 NXSERVER - Version $NX_VERSION $NX_LICENSE"
-
-case $CMD in
-	# 
-	# User functions ...
-	# 
-	--passwd)
-		cmd_passwd "$@"
-	;;
-	--adduser|--useradd)
-		cmd_adduser "$@"
-	;;
-	--deluser|--userdel)
-		cmd_deluser "$@"
-	;;
-	--listuser|--userlist)
-		cmd_listuser
-	;;
-	--start)
-		cmd_start
-	;;
-	--stop)
-		cmd_stop
-	;;
-	--status)
-		cmd_status
-	;;
-	--restart)
-		cmd_restart
-	;;
-	--list)
-		cmd_list "$@"
-	;;
-	--list-suspended)
-		cmd_list_suspended "$@"
-	;;
-	--history)
-		cmd_history "$@"
-	;;
-	--terminate|--suspend|--force-terminate)
-		cmd_terminate "$@"
-	;;
-	--cleanup)
-		cmd_terminate "--force-terminate" "*"
-	;;
-	--send|--broadcast)
-		cmd_send "$@"
-	;;
-	*)
-		cmd_abort "Error: Function $CMD not implemented yet."
-esac
-echo "NX> 999 Bye"

Deleted: trunk/freenx-server/trunk/nxsetup
===================================================================
--- trunk/freenx-server/trunk/nxsetup	2008-03-10 22:59:38 UTC (rev 511)
+++ trunk/freenx-server/trunk/nxsetup	2008-03-10 23:01:03 UTC (rev 512)
@@ -1,576 +0,0 @@
-#!/bin/bash
-
-# Coypright (c) 2004-2005 by Fabian Franz <freenx at fabian-franz.de>.
-#                    2005 by Jon Severinsson <jonno at users.berlios.de>.
-#
-# License: GNU GPL, version 2
-#
-# SVN: $Id$ 
-#
-
-HELP="no"
-INSTALL="no"
-SETUP_NOMACHINE_KEY="no"
-SETUP_UID=""
-SETUP_GID=""
-LOCAL_USER_OPTION=""
-# luseradd / luserdel are only available on RedHat
-[ -f /etc/redhat-release ] && LOCAL_USER_OPTION="yes"
-SETUP_LOCAL_USER="no"
-CLEAN="no"
-UNINSTALL="no"
-PURGE="no"
-SETUP_SSH2_KEY="no"
-BUILD_KNOWN_HOSTS="yes"
-AUTOMATIC="no"
-IGNORE_ERRORS="no"
-
-if [ $UID -ne 0 ]
-then
-	echo "You need to be root to use this program." 
-	exit 1
-fi
-
-parse_cmdline()
-{
-	while [ "$1" ]
-	do
-		case "$1" in
-			--help) HELP="yes"; shift ;;
-			--install) INSTALL="yes"; shift ;;
-			--ignore-errors) IGNORE_ERRORS="yes"; shift;;
-			--setup-nomachine-key) SETUP_NOMACHINE_KEY="yes"; shift ;;
-			--ssh2) SETUP_SSH2_KEY="yes"; shift;;
-			--dont-build-known-hosts) BUILD_KNOWN_HOSTS="no"; shift;;
-			--uid) SETUP_UID=$2; shift 2 ;;
-			--gid) SETUP_GID=$2; shift 2 ;;
-			--localuser) SETUP_LOCAL_USER="yes"; shift;;
-			--clean) CLEAN="yes"; shift ;;
-			--uninstall) UNINSTALL="yes"; shift ;;
-			--purge) PURGE="yes"; shift ;;
-			--auto) AUTOMATIC="yes"; shift ;;
-			--test) TEST="yes"; shift ;;
-			--) shift ; break ;;
-			*) echo "Invalid flag $1" ; HELP="yes"; shift ; break ;;
-		esac
-	done
-
-	[ "$TEST" = "yes" ] && return         # If we just test, we can return directly
-
-	#Check for invalid combinations:
-	[ "$SETUP_LOCAL_USER" = "yes" -a -z "$LOCAL_USER_OPTION" ] && HELP="yes"
-	[ "$INSTALL" = "yes" -a "$UNINSTALL" = "yes" ] && HELP="yes"
-	[ "$INSTALL" = "yes" -a "$CLEAN" = "no" -a "$PURGE" = "yes" ] && HELP="yes"
-	[ "$UNINSTALL" = "yes" ] && [ "$SETUP_NOMACHINE_KEY" = "yes" -o -n "$SETUP_UID" -o "$CLEAN" = "yes" ] && HELP="yes"
-	[ "$UNINSTALL" = "yes" -a "$CLEAN" = "yes" ] && HELP="yes"
-	[ "$SETUP_SSH2_KEY" = "yes" -a "$SETUP_NOMACHINE_KEY" = "no" ] && HELP="yes"
-
-	if [ "$INSTALL" = "no" -a "$UNINSTALL" = "no" -a "$AUTOMATIC" = "no" -a "$HELP" = "no" ]
-	then
-		echo "------> You did select no action."
-		echo "        FreeNX guesses that you want to _install_ the server."
-		echo "        Type \"y\" to abort the installation at this point in time."
-		echo "        \"N\" is the default and continues installation."
-		echo "        Use \"${0} --help\" to get more detailed help hints."
-		echo ""
-		echo -n " Do you want to abort now? [y/N] "
-		read -n 1 CHOICE
-		echo
-		[ "$CHOICE" = "y" ] || INSTALL="yes"
-	fi
-
-	[ "$INSTALL" = "no" -a "$UNINSTALL" = "no" ] && HELP="yes"
-
-	if [ "$HELP" = "yes" ]
-	then
-		echo "nxsetup - Setup the FreeNX server."
-		echo "Syntax: nxsetup --help"
-		echo "        nxsetup --test [--ignore-errors]"
-		echo "        nxsetup --install [--setup-nomachine-key] [--uid <nummber>] [--clean [--purge]]"
-		echo "        nxsetup --uninstall [--purge]"
-		echo
-		echo "  --help                 Display this help message."
-		echo "  --test                 Test the configuration and connection to localhost NX Server."
-		echo "  --install              Install necessary files and add the special user \"nx\"."
-		echo "  --ignore-errors        Check for false configuration, but don't complain."
-		echo "  --setup-nomachine-key  Allow login with the key shipped with the NoMachine"
-		echo "                         client. This is fairly secure, and it simplifies the "
-		echo "                         configuration of clients. (Using a custom key pair."
-		echo "                         increases security even more, but complicates the"
-		echo "                         configuration of clients.)"
-		echo "                         Use this option at your own risk."
-		echo "  --ssh2                 Create additionally commercial pubkey-support; beware:"
-		echo "                         own _commercial_ ssh2-key is not supported!"
-		echo "  --uid <number>         Give the uid <number> to the user \"nx\"."
-		echo "  --gid <number>         Give the gid <number> to the user \"nx\"."
-		[ -n "$LOCAL_USER_OPTION" ] && \
-		echo "  --localuser            The special user \"nx\" will be created locally using"
-		echo "                         \"luseradd\", for use in NIS and NISplus environments."
-		echo "  --clean                Perform an uninstallation prior to installation."
-		echo "  --uninstall            Remove log and session files, as well as the special"
-		echo "                         user \"nx\"."
-		echo "  --purge                Remove extra configuration files and ssh keys when"
-		echo "                         performing a \"--uninstall\"."
-		echo "                         Note that node.conf will always be saved."
-		echo "  --auto                 Perform automatic installation without testing or asking."
-		exit 0
-	fi
-	#Undocumented
-	#
-	#    --dont-build-known-hosts		For system without /etc/ssh/ssh_host_key.rsa.pub and anyway
-	#					expect should handle nx-users known-hosts keys so why borther
-	#					in nxsetup?
-
-	if [ "$INSTALL" = "yes" -a "$AUTOMATIC" = "no" -a "$SETUP_NOMACHINE_KEY" = "no" ]
-	then
-		echo "------> It is recommended that you use the NoMachine key for"
-		echo "        easier setup. If you answer \"y\", FreeNX creates a custom"
-		echo "        KeyPair and expects you to setup your clients manually. "
-		echo "        \"N\" is default and uses the NoMachine key for installation."
-		echo ""
-		echo -n " Do you want to use your own custom KeyPair? [y/N] "
-		read -n 1 CHOICE
-		[ "$CHOICE" = "y" ] || SETUP_NOMACHINE_KEY="yes"
-	fi
-}
-
-parse_cmdline "$@"
-
-# Read the config file
-. $(PATH=$(cd $(dirname $0) && pwd):$PATH which nxloadconfig) --
-
-run_nscd()
-{
-	if [ -f /var/run/nscd/nscd.pid ]
-	then
-		nscd "$@" 2>/dev/null || true
-	fi
-}
-
-nx_user_exists()
-{
-	if [ "$SETUP_LOCAL_USER" = "yes" ]
-	then
-		egrep "^nx:" /etc/passwd >/dev/null
-	else
-		getent passwd nx >/dev/null
-	fi
-}	
-nx_group_exists()
-{
-	# useradd/adduser need a valid group to add the user to
-	if [ "$SETUP_LOCAL_USER" = "yes" ]
-	then
-		egrep "^nx:" /etc/group >/dev/null
-	else
-		getent group nx >/dev/null
-	fi
-}	
-
-# Tries to add a system user
-useradd_nx()
-{
-	# In any case create the basedir of the HOME directory before, 
-	# because useradd will fail to make more than one directory
-	mkdir -p $(dirname "$NX_HOME_DIR")
-
-	# Is it a debian?
-	if [ -f /etc/debian_version -a -z "$SETUP_UID" ]
-	then
-		USERADD_OPTIONS="--ingroup nx --system --home $NX_HOME_DIR --shell $PATH_BIN/nxserver"
-		[ -n "$SETUP_GID" ] && GROUPADD_OPTIONS="--gid $SETUP_GID"
-
-		# adduser needs a valid group to add the user to
-		! nx_group_exists && addgroup --system --quiet $GROUPADD_OPTIONS nx
-		[ -f /etc/nscd.conf ] && { run_nscd --invalidate group; }
-
-		adduser $USERADD_OPTIONS nx
-		[ -f /etc/nscd.conf ] && { run_nscd --invalidate passwd; }
-		
-	# no, its a "normal" useradd
-	else
-		USERADD_OPTIONS="-g nx -d $NX_HOME_DIR -s $PATH_BIN/nxserver"
-		[ -n "$SETUP_GID" ] && GROUPADD_OPTIONS="-g $SETUP_GID"
-
-		# uid specified?
-		if [ -n "$SETUP_UID" ]
-		then
-			USERADD_OPTIONS="-u $SETUP_UID $USERADD_OPTIONS"
-		
-		# Is it a SuSE?
-		elif [ -f /etc/SuSE-release ]
-		then
-			USERADD_OPTIONS="-r $USERADD_OPTIONS"
-		fi
-		
-		if [ "$SETUP_LOCAL_USER" = "yes" ]
-		then
-			! nx_group_exists && lgroupadd $GROUPADD_OPTIONS nx 
-			[ -f /etc/nscd.conf ] && { run_nscd --invalidate group; }
-
-			luseradd $USERADD_OPTIONS nx
-			[ -f /etc/nscd.conf ] && { run_nscd --invalidate passwd; }
-		else
-			! nx_group_exists && groupadd $GROUPADD_OPTIONS nx
-			[ -f /etc/nscd.conf ] && { run_nscd --invalidate group; }
-
-			useradd $USERADD_OPTIONS nx
-			[ -f /etc/nscd.conf ] && { run_nscd --invalidate passwd; }
-		fi
-
-		
-	fi
-
-	# the nx user account might be locked, so unlock it.
-	passwd -u nx
-}
-
-install_nx()
-{
-	set -e
-	
-	if [ "$(pidof sshd 2>/dev/null)" = "" ]
-	then 
-		echo -n "Starting ssh service ..."
-		# Generate Host keys if they are not available, yet
-		[ -e /etc/ssh/ssh_host_rsa_key ] || $COMMAND_SSH_KEYGEN -q -t rsa -f /etc/ssh/ssh_host_rsa_key -C '' -N ''
-		[ -e /etc/ssh/ssh_host_dsa_key ] || $COMMAND_SSH_KEYGEN -q -t dsa -f /etc/ssh/ssh_host_dsa_key -C '' -N ''
-		[ -x /etc/init.d/sshd ] && /etc/init.d/sshd start
-		[ -x /etc/init.d/ssh ] && /etc/init.d/ssh start
-		echo "done"
-	fi
-	
-	echo -n "Setting up $NX_ETC_DIR ..."
-	mkdir -p $NX_ETC_DIR
-	touch $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
-	chmod 600 $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
-	echo "done"
-	
-	if [ ! -f $NX_ETC_DIR/users.id_dsa ]
-	then
-		$COMMAND_SSH_KEYGEN -f $NX_ETC_DIR/users.id_dsa -t dsa -N ""
-	fi
-	
-	echo -n "Setting up $NX_SESS_DIR ..."
-	mkdir -p $NX_SESS_DIR/closed $NX_SESS_DIR/running $NX_SESS_DIR/failed
-	chmod 700 $NX_SESS_DIR/*
-	echo "done"
-	
-	echo -n "Setting up $NX_LOGFILE ..."
-	mkdir -p $(dirname "$NX_LOGFILE")
-	touch "$NX_LOGFILE"
-	chmod 600 "$NX_LOGFILE"
-	echo "done"
-	
-	if ! nx_user_exists
-	then
-		echo -n "Setting up special user \"nx\" ..."
-		useradd_nx
-		echo "done"
-	fi
-	
-	if [ "$ENABLE_USESSION" = "1" ]
-	then
-		echo -n "Adding user \"nx\" to group \"utmp\" ..."
-		usermod -G utmp nx
-		echo "done"
-	fi
-	
-	if [ "$ENABLE_NOMACHINE_FORWARD_PORT" = "1" -a -x "$NOMACHINE_SERVER" ]
-	then
-		echo -n "Setting up NoMachine forwarding ..."
-		usermod -s "$PATH_BIN/nxserver" -d "$NOMACHINE_NX_HOME_DIR" nx
-		echo "done"
-	fi
-	
-	echo -n "Setting up known_hosts and $SSH_AUTHORIZED_KEYS ..."
-	
-	SETUP_NX_KEY="no"
-	
-	mkdir -p $NX_HOME_DIR/.ssh
-	chmod 700 $NX_HOME_DIR/ $NX_HOME_DIR/.ssh
-	
-	if [ ! -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS -o "$SETUP_NOMACHINE_KEY" = "yes" ]
-	then
-		SETUP_NX_KEY="yes"
-		if [ "$SETUP_NOMACHINE_KEY" = "yes" ]
-		then
-			cat << EOF >$NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS
-no-port-forwarding,no-agent-forwarding,command="$PATH_BIN/nxserver" ssh-dss AAAAB3NzaC1kc3MAAACBAJe/0DNBePG9dYLWq7cJ0SqyRf1iiZN/IbzrmBvgPTZnBa5FT/0Lcj39sRYt1paAlhchwUmwwIiSZaON5JnJOZ6jKkjWIuJ9MdTGfdvtY1aLwDMpxUVoGwEaKWOyin02IPWYSkDQb6cceuG9NfPulS9iuytdx0zIzqvGqfvudtufAAAAFQCwosRXR2QA8OSgFWSO6+kGrRJKiwAAAIEAjgvVNAYWSrnFD+cghyJbyx60AAjKtxZ0r/Pn9k94Qt2rvQoMnGgt/zU0v/y4hzg+g3JNEmO1PdHh/wDPVOxlZ6Hb5F4IQnENaAZ9uTZiFGqhBO1c8Wwjiq/MFZy3jZaidarLJvVs8EeT4mZcWxwm7nIVD4lRU2wQ2lj4aTPcepMAAACANlgcCuA4wrC+3Cic9CFkqiwO/Rn1vk8dvGuEQqFJ6f6LVfPfRTfaQU7TGVLk2CzY4dasrwxJ1f6FsT8DHTNGnxELPKRuLstGrFY/PR7KeafeFZDf+fJ3mbX5nxrld3wi5titTnX+8s4IKv29HJguPvOK/SI7cjzA+SqNfD7qEo8= root at nettuno
-EOF
-			chmod 600 $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS
-			cat << EOF >$NX_HOME_DIR/.ssh/client.id_dsa.key
------BEGIN DSA PRIVATE KEY-----
-MIIBuwIBAAKBgQCXv9AzQXjxvXWC1qu3CdEqskX9YomTfyG865gb4D02ZwWuRU/9
-C3I9/bEWLdaWgJYXIcFJsMCIkmWjjeSZyTmeoypI1iLifTHUxn3b7WNWi8AzKcVF
-aBsBGiljsop9NiD1mEpA0G+nHHrhvTXz7pUvYrsrXcdMyM6rxqn77nbbnwIVALCi
-xFdHZADw5KAVZI7r6QatEkqLAoGBAI4L1TQGFkq5xQ/nIIciW8setAAIyrcWdK/z
-5/ZPeELdq70KDJxoLf81NL/8uIc4PoNyTRJjtT3R4f8Az1TsZWeh2+ReCEJxDWgG
-fbk2YhRqoQTtXPFsI4qvzBWct42WonWqyyb1bPBHk+JmXFscJu5yFQ+JUVNsENpY
-+Gkz3HqTAoGANlgcCuA4wrC+3Cic9CFkqiwO/Rn1vk8dvGuEQqFJ6f6LVfPfRTfa
-QU7TGVLk2CzY4dasrwxJ1f6FsT8DHTNGnxELPKRuLstGrFY/PR7KeafeFZDf+fJ3
-mbX5nxrld3wi5titTnX+8s4IKv29HJguPvOK/SI7cjzA+SqNfD7qEo8CFDIm1xRf
-8xAPsSKs6yZ6j1FNklfu
------END DSA PRIVATE KEY-----
-EOF
-			chmod 600 $NX_HOME_DIR/.ssh/client.id_dsa.key
-		else
-			# generate a new key, backup the old and copy it to $SSH_AUTHORIZED_KEYS
-			$PATH_BIN/nxkeygen
-		fi
-	fi
-
-	# commercial ssh2-server uses other authentification-files
-	# as they are more or less static, I don't integrated these variable
-	# in node.conf, you have to change them here, if you like
-	SSH2_AUTHORIZATION="authorization"
-	SSH2_PUBKEY="nx_user.id.pub"
-	SSH2_HOME_DIR="$NX_HOME_DIR/.ssh2"
-	if [ ! -f "${SSH2_HOME_DIR}/$SSH2_PUBKEY" -a "$SETUP_SSH2_KEY" = "yes" -a "$SETUP_NOMACHINE_KEY" = "yes" ]
-	then
-		mkdir -p $SSH2_HOME_DIR
-		chmod 700 $SSH2_HOME_DIR
-		
-		cat >  ${SSH2_HOME_DIR}/$SSH2_PUBKEY <<EOF
----- BEGIN SSH2 PUBLIC KEY ----
-Comment: "1024-bit DSA, converted from OpenSSH by root at localhost"
-AAAAB3NzaC1kc3MAAACBAJe/0DNBePG9dYLWq7cJ0SqyRf1iiZN/IbzrmBvgPTZnBa5FT/
-0Lcj39sRYt1paAlhchwUmwwIiSZaON5JnJOZ6jKkjWIuJ9MdTGfdvtY1aLwDMpxUVoGwEa
-KWOyin02IPWYSkDQb6cceuG9NfPulS9iuytdx0zIzqvGqfvudtufAAAAFQCwosRXR2QA8O
-SgFWSO6+kGrRJKiwAAAIEAjgvVNAYWSrnFD+cghyJbyx60AAjKtxZ0r/Pn9k94Qt2rvQoM
-nGgt/zU0v/y4hzg+g3JNEmO1PdHh/wDPVOxlZ6Hb5F4IQnENaAZ9uTZiFGqhBO1c8Wwjiq
-/MFZy3jZaidarLJvVs8EeT4mZcWxwm7nIVD4lRU2wQ2lj4aTPcepMAAACANlgcCuA4wrC+
-3Cic9CFkqiwO/Rn1vk8dvGuEQqFJ6f6LVfPfRTfaQU7TGVLk2CzY4dasrwxJ1f6FsT8DHT
-NGnxELPKRuLstGrFY/PR7KeafeFZDf+fJ3mbX5nxrld3wi5titTnX+8s4IKv29HJguPvOK
-/SI7cjzA+SqNfD7qEo8=
----- END SSH2 PUBLIC KEY ----
-EOF
-		echo "Key $SSH2_PUBKEY" >> ${SSH2_HOME_DIR}/$SSH2_AUTHORIZATION
-		echo "Options no-port-forwarding,no-agent-forwarding,command=\"$PATH_BIN/nxserver\"" >> ${SSH2_HOME_DIR}/$SSH2_AUTHORIZATION
-		chmod 600 ${SSH2_HOME_DIR}/$SSH2_AUTHORIZATION ${SSH2_HOME_DIR}/$SSH2_PUBKEY
-	fi
-	
-	if [ ! -f $NX_HOME_DIR/.ssh/known_hosts -a "$BUILD_KNOWN_HOSTS" = "yes" ]
-	then
-		echo -n "127.0.0.1 " > $NX_HOME_DIR/.ssh/known_hosts
-		cat /etc/ssh/ssh_host_rsa_key.pub >> $NX_HOME_DIR/.ssh/known_hosts
-	fi
-	
-	echo "done"
-	
-	echo -n "Setting up permissions ..."
-	chown -R nx:root $NX_SESS_DIR
-	chown -R nx:root $NX_ETC_DIR
-	chown -R nx:root $NX_HOME_DIR
-	chown nx:root "$NX_LOGFILE"
-
-	echo "done"
-
-	if [ -d "$CUPS_BACKEND" ]
-	then
-		echo -n "Setting up cups nxipp backend ..."
-		cp -af "$CUPS_BACKEND/ipp" "$CUPS_IPP_BACKEND"
-		chmod 755 "$CUPS_IPP_BACKEND"
-		echo "done"
-	fi
-}
-
-test_nx()
-{
-	echo ""
-	echo "----> Testing your nxserver configuration ..."
-	[ "$IGNORE_ERRORS" = "yes" ] && NO_ERRORS="--ignore-errors"
-	. $(PATH=$(cd $(dirname $0) && pwd):$PATH which nxloadconfig) --check $NO_ERRORS
-	echo "<---- done"
-	echo ""
-	echo "----> Testing your nxserver connection ..."
-	
-	CONNECTION=""
-	while read -t 3 line
-	do
-		echo $line
-		
-		case "$line" in
-			*"HELLO NXSERVER - Version $NX_VERSION"*)
-				CONNECTION="yes"
-			;;
-			*"HELLO NXSERVER - Version"*)
-				echo "Warning: Version mismatch. Expected $NX_VERSION got: $line."
-				CONNECTION="yes"
-			;;
-			*"NX> 999 Bye"*)
-				break;
-			;;
-		esac
-
-	done < <(NODE_PUBLICKEY="$NX_HOME_DIR/.ssh/client.id_dsa.key" $PATH_BIN/nxnode-login test-nx nx "$SSHD_PORT" nxserver --check)
-
-	if [ -z "$CONNECTION" ]
-	then
-		echo "Fatal error: Could not connect to NX Server."
-		echo 
-		echo "Please check your ssh setup:"
-		echo ""
-		echo "The following are _examples_ of what you might need to check."
-		echo ""
-		echo "	- Make sure \"nx\" is one of the AllowUsers in sshd_config."
-		echo "    (or that the line is outcommented/not there)"
-		echo "	- Make sure \"nx\" is one of the AllowGroups in sshd_config."
-		echo "    (or that the line is outcommented/not there)"
-		echo "	- Make sure your sshd allows public key authentication."
-		echo "	- Make sure your sshd is really running on port $SSHD_PORT."
-		echo "	- Make sure your sshd_config AuthorizedKeysFile in sshd_config is set to $SSH_AUTHORIZED_KEYS."
-		echo "    (this should be a filename not a pathname+filename)"
-		echo "  - Make sure you allow ssh on localhost, this could come from some"
-		echo "    restriction of:"
-		echo "      -the tcp wrapper. Then add in /etc/hosts.allow: ALL:localhost"
-		echo "      -the iptables. add to it:"
-		echo "         $ iptables -A INPUT  -i lo -j ACCEPT"
-		echo "         $ iptables -A OUTPUT -o lo -j ACCEPT"
-		exit 1
-	fi
-	echo "<--- done"
-	echo ""
-}
-
-uninstall_nx() 
-{
-	if nx_user_exists
-	then
-		echo -n "Removing special user \"nx\" ..."
-		
-		if [ "$SETUP_LOCAL_USER" = "yes" ]
-		then
-			luserdel nx
-		else
-			userdel nx
-		fi
-			
-		echo "done"
-	fi
-	
-	if [ -e "$NX_SESS_DIR" ]
-	then
-		echo -n "Removing session database ..."
-		rm -f -r $NX_SESS_DIR/closed $NX_SESS_DIR/running $NX_SESS_DIR/failed 2>/dev/null
-		rmdir -p $NX_SESS_DIR 2>/dev/null
-		echo "done"
-	fi
-	
-	if [ -e "$NX_LOGFILE" ] 
-	then
-		echo -n "Removing logfile ..."
-		rm -f "$NX_LOGFILE" 2>/dev/null
-		rmdir -p $(dirname "$NX_LOGFILE") 2>/dev/null
-		echo "done"
-	fi
-	
-	if [ "$PURGE" = "yes" -a -e "$NX_HOME_DIR" ]
-	then
-		echo -n "Removing home directory of special user \"nx\" ..."
-		rm -f -r "$NX_HOME_DIR" 2>/dev/null
-		rmdir -p $(dirname "$NX_HOME_DIR") 2>/dev/null
-		echo "done"
-	fi
-	
-	if [ "$PURGE" = "yes" -a -e "$NX_ETC_DIR" ]
-	then
-		echo -n "Removing configuration files ..."
-		rm -f "$NX_ETC_DIR/passwords" "$NX_ETC_DIR/passwords.orig" "$NX_ETC_DIR/users.id_dsa" "$NX_ETC_DIR/users.id_dsa.pub" 2>/dev/null
-		for i in `ls $NX_ETC_DIR/*.node.conf 2>/dev/null` ;
-		do
-			rm -f "$i" 2>/dev/null;
-		done
-		echo "done"
-	fi
-}
-
-if [ "$TEST" = "yes" ]
-then
-	test_nx
-	exit 0
-fi
-
-if [ "$INSTALL" = "yes" ]
-then
-	#Perform cleanup?
-	[ "$CLEAN" = "yes" ] && uninstall_nx
-	
-	[ -f /etc/nscd.conf ] && { run_nscd --invalidate passwd; run_nscd --invalidate group; }
-	install_nx
-
-	[ "$AUTOMATIC" = "no" ] && test_nx
-	
-	echo "Ok, nxserver is ready."
-	echo 
-	if [ "$ENABLE_SSH_AUTHENTICATION" = "1" -o "$ENABLE_SU_AUTHENTICATION" = "1" ]
-	then
-		echo "PAM authentication enabled:"
-		if [ "$ENABLE_USER_DB" = "1" ]
-		then
-			echo "  Users will be able to login with their normal passwords,"
-			echo "  but they have to be registered in the NX database to do so."
-			echo "  To add new users to the NX user database do:"
-			echo "    nxserver --adduser <username>"
-		else
-			echo "  All users will be able to login with their normal passwords."
-		fi
-		echo
-		if [ "$ENABLE_SSH_AUTHENTICATION" = "1" -a "$ENABLE_SU_AUTHENTICATION" = "1" ]
-		then
-			echo "  Both SSH and SU authentication is enabled."
-			echo "  This does work, but is redundant."
-			echo "  Please check if this is really what you intended."
-		elif [ "$ENABLE_SSH_AUTHENTICATION" = "1" ]
-		then
-			echo "  PAM authentication will be done through SSH."
-			echo "  Please ensure that SSHD on localhost accepts password authentication."
-		else
-			echo "  PAM authentication will be done through SU."
-			echo "  Please ensure that the user "nx" is a member of the wheel group."
-		fi
-	else
-		echo "PAM authentication disabled."
-		echo "  Only users in the NX user database will be able to log in."
-		echo
-		echo "  To add new users to the NX user database do:"
-		echo "    nxserver --adduser <username>"
-		echo "  Afterwards change the password with:"
-		echo "    nxserver --passwd <username>"
-	fi
-	echo
-	echo "  You can change this behaviour in the $NX_ETC_DIR/node.conf file."
-	
-	if [ "$SETUP_NOMACHINE_KEY" = "no" -a "$SETUP_NX_KEY" = "yes" ]
-	then
-		echo
-		echo "Warning: Clients will not be able to login to this server with the standard key."
-		echo "         Please replace /usr/NX/share/client.id_dsa.key on all clients you want"
-		echo "         to use with $NX_HOME_DIR/.ssh/client.id_dsa.key"
-		echo "         and protect it accordingly."
-		echo ""
-		echo "         Since 1.5.0 you need to import the correct key via the GUI."
-		echo
-		echo "         If you really want to use the NoMachine key please remove"
-		echo "         '$NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS'"
-		echo "         and then run this script with the --setup-nomachine-key parameter."
-	fi
-	
-	echo "Have Fun!"
-elif [ "$UNINSTALL" = "yes" ]
-then
-	uninstall_nx
-	
-	echo "Ok, nxserver is uninstalled"
-	echo 
-	if [ "$PURGE" = "yes" ]
-	then
-		echo "To complete the uninstallation process, remove the FreeNX scripts in $PATH_BIN"
-		echo "and the $NX_ETC_DIR/node.conf configuration file."
-	else
-		echo "To complete the uninstallation process, remove the FreeNX scripts in $PATH_BIN"
-		echo
-		echo "Configuration files and ssh keys are saved in case you would like to reinstall"
-		echo "freenx at a later time. To remove them, please run 'nxsetup --uninstall --purge'"
-	fi
-fi

Deleted: trunk/freenx-server/trunk/nxviewer_helper
===================================================================
--- trunk/freenx-server/trunk/nxviewer_helper	2008-03-10 22:59:38 UTC (rev 511)
+++ trunk/freenx-server/trunk/nxviewer_helper	2008-03-10 23:01:03 UTC (rev 512)
@@ -1,39 +0,0 @@
-#!/bin/sh
-#
-# nxviewer_helper - Small helper for external vncviewer program as needed by NX 3.0.0 backend.
-#
-# Copyright (c) 2007 by Fabian Franz <freenx at fabian-franz.de>
-#
-# License: GPL, v2
-#
-# SVN: $Id $
-#
-
-[ -z "$COMMAND_VNCVIEWER" ] && COMMAND_VNCVIEWER="vncviewer"
-[ -z "$COMMAND_VNCPASSWD" ] && COMMAND_VNCPASSWD="$PATH_BIN/nxpasswd"
-[ -z "$COMMAND_X11VNC" ] && COMMAND_X11VNC="x11vnc"
-
-mkdir -p "$NXSESSION_DIRECTORY/scripts/"
-echo "$agent_password" | $COMMAND_VNCPASSWD "$NXSESSION_DIRECTORY/scripts/.passwd" doit
-
-# Start x11vnc
-if [ -n "$mirrordisplay" ]
-then
-	(
-		unset XAUTHORITY
-		# Note: No "-accept popup" as its the same user and with that password
-		#       he could do already more than -accept popup would allow.
-		DISPLAY="$mirrorhost:$mirrordisplay.0" $COMMAND_X11VNC -timeout 120 -once -rfbauth "$NXSESSION_DIRECTORY/scripts/.passwd" >"$NXSESSION_DIRECTORY/scripts/.vnc_port" &
-	)
-	sleep 1
-	agent_port=$(cat "$NXSESSION_DIRECTORY/scripts/.vnc_port" | egrep "^PORT=" | cut -d'=' -f 2)
-	[ -z "agent_port" ] && agent_port="0"
-	# note the :: is not a mistake, but rather a hint for nxviewer to use this as a port and not
-	# interpret it as a display.
-	agent_server="127.0.0.1::$agent_port"
-	rm -f "$NXSESSION_DIRECTORY/scripts/.vnc_port"
-fi
-
-# Start the vncviewer
-
-exec $COMMAND_VNCVIEWER -passwd "$NXSESSION_DIRECTORY/scripts/.passwd" -fullscreen $AGENT_EXTRA_OPTIONS_RFB "$agent_server" 



From fabianx at mail.berlios.de  Fri Mar 14 18:56:04 2008
From: fabianx at mail.berlios.de (fabianx at BerliOS)
Date: Fri, 14 Mar 2008 17:56:04 -0000
Subject: [Freenx-cvs] r528 - in trunk/freenx-server: . nxviewer-passwd
	nxviewer-passwd/include nxviewer-passwd/libvncauth
	nxviewer-passwd/nxpasswd
Message-ID: <200803141754.m2EHsL5V009435@sheep.berlios.de>

Author: fabianx
Date: 2008-03-14 18:54:12 +0100 (Fri, 14 Mar 2008)
New Revision: 528

Added:
   trunk/freenx-server/nxviewer-passwd/
   trunk/freenx-server/nxviewer-passwd/COPYING
   trunk/freenx-server/nxviewer-passwd/Imakefile
   trunk/freenx-server/nxviewer-passwd/README
   trunk/freenx-server/nxviewer-passwd/WhatsNew.TIGHTVNC.original
   trunk/freenx-server/nxviewer-passwd/include/
   trunk/freenx-server/nxviewer-passwd/include/rfbproto.h
   trunk/freenx-server/nxviewer-passwd/include/vncauth.h
   trunk/freenx-server/nxviewer-passwd/libvncauth/
   trunk/freenx-server/nxviewer-passwd/libvncauth/Imakefile
   trunk/freenx-server/nxviewer-passwd/libvncauth/d3des.c
   trunk/freenx-server/nxviewer-passwd/libvncauth/d3des.h
   trunk/freenx-server/nxviewer-passwd/libvncauth/vncauth.c
   trunk/freenx-server/nxviewer-passwd/nxpasswd/
   trunk/freenx-server/nxviewer-passwd/nxpasswd/Imakefile
   trunk/freenx-server/nxviewer-passwd/nxpasswd/nxpasswd.man
   trunk/freenx-server/nxviewer-passwd/nxpasswd/vncpasswd.c
   trunk/freenx-server/nxviewer-passwd/nxpasswd/vncpasswd.c.NX.original
   trunk/freenx-server/nxviewer-passwd/nxpasswd/vncpasswd.c.TIGHTVNC.original
Modified:
   trunk/freenx-server/ChangeLog
Log:
* Added nxviewer-passwd to distribution. It is a fork of the
  tightvnc 1.2.9 vncpasswd part, which is necessary for FreeNX to work
  with standard vncviewer.
(fabianx at bat.berlios.de


Modified: trunk/freenx-server/ChangeLog
===================================================================
--- trunk/freenx-server/ChangeLog	2008-03-14 17:45:36 UTC (rev 527)
+++ trunk/freenx-server/ChangeLog	2008-03-14 17:54:12 UTC (rev 528)
@@ -89,6 +89,10 @@
 	  (fabianx at bat.berlios.de)
 	* Updated documentation in INSTALL file.
 	  (fabianx at bat.berlios.de)
+	* Added nxviewer-passwd to distribution. It is a fork of the
+	  tightvnc vncpasswd part, which is necessary for FreeNX to work
+	  with standard vncviewer.
+	  (fabianx at bat.berlios.de)
 
 14.10.2007 FreeNX 0.7.1 "Hip Hop Edition"
 	* Fixed the issue that makes fonts look tiny and unreadable by default 

Added: trunk/freenx-server/nxviewer-passwd/COPYING
===================================================================
--- trunk/freenx-server/nxviewer-passwd/COPYING	2008-03-14 17:45:36 UTC (rev 527)
+++ trunk/freenx-server/nxviewer-passwd/COPYING	2008-03-14 17:54:12 UTC (rev 528)
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+	  Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+	 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	Appendix: How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) 19yy  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
+    USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) 19yy name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.

Added: trunk/freenx-server/nxviewer-passwd/Imakefile
===================================================================
--- trunk/freenx-server/nxviewer-passwd/Imakefile	2008-03-14 17:45:36 UTC (rev 527)
+++ trunk/freenx-server/nxviewer-passwd/Imakefile	2008-03-14 17:54:12 UTC (rev 528)
@@ -0,0 +1,35 @@
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001,2006 NoMachine, http://www.nomachine.com.           */
+/*                                                                        */
+/* NXVIEWER, NX protocol compression and NX extensions to this software   */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check http://www.nomachine.com/licensing.html for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+#define IHaveSubdirs
+#define PassCDebugFlags
+
+SUBDIRS = libvncauth nxpasswd
+
+World:
+	make Makefiles
+	make depend
+	make all
+	@echo ""
+	@echo Built $(SUBDIRS).
+	@echo ""
+
+libs:
+	@echo 'No libraries included.'
+
+MakeSubdirs($(SUBDIRS))
+DependSubdirs($(SUBDIRS))

Added: trunk/freenx-server/nxviewer-passwd/README
===================================================================
--- trunk/freenx-server/nxviewer-passwd/README	2008-03-14 17:45:36 UTC (rev 527)
+++ trunk/freenx-server/nxviewer-passwd/README	2008-03-14 17:54:12 UTC (rev 528)
@@ -0,0 +1,8 @@
+This is just a fork of the vncpasswd part of TightVNC. This builds nxpasswd, which is needed for FreeNX.
+
+To build:
+
+xmkmf
+make World
+
+- Fabian

Added: trunk/freenx-server/nxviewer-passwd/WhatsNew.TIGHTVNC.original
===================================================================
--- trunk/freenx-server/nxviewer-passwd/WhatsNew.TIGHTVNC.original	2008-03-14 17:45:36 UTC (rev 527)
+++ trunk/freenx-server/nxviewer-passwd/WhatsNew.TIGHTVNC.original	2008-03-14 17:54:12 UTC (rev 528)
@@ -0,0 +1,566 @@
++--------------------------------------------------------------------+
+|   This is a brief summary of changes introduced in each TightVNC   |
+|   release. For more details, please see ChangeLog files included   |
+|   in TightVNC source and binary archives.                          |
++--------------------------------------------------------------------+
+
+* TightVNC 1.2.9
+
+  - Win32 version: Major security-related bug in the server has been
+    fixed -- handling of the "QueryAllowNoPass" option was seriously
+    broken. Together with fixing this bug, the whole authentication
+    logic in the server code has been redesigned.
+
+  - Win32 version: Now the HKEY_CURRENT_USER registry hive is being
+    closed properly on restoring display settings, on disconnect. This
+    change should solve the problem with unloading the registry on
+    logout, when WinVNC is running as a service.
+
+  - Win32 version: Problems with "QuerySetting" and "QueryTimeout"
+    options have been fixed -- the settings could be copied from user
+    configuration to default settings without user's intention.
+
+  - Win32 version: A long-standing bug has been fixed -- the logic to
+    handle retries after authentication failures was flawed, and used
+    to delete the same object twice under certain conditions.
+
+  - Win32 version: Now it's possible to specify port numbers with the
+    winvnc -connect option, using the "host::port" format. Also,
+    providing a -connect option without arguments now brings up the
+    "Add New Client" dialog.
+
+  - Unix version: New "Request refresh" button has been implemented in
+    the viewer's F8 popup menu.
+
+  - Unix version: Xvnc compilation fixes for HP-UX and MacOS X have
+    been applied, from Ki NETWORKS, Inc.
+
+  - Unix version: New vncpasswd -f command-line option has been
+    implemented. It allows providing passwords on stdin and writes
+    encrypted passwords to stdout. In addition, the password file name
+    "-" now denotes stdout. Finally, a buffer overflow has been fixed
+    in vncpasswd -- it could be caused by a long file name in the
+    command line.
+
+  - Unix version: A patch to fix input focus problems in the X11
+    viewer has been applied, from Greg Breland.
+
+  - Unix version: A patch fixing Xvnc crashes on Sparc has been
+    applied, from the RealVNC distribution.
+
+  - Unix version: A problem with incorrect port interpretation has
+    been fixed, in the vncviewer's -tunnel option handling. Thanks to
+    Clark Sessions.
+
+  - Java viewer: A modification from Bernd Krueger-Knauber has been
+    accepted, to pass through X keysyms for foreign currencies.
+
+  - Java viewer: The problem with initial keyboard focus not set to
+    the desktop on some JVMs has been fixed.
+
+  - Other minor improvements and bugfixes.
+
+----------------------------------------------------------------------
+
+* TightVNC 1.2.8
+
+  - Unix and Win32 versions: Support for a separate view-only password
+    has been implemented. Now the servers support two passwords -- one
+    to allow full control, another to restrict remote keyboard and
+    mouse input.
+
+  - Win32 version: The password reset problem has been solved. In
+    versions starting from 1.2.4, the password could get changed in
+    the registry on opening Properties dialog and just hitting the OK
+    button.
+
+  - Win32 version: New "-reload" command-line option has been
+    implemented in Win32 server. It forces the running instance to
+    reload the registry settings.
+
+  - Win32 version: "RemoveWallpaper" and "LockSetting" options have
+    been made configurable in the Properties dialog; the code has been
+    ported from RealVNC 3.3.6.
+
+  - Win32 version: Support for "AllowEditClients" registry setting has
+    been ported from RealVNC 3.3.6.
+
+  - Unix version: New "-x11cursor" option has been implemented in
+    vncviewer; a patch from Peter Astrand. This option allows using a
+    real X11 cursor with X11-style cursor shape updates, disables the
+    dot cursor, and disables cursor position updates in non-fullscreen
+    mode.
+
+  - Unix version: New "RunCommand" command to customize the X11
+    vncviewer popup menu has been implemented; a patch from Peter
+    Astrand.
+
+  - Unix version: Several patches from Debian Linux have been applied.
+    This should fix a number of bugs and improve building on some
+    platforms supported by Debian Linux.
+
+  - Unix version: A problem with Xvnc eating all CPU time after xfs
+    restarts has been fixed; a patch from Martin Koegler.
+
+  - Other minor improvements and bugfixes.
+
+----------------------------------------------------------------------
+
+* TightVNC 1.2.7
+
+  - Unix and Win32 versions, Java viewer: The most significant problem
+    with local cursor handling has been solved -- now clients can see
+    remote cursor movements performed on the server or by another
+    client. New PointerPos encoding and cursor shape updates both
+    minimize bandwidth requirements and greatly improve responsiveness
+    of the mouse pointer, while still allow to track correct pointer
+    position in all situations.
+
+  - Unix and Win32 versions: In all the places where display numbers
+    had to be used, now it's easy to use port numbers as well. The
+    viewers now allow to use new "hostname::port" syntax, in addition
+    to the traditional "hostname:display" format. The same new syntax
+    can be used in the "Add new client" dialog of Win32 server. In the
+    server, now it's equally easy to set display and port numbers. 
+    Besides that, HTTP and RFB port numbers can be set individually.
+
+  - Unix and Win32 versions: In servers, decreased JPEG quality
+    factors for low quality levels. This improves bandwidth usage
+    while the image quality remains satisfactory in most cases. In
+    clients, JPEG compression is now enabled by default, because
+    usually it's a reasonable choice. To prevent viewers from
+    requesting JPEG compression, new -nojpeg option can be used.
+
+  - Unix and Win32 versions: Improved installer under Windows, better
+    RPMs for Linux.
+
+  - Win32 version: Major enhancements in layout and functionality of
+    the dialog boxes.
+
+  - Win32 version: New keyboard handling code has been ported from
+    RealVNC 3.3.6. This should solve all the issues with arrow keys
+    acting as numbers in console windows, and shift+arrows not working
+    under Win2k.
+
+  - Win32 version: Adopted WinVNC -reinstall option from RealVNC
+    3.3.5, together with a number of other changes in different
+    places. The viewer now accepts a port number after the -listen
+    command-line option, an improvement from RealVNC 3.3.6.
+
+  - Win32 version: Eliminated high CPU usage on the server before
+    sending cursor shape updates.
+
+  - Unix version: Bugfix for Xvnc's -localhost and -interface options
+    that were broken on many systems, thanks to Luke Mewburn for the
+    bugfix. Xvnc -version command-line option is now supported.
+
+  - Tight encoding is now documented in rfbproto.h files within source
+    archives.
+
+  - Java viewer: Implemented new buttons "Login again" and "Close
+    window" near the disconnect or error messages in the applet mode,
+    and introduced new "Offer Relogin" parameter to control this
+    improvement. Thanks to Peter Astrand for the initial version of
+    the "Login again" patch.
+
+  - Java viewer: Support for connections via HTTP proxies using HTTP
+    CONNECT method. This will not work in the applet mode, due to Java
+    security restrictions.
+
+  - Java viewer: Extra .vnc files have been removed, having just
+    index.vnc should be enough. Also, an example HTML page has been
+    prepared, to simplify installation under a standalone Web server.
+
+  - Java viewer: Added a MANIFEST to the JAR archive, to allow easy
+    execution of the JAR file, using java -jar command-line option.
+
+  - Other minor improvements and bugfixes.
+
+----------------------------------------------------------------------
+
+* TightVNC 1.2.6
+
+  - Win32 version: In this version, when WinVNC binds to a local TCP
+    port, it does not try to check several times if the port is in
+    use. It just re-uses the port if the display number is not set to
+    "Auto". One visible effect of this change is that the delay
+    between starting up and showing the icon is greatly reduced.
+
+  - Unix version: Fixed the bug which caused the vncserver script to
+    fail when the XAUTHORITY environment variable was not set.
+
+  - Unix version: Fixed the bug which prevented the vncpasswd utility
+    from setting correct permissions on the passwd file.
+
+  - Unix version: Fixed a repeated challenge replay attack
+    vulnerability, bugtraq id 5296.
+
+  - Unix version: Added files to simplify building of Linux RPMs,
+    thanks to Peter Astrand.
+
+  - Unix version: Improved scrolling in the full-screen mode, modified
+    patch from Ville Herva.
+
+  - Minor cleanups.
+
+----------------------------------------------------------------------
+
+* TightVNC 1.2.5
+
+  - Win32 version: Fixed a problem in the I/O subsystem that was
+    introduced in TightVNC 1.2.2 and was causing major slowdown in
+    communication with clients.
+
+  - Win32 version: Enabled remote upgrade in the installation script. 
+    Also, the installer will install a copy of the TightVNC Web site,
+    and will create shortcuts to most important documentation pages.
+
+  - Win32 version: Implemented new feature to specify applet
+    parameters in URL requests being sent to the built-in HTTP server. 
+    Added support for new "EnableURLParams" registry setting which can
+    be used to enable this feature.
+
+  - Win32 version: Added support for the NewFBSize pseudo-encoding
+    allowing to change framebuffer geometry on the fly on server's
+    request.
+
+  - Win32 version: Included "solution" and "project" files for MS
+    Visual Studio 7, from Andrew van der Stock, applied a set of minor
+    fixes to suppress compilation warnings under MS Visual Studio 7.
+
+  - Win32 version: The viewer now tries to preserve the size and
+    position of the desktop window after applying new connection
+    options.
+
+  - Unix version: Implemented new feature to specify applet parameters
+    in URL requests being sent to the built-in HTTP server. Added
+    support for new $PARAMS variable in .vnc HTML templates.
+
+  - Unix version: Added the possibility to keep users' vnc directories
+    under /tmp, as suggested by Ivan Popov. This mode can be enabled
+    by editing the $vncUserDir variable in the vncserver script. Also,
+    new -t option has been implemented in the vncpasswd utility which
+    allows to change VNC password files under /tmp.
+
+  - Unix version: Applied Xvnc -viewonly patch from Ehud Karni.
+
+  - Unix version: Applied Linux/PowerPC Xvnc fix from Peter A. Castro.
+
+  - Unix version: Bug fixed: Xvnc failed to reset compression level
+    and JPEG image quality on reading lists of encodings supported by
+    clients.
+
+  - Unix version: Made the viewer handle XCursor encoding operating on
+    the framebuffer instead of setting new cursors directly in X.
+
+  - Unix version: Applied a number of porting fixes from Ki Networks,
+    Inc.
+
+  - Java viewer: Added new feature allowing to save RFB sessions in
+    FBS files compatible with rfbproxy. This feature works only if JVM
+    security manager allows access to the local filesystem, which is
+    usually true only when the viewer is used as a standalone
+    application or if the viewer applet is cryptographically signed.
+    New "Record" button will appear in the button panel if this
+    feature is enabled.
+
+  - Java viewer: Added new "ENCPASSWORD" parameter, modified patch
+    from Peter Astrand.
+
+  - Java viewer: Applied patch from Peter Astrand to fix problems with
+    Swedish keys and broken JVMs.
+
+  - Other minor fixes and cleanups.
+
+----------------------------------------------------------------------
+
+* TightVNC 1.2.4
+
+  - Win32 version: WinVNC crashes on reporting zero statistics were
+    fixed. This should eliminate crashes when using x2vnc and win2vnc
+    client programs.
+
+  - Win32 version: a problem with listening viewer was fixed.
+    Initiating multiple non-shared connections could crash the viewer
+    application.
+
+  - Win32 version: real passwords are never placed into the password
+    text control in the WinVNC Properties dialog any more. This should
+    prevent grabbing plain-text passwords from that text control.
+
+  - Win32 version: logging on errors was improved to provide better
+    diagnosis for errors, especially for those causing the message
+    "Connection closed" right after authentication.
+
+  - Win32 version: handling of log files was improved. Now WinVNC
+    should be able to save backup copies of log files under
+    Win95/98/Me. Also, all log files are now written in MS-DOS/Windows
+    text format instead of the Unix one.
+
+  - Win32 version: a problem with reporting error messages in the
+    listening viewer was fixed.
+
+  - Win32 version: reporting incorrect statistics in the Tight encoder
+    was fixed.
+
+  - Win32 version: HTML pages and templates for the built-in HTTP
+    server were improved.
+
+  - Unix version: applied patch from Ki Networks, Inc. solving build
+    problems on a number of commercial Unix systems, and fixing a
+    number of minor bugs and typos.
+
+  - Unix version: added a possibility to denote standard input with
+    the "-" file name instead of a real password file name.
+
+  - Unix version: fixed a bug causing vncpasswd utility work
+    incorrectly when a file name argument was given in the command
+    line.
+
+  - Unix version: applied patch to solve keyboard focus problems in
+    the full-screen vncviewer, from Peter Astrand. The patch does not
+    seem to solve all the issues, but definitely makes things better.
+    New grabKeyboard resource was added to control full-screen mode
+    behavior.
+
+  - Java viewer: new "Show Offline Desktop" parameter was added to
+    make the desktop still visible even after the remote side has
+    closed connection.
+
+  - Java viewer: error messages were made much more meaningful.
+
+  - Java viewer: keyboard focus problems were fixed. This should
+    prevent opening new windows (e.g. Options or Clipboard) behind the
+    active authenticator or desktop window.
+
+  - Java viewer: now "R"/"r" keys can be used to request screen
+    updates in view-only mode.
+
+  - Java viewer: applied patch from Peter Astrand to fix problems with
+    Swedish keys and broken JVMs.
+
+  - Other minor fixes and cleanups.
+
+----------------------------------------------------------------------
+
+* TightVNC 1.2.3
+
+  - Unix and Win32 versions: zlib library was updated to the most
+    recent version (1.1.4) where a potential security issue was fixed.
+
+  - Unix and Win32 versions: fixed blocking I/O problems in built-in
+    HTTP servers. Older versions had to wait while one client finishes
+    his transaction, only then they served new client connections,
+    thus making easy denial-of-service attacks possible.
+
+  - Unix and Win32 versions: updated built-in Java viewer, see details
+    below.
+
+  - Win32 version: Added support for mouse wheel events. Wheel mouse
+    support is fully compatible and interoperable with Unix version
+    where this feature was available for a long time.
+
+  - Win32 version (WinVNC): The -connect command-line option now
+    accepts a display number after a hostname.
+
+  - Win32 version: Creating associations for .vnc files in the
+    installer.
+
+  - Java viewer was GREATLY improved: the code was converted to Java
+    1.1, painting techniques were re-designed completely (now the
+    viewer should work in MacOS), several new parameters were added,
+    all parameters were documented in the README file. Most important
+    new features include: support for 24-bit colors, JPEG support in
+    Tight encoding, RFB Bell message support, new "Refresh" button, a
+    possibility to operate in a separate scrollable window, dynamic
+    view-only mode. Many more changes were introduces, see the
+    ChangeLog for more information. Please note that new Java viewer
+    class names were changed, e.g. vncviewer.jar file has become
+    VncViewer.jar etc.
+
+  - Unix version: a number of changes in the vncserver script, e.g.
+    the default color depth is now 24, extra delay after Xvnc startup
+    removed, font path is now configurable in the beginning of the
+    script, and more.
+
+  - Unix version: zlib library was removed from the core X sources.
+    Instead, both vncviewer and Xvnc now can use either system zlib
+    and JPEG libraries, or ones packaged within TightVNC source
+    archive in the lib/ directory. Unix sources are distributed in two
+    versions: one with these libraries for those who don't have them
+    installed in the system, and another version without libraries,
+    copied directly from CVS, for those who do have zlib and/or JPEG
+    libraries installed. In the former case, build procedure would
+    include additional "make libs" step. System libraries will be
+    linked dynamically, libraries included in the source archive will
+    be linked in statically.
+
+  - Unix version now includes comprehensive manual pages for
+    vncviewer, vncserver, Xvnc, vncconnect and vncpasswd programs. The
+    vncinstall script in the source distribution now accepts one more
+    parameter allowing to specify where to install manual pages.
+
+  - Unix version (Xvnc): a number of patches from Red Hat Linux vnc
+    package were incorporated into the TightVNC codebase. This adds
+    support for more architectures including s390 and s390x, adds a
+    possibility to use tcp_wrappers for Xvnc access control.
+
+  - Unix version (Xvnc): several bugfixes, e.g. applied patch to fix
+    crash in the code dealing with font server; fixed word alignment
+    problem in raw encoder experienced by Sparc users.
+
+  - Unix version is no more distributed as patches to a standard VNC
+    release. This is because patches cannot handle changes in binary
+    files and handle file removals very inefficiently.
+
+  - Other minor fixes and cleanups.
+
+----------------------------------------------------------------------
+
+* TightVNC 1.2.2
+
+  - Win32 server: long-standing Win9x resource consumption problem has
+    been fixed. Now the server thread does not use blocking I/O, and
+    therefore is always ready to process messages from the VNCHooks
+    DLL.
+
+  - Win32 server: now built-in HTTP daemon may be enabled and disabled
+    interactively from the Advanced Preferences dialog (this setting
+    is saved in new "EnableHTTPDaemon" registry key).
+
+  - Win32 server: changes in layout and text of the Advanced
+    Preferences dialog.
+
+  - Xvnc: Minor bugfix which should prevent potential dereference of a
+    NULL pointer.
+
+  - Unix viewer: Now viewer window would be raised on beep (bell)
+    event, unless new -noraiseonbeep option is provided in the command
+    line or "raiseOnBeep" resource set to False.
+
+  - One more packaging option for the Unix source: ready to build
+    archive with Zlib and JPEG libraries inside.
+
+  - Other minor fixes and cleanups.
+
+----------------------------------------------------------------------
+
+* TightVNC 1.2.1
+
+  - Win32 server: added support for reverse connections on ports other
+    than 5500, modified patch from Steve Kann.
+
+  - Win32 viewer: added support for new command-line options:
+    -noshared and -encoding XXX.
+
+  - Bugfixes in Win32 viewer: changes in exception handling eliminate
+    Borland C++ compilation problems causing application crashes on
+    repetitive connections, notably in the listen mode. Also, now
+    warning exceptions causing disconnects are reported to user,
+    except for the case when a user has closed the viewer window.
+
+  - Better packaging in Win32 version: self-installing package is
+    available, vncviewer now shows correct icon image.
+
+  - Unix vncviewer: Default tunneling command template has been
+    changed, to allow tunneled connections to hosts where only
+    loopback VNC connections are enabled. New -via <GATEWAY>
+    command-line option provides enhanced tunneling functionality, now
+    one can make vncviewer tunnel connections to a VNC host via third
+    machine acting as a gateway.
+
+  - Java viewer: Addition of new parameters PASSWORD, "Show Controls",
+    and "View Only", modified patch from Steve Kann.
+
+----------------------------------------------------------------------
+
+* TightVNC 1.2.0
+
+  - Tight encoding is now configurable and can operate at different
+    compression levels where low compression levels are very fast in
+    terms of CPU usage. New "-compresslevel N" option implemented in
+    vncviewer to set compression levels for Tight encoding (1 - fast,
+    9 - best).
+
+  - Enhanced techniques to split large rectangles in Tight encoder;
+    now it tries to find large solid-color areas and send them in
+    separate rectangles.
+
+  - Lossy JPEG compression in Tight encoding has been implemented, new
+    "-quality N" vncviewer option should be used to enable this
+    feature (0 - low image quality and best compression, 9 - best
+    image quality). JPEG compression is used only for screen areas
+    that seem to be suitable for JPEG compression (although algorithms
+    to detect such areas are not perfect, of course).
+
+  - New "XCursor" and "RichCursor" encodings implemented. They are
+    used to transmit cursor shape updates from server to clients
+    ("local cursor" feature requested by many users). Mouse movement
+    no longer causes framebuffer updates to happen, vncviewer
+    processes mouse locally when this feature is active. New
+    -nocursorshape vncviewer option turns this feature off.
+
+  - A number of recent changes from both TridiaVNC and AT&T's releases
+    merged into the source, now the code is based on version 3.3.3r2
+    for Unix part, and on 3.3.3r9 for Win32.
+
+  - Unix vncviewer: When -tunnel option is specified in the command
+    line, special rules are now used to choose preferred encoding. Now
+    viewer does not think that server is running on the same machine
+    when tunneling is on and the preferred encoding is now "tight"
+    with default compression instead of raw.
+
+  - Xvnc: Rules to set default pixel formats have been changed: now
+    they are RGB565 instead of BGR556 for color depth 16, and RGB888
+    instead of BGR888 for depth 24. This makes Xvnc compatible with
+    Imlib renderer used in Gnome and also helps to avoid unnecessary
+    pixel format translations in many cases.
+
+  - Xvnc: X11 modifier mapped to META key is now Mod4 instead of Mod1.
+    New -compatiblekbd option implemented in Xvnc to force META and
+    ALT keys behave the same way as they do in the original AT&T's
+    version.
+
+  - A number of bugs fixed: viewer crashes after inflate() call, Xvnc
+    CoRRE encoding problems, Xvnc bit-order issues in XCursor and
+    RichCursor encodings, etc.
+
+  - Java viewer now supports Tight encoding and cursor shape updates.
+    Drawing techniques were changed, settings "Raw pixel drawing:
+    Fast/Reliable" and "CopyRect: Fast/Reliable" removed from the
+    Options panel since they do not make sense in new drawing model.
+
+  - Other new features, optimizations, fixes and cleanups, see
+    ChangeLog files.
+
+----------------------------------------------------------------------
+
+* VNC Tight Encoding 1.1
+
+  - New ``gradient'' filter implemented in servers (it can be disabled
+    in Xvnc with new -lazytight option). The filter preprocess
+    full-color screen areas prior to compression in order to achieve
+    better compression ratios (with the cost of slower compression).
+    Vncviewers of version 1.0 had support for this filter already, but
+    there was small bug causing image distortions in certain cases. So
+    it is recommended to upgrade both servers and viewers.
+
+  - Stupid bug fixed: extra unused color was included in palettes in
+    many cases; compression ratios used to be worse than they should
+    be.
+
+  - The algorithm used to split large rectangles into parts has been
+    changed. This change can increase compression ratios in many
+    situations.
+
+  - Byte-order issues in servers have been (hopefully) fixed.
+
+  - Performance tuning, code rewrites and cleanups in various places.
+
+----------------------------------------------------------------------
+
+* VNC Tight Encoding 1.0
+
+  - Initial release.
+
+----------------------------------------------------------------------

Added: trunk/freenx-server/nxviewer-passwd/include/rfbproto.h
===================================================================
--- trunk/freenx-server/nxviewer-passwd/include/rfbproto.h	2008-03-14 17:45:36 UTC (rev 527)
+++ trunk/freenx-server/nxviewer-passwd/include/rfbproto.h	2008-03-14 17:54:12 UTC (rev 528)
@@ -0,0 +1,907 @@
+/*
+ *  Copyright (C) 2000-2002 Constantin Kaplinsky.  All Rights Reserved.
+ *  Copyright (C) 2000 Tridia Corporation.  All Rights Reserved.
+ *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
+ *
+ *  This is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This software is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this software; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
+ *  USA.
+ */
+
+/*
+ * rfbproto.h - header file for the RFB protocol version 3.3
+ *
+ * Uses types CARD<n> for an n-bit unsigned integer, INT<n> for an n-bit signed
+ * integer (for n = 8, 16 and 32).
+ *
+ * All multiple byte integers are in big endian (network) order (most
+ * significant byte first).  Unless noted otherwise there is no special
+ * alignment of protocol structures.
+ *
+ *
+ * Once the initial handshaking is done, all messages start with a type byte,
+ * (usually) followed by message-specific data.  The order of definitions in
+ * this file is as follows:
+ *
+ *  (1) Structures used in several types of message.
+ *  (2) Structures used in the initial handshaking.
+ *  (3) Message types.
+ *  (4) Encoding types.
+ *  (5) For each message type, the form of the data following the type byte.
+ *      Sometimes this is defined by a single structure but the more complex
+ *      messages have to be explained by comments.
+ */
+
+
+/*****************************************************************************
+ *
+ * Structures used in several messages
+ *
+ *****************************************************************************/
+
+/*-----------------------------------------------------------------------------
+ * Structure used to specify a rectangle.  This structure is a multiple of 4
+ * bytes so that it can be interspersed with 32-bit pixel data without
+ * affecting alignment.
+ */
+
+typedef struct {
+    CARD16 x;
+    CARD16 y;
+    CARD16 w;
+    CARD16 h;
+} rfbRectangle;
+
+#define sz_rfbRectangle 8
+
+
+/*-----------------------------------------------------------------------------
+ * Structure used to specify pixel format.
+ */
+
+typedef struct {
+
+    CARD8 bitsPerPixel;		/* 8,16,32 only */
+
+    CARD8 depth;		/* 8 to 32 */
+
+    CARD8 bigEndian;		/* True if multi-byte pixels are interpreted
+				   as big endian, or if single-bit-per-pixel
+				   has most significant bit of the byte
+				   corresponding to first (leftmost) pixel. Of
+				   course this is meaningless for 8 bits/pix */
+
+    CARD8 trueColour;		/* If false then we need a "colour map" to
+				   convert pixels to RGB.  If true, xxxMax and
+				   xxxShift specify bits used for red, green
+				   and blue */
+
+    /* the following fields are only meaningful if trueColour is true */
+
+    CARD16 redMax;		/* maximum red value (= 2^n - 1 where n is the
+				   number of bits used for red). Note this
+				   value is always in big endian order. */
+
+    CARD16 greenMax;		/* similar for green */
+
+    CARD16 blueMax;		/* and blue */
+
+    CARD8 redShift;		/* number of shifts needed to get the red
+				   value in a pixel to the least significant
+				   bit. To find the red value from a given
+				   pixel, do the following:
+				   1) Swap pixel value according to bigEndian
+				      (e.g. if bigEndian is false and host byte
+				      order is big endian, then swap).
+				   2) Shift right by redShift.
+				   3) AND with redMax (in host byte order).
+				   4) You now have the red value between 0 and
+				      redMax. */
+
+    CARD8 greenShift;		/* similar for green */
+
+    CARD8 blueShift;		/* and blue */
+
+    CARD8 pad1;
+    CARD16 pad2;
+
+} rfbPixelFormat;
+
+#define sz_rfbPixelFormat 16
+
+
+
+/*****************************************************************************
+ *
+ * Initial handshaking messages
+ *
+ *****************************************************************************/
+
+/*-----------------------------------------------------------------------------
+ * Protocol Version
+ *
+ * The server always sends 12 bytes to start which identifies the latest RFB
+ * protocol version number which it supports.  These bytes are interpreted
+ * as a string of 12 ASCII characters in the format "RFB xxx.yyy\n" where
+ * xxx and yyy are the major and minor version numbers (for version 3.3
+ * this is "RFB 003.003\n").
+ *
+ * The client then replies with a similar 12-byte message giving the version
+ * number of the protocol which should actually be used (which may be different
+ * to that quoted by the server).
+ *
+ * It is intended that both clients and servers may provide some level of
+ * backwards compatibility by this mechanism.  Servers in particular should
+ * attempt to provide backwards compatibility, and even forwards compatibility
+ * to some extent.  For example if a client demands version 3.1 of the
+ * protocol, a 3.0 server can probably assume that by ignoring requests for
+ * encoding types it doesn't understand, everything will still work OK.  This
+ * will probably not be the case for changes in the major version number.
+ *
+ * The format string below can be used in sprintf or sscanf to generate or
+ * decode the version string respectively.
+ */
+
+#define rfbProtocolVersionFormat "RFB %03d.%03d\n"
+#define rfbProtocolMajorVersion 3
+#define rfbProtocolMinorVersion 3
+
+typedef char rfbProtocolVersionMsg[13];	/* allow extra byte for null */
+
+#define sz_rfbProtocolVersionMsg 12
+
+
+/*-----------------------------------------------------------------------------
+ * Authentication
+ *
+ * Once the protocol version has been decided, the server then sends a 32-bit
+ * word indicating whether any authentication is needed on the connection.
+ * The value of this word determines the authentication scheme in use.  For
+ * version 3.0 of the protocol this may have one of the following values:
+ */
+
+#define rfbConnFailed 0
+#define rfbNoAuth 1
+#define rfbVncAuth 2
+
+/*
+ * rfbConnFailed:	For some reason the connection failed (e.g. the server
+ *			cannot support the desired protocol version).  This is
+ *			followed by a string describing the reason (where a
+ *			string is specified as a 32-bit length followed by that
+ *			many ASCII characters).
+ *
+ * rfbNoAuth:		No authentication is needed.
+ *
+ * rfbVncAuth:		The VNC authentication scheme is to be used.  A 16-byte
+ *			challenge follows, which the client encrypts as
+ *			appropriate using the password and sends the resulting
+ *			16-byte response.  If the response is correct, the
+ *			server sends the 32-bit word rfbVncAuthOK.  If a simple
+ *			failure happens, the server sends rfbVncAuthFailed and
+ *			closes the connection. If the server decides that too
+ *			many failures have occurred, it sends rfbVncAuthTooMany
+ *			and closes the connection.  In the latter case, the
+ *			server should not allow an immediate reconnection by
+ *			the client.
+ */
+
+#define rfbVncAuthOK 0
+#define rfbVncAuthFailed 1
+#define rfbVncAuthTooMany 2
+
+
+/*-----------------------------------------------------------------------------
+ * Client Initialisation Message
+ *
+ * Once the client and server are sure that they're happy to talk to one
+ * another, the client sends an initialisation message.  At present this
+ * message only consists of a boolean indicating whether the server should try
+ * to share the desktop by leaving other clients connected, or give exclusive
+ * access to this client by disconnecting all other clients.
+ */
+
+typedef struct {
+    CARD8 shared;
+} rfbClientInitMsg;
+
+#define sz_rfbClientInitMsg 1
+
+
+/*-----------------------------------------------------------------------------
+ * Server Initialisation Message
+ *
+ * After the client initialisation message, the server sends one of its own.
+ * This tells the client the width and height of the server's framebuffer,
+ * its pixel format and the name associated with the desktop.
+ */
+
+typedef struct {
+    CARD16 framebufferWidth;
+    CARD16 framebufferHeight;
+    rfbPixelFormat format;	/* the server's preferred pixel format */
+    CARD32 nameLength;
+    /* followed by char name[nameLength] */
+} rfbServerInitMsg;
+
+#define sz_rfbServerInitMsg (8 + sz_rfbPixelFormat)
+
+
+/*
+ * Following the server initialisation message it's up to the client to send
+ * whichever protocol messages it wants.  Typically it will send a
+ * SetPixelFormat message and a SetEncodings message, followed by a
+ * FramebufferUpdateRequest.  From then on the server will send
+ * FramebufferUpdate messages in response to the client's
+ * FramebufferUpdateRequest messages.  The client should send
+ * FramebufferUpdateRequest messages with incremental set to true when it has
+ * finished processing one FramebufferUpdate and is ready to process another.
+ * With a fast client, the rate at which FramebufferUpdateRequests are sent
+ * should be regulated to avoid hogging the network.
+ */
+
+
+
+/*****************************************************************************
+ *
+ * Message types
+ *
+ *****************************************************************************/
+
+/* server -> client */
+
+#define rfbFramebufferUpdate 0
+#define rfbSetColourMapEntries 1
+#define rfbBell 2
+#define rfbServerCutText 3
+
+
+/* client -> server */
+
+#define rfbSetPixelFormat 0
+#define rfbFixColourMapEntries 1	/* not currently supported */
+#define rfbSetEncodings 2
+#define rfbFramebufferUpdateRequest 3
+#define rfbKeyEvent 4
+#define rfbPointerEvent 5
+#define rfbClientCutText 6
+
+
+
+
+/*****************************************************************************
+ *
+ * Encoding types
+ *
+ *****************************************************************************/
+
+#define rfbEncodingRaw 0
+#define rfbEncodingCopyRect 1
+#define rfbEncodingRRE 2
+#define rfbEncodingCoRRE 4
+#define rfbEncodingHextile 5
+#define rfbEncodingZlib 6
+#define rfbEncodingTight 7
+#define rfbEncodingZlibHex 8
+
+/*
+ * Special encoding numbers:
+ *   0xFFFFFF00 .. 0xFFFFFF0F -- encoding-specific compression levels;
+ *   0xFFFFFF10 .. 0xFFFFFF1F -- mouse cursor shape data;
+ *   0xFFFFFF20 .. 0xFFFFFF2F -- various protocol extensions;
+ *   0xFFFFFF30 .. 0xFFFFFFDF -- not allocated yet;
+ *   0xFFFFFFE0 .. 0xFFFFFFEF -- quality level for JPEG compressor;
+ *   0xFFFFFFF0 .. 0xFFFFFFFF -- cross-encoding compression levels.
+ */
+
+#define rfbEncodingCompressLevel0  0xFFFFFF00
+#define rfbEncodingCompressLevel1  0xFFFFFF01
+#define rfbEncodingCompressLevel2  0xFFFFFF02
+#define rfbEncodingCompressLevel3  0xFFFFFF03
+#define rfbEncodingCompressLevel4  0xFFFFFF04
+#define rfbEncodingCompressLevel5  0xFFFFFF05
+#define rfbEncodingCompressLevel6  0xFFFFFF06
+#define rfbEncodingCompressLevel7  0xFFFFFF07
+#define rfbEncodingCompressLevel8  0xFFFFFF08
+#define rfbEncodingCompressLevel9  0xFFFFFF09
+
+#define rfbEncodingXCursor         0xFFFFFF10
+#define rfbEncodingRichCursor      0xFFFFFF11
+#define rfbEncodingPointerPos      0xFFFFFF18
+
+#define rfbEncodingLastRect        0xFFFFFF20
+
+#define rfbEncodingQualityLevel0   0xFFFFFFE0
+#define rfbEncodingQualityLevel1   0xFFFFFFE1
+#define rfbEncodingQualityLevel2   0xFFFFFFE2
+#define rfbEncodingQualityLevel3   0xFFFFFFE3
+#define rfbEncodingQualityLevel4   0xFFFFFFE4
+#define rfbEncodingQualityLevel5   0xFFFFFFE5
+#define rfbEncodingQualityLevel6   0xFFFFFFE6
+#define rfbEncodingQualityLevel7   0xFFFFFFE7
+#define rfbEncodingQualityLevel8   0xFFFFFFE8
+#define rfbEncodingQualityLevel9   0xFFFFFFE9
+
+
+/*****************************************************************************
+ *
+ * Server -> client message definitions
+ *
+ *****************************************************************************/
+
+
+/*-----------------------------------------------------------------------------
+ * FramebufferUpdate - a block of rectangles to be copied to the framebuffer.
+ *
+ * This message consists of a header giving the number of rectangles of pixel
+ * data followed by the rectangles themselves.  The header is padded so that
+ * together with the type byte it is an exact multiple of 4 bytes (to help
+ * with alignment of 32-bit pixels):
+ */
+
+typedef struct {
+    CARD8 type;			/* always rfbFramebufferUpdate */
+    CARD8 pad;
+    CARD16 nRects;
+    /* followed by nRects rectangles */
+} rfbFramebufferUpdateMsg;
+
+#define sz_rfbFramebufferUpdateMsg 4
+
+/*
+ * Each rectangle of pixel data consists of a header describing the position
+ * and size of the rectangle and a type word describing the encoding of the
+ * pixel data, followed finally by the pixel data.  Note that if the client has
+ * not sent a SetEncodings message then it will only receive raw pixel data.
+ * Also note again that this structure is a multiple of 4 bytes.
+ */
+
+typedef struct {
+    rfbRectangle r;
+    CARD32 encoding;	/* one of the encoding types rfbEncoding... */
+} rfbFramebufferUpdateRectHeader;
+
+#define sz_rfbFramebufferUpdateRectHeader (sz_rfbRectangle + 4)
+
+
+/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+ * Raw Encoding.  Pixels are sent in top-to-bottom scanline order,
+ * left-to-right within a scanline with no padding in between.
+ */
+
+
+/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+ * CopyRect Encoding.  The pixels are specified simply by the x and y position
+ * of the source rectangle.
+ */
+
+typedef struct {
+    CARD16 srcX;
+    CARD16 srcY;
+} rfbCopyRect;
+
+#define sz_rfbCopyRect 4
+
+
+/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+ * RRE - Rise-and-Run-length Encoding.  We have an rfbRREHeader structure
+ * giving the number of subrectangles following.  Finally the data follows in
+ * the form [<bgpixel><subrect><subrect>...] where each <subrect> is
+ * [<pixel><rfbRectangle>].
+ */
+
+typedef struct {
+    CARD32 nSubrects;
+} rfbRREHeader;
+
+#define sz_rfbRREHeader 4
+
+
+/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+ * CoRRE - Compact RRE Encoding.  We have an rfbRREHeader structure giving
+ * the number of subrectangles following.  Finally the data follows in the form
+ * [<bgpixel><subrect><subrect>...] where each <subrect> is
+ * [<pixel><rfbCoRRERectangle>].  This means that
+ * the whole rectangle must be at most 255x255 pixels.
+ */
+
+typedef struct {
+    CARD8 x;
+    CARD8 y;
+    CARD8 w;
+    CARD8 h;
+} rfbCoRRERectangle;
+
+#define sz_rfbCoRRERectangle 4
+
+
+/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+ * Hextile Encoding.  The rectangle is divided up into "tiles" of 16x16 pixels,
+ * starting at the top left going in left-to-right, top-to-bottom order.  If
+ * the width of the rectangle is not an exact multiple of 16 then the width of
+ * the last tile in each row will be correspondingly smaller.  Similarly if the
+ * height is not an exact multiple of 16 then the height of each tile in the
+ * final row will also be smaller.  Each tile begins with a "subencoding" type
+ * byte, which is a mask made up of a number of bits.  If the Raw bit is set
+ * then the other bits are irrelevant; w*h pixel values follow (where w and h
+ * are the width and height of the tile).  Otherwise the tile is encoded in a
+ * similar way to RRE, except that the position and size of each subrectangle
+ * can be specified in just two bytes.  The other bits in the mask are as
+ * follows:
+ *
+ * BackgroundSpecified - if set, a pixel value follows which specifies
+ *    the background colour for this tile.  The first non-raw tile in a
+ *    rectangle must have this bit set.  If this bit isn't set then the
+ *    background is the same as the last tile.
+ *
+ * ForegroundSpecified - if set, a pixel value follows which specifies
+ *    the foreground colour to be used for all subrectangles in this tile.
+ *    If this bit is set then the SubrectsColoured bit must be zero.
+ *
+ * AnySubrects - if set, a single byte follows giving the number of
+ *    subrectangles following.  If not set, there are no subrectangles (i.e.
+ *    the whole tile is just solid background colour).
+ *
+ * SubrectsColoured - if set then each subrectangle is preceded by a pixel
+ *    value giving the colour of that subrectangle.  If not set, all
+ *    subrectangles are the same colour, the foreground colour;  if the
+ *    ForegroundSpecified bit wasn't set then the foreground is the same as
+ *    the last tile.
+ *
+ * The position and size of each subrectangle is specified in two bytes.  The
+ * Pack macros below can be used to generate the two bytes from x, y, w, h,
+ * and the Extract macros can be used to extract the x, y, w, h values from
+ * the two bytes.
+ */
+
+#define rfbHextileRaw			(1 << 0)
+#define rfbHextileBackgroundSpecified	(1 << 1)
+#define rfbHextileForegroundSpecified	(1 << 2)
+#define rfbHextileAnySubrects		(1 << 3)
+#define rfbHextileSubrectsColoured	(1 << 4)
+
+#define rfbHextilePackXY(x,y) (((x) << 4) | (y))
+#define rfbHextilePackWH(w,h) ((((w)-1) << 4) | ((h)-1))
+#define rfbHextileExtractX(byte) ((byte) >> 4)
+#define rfbHextileExtractY(byte) ((byte) & 0xf)
+#define rfbHextileExtractW(byte) (((byte) >> 4) + 1)
+#define rfbHextileExtractH(byte) (((byte) & 0xf) + 1)
+
+
+/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+ * zlib - zlib compressed Encoding.  We have an rfbZlibHeader structure
+ * giving the number of bytes following.  Finally the data follows is
+ * zlib compressed version of the raw pixel data as negotiated.
+ */
+
+typedef struct {
+    CARD32 nBytes;
+} rfbZlibHeader;
+
+#define sz_rfbZlibHeader 4
+
+
+/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+ * Tight Encoding.
+ *
+ *-- The first byte of each Tight-encoded rectangle is a "compression control
+ *   byte". Its format is as follows (bit 0 is the least significant one):
+ *
+ *   bit 0:    if 1, then compression stream 0 should be reset;
+ *   bit 1:    if 1, then compression stream 1 should be reset;
+ *   bit 2:    if 1, then compression stream 2 should be reset;
+ *   bit 3:    if 1, then compression stream 3 should be reset;
+ *   bits 7-4: if 1000 (0x08), then the compression type is "fill",
+ *             if 1001 (0x09), then the compression type is "jpeg",
+ *             if 0xxx, then the compression type is "basic",
+ *             values greater than 1001 are not valid.
+ *
+ * If the compression type is "basic", then bits 6..4 of the
+ * compression control byte (those xxx in 0xxx) specify the following:
+ *
+ *   bits 5-4:  decimal representation is the index of a particular zlib
+ *              stream which should be used for decompressing the data;
+ *   bit 6:     if 1, then a "filter id" byte is following this byte.
+ *
+ *-- The data that follows after the compression control byte described
+ * above depends on the compression type ("fill", "jpeg" or "basic").
+ *
+ *-- If the compression type is "fill", then the only pixel value follows, in
+ * client pixel format (see NOTE 1). This value applies to all pixels of the
+ * rectangle.
+ *
+ *-- If the compression type is "jpeg", the following data stream looks like
+ * this:
+ *
+ *   1..3 bytes:  data size (N) in compact representation;
+ *   N bytes:     JPEG image.
+ *
+ * Data size is compactly represented in one, two or three bytes, according
+ * to the following scheme:
+ *
+ *  0xxxxxxx                    (for values 0..127)
+ *  1xxxxxxx 0yyyyyyy           (for values 128..16383)
+ *  1xxxxxxx 1yyyyyyy zzzzzzzz  (for values 16384..4194303)
+ *
+ * Here each character denotes one bit, xxxxxxx are the least significant 7
+ * bits of the value (bits 0-6), yyyyyyy are bits 7-13, and zzzzzzzz are the
+ * most significant 8 bits (bits 14-21). For example, decimal value 10000
+ * should be represented as two bytes: binary 10010000 01001110, or
+ * hexadecimal 90 4E.
+ *
+ *-- If the compression type is "basic" and bit 6 of the compression control
+ * byte was set to 1, then the next (second) byte specifies "filter id" which
+ * tells the decoder what filter type was used by the encoder to pre-process
+ * pixel data before the compression. The "filter id" byte can be one of the
+ * following:
+ *
+ *   0:  no filter ("copy" filter);
+ *   1:  "palette" filter;
+ *   2:  "gradient" filter.
+ *
+ *-- If bit 6 of the compression control byte is set to 0 (no "filter id"
+ * byte), or if the filter id is 0, then raw pixel values in the client
+ * format (see NOTE 1) will be compressed. See below details on the
+ * compression.
+ *
+ *-- The "gradient" filter pre-processes pixel data with a simple algorithm
+ * which converts each color component to a difference between a "predicted"
+ * intensity and the actual intensity. Such a technique does not affect
+ * uncompressed data size, but helps to compress photo-like images better. 
+ * Pseudo-code for converting intensities to differences is the following:
+ *
+ *   P[i,j] := V[i-1,j] + V[i,j-1] - V[i-1,j-1];
+ *   if (P[i,j] < 0) then P[i,j] := 0;
+ *   if (P[i,j] > MAX) then P[i,j] := MAX;
+ *   D[i,j] := V[i,j] - P[i,j];
+ *
+ * Here V[i,j] is the intensity of a color component for a pixel at
+ * coordinates (i,j). MAX is the maximum value of intensity for a color
+ * component.
+ *
+ *-- The "palette" filter converts true-color pixel data to indexed colors
+ * and a palette which can consist of 2..256 colors. If the number of colors
+ * is 2, then each pixel is encoded in 1 bit, otherwise 8 bits is used to
+ * encode one pixel. 1-bit encoding is performed such way that the most
+ * significant bits correspond to the leftmost pixels, and each raw of pixels
+ * is aligned to the byte boundary. When "palette" filter is used, the
+ * palette is sent before the pixel data. The palette begins with an unsigned
+ * byte which value is the number of colors in the palette minus 1 (i.e. 1
+ * means 2 colors, 255 means 256 colors in the palette). Then follows the
+ * palette itself which consist of pixel values in client pixel format (see
+ * NOTE 1).
+ *
+ *-- The pixel data is compressed using the zlib library. But if the data
+ * size after applying the filter but before the compression is less then 12,
+ * then the data is sent as is, uncompressed. Four separate zlib streams
+ * (0..3) can be used and the decoder should read the actual stream id from
+ * the compression control byte (see NOTE 2).
+ *
+ * If the compression is not used, then the pixel data is sent as is,
+ * otherwise the data stream looks like this:
+ *
+ *   1..3 bytes:  data size (N) in compact representation;
+ *   N bytes:     zlib-compressed data.
+ *
+ * Data size is compactly represented in one, two or three bytes, just like
+ * in the "jpeg" compression method (see above).
+ *
+ *-- NOTE 1. If the color depth is 24, and all three color components are
+ * 8-bit wide, then one pixel in Tight encoding is always represented by
+ * three bytes, where the first byte is red component, the second byte is
+ * green component, and the third byte is blue component of the pixel color
+ * value. This applies to colors in palettes as well.
+ *
+ *-- NOTE 2. The decoder must reset compression streams' states before
+ * decoding the rectangle, if some of bits 0,1,2,3 in the compression control
+ * byte are set to 1. Note that the decoder must reset zlib streams even if
+ * the compression type is "fill" or "jpeg".
+ *
+ *-- NOTE 3. The "gradient" filter and "jpeg" compression may be used only
+ * when bits-per-pixel value is either 16 or 32, not 8.
+ *
+ *-- NOTE 4. The width of any Tight-encoded rectangle cannot exceed 2048
+ * pixels. If a rectangle is wider, it must be split into several rectangles
+ * and each one should be encoded separately.
+ *
+ */
+
+#define rfbTightExplicitFilter         0x04
+#define rfbTightFill                   0x08
+#define rfbTightJpeg                   0x09
+#define rfbTightMaxSubencoding         0x09
+
+/* Filters to improve compression efficiency */
+#define rfbTightFilterCopy             0x00
+#define rfbTightFilterPalette          0x01
+#define rfbTightFilterGradient         0x02
+
+
+/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+ * XCursor encoding. This is a special encoding used to transmit X-style
+ * cursor shapes from server to clients. Note that for this encoding,
+ * coordinates in rfbFramebufferUpdateRectHeader structure hold hotspot
+ * position (r.x, r.y) and cursor size (r.w, r.h). If (w * h != 0), two RGB
+ * samples are sent after header in the rfbXCursorColors structure. They
+ * denote foreground and background colors of the cursor. If a client
+ * supports only black-and-white cursors, it should ignore these colors and
+ * assume that foreground is black and background is white. Next, two bitmaps
+ * (1 bits per pixel) follow: first one with actual data (value 0 denotes
+ * background color, value 1 denotes foreground color), second one with
+ * transparency data (bits with zero value mean that these pixels are
+ * transparent). Both bitmaps represent cursor data in a byte stream, from
+ * left to right, from top to bottom, and each row is byte-aligned. Most
+ * significant bits correspond to leftmost pixels. The number of bytes in
+ * each row can be calculated as ((w + 7) / 8). If (w * h == 0), cursor
+ * should be hidden (or default local cursor should be set by the client).
+ */
+
+typedef struct {
+    CARD8 foreRed;
+    CARD8 foreGreen;
+    CARD8 foreBlue;
+    CARD8 backRed;
+    CARD8 backGreen;
+    CARD8 backBlue;
+} rfbXCursorColors;
+
+#define sz_rfbXCursorColors 6
+
+
+/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+ * RichCursor encoding. This is a special encoding used to transmit cursor
+ * shapes from server to clients. It is similar to the XCursor encoding but
+ * uses client pixel format instead of two RGB colors to represent cursor
+ * image. For this encoding, coordinates in rfbFramebufferUpdateRectHeader
+ * structure hold hotspot position (r.x, r.y) and cursor size (r.w, r.h).
+ * After header, two pixmaps follow: first one with cursor image in current
+ * client pixel format (like in raw encoding), second with transparency data
+ * (1 bit per pixel, exactly the same format as used for transparency bitmap
+ * in the XCursor encoding). If (w * h == 0), cursor should be hidden (or
+ * default local cursor should be set by the client).
+ */
+
+
+/*-----------------------------------------------------------------------------
+ * SetColourMapEntries - these messages are only sent if the pixel
+ * format uses a "colour map" (i.e. trueColour false) and the client has not
+ * fixed the entire colour map using FixColourMapEntries.  In addition they
+ * will only start being sent after the client has sent its first
+ * FramebufferUpdateRequest.  So if the client always tells the server to use
+ * trueColour then it never needs to process this type of message.
+ */
+
+typedef struct {
+    CARD8 type;			/* always rfbSetColourMapEntries */
+    CARD8 pad;
+    CARD16 firstColour;
+    CARD16 nColours;
+
+    /* Followed by nColours * 3 * CARD16
+       r1, g1, b1, r2, g2, b2, r3, g3, b3, ..., rn, bn, gn */
+
+} rfbSetColourMapEntriesMsg;
+
+#define sz_rfbSetColourMapEntriesMsg 6
+
+
+
+/*-----------------------------------------------------------------------------
+ * Bell - ring a bell on the client if it has one.
+ */
+
+typedef struct {
+    CARD8 type;			/* always rfbBell */
+} rfbBellMsg;
+
+#define sz_rfbBellMsg 1
+
+
+
+/*-----------------------------------------------------------------------------
+ * ServerCutText - the server has new text in its cut buffer.
+ */
+
+typedef struct {
+    CARD8 type;			/* always rfbServerCutText */
+    CARD8 pad1;
+    CARD16 pad2;
+    CARD32 length;
+    /* followed by char text[length] */
+} rfbServerCutTextMsg;
+
+#define sz_rfbServerCutTextMsg 8
+
+
+/*-----------------------------------------------------------------------------
+ * Union of all server->client messages.
+ */
+
+typedef union {
+    CARD8 type;
+    rfbFramebufferUpdateMsg fu;
+    rfbSetColourMapEntriesMsg scme;
+    rfbBellMsg b;
+    rfbServerCutTextMsg sct;
+} rfbServerToClientMsg;
+
+
+
+/*****************************************************************************
+ *
+ * Message definitions (client -> server)
+ *
+ *****************************************************************************/
+
+
+/*-----------------------------------------------------------------------------
+ * SetPixelFormat - tell the RFB server the format in which the client wants
+ * pixels sent.
+ */
+
+typedef struct {
+    CARD8 type;			/* always rfbSetPixelFormat */
+    CARD8 pad1;
+    CARD16 pad2;
+    rfbPixelFormat format;
+} rfbSetPixelFormatMsg;
+
+#define sz_rfbSetPixelFormatMsg (sz_rfbPixelFormat + 4)
+
+
+/*-----------------------------------------------------------------------------
+ * FixColourMapEntries - when the pixel format uses a "colour map", fix
+ * read-only colour map entries.
+ *
+ *    ***************** NOT CURRENTLY SUPPORTED *****************
+ */
+
+typedef struct {
+    CARD8 type;			/* always rfbFixColourMapEntries */
+    CARD8 pad;
+    CARD16 firstColour;
+    CARD16 nColours;
+
+    /* Followed by nColours * 3 * CARD16
+       r1, g1, b1, r2, g2, b2, r3, g3, b3, ..., rn, bn, gn */
+
+} rfbFixColourMapEntriesMsg;
+
+#define sz_rfbFixColourMapEntriesMsg 6
+
+
+/*-----------------------------------------------------------------------------
+ * SetEncodings - tell the RFB server which encoding types we accept.  Put them
+ * in order of preference, if we have any.  We may always receive raw
+ * encoding, even if we don't specify it here.
+ */
+
+typedef struct {
+    CARD8 type;			/* always rfbSetEncodings */
+    CARD8 pad;
+    CARD16 nEncodings;
+    /* followed by nEncodings * CARD32 encoding types */
+} rfbSetEncodingsMsg;
+
+#define sz_rfbSetEncodingsMsg 4
+
+
+/*-----------------------------------------------------------------------------
+ * FramebufferUpdateRequest - request for a framebuffer update.  If incremental
+ * is true then the client just wants the changes since the last update.  If
+ * false then it wants the whole of the specified rectangle.
+ */
+
+typedef struct {
+    CARD8 type;			/* always rfbFramebufferUpdateRequest */
+    CARD8 incremental;
+    CARD16 x;
+    CARD16 y;
+    CARD16 w;
+    CARD16 h;
+} rfbFramebufferUpdateRequestMsg;
+
+#define sz_rfbFramebufferUpdateRequestMsg 10
+
+
+/*-----------------------------------------------------------------------------
+ * KeyEvent - key press or release
+ *
+ * Keys are specified using the "keysym" values defined by the X Window System.
+ * For most ordinary keys, the keysym is the same as the corresponding ASCII
+ * value.  Other common keys are:
+ *
+ * BackSpace		0xff08
+ * Tab			0xff09
+ * Return or Enter	0xff0d
+ * Escape		0xff1b
+ * Insert		0xff63
+ * Delete		0xffff
+ * Home			0xff50
+ * End			0xff57
+ * Page Up		0xff55
+ * Page Down		0xff56
+ * Left			0xff51
+ * Up			0xff52
+ * Right		0xff53
+ * Down			0xff54
+ * F1			0xffbe
+ * F2			0xffbf
+ * ...			...
+ * F12			0xffc9
+ * Shift		0xffe1
+ * Control		0xffe3
+ * Meta			0xffe7
+ * Alt			0xffe9
+ */
+
+typedef struct {
+    CARD8 type;			/* always rfbKeyEvent */
+    CARD8 down;			/* true if down (press), false if up */
+    CARD16 pad;
+    CARD32 key;			/* key is specified as an X keysym */
+} rfbKeyEventMsg;
+
+#define sz_rfbKeyEventMsg 8
+
+
+/*-----------------------------------------------------------------------------
+ * PointerEvent - mouse/pen move and/or button press.
+ */
+
+typedef struct {
+    CARD8 type;			/* always rfbPointerEvent */
+    CARD8 buttonMask;		/* bits 0-7 are buttons 1-8, 0=up, 1=down */
+    CARD16 x;
+    CARD16 y;
+} rfbPointerEventMsg;
+
+#define rfbButton1Mask 1
+#define rfbButton2Mask 2
+#define rfbButton3Mask 4
+
+#define sz_rfbPointerEventMsg 6
+
+
+
+/*-----------------------------------------------------------------------------
+ * ClientCutText - the client has new text in its cut buffer.
+ */
+
+typedef struct {
+    CARD8 type;			/* always rfbClientCutText */
+    CARD8 pad1;
+    CARD16 pad2;
+    CARD32 length;
+    /* followed by char text[length] */
+} rfbClientCutTextMsg;
+
+#define sz_rfbClientCutTextMsg 8
+
+
+
+/*-----------------------------------------------------------------------------
+ * Union of all client->server messages.
+ */
+
+typedef union {
+    CARD8 type;
+    rfbSetPixelFormatMsg spf;
+    rfbFixColourMapEntriesMsg fcme;
+    rfbSetEncodingsMsg se;
+    rfbFramebufferUpdateRequestMsg fur;
+    rfbKeyEventMsg ke;
+    rfbPointerEventMsg pe;
+    rfbClientCutTextMsg cct;
+} rfbClientToServerMsg;

Added: trunk/freenx-server/nxviewer-passwd/include/vncauth.h
===================================================================
--- trunk/freenx-server/nxviewer-passwd/include/vncauth.h	2008-03-14 17:45:36 UTC (rev 527)
+++ trunk/freenx-server/nxviewer-passwd/include/vncauth.h	2008-03-14 17:54:12 UTC (rev 528)
@@ -0,0 +1,30 @@
+/*
+ *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
+ *
+ *  This is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This software is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this software; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
+ *  USA.
+ */
+
+/* 
+ * vncauth.h - describes the functions provided by the vncauth library.
+ */
+
+#define MAXPWLEN 8
+#define CHALLENGESIZE 16
+
+extern int vncEncryptAndStorePasswd(char *passwd, char *fname);
+extern char *vncDecryptPasswdFromFile(char *fname);
+extern void vncRandomBytes(unsigned char *bytes);
+extern void vncEncryptBytes(unsigned char *bytes, char *passwd);

Added: trunk/freenx-server/nxviewer-passwd/libvncauth/Imakefile
===================================================================
--- trunk/freenx-server/nxviewer-passwd/libvncauth/Imakefile	2008-03-14 17:45:36 UTC (rev 527)
+++ trunk/freenx-server/nxviewer-passwd/libvncauth/Imakefile	2008-03-14 17:54:12 UTC (rev 528)
@@ -0,0 +1,14 @@
+
+#ifdef SunArchitecture
+EXTRA_DEFINES = -D__EXTENSIONS__
+#endif
+
+SRCS = vncauth.c d3des.c
+
+OBJS = vncauth.o d3des.o
+
+INCLUDES = -I. -I../include
+
+NormalLibraryTarget(vncauth,$(OBJS))
+
+DependTarget()

Added: trunk/freenx-server/nxviewer-passwd/libvncauth/d3des.c
===================================================================
--- trunk/freenx-server/nxviewer-passwd/libvncauth/d3des.c	2008-03-14 17:45:36 UTC (rev 527)
+++ trunk/freenx-server/nxviewer-passwd/libvncauth/d3des.c	2008-03-14 17:54:12 UTC (rev 528)
@@ -0,0 +1,440 @@
+/*
+ * This is D3DES (V5.09) by Richard Outerbridge with the double and
+ * triple-length support removed for use in VNC.  Also the bytebit[] array
+ * has been reversed so that the most significant bit in each byte of the
+ * key is ignored, not the least significant.
+ *
+ * These changes are:
+ *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
+ *
+ * This software is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/* D3DES (V5.09) -
+ *
+ * A portable, public domain, version of the Data Encryption Standard.
+ *
+ * Written with Symantec's THINK (Lightspeed) C by Richard Outerbridge.
+ * Thanks to: Dan Hoey for his excellent Initial and Inverse permutation
+ * code;  Jim Gillogly & Phil Karn for the DES key schedule code; Dennis
+ * Ferguson, Eric Young and Dana How for comparing notes; and Ray Lau,
+ * for humouring me on.
+ *
+ * Copyright (c) 1988,1989,1990,1991,1992 by Richard Outerbridge.
+ * (GEnie : OUTER; CIS : [71755,204]) Graven Imagery, 1992.
+ */
+
+#include "d3des.h"
+
+static void scrunch(unsigned char *, unsigned long *);
+static void unscrun(unsigned long *, unsigned char *);
+static void desfunc(unsigned long *, unsigned long *);
+static void cookey(unsigned long *);
+
+static unsigned long KnL[32] = { 0L };
+static unsigned long KnR[32] = { 0L };
+static unsigned long Kn3[32] = { 0L };
+static unsigned char Df_Key[24] = {
+	0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,
+	0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,
+	0x89,0xab,0xcd,0xef,0x01,0x23,0x45,0x67 };
+
+static unsigned short bytebit[8]	= {
+	01, 02, 04, 010, 020, 040, 0100, 0200 };
+
+static unsigned long bigbyte[24] = {
+	0x800000L,	0x400000L,	0x200000L,	0x100000L,
+	0x80000L,	0x40000L,	0x20000L,	0x10000L,
+	0x8000L,	0x4000L,	0x2000L,	0x1000L,
+	0x800L, 	0x400L, 	0x200L, 	0x100L,
+	0x80L,		0x40L,		0x20L,		0x10L,
+	0x8L,		0x4L,		0x2L,		0x1L	};
+
+/* Use the key schedule specified in the Standard (ANSI X3.92-1981). */
+
+static unsigned char pc1[56] = {
+	56, 48, 40, 32, 24, 16,  8,	 0, 57, 49, 41, 33, 25, 17,
+	 9,  1, 58, 50, 42, 34, 26,	18, 10,  2, 59, 51, 43, 35,
+	62, 54, 46, 38, 30, 22, 14,	 6, 61, 53, 45, 37, 29, 21,
+	13,  5, 60, 52, 44, 36, 28,	20, 12,  4, 27, 19, 11,  3 };
+
+static unsigned char totrot[16] = {
+	1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28 };
+
+static unsigned char pc2[48] = {
+	13, 16, 10, 23,  0,  4,  2, 27, 14,  5, 20,  9,
+	22, 18, 11,  3, 25,  7, 15,  6, 26, 19, 12,  1,
+	40, 51, 30, 36, 46, 54, 29, 39, 50, 44, 32, 47,
+	43, 48, 38, 55, 33, 52, 45, 41, 49, 35, 28, 31 };
+
+void deskey(key, edf)	/* Thanks to James Gillogly & Phil Karn! */
+unsigned char *key;
+int edf;
+{
+	register int i, j, l, m, n;
+	unsigned char pc1m[56], pcr[56];
+	unsigned long kn[32];
+
+	for ( j = 0; j < 56; j++ ) {
+		l = pc1[j];
+		m = l & 07;
+		pc1m[j] = (key[l >> 3] & bytebit[m]) ? 1 : 0;
+		}
+	for( i = 0; i < 16; i++ ) {
+		if( edf == DE1 ) m = (15 - i) << 1;
+		else m = i << 1;
+		n = m + 1;
+		kn[m] = kn[n] = 0L;
+		for( j = 0; j < 28; j++ ) {
+			l = j + totrot[i];
+			if( l < 28 ) pcr[j] = pc1m[l];
+			else pcr[j] = pc1m[l - 28];
+			}
+		for( j = 28; j < 56; j++ ) {
+		    l = j + totrot[i];
+		    if( l < 56 ) pcr[j] = pc1m[l];
+		    else pcr[j] = pc1m[l - 28];
+		    }
+		for( j = 0; j < 24; j++ ) {
+			if( pcr[pc2[j]] ) kn[m] |= bigbyte[j];
+			if( pcr[pc2[j+24]] ) kn[n] |= bigbyte[j];
+			}
+		}
+	cookey(kn);
+	return;
+	}
+
+static void cookey(raw1)
+register unsigned long *raw1;
+{
+	register unsigned long *cook, *raw0;
+	unsigned long dough[32];
+	register int i;
+
+	cook = dough;
+	for( i = 0; i < 16; i++, raw1++ ) {
+		raw0 = raw1++;
+		*cook	 = (*raw0 & 0x00fc0000L) << 6;
+		*cook	|= (*raw0 & 0x00000fc0L) << 10;
+		*cook	|= (*raw1 & 0x00fc0000L) >> 10;
+		*cook++ |= (*raw1 & 0x00000fc0L) >> 6;
+		*cook	 = (*raw0 & 0x0003f000L) << 12;
+		*cook	|= (*raw0 & 0x0000003fL) << 16;
+		*cook	|= (*raw1 & 0x0003f000L) >> 4;
+		*cook++ |= (*raw1 & 0x0000003fL);
+		}
+	usekey(dough);
+	return;
+	}
+
+void cpkey(into)
+register unsigned long *into;
+{
+	register unsigned long *from, *endp;
+
+	from = KnL, endp = &KnL[32];
+	while( from < endp ) *into++ = *from++;
+	return;
+	}
+
+void usekey(from)
+register unsigned long *from;
+{
+	register unsigned long *to, *endp;
+
+	to = KnL, endp = &KnL[32];
+	while( to < endp ) *to++ = *from++;
+	return;
+	}
+
+void des(inblock, outblock)
+unsigned char *inblock, *outblock;
+{
+	unsigned long work[2];
+
+	scrunch(inblock, work);
+	desfunc(work, KnL);
+	unscrun(work, outblock);
+	return;
+	}
+
+static void scrunch(outof, into)
+register unsigned char *outof;
+register unsigned long *into;
+{
+	*into	 = (*outof++ & 0xffL) << 24;
+	*into	|= (*outof++ & 0xffL) << 16;
+	*into	|= (*outof++ & 0xffL) << 8;
+	*into++ |= (*outof++ & 0xffL);
+	*into	 = (*outof++ & 0xffL) << 24;
+	*into	|= (*outof++ & 0xffL) << 16;
+	*into	|= (*outof++ & 0xffL) << 8;
+	*into	|= (*outof   & 0xffL);
+	return;
+	}
+
+static void unscrun(outof, into)
+register unsigned long *outof;
+register unsigned char *into;
+{
+	*into++ = (*outof >> 24) & 0xffL;
+	*into++ = (*outof >> 16) & 0xffL;
+	*into++ = (*outof >>  8) & 0xffL;
+	*into++ =  *outof++	 & 0xffL;
+	*into++ = (*outof >> 24) & 0xffL;
+	*into++ = (*outof >> 16) & 0xffL;
+	*into++ = (*outof >>  8) & 0xffL;
+	*into	=  *outof	 & 0xffL;
+	return;
+	}
+
+static unsigned long SP1[64] = {
+	0x01010400L, 0x00000000L, 0x00010000L, 0x01010404L,
+	0x01010004L, 0x00010404L, 0x00000004L, 0x00010000L,
+	0x00000400L, 0x01010400L, 0x01010404L, 0x00000400L,
+	0x01000404L, 0x01010004L, 0x01000000L, 0x00000004L,
+	0x00000404L, 0x01000400L, 0x01000400L, 0x00010400L,
+	0x00010400L, 0x01010000L, 0x01010000L, 0x01000404L,
+	0x00010004L, 0x01000004L, 0x01000004L, 0x00010004L,
+	0x00000000L, 0x00000404L, 0x00010404L, 0x01000000L,
+	0x00010000L, 0x01010404L, 0x00000004L, 0x01010000L,
+	0x01010400L, 0x01000000L, 0x01000000L, 0x00000400L,
+	0x01010004L, 0x00010000L, 0x00010400L, 0x01000004L,
+	0x00000400L, 0x00000004L, 0x01000404L, 0x00010404L,
+	0x01010404L, 0x00010004L, 0x01010000L, 0x01000404L,
+	0x01000004L, 0x00000404L, 0x00010404L, 0x01010400L,
+	0x00000404L, 0x01000400L, 0x01000400L, 0x00000000L,
+	0x00010004L, 0x00010400L, 0x00000000L, 0x01010004L };
+
+static unsigned long SP2[64] = {
+	0x80108020L, 0x80008000L, 0x00008000L, 0x00108020L,
+	0x00100000L, 0x00000020L, 0x80100020L, 0x80008020L,
+	0x80000020L, 0x80108020L, 0x80108000L, 0x80000000L,
+	0x80008000L, 0x00100000L, 0x00000020L, 0x80100020L,
+	0x00108000L, 0x00100020L, 0x80008020L, 0x00000000L,
+	0x80000000L, 0x00008000L, 0x00108020L, 0x80100000L,
+	0x00100020L, 0x80000020L, 0x00000000L, 0x00108000L,
+	0x00008020L, 0x80108000L, 0x80100000L, 0x00008020L,
+	0x00000000L, 0x00108020L, 0x80100020L, 0x00100000L,
+	0x80008020L, 0x80100000L, 0x80108000L, 0x00008000L,
+	0x80100000L, 0x80008000L, 0x00000020L, 0x80108020L,
+	0x00108020L, 0x00000020L, 0x00008000L, 0x80000000L,
+	0x00008020L, 0x80108000L, 0x00100000L, 0x80000020L,
+	0x00100020L, 0x80008020L, 0x80000020L, 0x00100020L,
+	0x00108000L, 0x00000000L, 0x80008000L, 0x00008020L,
+	0x80000000L, 0x80100020L, 0x80108020L, 0x00108000L };
+
+static unsigned long SP3[64] = {
+	0x00000208L, 0x08020200L, 0x00000000L, 0x08020008L,
+	0x08000200L, 0x00000000L, 0x00020208L, 0x08000200L,
+	0x00020008L, 0x08000008L, 0x08000008L, 0x00020000L,
+	0x08020208L, 0x00020008L, 0x08020000L, 0x00000208L,
+	0x08000000L, 0x00000008L, 0x08020200L, 0x00000200L,
+	0x00020200L, 0x08020000L, 0x08020008L, 0x00020208L,
+	0x08000208L, 0x00020200L, 0x00020000L, 0x08000208L,
+	0x00000008L, 0x08020208L, 0x00000200L, 0x08000000L,
+	0x08020200L, 0x08000000L, 0x00020008L, 0x00000208L,
+	0x00020000L, 0x08020200L, 0x08000200L, 0x00000000L,
+	0x00000200L, 0x00020008L, 0x08020208L, 0x08000200L,
+	0x08000008L, 0x00000200L, 0x00000000L, 0x08020008L,
+	0x08000208L, 0x00020000L, 0x08000000L, 0x08020208L,
+	0x00000008L, 0x00020208L, 0x00020200L, 0x08000008L,
+	0x08020000L, 0x08000208L, 0x00000208L, 0x08020000L,
+	0x00020208L, 0x00000008L, 0x08020008L, 0x00020200L };
+
+static unsigned long SP4[64] = {
+	0x00802001L, 0x00002081L, 0x00002081L, 0x00000080L,
+	0x00802080L, 0x00800081L, 0x00800001L, 0x00002001L,
+	0x00000000L, 0x00802000L, 0x00802000L, 0x00802081L,
+	0x00000081L, 0x00000000L, 0x00800080L, 0x00800001L,
+	0x00000001L, 0x00002000L, 0x00800000L, 0x00802001L,
+	0x00000080L, 0x00800000L, 0x00002001L, 0x00002080L,
+	0x00800081L, 0x00000001L, 0x00002080L, 0x00800080L,
+	0x00002000L, 0x00802080L, 0x00802081L, 0x00000081L,
+	0x00800080L, 0x00800001L, 0x00802000L, 0x00802081L,
+	0x00000081L, 0x00000000L, 0x00000000L, 0x00802000L,
+	0x00002080L, 0x00800080L, 0x00800081L, 0x00000001L,
+	0x00802001L, 0x00002081L, 0x00002081L, 0x00000080L,
+	0x00802081L, 0x00000081L, 0x00000001L, 0x00002000L,
+	0x00800001L, 0x00002001L, 0x00802080L, 0x00800081L,
+	0x00002001L, 0x00002080L, 0x00800000L, 0x00802001L,
+	0x00000080L, 0x00800000L, 0x00002000L, 0x00802080L };
+
+static unsigned long SP5[64] = {
+	0x00000100L, 0x02080100L, 0x02080000L, 0x42000100L,
+	0x00080000L, 0x00000100L, 0x40000000L, 0x02080000L,
+	0x40080100L, 0x00080000L, 0x02000100L, 0x40080100L,
+	0x42000100L, 0x42080000L, 0x00080100L, 0x40000000L,
+	0x02000000L, 0x40080000L, 0x40080000L, 0x00000000L,
+	0x40000100L, 0x42080100L, 0x42080100L, 0x02000100L,
+	0x42080000L, 0x40000100L, 0x00000000L, 0x42000000L,
+	0x02080100L, 0x02000000L, 0x42000000L, 0x00080100L,
+	0x00080000L, 0x42000100L, 0x00000100L, 0x02000000L,
+	0x40000000L, 0x02080000L, 0x42000100L, 0x40080100L,
+	0x02000100L, 0x40000000L, 0x42080000L, 0x02080100L,
+	0x40080100L, 0x00000100L, 0x02000000L, 0x42080000L,
+	0x42080100L, 0x00080100L, 0x42000000L, 0x42080100L,
+	0x02080000L, 0x00000000L, 0x40080000L, 0x42000000L,
+	0x00080100L, 0x02000100L, 0x40000100L, 0x00080000L,
+	0x00000000L, 0x40080000L, 0x02080100L, 0x40000100L };
+
+static unsigned long SP6[64] = {
+	0x20000010L, 0x20400000L, 0x00004000L, 0x20404010L,
+	0x20400000L, 0x00000010L, 0x20404010L, 0x00400000L,
+	0x20004000L, 0x00404010L, 0x00400000L, 0x20000010L,
+	0x00400010L, 0x20004000L, 0x20000000L, 0x00004010L,
+	0x00000000L, 0x00400010L, 0x20004010L, 0x00004000L,
+	0x00404000L, 0x20004010L, 0x00000010L, 0x20400010L,
+	0x20400010L, 0x00000000L, 0x00404010L, 0x20404000L,
+	0x00004010L, 0x00404000L, 0x20404000L, 0x20000000L,
+	0x20004000L, 0x00000010L, 0x20400010L, 0x00404000L,
+	0x20404010L, 0x00400000L, 0x00004010L, 0x20000010L,
+	0x00400000L, 0x20004000L, 0x20000000L, 0x00004010L,
+	0x20000010L, 0x20404010L, 0x00404000L, 0x20400000L,
+	0x00404010L, 0x20404000L, 0x00000000L, 0x20400010L,
+	0x00000010L, 0x00004000L, 0x20400000L, 0x00404010L,
+	0x00004000L, 0x00400010L, 0x20004010L, 0x00000000L,
+	0x20404000L, 0x20000000L, 0x00400010L, 0x20004010L };
+
+static unsigned long SP7[64] = {
+	0x00200000L, 0x04200002L, 0x04000802L, 0x00000000L,
+	0x00000800L, 0x04000802L, 0x00200802L, 0x04200800L,
+	0x04200802L, 0x00200000L, 0x00000000L, 0x04000002L,
+	0x00000002L, 0x04000000L, 0x04200002L, 0x00000802L,
+	0x04000800L, 0x00200802L, 0x00200002L, 0x04000800L,
+	0x04000002L, 0x04200000L, 0x04200800L, 0x00200002L,
+	0x04200000L, 0x00000800L, 0x00000802L, 0x04200802L,
+	0x00200800L, 0x00000002L, 0x04000000L, 0x00200800L,
+	0x04000000L, 0x00200800L, 0x00200000L, 0x04000802L,
+	0x04000802L, 0x04200002L, 0x04200002L, 0x00000002L,
+	0x00200002L, 0x04000000L, 0x04000800L, 0x00200000L,
+	0x04200800L, 0x00000802L, 0x00200802L, 0x04200800L,
+	0x00000802L, 0x04000002L, 0x04200802L, 0x04200000L,
+	0x00200800L, 0x00000000L, 0x00000002L, 0x04200802L,
+	0x00000000L, 0x00200802L, 0x04200000L, 0x00000800L,
+	0x04000002L, 0x04000800L, 0x00000800L, 0x00200002L };
+
+static unsigned long SP8[64] = {
+	0x10001040L, 0x00001000L, 0x00040000L, 0x10041040L,
+	0x10000000L, 0x10001040L, 0x00000040L, 0x10000000L,
+	0x00040040L, 0x10040000L, 0x10041040L, 0x00041000L,
+	0x10041000L, 0x00041040L, 0x00001000L, 0x00000040L,
+	0x10040000L, 0x10000040L, 0x10001000L, 0x00001040L,
+	0x00041000L, 0x00040040L, 0x10040040L, 0x10041000L,
+	0x00001040L, 0x00000000L, 0x00000000L, 0x10040040L,
+	0x10000040L, 0x10001000L, 0x00041040L, 0x00040000L,
+	0x00041040L, 0x00040000L, 0x10041000L, 0x00001000L,
+	0x00000040L, 0x10040040L, 0x00001000L, 0x00041040L,
+	0x10001000L, 0x00000040L, 0x10000040L, 0x10040000L,
+	0x10040040L, 0x10000000L, 0x00040000L, 0x10001040L,
+	0x00000000L, 0x10041040L, 0x00040040L, 0x10000040L,
+	0x10040000L, 0x10001000L, 0x10001040L, 0x00000000L,
+	0x10041040L, 0x00041000L, 0x00041000L, 0x00001040L,
+	0x00001040L, 0x00040040L, 0x10000000L, 0x10041000L };
+
+static void desfunc(block, keys)
+register unsigned long *block, *keys;
+{
+	register unsigned long fval, work, right, leftt;
+	register int round;
+
+	leftt = block[0];
+	right = block[1];
+	work = ((leftt >> 4) ^ right) & 0x0f0f0f0fL;
+	right ^= work;
+	leftt ^= (work << 4);
+	work = ((leftt >> 16) ^ right) & 0x0000ffffL;
+	right ^= work;
+	leftt ^= (work << 16);
+	work = ((right >> 2) ^ leftt) & 0x33333333L;
+	leftt ^= work;
+	right ^= (work << 2);
+	work = ((right >> 8) ^ leftt) & 0x00ff00ffL;
+	leftt ^= work;
+	right ^= (work << 8);
+	right = ((right << 1) | ((right >> 31) & 1L)) & 0xffffffffL;
+	work = (leftt ^ right) & 0xaaaaaaaaL;
+	leftt ^= work;
+	right ^= work;
+	leftt = ((leftt << 1) | ((leftt >> 31) & 1L)) & 0xffffffffL;
+
+	for( round = 0; round < 8; round++ ) {
+		work  = (right << 28) | (right >> 4);
+		work ^= *keys++;
+		fval  = SP7[ work		 & 0x3fL];
+		fval |= SP5[(work >>  8) & 0x3fL];
+		fval |= SP3[(work >> 16) & 0x3fL];
+		fval |= SP1[(work >> 24) & 0x3fL];
+		work  = right ^ *keys++;
+		fval |= SP8[ work		 & 0x3fL];
+		fval |= SP6[(work >>  8) & 0x3fL];
+		fval |= SP4[(work >> 16) & 0x3fL];
+		fval |= SP2[(work >> 24) & 0x3fL];
+		leftt ^= fval;
+		work  = (leftt << 28) | (leftt >> 4);
+		work ^= *keys++;
+		fval  = SP7[ work		 & 0x3fL];
+		fval |= SP5[(work >>  8) & 0x3fL];
+		fval |= SP3[(work >> 16) & 0x3fL];
+		fval |= SP1[(work >> 24) & 0x3fL];
+		work  = leftt ^ *keys++;
+		fval |= SP8[ work		 & 0x3fL];
+		fval |= SP6[(work >>  8) & 0x3fL];
+		fval |= SP4[(work >> 16) & 0x3fL];
+		fval |= SP2[(work >> 24) & 0x3fL];
+		right ^= fval;
+		}
+
+	right = (right << 31) | (right >> 1);
+	work = (leftt ^ right) & 0xaaaaaaaaL;
+	leftt ^= work;
+	right ^= work;
+	leftt = (leftt << 31) | (leftt >> 1);
+	work = ((leftt >> 8) ^ right) & 0x00ff00ffL;
+	right ^= work;
+	leftt ^= (work << 8);
+	work = ((leftt >> 2) ^ right) & 0x33333333L;
+	right ^= work;
+	leftt ^= (work << 2);
+	work = ((right >> 16) ^ leftt) & 0x0000ffffL;
+	leftt ^= work;
+	right ^= (work << 16);
+	work = ((right >> 4) ^ leftt) & 0x0f0f0f0fL;
+	leftt ^= work;
+	right ^= (work << 4);
+	*block++ = right;
+	*block = leftt;
+	return;
+	}
+
+/* Validation sets:
+ *
+ * Single-length key, single-length plaintext -
+ * Key	  : 0123 4567 89ab cdef
+ * Plain  : 0123 4567 89ab cde7
+ * Cipher : c957 4425 6a5e d31d
+ *
+ * Double-length key, single-length plaintext -
+ * Key	  : 0123 4567 89ab cdef fedc ba98 7654 3210
+ * Plain  : 0123 4567 89ab cde7
+ * Cipher : 7f1d 0a77 826b 8aff
+ *
+ * Double-length key, double-length plaintext -
+ * Key	  : 0123 4567 89ab cdef fedc ba98 7654 3210
+ * Plain  : 0123 4567 89ab cdef 0123 4567 89ab cdff
+ * Cipher : 27a0 8440 406a df60 278f 47cf 42d6 15d7
+ *
+ * Triple-length key, single-length plaintext -
+ * Key	  : 0123 4567 89ab cdef fedc ba98 7654 3210 89ab cdef 0123 4567
+ * Plain  : 0123 4567 89ab cde7
+ * Cipher : de0b 7c06 ae5e 0ed5
+ *
+ * Triple-length key, double-length plaintext -
+ * Key	  : 0123 4567 89ab cdef fedc ba98 7654 3210 89ab cdef 0123 4567
+ * Plain  : 0123 4567 89ab cdef 0123 4567 89ab cdff
+ * Cipher : ad0d 1b30 ac17 cf07 0ed1 1c63 81e4 4de5
+ *
+ * d3des V5.0a rwo 9208.07 18:44 Graven Imagery
+ **********************************************************************/

Added: trunk/freenx-server/nxviewer-passwd/libvncauth/d3des.h
===================================================================
--- trunk/freenx-server/nxviewer-passwd/libvncauth/d3des.h	2008-03-14 17:45:36 UTC (rev 527)
+++ trunk/freenx-server/nxviewer-passwd/libvncauth/d3des.h	2008-03-14 17:54:12 UTC (rev 528)
@@ -0,0 +1,51 @@
+/*
+ * This is D3DES (V5.09) by Richard Outerbridge with the double and
+ * triple-length support removed for use in VNC.
+ *
+ * These changes are:
+ *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
+ *
+ * This software is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/* d3des.h -
+ *
+ *	Headers and defines for d3des.c
+ *	Graven Imagery, 1992.
+ *
+ * Copyright (c) 1988,1989,1990,1991,1992 by Richard Outerbridge
+ *	(GEnie : OUTER; CIS : [71755,204])
+ */
+
+#define EN0	0	/* MODE == encrypt */
+#define DE1	1	/* MODE == decrypt */
+
+extern void deskey(unsigned char *, int);
+/*		      hexkey[8]     MODE
+ * Sets the internal key register according to the hexadecimal
+ * key contained in the 8 bytes of hexkey, according to the DES,
+ * for encryption or decryption according to MODE.
+ */
+
+extern void usekey(unsigned long *);
+/*		    cookedkey[32]
+ * Loads the internal key register with the data in cookedkey.
+ */
+
+extern void cpkey(unsigned long *);
+/*		   cookedkey[32]
+ * Copies the contents of the internal key register into the storage
+ * located at &cookedkey[0].
+ */
+
+extern void des(unsigned char *, unsigned char *);
+/*		    from[8]	      to[8]
+ * Encrypts/Decrypts (according to the key currently loaded in the
+ * internal key register) one block of eight bytes at address 'from'
+ * into the block at address 'to'.  They can be the same.
+ */
+
+/* d3des.h V5.09 rwo 9208.04 15:06 Graven Imagery
+ ********************************************************************/

Added: trunk/freenx-server/nxviewer-passwd/libvncauth/vncauth.c
===================================================================
--- trunk/freenx-server/nxviewer-passwd/libvncauth/vncauth.c	2008-03-14 17:45:36 UTC (rev 527)
+++ trunk/freenx-server/nxviewer-passwd/libvncauth/vncauth.c	2008-03-14 17:54:12 UTC (rev 528)
@@ -0,0 +1,247 @@
+/*
+ *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
+ *
+ *  This is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This software is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
+ *  USA.
+ */
+
+/*
+ * vncauth.c - Functions for VNC password management and authentication.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <vncauth.h>
+#include <d3des.h>
+
+
+/*
+ * Make sure we call srandom() only once.
+ */
+
+static int s_srandom_called = 0;
+
+/*
+ * We use a fixed key to store passwords, since we assume that our local
+ * file system is secure but nonetheless don't want to store passwords
+ * as plaintext.
+ */
+
+static unsigned char s_fixedkey[8] = {23,82,107,6,35,78,88,7};
+
+
+/*
+ * Encrypt a password and store it in a file.  Returns 0 if successful,
+ * 1 if the file could not be written.
+ *
+ * NOTE: This function is preserved only for compatibility with the original
+ * AT&T VNC software.  Use vncEncryptAndStorePasswd2() instead.
+ */
+
+int
+vncEncryptAndStorePasswd(char *passwd, char *fname)
+{
+    return (vncEncryptAndStorePasswd2(passwd, NULL, fname) == 0);
+}
+
+/*
+ * Encrypt one or two passwords and store them in a file.  Returns 1 if
+ * successful, 0 if the file could not be written (note that the original
+ * vncEncryptAndStorePasswd() function returns inverse values).  The
+ * passwdViewOnly pointer may be NULL.
+ *
+ * NOTE: The file name of "-" denotes stdout.
+ */
+
+int
+vncEncryptAndStorePasswd2(char *passwd, char *passwdViewOnly, char *fname)
+{
+    FILE *fp;
+    int i, bytesToWrite, bytesWrote;
+    unsigned char encryptedPasswd[16] = {
+	0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0
+    };
+
+    if (strcmp(fname, "-") != 0) {
+      fp = fopen(fname, "w");
+      if (fp == NULL) {
+	return 0;
+      }
+      chmod(fname, S_IRUSR|S_IWUSR);
+    } else {
+      fp = stdout;
+    }
+
+    strncpy(encryptedPasswd, passwd, 8);
+    if (passwdViewOnly != NULL)
+	strncpy(encryptedPasswd + 8, passwdViewOnly, 8);
+
+    /* Do encryption in-place - this way we overwrite our copies of
+       plaintext passwords. */
+
+    deskey(s_fixedkey, EN0);
+    des(encryptedPasswd, encryptedPasswd);
+    if (passwdViewOnly != NULL)
+	des(encryptedPasswd + 8, encryptedPasswd + 8);
+
+    bytesToWrite = (passwdViewOnly == NULL) ? 8 : 16;
+    bytesWrote = fwrite(encryptedPasswd, 1, bytesToWrite, fp);
+  
+    if (fp != stdout) {
+      fclose(fp);
+    }
+    return (bytesWrote == bytesToWrite);
+}
+
+
+/*
+ * Decrypt a password from a file.  Returns a pointer to a newly allocated
+ * string containing the password or a null pointer if the password could
+ * not be retrieved for some reason.
+ *
+ * NOTE: This function is preserved only for compatibility with the original
+ * AT&T VNC software.  Use vncDecryptPasswdFromFile2() instead.
+ */
+
+char *
+vncDecryptPasswdFromFile(char *fname)
+{
+    char *passwd;
+
+    passwd = malloc(9);
+
+    if (passwd != NULL) {
+	if (vncDecryptPasswdFromFile2(fname, passwd, NULL) == 0) {
+	    free(passwd);
+	    passwd = NULL;
+	}
+    }
+
+    return passwd;
+}
+
+/*
+ * Decrypt one or two passwords from a file.  Returns the number of
+ * passwords read (1, 2, or 0 on error).  On success, the passwords are
+ * written into buffers passwdFullControl[] and passwdViewOnly[] if
+ * they are not NULL.  If the pointers to buffers are not NULL, then
+ * the buffers should be at least of 9 bytes length.
+ */
+
+int
+vncDecryptPasswdFromFile2(char *fname,
+			  char *passwdFullControl, char *passwdViewOnly)
+{
+    FILE *fp;
+    int i, ch;
+    char passwd[16];
+
+    if (strcmp(fname, "-") != 0) {
+	if ((fp = fopen(fname,"r")) == NULL)
+	    return 0;		/* Could not open the file */
+    } else {
+	fp = stdin;
+    }
+
+    for (i = 0; i < 16; i++) {
+	ch = getc(fp);
+	if (ch == EOF)
+	    break;
+	passwd[i] = ch;
+    }
+
+    if (fp != stdin)
+	fclose(fp);
+
+    if (i < 8)
+	return 0;		/* Could not read eight bytes */
+
+    deskey(s_fixedkey, DE1);
+
+    /* Decoding first (full-control) password */
+    if (passwdFullControl != NULL) {
+	des(passwd, passwd);
+	memcpy(passwdFullControl, passwd, 8);
+	passwdFullControl[8] = '\0';
+    }
+
+    /* Decoding second (view-only) password if available */
+    if (i == 16 && passwdViewOnly != NULL) {
+	des(&passwd[8], &passwd[8]);
+	memcpy(passwdViewOnly, &passwd[8], 8);
+	passwdViewOnly[8] = '\0';
+    }
+
+    /* Destroying our copy of clear-text passwords */
+    memset(passwd, 0, 16);
+
+    return (i < 16) ? 1 : 2;
+}
+
+
+/*
+ * Generate CHALLENGESIZE random bytes for use in challenge-response
+ * authentication.
+ */
+
+void
+vncRandomBytes(unsigned char *bytes)
+{
+    int i;
+    unsigned int seed;
+
+    if (!s_srandom_called) {
+      seed = (unsigned int)time(0) ^ (unsigned int)getpid();
+      srandom(seed);
+      s_srandom_called = 1;
+    }
+
+    for (i = 0; i < CHALLENGESIZE; i++) {
+	bytes[i] = (unsigned char)(random() & 255);    
+    }
+}
+
+
+/*
+ * Encrypt CHALLENGESIZE bytes in memory using a password.
+ */
+
+void
+vncEncryptBytes(unsigned char *bytes, char *passwd)
+{
+    unsigned char key[8];
+    int i;
+
+    /* key is simply password padded with nulls */
+
+    for (i = 0; i < 8; i++) {
+	if (i < strlen(passwd)) {
+	    key[i] = passwd[i];
+	} else {
+	    key[i] = 0;
+	}
+    }
+
+    deskey(key, EN0);
+
+    for (i = 0; i < CHALLENGESIZE; i += 8) {
+	des(bytes+i, bytes+i);
+    }
+}

Added: trunk/freenx-server/nxviewer-passwd/nxpasswd/Imakefile
===================================================================
--- trunk/freenx-server/nxviewer-passwd/nxpasswd/Imakefile	2008-03-14 17:45:36 UTC (rev 527)
+++ trunk/freenx-server/nxviewer-passwd/nxpasswd/Imakefile	2008-03-14 17:54:12 UTC (rev 528)
@@ -0,0 +1,13 @@
+
+#ifdef SunArchitecture
+EXTRA_DEFINES = -D__EXTENSIONS__
+#endif
+
+SRCS = vncpasswd.c
+INCLUDES = -I../include
+VNCAUTH_LIB = ../libvncauth/libvncauth.a
+
+all:: nxpasswd
+
+NormalProgramTarget(nxpasswd,vncpasswd.o,$(VNCAUTH_LIB),$(VNCAUTH_LIB),)
+DependTarget()

Added: trunk/freenx-server/nxviewer-passwd/nxpasswd/nxpasswd.man
===================================================================
--- trunk/freenx-server/nxviewer-passwd/nxpasswd/nxpasswd.man	2008-03-14 17:45:36 UTC (rev 527)
+++ trunk/freenx-server/nxviewer-passwd/nxpasswd/nxpasswd.man	2008-03-14 17:54:12 UTC (rev 528)
@@ -0,0 +1,87 @@
+'\" t
+.\" ** The above line should force tbl to be a preprocessor **
+.\" Man page for X vncpasswd
+.\"
+.\" Copyright (C) 1998 Marcus.Brinkmann at ruhr-uni-bochum.de
+.\" Copyright (C) 2000 Red Hat, Inc.
+.\" Copyright (C) 2001-2003 Constantin Kaplinsky <const at ce.cctpu.edu.ru>
+.\"
+.\" You may distribute under the terms of the GNU General Public
+.\" License as specified in the file LICENCE.TXT that comes with the
+.\" TightVNC distribution.
+.\"
+.TH vncpasswd 1 "March 2003" "" "TightVNC"
+.SH NAME
+vncpasswd \- set passwords for VNC server
+.SH SYNOPSIS
+.B vncpasswd
+.RI [\| file \|]
+.br
+.B vncpasswd
+.IR \-t
+.br
+.B vncpasswd
+.IR \-f
+.br
+.SH DESCRIPTION
+The \fBvncpasswd\fR utility should be used to create and change
+passwords for the TightVNC server authentication. \fBXvnc\fR uses such
+passwords when started with the \fB\-rfbauth\fR command-line option
+(or when started from the \fBvncserver\fR script).
+
+\fBvncpasswd\fR allows to enter either one or two passwords. The first
+password is the primary one, the second password can be used for
+view-only authentication. \fBXvnc\fR will restrict mouse and keyboard
+input from clients who authenticated with the view-only password. The
+\fBvncpasswd\fR utility asks interactively if it should set the second
+password.
+
+The password file name defaults to \fB$HOME/.vnc/passwd\fR unless the
+\fB\-t\fR command-line option was used (see the OPTIONS section
+below). The \fB$HOME/.vnc/\fR directory will be created if it does not
+exist.
+
+Each password has to be longer than five characters (unless the
+\fB\-f\fR command-line option was used, see its description below). 
+Only the first eight characters are significant. If the primary
+password is too short, the program will abort. If the view-only
+password is too short, then only the primary password will be saved.
+
+Unless a file name was provided in the command-line explicitly, this
+utility may perform certain sanity checks to prevent writing a
+password file into some hazardous place.
+
+If at least one password was saved successfully, \fBvncpasswd\fR will
+exit with status code 0. Otherwise the returned status code will be
+set to 1.
+.br
+.SH OPTIONS
+.TP
+\fB\-t\fR
+Write passwords into \fB/tmp/$USER-vnc/passwd\fR, creating the
+\fB/tmp/$USER-vnc/\fR directory if it does not exist, and checking the
+permissions on that directory (the mode must be 700). This option can
+help to improve security when your home partition may be shared via
+network (e.g. when using NFS).
+.TP
+\fB\-f\fR
+Filter mode. Read plain-text passwords from stdin, write encrypted
+versions to stdout. One or two passwords (full-control and view-only)
+can be supplied in the input stream, newline terminates a password. 
+Note that in the filter mode, short or even empty passwords will be
+silently accepted.
+.SH SEE ALSO
+\fBvncserver\fR(1), \fBXvnc\fR(1), \fBvncviewer\fR(1),
+\fBvncconnect\fR(1)
+.SH AUTHORS
+Original VNC was developed in AT&T Laboratories Cambridge. TightVNC
+additions was implemented by Constantin Kaplinsky. Many other people
+participated in development, testing and support.
+
+\fBMan page authors:\fR
+.br
+Marcus Brinkmann <Marcus.Brinkmann at ruhr-uni-bochum.de>,
+.br
+Tim Waugh <twaugh at redhat.com>,
+.br
+Constantin Kaplinsky <const at ce.cctpu.edu.ru>

Added: trunk/freenx-server/nxviewer-passwd/nxpasswd/vncpasswd.c
===================================================================
--- trunk/freenx-server/nxviewer-passwd/nxpasswd/vncpasswd.c	2008-03-14 17:45:36 UTC (rev 527)
+++ trunk/freenx-server/nxviewer-passwd/nxpasswd/vncpasswd.c	2008-03-14 17:54:12 UTC (rev 528)
@@ -0,0 +1,301 @@
+/*
+ *  Copyright (C) 2002-2003 Constantin Kaplinsky.  All Rights Reserved.
+ *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
+ *
+ *  This is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This software is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this software; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
+ *  USA.
+ */
+
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001,2006 NoMachine, http://www.nomachine.com.           */
+/*                                                                        */
+/* NXVIEWER, NX protocol compression and NX extensions to this software   */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check http://www.nomachine.com/licensing.html for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+/*
+ *  vncpasswd:  A standalone program which gets and verifies a password, 
+ *              encrypts it, and stores it to a file. Optionally, it does
+ *              the same for a second (view-only) password.  Always ignore
+ *              anything after 8 characters, since this is what Solaris
+ *              getpass() does anyway.
+ */
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include "vncauth.h"
+
+static void usage(char *argv[]);
+static char *getenv_safe(char *name, size_t maxlen);
+static void mkdir_and_check(char *dirname, int be_strict);
+static int read_password(char *result);
+static int ask_password(char *result);
+
+int main(int argc, char *argv[]) 
+{
+  int read_from_stdin = 0;
+  int make_directory = 0;
+  int check_strictly = 0;
+  char passwd1[9];
+  char passwd2[9];
+  char *passwd2_ptr;
+  char yesno[2];
+  char passwdDir[256];
+  char passwdFile[256];
+
+  if (argc == 1) {
+
+    sprintf(passwdDir, "%s/.vnc", getenv_safe("HOME", 240));
+    sprintf(passwdFile, "%s/passwd", passwdDir);
+    read_from_stdin = 0;
+    make_directory = 1;
+    check_strictly = 0;
+
+  } else if (argc == 2 || argc == 3) {
+
+    if (strcmp(argv[1], "-t") == 0) {
+      sprintf(passwdDir, "/tmp/%s-vnc", getenv_safe("USER", 32));
+      sprintf(passwdFile, "%s/passwd", passwdDir);
+      read_from_stdin = 0;
+      make_directory = 1;
+      check_strictly = 1;
+    } else if (strcmp(argv[1], "-f") == 0) {
+      strcpy(passwdFile, "-");
+      read_from_stdin = 1;
+      make_directory = 0;
+      check_strictly = 0;
+    } else {
+      if (strlen(argv[1]) > 255) {
+        fprintf(stderr, "Error: file name too long\n");
+        exit(1);
+      }
+      strcpy(passwdFile, argv[1]);
+      read_from_stdin = 1;
+      make_directory = 0;
+      check_strictly = 0;
+    }
+
+  } else {
+      usage(argv);
+  }
+
+  if (make_directory) {
+    fprintf(stderr, "Using password file %s\n", passwdFile);
+    mkdir_and_check(passwdDir, check_strictly);
+  }
+
+  passwd2_ptr = NULL;
+
+  if (read_from_stdin) {
+
+    /* Read one or two passwords from stdin */
+    if (!read_password(passwd1)) {
+      fprintf(stderr, "Could not read password\n");
+      exit(1);
+    }
+    if (read_password(passwd2)) {
+      passwd2_ptr = passwd2;
+    }
+
+  } else {
+
+    /* Ask the primary (full-control) password. */
+    if (!ask_password(passwd1)) {
+      exit(1);
+    }
+    /* Optionally, ask the second (view-only) password. */
+    /* FIXME: Is it correct to read from stdin here? */
+    fprintf(stderr, "Would you like to enter a view-only password (y/n)? ");
+    if (fgets(yesno, 2, stdin) != NULL && strchr("Yy", yesno[0]) != NULL) {
+      if (ask_password(passwd2)) {
+        passwd2_ptr = passwd2;
+      }
+    }
+
+  }
+
+  /* Actually write the passwords. */
+  if (!vncEncryptAndStorePasswd2(passwd1, passwd2_ptr, passwdFile)) {
+    memset(passwd1, 0, strlen(passwd1));
+    memset(passwd2, 0, strlen(passwd2));
+    fprintf(stderr, "Cannot write password file %s\n", passwdFile);
+    exit(1);
+  }
+
+  /* Zero the memory. */
+  memset(passwd1, 0, strlen(passwd1));
+  memset(passwd2, 0, strlen(passwd2));
+  return 0;
+}
+
+static void usage(char *argv[])
+{
+  fprintf(stderr,
+          "Usage: %s [FILE]\n"
+          "       %s -t\n",
+          argv[0], argv[0]);
+  exit(1);
+}
+
+static char *getenv_safe(char *name, size_t maxlen)
+{
+  char *result;
+
+  result = getenv(name);
+  if (result == NULL) {
+    fprintf(stderr, "Error: no %s environment variable\n", name);
+    exit(1);
+  }
+  if (strlen(result) > maxlen) {
+    fprintf(stderr, "Error: %s environment variable string too long\n", name);
+    exit(1);
+  }
+  return result;
+}
+
+/*
+ * Check if the specified vnc directory exists, create it if
+ * necessary, and perform a number of sanity checks.
+ */
+
+static void mkdir_and_check(char *dirname, int be_strict)
+{
+  struct stat stbuf;
+
+  if (lstat(dirname, &stbuf) != 0) {
+    if (errno != ENOENT) {
+      fprintf(stderr, "lstat() failed for %s: %s\n", dirname, strerror(errno));
+      exit(1);
+    }
+    fprintf(stderr, "VNC directory %s does not exist, creating.\n", dirname);
+    if (mkdir(dirname, S_IRWXU) == -1) {
+      fprintf(stderr, "Error creating directory %s: %s\n",
+              dirname, strerror(errno));
+      exit(1);
+    }
+  }
+
+  if (lstat(dirname, &stbuf) != 0) {
+    fprintf(stderr, "Error in lstat() for %s: %s\n", dirname, strerror(errno));
+    exit(1);
+  }
+  if (!S_ISDIR(stbuf.st_mode)) {
+    fprintf(stderr, "Error: %s is not a directory\n", dirname);
+    exit(1);
+  }
+  if (stbuf.st_uid != getuid()) {
+    fprintf(stderr, "Error: bad ownership on %s\n", dirname);
+    exit(1);
+  }
+  if (be_strict && ((S_IRWXG|S_IRWXO) & stbuf.st_mode)){
+    fprintf(stderr, "Error: bad access modes on %s\n", dirname);
+    exit(1);
+  }
+}
+
+/*
+ * Read a password from stdin. The password is terminated either by an
+ * end of line, or by the end of stdin data. Return 1 on success, 0 on
+ * error. On success, the password will be stored in the specified
+ * 9-byte buffer.
+ */
+
+static int read_password(char *result)
+{
+  char passwd[256];
+  char *ptr;
+
+  /* Try to read the password. */
+  if (fgets(passwd, 256, stdin) == NULL)
+    return 0;
+
+  /* Remove the newline if present. */
+  ptr = strchr(passwd, '\n');
+  if (ptr != NULL)
+    *ptr = '\0';
+
+  /* Truncate if necessary. */
+  if (strlen(passwd) > 8) {
+    memset(passwd + 8, 0, strlen(passwd) - 8);
+    fprintf(stderr, "Warning: password truncated to the length of 8.\n");
+  }
+
+  /* Save the password and zero our copies. */
+  strcpy(result, passwd);
+  memset(passwd, 0, strlen(passwd));
+
+  return 1;
+}
+
+/*
+ * Ask a password, check its length and ask to confirm it once more. 
+ * Return 1 on success, 0 on error. On success, the password will be
+ * stored in the specified 9-byte buffer.
+ */
+
+static int ask_password(char *result)
+{
+  char *passwd;
+  char passwd_copy[9];
+
+  while (1) {  
+    passwd = getpass("Password: ");
+    if (!passwd) {
+      fprintf(stderr, "Can't get password: not a tty?\n");
+      return 0;
+    }   
+    if (strlen(passwd) < 5) {
+      fprintf(stderr, "Password too short\n");
+      return 0;
+    }   
+    if (strlen(passwd) > 8) {
+      memset(passwd + 8, 0, strlen(passwd) - 8);
+      fprintf(stderr, "Warning: password truncated to the length of 8.\n");
+    }
+
+    strcpy(passwd_copy, passwd);
+
+    passwd = getpass("Verify:   ");
+    if (strlen(passwd) > 8)
+      memset(passwd + 8, 0, strlen(passwd) - 8);
+
+    if (strcmp(passwd, passwd_copy) == 0)
+      break;                    /* success */
+
+    fprintf(stderr,"Passwords do not match. Please try again.\n\n");
+  }
+
+  /* Save the password and zero our copies. */
+  strcpy(result, passwd);
+  memset(passwd, 0, strlen(passwd));
+  memset(passwd_copy, 0, strlen(passwd_copy));
+
+  return 1;
+}

Added: trunk/freenx-server/nxviewer-passwd/nxpasswd/vncpasswd.c.NX.original
===================================================================
--- trunk/freenx-server/nxviewer-passwd/nxpasswd/vncpasswd.c.NX.original	2008-03-14 17:45:36 UTC (rev 527)
+++ trunk/freenx-server/nxviewer-passwd/nxpasswd/vncpasswd.c.NX.original	2008-03-14 17:54:12 UTC (rev 528)
@@ -0,0 +1,301 @@
+/*
+ *  Copyright (C) 2002-2003 Constantin Kaplinsky.  All Rights Reserved.
+ *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
+ *
+ *  This is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This software is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this software; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
+ *  USA.
+ */
+
+/**************************************************************************/
+/*                                                                        */
+/* Copyright (c) 2001,2006 NoMachine, http://www.nomachine.com.           */
+/*                                                                        */
+/* NXVIEWER, NX protocol compression and NX extensions to this software   */
+/* are copyright of NoMachine. Redistribution and use of the present      */
+/* software is allowed according to terms specified in the file LICENSE   */
+/* which comes in the source distribution.                                */
+/*                                                                        */
+/* Check http://www.nomachine.com/licensing.html for applicability.       */
+/*                                                                        */
+/* NX and NoMachine are trademarks of Medialogic S.p.A.                   */
+/*                                                                        */
+/* All rights reserved.                                                   */
+/*                                                                        */
+/**************************************************************************/
+
+/*
+ *  vncpasswd:  A standalone program which gets and verifies a password, 
+ *              encrypts it, and stores it to a file. Optionally, it does
+ *              the same for a second (view-only) password.  Always ignore
+ *              anything after 8 characters, since this is what Solaris
+ *              getpass() does anyway.
+ */
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include "vncauth.h"
+
+static void usage(char *argv[]);
+static char *getenv_safe(char *name, size_t maxlen);
+static void mkdir_and_check(char *dirname, int be_strict);
+static int read_password(char *result);
+static int ask_password(char *result);
+
+int main(int argc, char *argv[]) 
+{
+  int read_from_stdin = 0;
+  int make_directory = 0;
+  int check_strictly = 0;
+  char passwd1[9];
+  char passwd2[9];
+  char *passwd2_ptr;
+  char yesno[2];
+  char passwdDir[256];
+  char passwdFile[256];
+
+  if (argc == 1) {
+
+    sprintf(passwdDir, "%s/.vnc", getenv_safe("HOME", 240));
+    sprintf(passwdFile, "%s/passwd", passwdDir);
+    read_from_stdin = 0;
+    make_directory = 1;
+    check_strictly = 0;
+
+  } else if (argc == 2 || argc == 3) {
+
+    if (strcmp(argv[1], "-t") == 0) {
+      sprintf(passwdDir, "/tmp/%s-vnc", getenv_safe("USER", 32));
+      sprintf(passwdFile, "%s/passwd", passwdDir);
+      read_from_stdin = 0;
+      make_directory = 1;
+      check_strictly = 1;
+    } else if (strcmp(argv[1], "-f") == 0) {
+      strcpy(passwdFile, "-");
+      read_from_stdin = 1;
+      make_directory = 0;
+      check_strictly = 0;
+    } else {
+      if (strlen(argv[1]) > 255) {
+        fprintf(stderr, "Error: file name too long\n");
+        exit(1);
+      }
+      strcpy(passwdFile, argv[1]);
+      read_from_stdin = 1;
+      make_directory = 0;
+      check_strictly = 0;
+    }
+
+  } else {
+      usage(argv);
+  }
+
+  if (make_directory) {
+    fprintf(stderr, "Using password file %s\n", passwdFile);
+    mkdir_and_check(passwdDir, check_strictly);
+  }
+
+  passwd2_ptr = NULL;
+
+  if (read_from_stdin) {
+
+    /* Read one or two passwords from stdin */
+    if (!read_password(passwd1)) {
+      fprintf(stderr, "Could not read password\n");
+      exit(1);
+    }
+    if (read_password(passwd2)) {
+      passwd2_ptr = passwd2;
+    }
+
+  } else {
+
+    /* Ask the primary (full-control) password. */
+    if (!ask_password(passwd1)) {
+      exit(1);
+    }
+    /* Optionally, ask the second (view-only) password. */
+    /* FIXME: Is it correct to read from stdin here? */
+    fprintf(stderr, "Would you like to enter a view-only password (y/n)? ");
+    if (fgets(yesno, 2, stdin) != NULL && strchr("Yy", yesno[0]) != NULL) {
+      if (ask_password(passwd2)) {
+        passwd2_ptr = passwd2;
+      }
+    }
+
+  }
+
+  /* Actually write the passwords. */
+  if (!vncEncryptAndStorePasswd2(passwd1, passwd2_ptr, passwdFile)) {
+    memset(passwd1, 0, strlen(passwd1));
+    memset(passwd2, 0, strlen(passwd2));
+    fprintf(stderr, "Cannot write password file %s\n", passwdFile);
+    exit(1);
+  }
+
+  /* Zero the memory. */
+  memset(passwd1, 0, strlen(passwd1));
+  memset(passwd2, 0, strlen(passwd2));
+  return 0;
+}
+
+static void usage(char *argv[])
+{
+  fprintf(stderr,
+          "Usage: %s [FILE]\n"
+          "       %s -t\n",
+          argv[0], argv[0]);
+  exit(1);
+}
+
+static char *getenv_safe(char *name, size_t maxlen)
+{
+  char *result;
+
+  result = getenv(name);
+  if (result == NULL) {
+    fprintf(stderr, "Error: no %s environment variable\n", name);
+    exit(1);
+  }
+  if (strlen(result) > maxlen) {
+    fprintf(stderr, "Error: %s environment variable string too long\n", name);
+    exit(1);
+  }
+  return result;
+}
+
+/*
+ * Check if the specified vnc directory exists, create it if
+ * necessary, and perform a number of sanity checks.
+ */
+
+static void mkdir_and_check(char *dirname, int be_strict)
+{
+  struct stat stbuf;
+
+  if (lstat(dirname, &stbuf) != 0) {
+    if (errno != ENOENT) {
+      fprintf(stderr, "lstat() failed for %s: %s\n", dirname, strerror(errno));
+      exit(1);
+    }
+    fprintf(stderr, "VNC directory %s does not exist, creating.\n", dirname);
+    if (mkdir(dirname, S_IRWXU) == -1) {
+      fprintf(stderr, "Error creating directory %s: %s\n",
+              dirname, strerror(errno));
+      exit(1);
+    }
+  }
+
+  if (lstat(dirname, &stbuf) != 0) {
+    fprintf(stderr, "Error in lstat() for %s: %s\n", dirname, strerror(errno));
+    exit(1);
+  }
+  if (!S_ISDIR(stbuf.st_mode)) {
+    fprintf(stderr, "Error: %s is not a directory\n", dirname);
+    exit(1);
+  }
+  if (stbuf.st_uid != getuid()) {
+    fprintf(stderr, "Error: bad ownership on %s\n", dirname);
+    exit(1);
+  }
+  if (be_strict && ((S_IRWXG|S_IRWXO) & stbuf.st_mode)){
+    fprintf(stderr, "Error: bad access modes on %s\n", dirname);
+    exit(1);
+  }
+}
+
+/*
+ * Read a password from stdin. The password is terminated either by an
+ * end of line, or by the end of stdin data. Return 1 on success, 0 on
+ * error. On success, the password will be stored in the specified
+ * 9-byte buffer.
+ */
+
+static int read_password(char *result)
+{
+  char passwd[256];
+  char *ptr;
+
+  /* Try to read the password. */
+  if (fgets(passwd, 256, stdin) == NULL)
+    return 0;
+
+  /* Remove the newline if present. */
+  ptr = strchr(passwd, '\n');
+  if (ptr != NULL)
+    *ptr = '\0';
+
+  /* Truncate if necessary. */
+  if (strlen(passwd) > 8) {
+    memset(passwd + 8, 0, strlen(passwd) - 8);
+    fprintf(stderr, "Warning: password truncated to the length of 8.\n");
+  }
+
+  /* Save the password and zero our copies. */
+  strcpy(result, passwd);
+  memset(passwd, 0, strlen(passwd));
+
+  return 1;
+}
+
+/*
+ * Ask a password, check its length and ask to confirm it once more. 
+ * Return 1 on success, 0 on error. On success, the password will be
+ * stored in the specified 9-byte buffer.
+ */
+
+static int ask_password(char *result)
+{
+  char *passwd;
+  char passwd_copy[9];
+
+  while (1) {  
+    passwd = getpass("Password: ");
+    if (!passwd) {
+      fprintf(stderr, "Can't get password: not a tty?\n");
+      return 0;
+    }   
+    if (strlen(passwd) < 5) {
+      fprintf(stderr, "Password too short\n");
+      return 0;
+    }   
+    if (strlen(passwd) > 8) {
+      memset(passwd + 8, 0, strlen(passwd) - 8);
+      fprintf(stderr, "Warning: password truncated to the length of 8.\n");
+    }
+
+    strcpy(passwd_copy, passwd);
+
+    passwd = getpass("Verify:   ");
+    if (strlen(passwd) > 8)
+      memset(passwd + 8, 0, strlen(passwd) - 8);
+
+    if (strcmp(passwd, passwd_copy) == 0)
+      break;                    /* success */
+
+    fprintf(stderr,"Passwords do not match. Please try again.\n\n");
+  }
+
+  /* Save the password and zero our copies. */
+  strcpy(result, passwd);
+  memset(passwd, 0, strlen(passwd));
+  memset(passwd_copy, 0, strlen(passwd_copy));
+
+  return 1;
+}

Added: trunk/freenx-server/nxviewer-passwd/nxpasswd/vncpasswd.c.TIGHTVNC.original
===================================================================
--- trunk/freenx-server/nxviewer-passwd/nxpasswd/vncpasswd.c.TIGHTVNC.original	2008-03-14 17:45:36 UTC (rev 527)
+++ trunk/freenx-server/nxviewer-passwd/nxpasswd/vncpasswd.c.TIGHTVNC.original	2008-03-14 17:54:12 UTC (rev 528)
@@ -0,0 +1,286 @@
+/*
+ *  Copyright (C) 2002-2003 Constantin Kaplinsky.  All Rights Reserved.
+ *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
+ *
+ *  This is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This software is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this software; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
+ *  USA.
+ */
+
+/*
+ *  vncpasswd:  A standalone program which gets and verifies a password, 
+ *              encrypts it, and stores it to a file.  Optionally, it does
+ *              the same for a second (view-only) password.  Always ignore
+ *              anything after 8 characters, since this is what Solaris
+ *              getpass() does anyway.
+ */
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <errno.h>
+#include "vncauth.h"
+
+static void usage(char *argv[]);
+static char *getenv_safe(char *name, size_t maxlen);
+static void mkdir_and_check(char *dirname, int be_strict);
+static int read_password(char *result);
+static int ask_password(char *result);
+
+int main(int argc, char *argv[])
+{
+  int read_from_stdin = 0;
+  int make_directory = 0;
+  int check_strictly = 0;
+  char passwd1[9];
+  char passwd2[9];
+  char *passwd2_ptr;
+  char yesno[2];
+  char passwdDir[256];
+  char passwdFile[256];
+  int i;
+
+  if (argc == 1) {
+
+    sprintf(passwdDir, "%s/.vnc", getenv_safe("HOME", 240));
+    sprintf(passwdFile, "%s/passwd", passwdDir);
+    read_from_stdin = 0;
+    make_directory = 1;
+    check_strictly = 0;
+
+  } else if (argc == 2) {
+
+    if (strcmp(argv[1], "-t") == 0) {
+      sprintf(passwdDir, "/tmp/%s-vnc", getenv_safe("USER", 32));
+      sprintf(passwdFile, "%s/passwd", passwdDir);
+      read_from_stdin = 0;
+      make_directory = 1;
+      check_strictly = 1;
+    } else if (strcmp(argv[1], "-f") == 0) {
+      strcpy(passwdFile, "-");
+      read_from_stdin = 1;
+      make_directory = 0;
+      check_strictly = 0;
+    } else {
+      if (strlen(argv[1]) > 255) {
+        fprintf(stderr, "Error: file name too long\n");
+        exit(1);
+      }
+      strcpy(passwdFile, argv[1]);
+      read_from_stdin = 0;
+      make_directory = 0;
+      check_strictly = 0;
+    }
+
+  } else {
+    usage(argv);
+  }
+
+  if (make_directory) {
+    fprintf(stderr, "Using password file %s\n", passwdFile);
+    mkdir_and_check(passwdDir, check_strictly);
+  }
+
+  passwd2_ptr = NULL;
+
+  if (read_from_stdin) {
+
+    /* Read one or two passwords from stdin */
+    if (!read_password(passwd1)) {
+      fprintf(stderr, "Could not read password\n");
+      exit(1);
+    }
+    if (read_password(passwd2)) {
+      passwd2_ptr = passwd2;
+    }
+
+  } else {
+
+    /* Ask the primary (full-control) password. */
+    if (!ask_password(passwd1)) {
+      exit(1);
+    }
+    /* Optionally, ask the second (view-only) password. */
+    /* FIXME: Is it correct to read from stdin here? */
+    fprintf(stderr, "Would you like to enter a view-only password (y/n)? ");
+    if (fgets(yesno, 2, stdin) != NULL && strchr("Yy", yesno[0]) != NULL) {
+      if (ask_password(passwd2)) {
+        passwd2_ptr = passwd2;
+      }
+    }
+
+  }
+
+  /* Actually write the passwords. */
+  if (!vncEncryptAndStorePasswd2(passwd1, passwd2_ptr, passwdFile)) {
+    memset(passwd1, 0, strlen(passwd1));
+    memset(passwd2, 0, strlen(passwd2));
+    fprintf(stderr, "Cannot write password file %s\n", passwdFile);
+    exit(1);
+  }
+
+  /* Zero the memory. */
+  memset(passwd1, 0, strlen(passwd1));
+  memset(passwd2, 0, strlen(passwd2));
+  return 0;
+}
+
+static void usage(char *argv[])
+{
+  fprintf(stderr,
+          "Usage: %s [FILE]\n"
+          "       %s -t\n",
+          argv[0], argv[0], argv[0]);
+  exit(1);
+}
+
+static char *getenv_safe(char *name, size_t maxlen)
+{
+  char *result;
+
+  result = getenv(name);
+  if (result == NULL) {
+    fprintf(stderr, "Error: no %s environment variable\n", name);
+    exit(1);
+  }
+  if (strlen(result) > maxlen) {
+    fprintf(stderr, "Error: %s environment variable string too long\n", name);
+    exit(1);
+  }
+  return result;
+}
+
+/*
+ * Check if the specified vnc directory exists, create it if
+ * necessary, and perform a number of sanity checks.
+ */
+
+static void mkdir_and_check(char *dirname, int be_strict)
+{
+  struct stat stbuf;
+
+  if (lstat(dirname, &stbuf) != 0) {
+    if (errno != ENOENT) {
+      fprintf(stderr, "lstat() failed for %s: %s\n", dirname, strerror(errno));
+      exit(1);
+    }
+    fprintf(stderr, "VNC directory %s does not exist, creating.\n", dirname);
+    if (mkdir(dirname, S_IRWXU) == -1) {
+      fprintf(stderr, "Error creating directory %s: %s\n",
+              dirname, strerror(errno));
+      exit(1);
+    }
+  }
+
+  if (lstat(dirname, &stbuf) != 0) {
+    fprintf(stderr, "Error in lstat() for %s: %s\n", dirname, strerror(errno));
+    exit(1);
+  }
+  if (!S_ISDIR(stbuf.st_mode)) {
+    fprintf(stderr, "Error: %s is not a directory\n", dirname);
+    exit(1);
+  }
+  if (stbuf.st_uid != getuid()) {
+    fprintf(stderr, "Error: bad ownership on %s\n", dirname);
+    exit(1);
+  }
+  if (be_strict && ((S_IRWXG|S_IRWXO) & stbuf.st_mode)){
+    fprintf(stderr, "Error: bad access modes on %s\n", dirname);
+    exit(1);
+  }
+}
+
+/*
+ * Read a password from stdin. The password is terminated either by an
+ * end of line, or by the end of stdin data. Return 1 on success, 0 on
+ * error. On success, the password will be stored in the specified
+ * 9-byte buffer.
+ */
+
+static int read_password(char *result)
+{
+  char passwd[256];
+  char *ptr;
+
+  /* Try to read the password. */
+  if (fgets(passwd, 256, stdin) == NULL)
+    return 0;
+
+  /* Remove the newline if present. */
+  ptr = strchr(passwd, '\n');
+  if (ptr != NULL)
+    *ptr = '\0';
+
+  /* Truncate if necessary. */
+  if (strlen(passwd) > 8) {
+    memset(passwd + 8, 0, strlen(passwd) - 8);
+    fprintf(stderr, "Warning: password truncated to the length of 8.\n");
+  }
+
+  /* Save the password and zero our copies. */
+  strcpy(result, passwd);
+  memset(passwd, 0, strlen(passwd));
+
+  return 1;
+}
+
+/*
+ * Ask a password, check its length and ask to confirm it once more. 
+ * Return 1 on success, 0 on error. On success, the password will be
+ * stored in the specified 9-byte buffer.
+ */
+
+static int ask_password(char *result)
+{
+  char *passwd;
+  char passwd_copy[9];
+
+  while (1) {  
+    passwd = getpass("Password: ");
+    if (!passwd) {
+      fprintf(stderr, "Can't get password: not a tty?\n");
+      return 0;
+    }   
+    if (strlen(passwd) < 6) {
+      fprintf(stderr, "Password too short\n");
+      return 0;
+    }   
+    if (strlen(passwd) > 8) {
+      memset(passwd + 8, 0, strlen(passwd) - 8);
+      fprintf(stderr, "Warning: password truncated to the length of 8.\n");
+    }
+
+    strcpy(passwd_copy, passwd);
+
+    passwd = getpass("Verify:   ");
+    if (strlen(passwd) > 8)
+      memset(passwd + 8, 0, strlen(passwd) - 8);
+
+    if (strcmp(passwd, passwd_copy) == 0)
+      break;                    /* success */
+
+    fprintf(stderr,"Passwords do not match. Please try again.\n\n");
+  }
+
+  /* Save the password and zero our copies. */
+  strcpy(result, passwd);
+  memset(passwd, 0, strlen(passwd));
+  memset(passwd_copy, 0, strlen(passwd_copy));
+
+  return 1;
+}



