From fabianx at berlios.de  Sun Jul  3 16:35:35 2005
From: fabianx at berlios.de (Fabian Franz at BerliOS)
Date: Sun, 3 Jul 2005 16:35:35 +0200
Subject: [Freenx-cvs] r62 - / freenx-server freenx-server/CVS
Message-ID: <200507031435.j63EZZWx005285@sheep.berlios.de>

Author: fabianx
Date: 2005-07-03 16:35:34 +0200 (Sun, 03 Jul 2005)
New Revision: 62

Added:
   freenx-server/
   freenx-server/AUTHORS
   freenx-server/CONTRIB
   freenx-server/COPYING
   freenx-server/CVS/
   freenx-server/CVS/Entries
   freenx-server/CVS/Repository
   freenx-server/CVS/Root
   freenx-server/ChangeLog
   freenx-server/INSTALL
   freenx-server/RoadMap
   freenx-server/gentoo-nomachine.diff
   freenx-server/node.conf.sample
   freenx-server/nxclient
   freenx-server/nxkeygen
   freenx-server/nxloadconfig
   freenx-server/nxnode
   freenx-server/nxnode-login
   freenx-server/nxprint
   freenx-server/nxserver
   freenx-server/nxserver.old
   freenx-server/nxsetup
Log:
Initial import of FreeNX 0.4.1.


Added: freenx-server/AUTHORS
===================================================================
--- freenx-server/AUTHORS	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/AUTHORS	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,5 @@
+Fabian Franz <freenx at fabian-franz.de>
+Rick Stout <zipsonic at gmail.com>
+Thorsten Sandfuchs <fux at users.berlios.de>
+Kurt Pfeifle <pfeifle at kde.org>
+Jon Severinsson <jonno at users.berlios.de>

Added: freenx-server/CONTRIB
===================================================================
--- freenx-server/CONTRIB	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/CONTRIB	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,81 @@
+III. How you can help
+=====================
+
+1. Documentation
+----------------
+
+Documentation and experience reports are most important of course. So if you have something send it to us ;-). (FreeNX-kNX at kde.org)
+
+2. Code and Patches
+-------------------
+
+While FreeNX is a volounteer project, it of course depends on the work of 7 years kindly donated by NoMachine to the Free Software Community: 
+
+The NX open source libraries
+
+While they are mature and very good working, they need work in some very important fields. Most "difficulties" were provided by Gian Fillipo Pinzari main developer of NoMachine NX and CEO of NoMachine.
+
+2.1 Rootless nxagent
+
+This is the most needed feature at the moment. It will allow using single applications instead of a full featured desktop. Most code needed for that is already in the nxagent source tree; its just still a bit buggy and needs some "love".
+
+Difficulty: Medium
+
+2.2 Pseudo Color / True Color support
+
+This is the second most important feature needed. With the addition of Pseudo Color / True Color, it it possible to reconnect also on different depths (which is not possible at the moment). This will also make nxagent independent of the used Visuals (as far as I've understand it).
+
+Last but not least, will this allow me to use Xvfb to keep a session running, while no display is attached to it.
+
+Difficulty: Medium
+
+2.3 XRandr support
+
+XRandr support is available since version XFree86 4.3 and also most applications already support it. XRandr support would also enable one to reconnect at different geometry sizes and you could in an ideal case also just resize the window and it would work.
+
+At reconnection stage this is really important for the fullscreen mode.
+
+Difficulty: Easy
+
+2.4 XDamage support
+
+nxagent should be also able to profit from the new XDamage extension, to allow making NX sessions again even faster. 
+
+Difficulty: Easy
+
+2.5 "Lazy image encoding"
+
+Currently images are sent at once and just limited by having a small control channel open to allow fast user interaction. It would be much better if the images would be "streamed" in a way. 
+
+Quoting GFP:
+
+"> What about doing this asynchronously? Not necessarily doing it immediately,
+> but analyzing (in parallel, the data is still sent with normal compression
+> regardless) what is seen and then biasing the type of compression over
+> time based on the "popularity" of given image characteristics for a
+> specific application or window class.
+
+This is more or less what we want to do as part of the "lazy"
+image encoding functionality that is going to be implemented.
+The main goal of the "lazy" encoding is to decouple the image
+handling from other protocol requests. The effect we want to
+achieve is similar to loading a web page, where the browser
+renders the images progressively, as they are downloaded from
+the network. Once you have images sent asynchrounously, you
+have opened the way to any form of post-processing."
+
+[TODO: This part is not yet explained enough ]
+
+2.6 Drag and Drop with automatic file transfer
+
+The idea is:
+
+Grab the X Drag And Drop requests in nxagent and advise the nxproxy on the other side to stream you the file with the filename, which you have got. The file should then be saved to a temporary location and the event given to the real application. While the file is transferred nxagent should display some kind of status bar.
+
+Difficulty: ~ Medium - Difficult
+
+2.7 Add the GLX extension
+
+Add the glx extension to nxagent and also try to remove roundtrips in GLX.
+
+Difficulty: Easy - Medium

Added: freenx-server/COPYING
===================================================================
--- freenx-server/COPYING	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/COPYING	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.

Added: freenx-server/CVS/Entries
===================================================================
--- freenx-server/CVS/Entries	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/CVS/Entries	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,16 @@
+/CONTRIB/1.1.1.1/Thu Jan 27 02:08:55 2005//
+/COPYING/1.1.1.1/Thu Jan 27 02:08:55 2005//
+/gentoo-nomachine.diff/1.14/Sat Mar 12 18:03:32 2005//
+/nxprint/1.1/Tue Mar 15 03:55:08 2005//
+/AUTHORS/1.4/Wed Mar 16 03:14:42 2005//
+/nxnode-login/1.12/Thu Mar 24 00:10:37 2005//
+/nxclient/1.5/Mon Apr 25 02:11:24 2005//
+/INSTALL/1.6/Sat Apr 30 14:37:01 2005//
+/node.conf.sample/1.28/Sun Jun 19 23:51:22 2005//
+/nxkeygen/1.12/Sun Jun 19 23:51:22 2005//
+/nxloadconfig/1.33/Sun Jun 19 23:51:22 2005//
+/nxsetup/1.28/Sun Jun 19 23:51:22 2005//
+/nxnode/1.60/Thu Jun 23 15:42:52 2005//
+/ChangeLog/1.58/Sat Jun 25 12:24:10 2005//
+/nxserver/1.55/Sat Jun 25 12:26:22 2005//
+D

Added: freenx-server/CVS/Repository
===================================================================
--- freenx-server/CVS/Repository	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/CVS/Repository	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1 @@
+freenx

Added: freenx-server/CVS/Root
===================================================================
--- freenx-server/CVS/Root	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/CVS/Root	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1 @@
+fabianx at cvs.berlios.de:/cvsroot/freenx

Added: freenx-server/ChangeLog
===================================================================
--- freenx-server/ChangeLog	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/ChangeLog	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,194 @@
+24.06.2005 FreeNX 0.4.1 "LinuxTag Edition"
+	* Fixed a small security problem giving access to session database.
+	* Added support for 1.5.0 OSS components. (especially rootless mode)
+	* Fixed Filesharing over the Internet. (Thanks to rogierm at users.berlios.de)
+	* Fixed Resume on Windows with non-fullscreen sessions.
+	* Added suspend/resume support for 1.5.0 OSS components.
+	* Fixed display of suspended sessions in nxserver --list.
+
+04.05.2005 FreeNX 0.4.0 "SambaXP Edition"
+	* Opened the 0.4.0 branch.
+	* Added initial support for filesharing via samba.
+	* Improvements to be more node.conf compatible.
+	* Added COMMAND_NETCAT, COMMAND_SSH & COMMAND_SSH_KEYGEN directive
+	* Added support for 'nxloadconfig --check' to validate node.conf 
+	  settings
+	* Added initial support for sound (esd/artsd).
+	* Added optional support for utmp/wtmp/lastlog database.
+	* Removed support for OSS components prior version 1.4.0 in nxnode.
+	  Added -option option to nxagent/nxdesktop/nxviewer.
+	* Added forwarding to commercial server via destination port.
+	* Added more compatible getparam function
+	* Sets LD_PRELOAD for applications and LD_LIBRARY_PATH for 
+	  nxagent/nxproxy by default.
+		- SET_LD_LIBRARY_PATH replaces NX_NOMACHINE_WAY and is 
+		  enabled by default, as it is now safe to do so
+	* Implemented SSHD_CHECK_IP directive.
+	* Added the SESSION_HISTORY directive. Session history will by default 
+	  be kept for 30 days.
+	* Implemented DEFAULT_X_WM for unix-application virtual desktop mode.
+	* Implemented SESSION_LIMIT and SESSION_USER_LIMIT.
+	* Fixed nxviewer commandline for geometry and fullscreen-support
+	* Added NX_LOG_LEVEL instead of NX_LOGGING, allowing less verbose 
+	  logfile.
+	* Added SESSION_LOG_CLEAN for configurable removal of the temporary 
+	  session directory.
+	* Added "--ssh2" cmdline switch for commercial ssh2-server support 
+	  in nxsetup.
+	* Added ENABLE_FORCE_ENCRYPTION to enforce the usage of encryption on 
+	  the server.
+	* Added nxprint and added -printer to nxclient together with handling
+	  of drivers cache.
+	* Fixed a possible race-condition. (reported by Edward Warnicke
+	  <eaw at cisco.com>)
+	* Feature Request #847 (stderror of some applications to log-file)
+	* Feature Request #900 (Detect ssh/sshd in nxsetup)
+	* Added printing support via userspace CUPSd and Samba.
+
+20.03.2005 FreeNX 0.3.1 "Bugfix Edition"
+	* Fixed keyboard mapping problems.
+	* Fixed unix-custom mode; now allowing parameters to be passed.
+	* Fixed password prompt detection support in nxnode-login.
+	* Fixed locking to prevent usage of the same display.
+	* Fixed resume when agent is no longer there.
+	* Fixed error message shown to user, when session startup fails.
+	* Fixed handling of /tmp/.X*-lock files.
+	* Fixed handling of not closed sessions in "Terminating" status.
+	* Fixed resume of multiple suspended sessions.
+
+05.03.2005 FreeNX 0.3.0 "Chemnitzer LinuxTage Edition"
+	* Initial CVS checkin.
+	* Added unix-default as session type - by Kalev Lember 
+	  <kalev at smartlink.ee>
+	* Fixed nxclient loop - by "Neil Wilson" <neil at aldur.co.uk>.
+	* Several fixes by Thorsten Sandfuchs <fux at users.berlios.de>.
+	* Optional config file support (system- and user-wide)
+		- by Jon Severinsson <jonno at users.berlios.de>.
+	* Moved logfile to /var/log/nxserver.log.
+	* Moved nx homedir to /var/lib/nxserver/home
+	* Complete rewrite of authentication code
+		* passdb, su or ssh is now supported.
+		- by Jon Severinsson <jonno at users.berlios.de>.
+	* Added NODE_AUTOSTART, EXPORT_{USERIP/SESSIONID} config file
+	  directives.
+	* Added mechanism to forward connection to commercial NoMachine 
+	  nxserver (as available from www.nomachine.com).
+	* Added mechanism to forward connection to another nxserver. This
+	  allows using a "chain" of nxservers.
+	* Added "floating window" support by using rootless nxagent as
+	  it will be standard in NX 1.5.0.
+	* Added "floating window" support by just nxproxy/nxproxy connection
+	  and added configuration directive to enable rootless mode.
+	* Added nxsetup --uninstall and added more feature to nxsetup.
+	  Note: You need to use nxsetup --install for installation now.
+	* Added Disabling of port-forwarding, X11-forwarding, ... to ssh-key.
+
+	* Security: Fixed a security blunder. Authority file was not used 
+	            and so basically xhost +localhost was set. (ported from
+		    0.2.8)
+		    
+		    Update immediately.
+                   
+	* Security: Fixed two possible security problems (umask was not set
+                   correctly; ported from 0.2.8)
+
+20.11.2004 FreeNX 0.2.7 "Skolelinux Edition"
+	* Fix nxserver to work again with KNX-Client. ('\r' is evil)
+	* Fix timeout in nxnode-login to allow proper session management
+	  again.
+	* Fixed possible race condition for the wait-file.
+
+11.11.2004 FreeNX 0.2.6
+	
+	* Security: Fixed a possible exploit in ssh-usage
+	    (thanx to Sebastian Krahmer from the SuSE security team)
+	* Important: Public/Private key is no longer used for PAM auth mode.
+	
+14.10.2004 FreeNX 0.2.5
+	* Added Xdialog interface for nxclient and automatic usage
+	  of commercial nxclient when available. (Thx go to Rick Stout 
+	  <zipsonic at gmail.com>)
+	* Added bugfix from the 0.3.0 branch for more flexible nxdesktop in
+	  nxnode.
+	* Added patch by Rick Stout for permission problems in nxnode.
+	* Added patch by Rick Stout for a typo in nxkeygen.
+	* Updated gentoo-nomachine.diff.
+	* Updated CONTRIB to include a description of lazy-image encoding.
+
+11.09.2004 FreeNX 0.2.4
+	* Added timeout to avoid having hanging tail processes.
+	* Added "locking" of the display-offset if nxagent failed to start.
+	* Fixed ssh encryption for resume on client 1.4.0-snapshot 5.
+	* Fixed mktemp, which was non-portable to FreeBSD and Red Hat 9.
+
+10.09.2004 FreeNX 0.2-3
+	* Added support for autoreconnection or autoreconnection just 
+	  for the case when an older client version is used.
+	  	* This makes it possible to use Reconnection with the 
+	  	  stable version 1.3.2-7 (enabled by default)
+	* Added instructions how to install the NoMachine sources to INSTALL
+	* Changed $NX_DIR/bin/ssh to ssh to fix gentoo-nomachine.diff
+	* Added nxkeygen by Stuart Herbert for easier change from the 
+	  NoMachine key to another key afterwards.
+	
+	* Security: Any user was able to change the status of other sessions
+	            in the session database by providing the correct uniqueid.
+
+10.09.2004 FreeNX 0.2-2
+	* Added additional support for safe session suspend, 
+	  autosuspend when network connection times out works now!
+	* AuthorizedKeysFile cannot be safely determined on Gentoo;
+	  changed it to config option now.
+	* Added config option to completely disable passdb support.
+	* Fixed bugs in nxclient dialog frontend.
+	* Removed all usage of nxssh due to security concerns from SuSE. 
+	* Fixed session management for knx client.
+	* Added detection of failed nxagent startup.
+	* Updated the gentoo-nomachine.diff to be not fuzzy.
+
+08.09.2004 FreeNX 0.2-1
+	* Fixed support for one windows client version. 
+	* Fixed setting of key with --adduser.
+	  (Thanks to Stuart Herbert <stuart at gentoo.org>)
+	* Fixed _some_ cases for AuthorizedKeysFile in sshd_config.
+	  (Thanks to Peter Holik <peter at holik.at>)
+
+	* Fixed gentoo-nomachine.diff (nxnode not in path, but nxnode-login would try that)
+	* Fixed the bug with hanging tail processes.
+
+07.09.2004 FreeNX 0.2-0
+	* Reworked the whole security model in nxsetup due to requests from SuSE and Gentoo.
+		- nxsetup does not use the NoMachine key by default. 
+		- PAM authentication is enabled by default.
+	
+	* Added nxclient for compatibility with nxclient -dialog mode.
+	
+	* Minor changes
+		* Added SSHD_AUTH_PORT to config vars in nxserver
+		* Made all programs NX_ aware
+		* Programs do now honor the setting of AuthorizedKeysFile in sshd_config
+		* Changed nxsetup check from direct reading of passwd to getent
+		  (Thanks to Tom Hibbert <tom at nsp.co.nz>)
+		* Changed overall messages in nxsetup
+	
+	* Made a overall clean upstream package.
+	* Added Gentoo / NoMachine compatibility diff
+
+06.09.2004 
+	* Added pam authentication
+	* Added user_db switch
+	* moved some su - to nxnode-login
+
+02.09.2004 
+	* Added support for snapshot 4 (43/66)
+	* Fixed compatibility issue with 1.3.0 
+	  (Used by Knoppix 3.4 and earlier)
+	* added sane logging (LOGGING is now properly used)
+
+20.06.2004 
+	* Added Protocol version 1.4.0
+	* Cleanup
+	* Added missing functions
+
+14.06.2004 
+	* Added Protocol version 1.3.2

Added: freenx-server/INSTALL
===================================================================
--- freenx-server/INSTALL	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/INSTALL	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,65 @@
+INTRODUCTION
+------------
+
+This is the FreeNX server package.
+
+DEPENDENCIES
+------------
+
+It depends on:
+
+- NX sources
+- X11 libraries
+- sshd
+- expect
+- netcat
+
+NOTE
+----
+
+This tarball is intented mainly for distributions, which want to use FreeNX as building the other OpenSource NX components is quite difficult.
+
+In the following sections it is outlined how to install FreeNX as soon as you've build all open source components. 
+
+HOWTO MANUALLY INSTALL
+----------------------
+
+You must apply the gentoo-nomachine.diff and then copy the files to /usr/NX/bin and /usr/NX/lib.
+
+You can use the following schema to do the install to /usr/NX/:
+
+NXPREFIX=/usr/NX
+mkdir -p ${NXPREFIX}/lib ${NXPREFIX}/bin
+
+# Libraries
+cp -a nx-X11/lib/X11/libX11.so* ${NXPREFIX}/lib
+cp -a nx-X11/lib/Xext/libXext.so* ${NXPREFIX}/lib
+cp -a nx-X11/lib/Xrender/libXrender.so* ${NXPREFIX}/lib
+cp -a nxcomp/libXcomp.so* ${NXPREFIX}/lib
+cp -a nxcompext/libXcompext.so* ${NXPREFIX}/lib
+
+# binaries
+cp -a nx-X11/programs/Xserver/nxagent ${NXPREFIX}/bin
+cp -a nxproxy/nxproxy ${NXPREFIX}/bin
+cp -a nxdesktop/nxdesktop ${NXPREFIX}/bin
+cp -a nxviewer/nxviewer/nxviewer ${NXPREFIX}/bin
+cp -a nxviewer/nxpasswd/nxpasswd ${NXPREFIX}/bin
+
+# windows-keymaps for nxdesktop RDP-sessions and keyboard layout != us
+cd nxdesktop
+make installkeymaps
+
+# scripts
+cp -a freenx*/nxnode ${NXPREFIX}/bin
+cp -a freenx*/nxserver ${NXPREFIX}/bin
+cp -a freenx*/nxsetup ${NXPREFIX}/bin
+cp -a freenx*/nxkeygen ${NXPREFIX}/bin
+cp -a freenx*/nxnode-login ${NXPREFIX}/bin
+cp -a freenx*/nxloadconfig ${NXPREFIX}/bin
+
+# config file
+cp -a freenx*/node.conf.sample ${NXPREFIX}/etc/
+
+You should also install the nxclient from NoMachine or also copy the nxclient program from freenx. 
+
+Then you need to run 'nxsetup --install' and follow the instructions given.

Added: freenx-server/RoadMap
===================================================================
--- freenx-server/RoadMap	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/RoadMap	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,21 @@
+0.4.0
+	- Samba File and Printer sharing
+	- Sound via SOUNDSERVER
+
+0.4.1
+	- Bugfixes
+	
+0.4.2
+	- Solaris Support
+	- Stability Support
+
+[Between]
+	- Umfrage zu NX (Ask Slashdot?)
+	- Dokumentation
+	
+0.5.0
+	- "Rewrite" of Session-Management
+	- Transparent Socks-Implementation
+		- Seamless printing
+		- Seamless FileSharing (fish)
+	- Transparent tunnel of devices

Added: freenx-server/gentoo-nomachine.diff
===================================================================
--- freenx-server/gentoo-nomachine.diff	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/gentoo-nomachine.diff	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,19 @@
+--- nxloadconfig.old	2005-02-14 01:08:56.482546352 +0100
++++ nxloadconfig	2005-02-14 01:09:40.109913984 +0100
+@@ -53,12 +53,12 @@
+ NX_LICENSE="OS (GPL)"
+ 
+ # Where can different nx components be found
+-NX_DIR=/usr
++NX_DIR=/usr/NX
+ PATH_BIN=$NX_DIR/bin # if you change that, be sure to also change the public keys
+ PATH_LIB=$NX_DIR/lib
+-NX_ETC_DIR=/etc/nxserver
+-NX_SESS_DIR=/var/lib/nxserver/db
+-NX_HOME_DIR=/var/lib/nxserver/home
++NX_ETC_DIR=$NX_DIR/etc
++NX_SESS_DIR=$NX_DIR/var/db
++NX_HOME_DIR=$NX_DIR/home/nx
+ 
+ # the name of the authorized keys file for ssh
+ SSH_AUTHORIZED_KEYS="authorized_keys2"

Added: freenx-server/node.conf.sample
===================================================================
--- freenx-server/node.conf.sample	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/node.conf.sample	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,352 @@
+# node.conf
+#
+# This file is provided by FreeNX. It should be placed either into
+# /etc/nxserver/node.conf (FreeNX style) or /usr/NX/etc/node.conf
+# (NoMachine NX style).
+#
+# It is mostly compatible with NoMachine node.conf. The most important 
+# difference is that no spaces are allowed when assigning values (eg 
+# "A=value" is allowed, "A = value" is NOT).
+#
+# This file is sourced by bash, so you can do some fancy stuff here if you
+# want to, but be aware that it is sourced 3 times per connection. If you 
+# want autostart stuff, set NODE_AUTOSTART instead!
+# 
+#
+# You surely are aware that FreeNX is based on the fantastic results that
+# the hard work by NoMachine.com has achieved. NoMachine.com released the
+# core NX libraries under the GPL. The installation of these libs are the
+# precondition for all FreeNX scripts to work. If you are installing this
+# software with the help of one of the package management tools of your
+# Linux distribution, you can assume that this dependency is taken care of
+# by the tool.
+#
+# You have questions about the inner workings of the NX technology?
+#
+# Then you are recommended to first check out the rich and very detailed
+# NoMachine documentation and their online Knowledge Base at 
+#
+#           http://www.nomachine.com/kb/
+#
+# Other sources of information are the NoMachine mailing lists 
+# (nxusers at nomachine.com and nxdevelopers at nomachine.com):
+#
+#           http://www.nomachine.com/mailinglists.php
+#
+# The FreeNX (freenx-knx at kde.org) list is here:
+#
+#           https://mail.kde.org/mailman/listinfo/freenx-knx
+#
+# CVS: $Id: node.conf.sample,v 1.28 2005/05/05 08:17:54 jonno Exp $
+
+#########################################################################
+# General FreeNX directives
+#########################################################################
+
+# The host name which is used by NX server. It's should be used if it's
+# different than the default hostname (as returned by `hostname`)
+#SERVER_NAME="$(hostname)"
+
+# The port number where local 'sshd' is listening.
+#SSHD_PORT=22
+
+
+#########################################################################
+# Authentication / Security directives
+#########################################################################
+
+# Authentication directives
+# This adds the passdb to the possible authentication methods
+#ENABLE_PASSDB_AUTHENTICATION="1"
+
+# This adds SSH to the possible authentication methods. For it to work sshd
+# must be set up at localhost accepting password authentication.
+#ENABLE_SSH_AUTHENTICATION="1"
+
+# This adds SU to the possible authentication methods. For it to work the 
+# "nx" user must be in the wheel (RedHat, Fedora) or the users group (SUSE)
+# and the user logging in must have a valid shell that accepts the -c
+# parameter.
+#ENABLE_SU_AUTHENTICATION="0"
+
+# Require all users to be in the passdb, regardless of authentication method
+#ENABLE_USER_DB="0"
+
+
+# If enabled forces the user to use encryption. This will bail out
+# if the user does not have encryption enabled.
+#ENABLE_FORCE_ENCRYPTION="0"
+
+# Refuse the NX client connection if SSHD does not export the
+# SSH_CONNECTION and SSH_CLIENT variables in the environment
+# passed to the NX server.
+# 1: Will check the remote IP and will not accept the
+#    connection if it can't be determined.
+# 0: Will accept the connection even if the remote IP
+#    is not provided.
+#SSHD_CHECK_IP="0"
+
+
+#########################################################################
+# Restriction directives
+#########################################################################
+
+# The base display number from which sessions are started.
+#DISPLAY_BASE=1000
+
+# The maximum number of contemporary sessions that can be run on FreeNX
+#SESSION_LIMIT=200
+
+# The maximum number of contemporary sessions that a single user can run
+# on FreeNX. Defaults to the value of SESSION_LIMIT.
+#SESSION_USER_LIMIT=200
+
+# The number of displays reserved for sessions, it has to be greater or equal
+# to the maximum number of contemporary sessions that a server can run.
+#DISPLAY_LIMIT=200
+
+
+# User for which sessions should be persistent. Either the keyword "all" or a
+# comma-separated list of usernames or groups in the @groupname syntax.
+#ENABLE_PERSISTENT_SESSION="all"
+
+# Users and groups for whom persistent sessions should be disabled.
+# Especially useful if ENABLE_PERSISTENT_SESSION="all"
+#DISABLE_PERSISTENT_SESSION=""
+
+
+#########################################################################
+# Logging directives
+#########################################################################
+
+# This directives controls the verbosity of the server-wide log.
+# 0: No Logging
+# 1: Errors
+# 2: Warnings
+# 3: Important information
+# 4: Server - Client communication
+# 5: Information
+# 6: Debugging information
+# 7: stderror of some applications
+#NX_LOG_LEVEL=0
+
+# Before turning logging on, please make sure that NX_LOGFILE is
+# writeable for the "nx" user
+#NX_LOGFILE=/var/log/nxserver.log
+
+# This directive controls if the temporary session directory
+# ($HOME/.nx/C-<hostname>-<display>-<session_id>) should be kept after a
+# session has ended. A successfully terminated session will be saved as
+# T-C-<hostname>-<display>-<session_id> while a failed session will be saved
+# as F-C-<hostname>-<display>-<session_id>.
+#SESSION_LOG_CLEAN=0
+
+# Amount of seconds nxserver is to keep session history. The default of 2592000
+# is equivalent to 30 days. If this is 0 no session history will be kept
+# and a negative value denotes infinity.
+#SESSION_HISTORY=2592000
+
+
+#########################################################################
+# Forwarding directives
+#########################################################################
+
+# FreeNX with ENABLE_SERVER_FORWARD="1" will automatically forward all
+# connections to the host specified in SERVER_FORWARD_HOST with the
+# secret key SERVER_FORWARD_KEY.
+#
+# This allows to have a "chain" of NX Servers. Note that you will need to
+# use "SSL encryption" for all connections.
+
+#ENABLE_SERVER_FORWARD="0"
+#SERVER_FORWARD_HOST=""
+#SERVER_FORWARD_PORT=22
+#SERVER_FORWARD_KEY="/usr/NX/share/client.id_dsa.key"
+
+
+# FreeNX with ENABLE_NOMACHINE_FORWARD_USER="1" will automatically forward all
+# connections to the commercial NoMachine nxserver installed on the same
+# machine. This feature is introduced to enable the usage of FreeNX and
+# NoMachine NX side by side on the same machine without conflicts.
+#
+# To make a connection to the FreeNX server, just use 'freenx.<user>' as 
+# username (where <username> is the existing Unix username. (You do not 
+# need to create a user named 'freenx.<user>'!)
+#
+# To make a connection to the NoMachine nxserver, use the unmodified
+# '<user>' username.
+
+#ENABLE_NOMACHINE_FORWARD_USER="0"
+#NOMACHINE_SERVER="/usr/NX/bin/nxserver"
+#NOMACHINE_NX_HOME_DIR="/usr/NX/home/nx"
+
+
+# To just forward connections to the NoMachine server, which connect to a
+# certain port enable the following two directives.
+# 
+# Note: You need to let SSHD listen to several ports to make use of this
+#       directive.
+
+#ENABLE_NOMACHINE_FORWARD_PORT="0"
+#NOMACHINE_FORWARD_PORT="22"
+
+
+#########################################################################
+# Services directives
+#########################################################################
+
+# FreeNX with ENABLE_ESD_PRELOAD="1" will automatically try to setup
+# the sound with the help of the esd media helper.
+#
+# Currently ESD will be used just by the Windows NX Client.
+#
+# Be sure that $ESD_BIN_PRELOAD is in your path, does exist and work
+# before enabling this directive.
+
+#ENABLE_ESD_PRELOAD="0"
+#ESD_BIN_PRELOAD="esddsp"
+
+# FreeNX with ENABLE_ARTSD_PRELOAD="1" will automatically try to setup
+# the sound with the help of the artsd media helper.
+#
+# Currently ARTSD will be used just by the Linux NX Client.
+#
+# Be sure that $ARTSD_BIN_PRELOAD is in your path, does exist and work
+# before enabling this directive.
+
+#ENABLE_ARTSD_PRELOAD="0"
+#ARTSD_BIN_PRELOAD="artsdsp"
+
+# FreeNX with ENABLE_KDE_CUPS="1" will automatically write 
+# $KDE_PRINTRC and put the current used port into it.
+# $KDE_PRINTRC is automatically calculated if its not set.
+
+#ENABLE_KDE_CUPS="0"
+#KDE_PRINTRC="$KDEHOME/share/config/kdeprintrc"
+#CUPS_ETC="/etc/cups"
+
+#########################################################################
+# Path directives
+#########################################################################
+
+# USER_FAKE_HOME is the base directory for the .nx directory. Use this
+# parameter instead of the users home directory if $HOME is on a NFS share.
+# Note that this directory must be unique for every user! To accomplish this
+# it is recommended to include $USER in the path.
+#USER_FAKE_HOME=$HOME
+
+# Add the nx libraries to LD_LIBRARY_PATH before starting nx agents.
+# WARNING: This will NOT (and should not) affect applications. ONLY Disable
+# this if the nx libraries are in a standard system path (such as /usr/lib)!
+#SET_LD_LIBRARY_PATH="1"
+
+
+# The command binary for the default window manager. If set it is run when a
+# 'unix-custom' session is requested by the NX Client and an application
+# to run is specified. It defaults to empty (ie no WM is run).
+# If KILL_DEFAULT_X_WM is set the WM is terminated after the started 
+# application finishes. Else FreeNX will wait for the WM to complete.
+#DEFAULT_X_WM=""
+#KILL_DEFAULT_X_WM="1"
+
+# When a 'unix-default' session is requested by the client the user's X startup
+# script will be run if pressent and executable, otherwise the default X
+# session will be run.
+# Depending on distribution USER_X_STARTUP_SCRIPT might be .Xclients, .xinitrc
+# and .Xsession
+# Depending on distribution DEFAULT_X_SESSION might be /etc/X11/xdm/Xsession,
+# /etc/X11/Sessions/Xsession or /etc/X11/xinit/xinitrc
+#USER_X_STARTUP_SCRIPT=.Xclients
+#DEFAULT_X_SESSION=/etc/X11/xdm/Xsession
+
+# The key that contains the name of the script that starts a KDE session.
+# It's run when a 'unix-kde' session is requested by the client.
+#COMMAND_START_KDE=startkde
+
+# The key that contains the name of the script that starts a gnome session.
+# It's run when a 'unix-gnome' session is requested by the client.
+#COMMAND_START_GNOME=gnome-session
+
+# The key that contains the name of the script that starts a CDE session.
+# It's run when a 'unix-cde' session is requested by the client.
+#COMMAND_START_CDE=cdwm
+
+# The key that contains the name of the complete path of command name
+# 'xterm'. It is run when a unix "xterm" session is requested by the
+# client.
+#COMMAND_XTERM=xterm
+
+# The key that contains the name of the complete path of command name
+# 'xauth'.
+#COMMAND_XAUTH=/usr/X11R6/bin/xauth
+
+# The key that contains the name of the complete path of command name
+# 'smbmount'.
+#COMMAND_SMBMOUNT=smbmount
+
+# The key that contains the name of the complete path of command name
+# 'smbumount'.
+#COMMAND_SMBUMOUNT=smbumount
+
+# The key that contains the name of the complete path of the 'netcat' command.
+#COMMAND_NETCAT=netcat
+
+# The key that contains the name of the complete path of the 'ssh' and
+# 'ssh-keygen' command.
+#COMMAND_SSH=ssh
+#COMMAND_SSH_KEYGEN=ssh-keygen
+
+# The key that contains the name of the complete path of the 'cupsd' command.
+#COMMAND_CUPSD=/usr/sbin/cupsd
+
+#########################################################################
+# Misc directives
+#########################################################################
+
+# When set to 1 this will automatically resume started sessions
+#ENABLE_AUTORECONNECT="0"
+
+# When set to 1 this will automatically resume started sessions
+# but only if an older client version is used
+#ENABLE_AUTORECONNECT_BEFORE_140="1"
+
+# When set to 1 exports NXUSERIP / NXSESSIONID in nxnode
+#EXPORT_USERIP="0"
+#EXPORT_SESSIONID="0"
+
+# This can be set to any executable, which is started after session startup
+# like: $NODE_AUTOSTART {start|restore}
+#NODE_AUTOSTART=""
+
+# When set to 1 will start nxagent in rootless mode.
+#ENABLE_ROOTLESS_MODE="0"
+
+# If enabled writes entries via the COMMAND_SESSREG program
+# into utmp/wtmp/lastlog database.
+# Note: You have to make sure that you add the nx user to the
+#       utmp or tty group or how its called on your system
+#       before this directive works.
+#ENABLE_USESSION="0"
+#COMMAND_SESSREG="sessreg"
+
+# Extra options sent to the different nx agents. See !M documentation
+# for examples of useful parameters.
+#AGENT_EXTRA_OPTIONS_RFB=""
+#AGENT_EXTRA_OPTIONS_RDP=""
+#AGENT_EXTRA_OPTIONS_X=""
+
+# The font server the agent will use. If set to "" no font server is used.
+# For this to do any good, the client has to have the same font server set
+# in /etc/X11/XF86Config
+#AGENT_FONT_SERVER=""
+
+# Disable or enable use of 'tcp nodelay' on proxy. Old versions of Linux
+# kernels have problems using this option on sockets that will cause a loss
+# of TCP connections. This option is not set by default to allow clients to
+# specify whether to enable or disable TCP nodelay. Setting this option to
+# the value of "0" NX proxy avoids using 'tcp nodelay' but it will cause a
+# loss of interaction in sessions.
+#PROXY_TCP_NODELAY="0"
+
+# Extra options to nxproxy. See !M documentation for useful parameters.
+#PROXY_EXTRA_OPTIONS=""

Added: freenx-server/nxclient
===================================================================
--- freenx-server/nxclient	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/nxclient	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,334 @@
+#!/bin/bash
+#
+# Copyright (c) 2004 by Fabian Franz <freenx at fabian-franz.de>
+#           (c) 2004 by Rick Stout <zipsonic at gmail.com>
+#
+# License: GPL, version 2
+#
+# Note: NX does not check the exit-code from nxclient,
+#       but we set it to a "good value" anyway in case 
+#       it does check it someday.
+#
+# CVS: $Id: nxclient,v 1.5 2005/04/25 02:11:24 fabianx Exp $
+#
+# ========================================================================
+
+# First check if the commercial nxclient is available and use it
+# but check that it isn't this script to prevent a loop!
+NXCLIENT="/usr/NX/bin/nxclient"
+[ -x "$NXCLIENT" -a "$(file -bi $NXCLIENT)" != 'application/x-shellscript' ] \
+	&& exec ${NXCLIENT} "$@"
+
+TEMP=`getopt -a -o d: --long local,noautokill,dialog:,caption:,message:,display:,printer: -n $(basename $0) -- "$@"`
+
+if [ $? != 0 ] ; then echo "Terminating..." >&2 ; exit 1 ; fi
+
+# Note the quotes around `$TEMP': they are essential!
+eval set -- "$TEMP"
+
+DIALOG_TYPE="ok";
+DIALOG_CAPTION=""
+DIALOG_MESSAGE=""
+DIALOG_LOCAL=""
+DIALOG_NOAUTOKILL=""
+DIALOG_PRINTER=""
+
+while true
+do
+        case "$1" in
+		--dialog) DIALOG_TYPE="$2"; shift 2 ;;
+		--caption) DIALOG_CAPTION="$2"; shift 2 ;;
+		--message) DIALOG_MESSAGE="$2"; shift 2 ;;
+		--local) DIALOG_LOCAL="yes"; shift ;;
+		--noautokill) DIALOG_NOAUTOKILL="yes"; shift ;;
+		--display) DISPLAY="$2"; shift 2 ;;
+		--printer) DIALOG_PRINTER="$2"; shift 2 ; break ;;
+		--) shift ; break ;;
+                *) echo "Internal error!" ; exit 1; ;;
+	esac
+done
+
+export DISPLAY
+
+# if --printer is set, the dialog type is overridden
+[ -n "$DIALOG_PRINTER" ] && DIALOG_TYPE="printer"
+
+if [ -x /usr/bin/Xdialog ] 
+then
+	dialog_interface="xdialog"
+	DIALOG=/usr/bin/Xdialog # just in case that we have no good path
+else
+	dialog_interface="xmessage"
+	xmessage=$(which xmessage 2>/dev/null)
+	[ -z "$xmessage" ] && xmessage="/usr/X11R6/bin/xmessage"
+fi
+
+#
+# utility functions for all interfaces
+#
+
+# utility_printer "get|set|getlist|getvendlist|getdrvlist"
+#
+#	get <name> - gets the current driver for name
+#	set <name> <driver> <description> - sets the current driver and description for name
+#	getvendlist - gets a list of vendors
+#	getdrvlist <vendor> - gets a list of drivers for vendor
+#	getextdrvlist <vendor> - gets an extended list (with driver and 
+#                                description) of drivers for vendor
+#	getdesc <driver> - gets the description for driver <driver>
+#	getlist - gets a list of drivers
+
+#
+# drivers.cache has the following format:
+#	
+#	driver|<printername>|<ppdfile>|<description>
+#
+
+#
+# Example: IFS='|' DEFAULT_PRINTER=( $(utility_printer get <myprinter>) )
+# 	  
+#	You can then select ${DEFAULT_PRINTER[1]} for <printername>.
+# 
+
+utility_printer()
+{
+	UTILITY_DRIVERS_CACHE="$HOME/.nx/config/drivers.cache"
+	[ -n "$USER_FAKE_HOME" ] && UTILITY_DRIVERS_CACHE="$USER_FAKE_HOME/.nx/config/drivers.cache"
+	UTILITY_NXPRINT="nxprint"
+	[ -n "$PATH_BIN" ] && UTILITY_NXPRINT="$PATH_BIN/nxprint"
+	case "$1" in 
+		get)
+			grep "driver|$2|" "$UTILITY_DRIVERS_CACHE" 2>/dev/null
+		;;
+		set)
+			# FIXME: Handle possible race conditions?
+			grep -v "driver|$2|" "$UTILITY_DRIVERS_CACHE" 2>/dev/null > $UTILITY_DRIVERS_CACHE.tmp
+			echo "driver|$2|$3|$4" >> $UTILITY_DRIVERS_CACHE.tmp
+			mv -f $UTILITY_DRIVERS_CACHE.tmp $UTILITY_DRIVERS_CACHE
+		;;
+		getvendlist)
+			$UTILITY_NXPRINT -d | awk -F'|' '{ print $2 }' | uniq | tr '\n' '|'
+		;;
+		getdrvlist)
+			$UTILITY_NXPRINT -d | awk -F'|' '($2=="'$2'") { print $4}' | tr '\n' '|'
+		;;
+		getextdrvlist)
+			$UTILITY_NXPRINT -d | awk -F'|' '($2=="'$2'") { print $4 "|" $3 }'
+		;;
+
+		getdesc)
+			$UTILITY_NXPRINT -d | awk -F'|' '($4=="'$2'") { print $3}'
+		;;
+		getlist)
+			$UTILITY_NXPRINT -d
+		;;
+	esac
+}
+
+#
+# xmessage dialog interface
+#
+
+xmessage_ok()
+{
+	$xmessage -buttons "Ok:0" -center "$DIALOG_MESSAGE"
+	return 0 # Give cancel on close ...
+}
+
+xmessage_yesno()
+{
+	$xmessage -buttons "Yes:2,No:0" -center "$DIALOG_MESSAGE"
+}
+
+xmessage_yesnosuspend()
+{
+	$xmessage -buttons "Suspend:3,Terminate:2,Cancel:0" -center "$DIALOG_MESSAGE"
+}
+
+xmessage_panic()
+{
+	$xmessage -buttons "Terminate:2,Cancel:0" -center "$DIALOG_MESSAGE"
+}
+
+xmessage_quit()
+{
+	$xmessage -buttons "Quit:0" -center "$DIALOG_MESSAGE"
+	return 0 # Give cancel on close ...
+}
+
+xmessage_printer_ask()
+{
+	$xmessage -buttons "Ok:100,Configure:101,Cancel:102" -center "$DIALOG_MESSAGE"
+	RC=$?
+	[ $RC -lt 100 ] && return 2
+	let RC=$RC-100
+	return $RC
+}
+
+xmessage_printer_configure()
+{
+	IFS=','
+	$xmessage -buttons "$*" -center "$DIALOG_MESSAGE"
+	RC=$?
+	unset IFS
+	VENDOR=""
+	if [ $RC -gt 100 ]
+	then
+		let NR=$RC-100
+		VENDOR="${!NR}"
+	fi
+	echo "$VENDOR"
+}
+
+xmessage_printer_configure_vendor()
+{
+	IFS='|' VENDOR_LIST=( $(utility_printer getvendlist) )
+	xmessage_printer_configure "${VENDOR_LIST[@]}"
+}
+
+xmessage_printer_configure_driver()
+{
+	IFS='|' DRIVER_LIST=( $(utility_printer getdrvlist "$1") )
+	xmessage_printer_configure "${DRIVER_LIST[@]}"
+}
+
+#
+# xdialog interface
+#
+
+xdialog_ok()
+{
+	$DIALOG --title "$DIALOG_CAPTION" --msgbox "$DIALOG_MESSAGE" 0 0
+	return 0 # Give cancel on close ...
+}
+
+xdialog_yesno()
+{
+	$DIALOG --title "$DIALOG_CAPTION" --yesno "$DIALOG_MESSAGE" 0 0
+	RC=$?
+	[ $RC -eq 0 ] && return 2
+	[ $RC -eq 1 ] && return 0
+}
+
+xdialog_yesnosuspend()
+{
+	$DIALOG --title "$DIALOG_CAPTION" --buttons-style text --ok-label "Suspend" --cancel-label "Terminate" --yesno "$DIALOG_MESSAGE Close window to cancel." 400x150
+	RC=$?
+	[ $RC -eq 0 ] && return 3
+	[ $RC -eq 1 ] && return 2
+}
+
+xdialog_panic()
+{
+	$DIALOG --title "$DIALOG_CAPTION" --buttons-style text --default-no --ok-label "Terminate" --cancel-label "Cancel" --yesno "$DIALOG_MESSAGE" 0x0
+	RC=$?
+	[ $RC -eq 0 ] && return 2
+	[ $RC -eq 1 ] && return 0
+}
+
+xdialog_quit()
+{
+        $DIALOG --buttons-style text --ok-label "Quit" --title "$DIALOG_CAPTION" --msgbox "$DIALOG_MESSAGE" 0 0
+        return 0 # Give cancel on close ...
+}
+
+xdialog_printer_ask()
+{
+	$DIALOG --title "$DIALOG_CAPTION" --buttons-style text --ok-label "Ok" --cancel-label "Configure" --yesno "$DIALOG_MESSAGE\n\nClose window to cancel." 400x250
+	RC=$?
+	[ $RC -eq 255 ] && return 2
+	return $RC
+}
+
+xdialog_printer_configure_vendor()
+{
+	IFS='|' VENDOR_LIST=( $(utility_printer getvendlist | sed 's/|/||off|/g') )
+	$DIALOG --stdout --title "$DIALOG_CAPTION" --radiolist "$DIALOG_MESSAGE" 0 0 6 "${VENDOR_LIST[@]}"
+}
+
+# xdialog_printer_configure_driver vendor old_driver
+xdialog_printer_configure_driver()
+{
+	IFS='|' XDIALOG_LIST=( $(utility_printer getextdrvlist "$1" | sed 's/$/|off/g; /'"$2"'/ s/|off/|on/g' | tr '\n' '|') )
+	$DIALOG --stdout --title "$DIALOG_CAPTION" --radiolist "$DIALOG_MESSAGE" 0 0 6 "${XDIALOG_LIST[@]}"
+}
+
+
+#
+# helper functions
+#
+
+helper_dialog_printer()
+{
+	IFS="|" PRINTER_INFORMATION=( $(utility_printer get "$DIALOG_PRINTER") )
+	PRINTER_CONFIGURE="yes"
+	[ -z "$DIALOG_CAPTION" ] && DIALOG_CAPTION="NX Printer configuration for $DIALOG_PRINTER"
+	
+	# Do we have old printer information present?
+	if [ -n "$PRINTER_INFORMATION" ]
+	then
+		DIALOG_MESSAGE=$(echo -e "Found driver for printer $DIALOG_PRINTER.\n\nOld choice was: ${PRINTER_INFORMATION[3]}.\n\nIf you want to keep the settings click on 'Ok' \n- else click on 'Configure'.") ${dialog_interface}_printer_ask
+		RC=$?
+		# bail out with exit code 2 in case the user cancelled the operation
+		[ $RC -eq 2 ] && echo "cancel: aborted" && exit 2
+		[ $RC -eq 0 ] && PRINTER_CONFIGURE="no"
+	fi
+	
+	VENDOR=""
+	OLD_DRIVER="${PRINTER_INFORMATION[2]}"
+
+	if [ "$PRINTER_CONFIGURE" = "yes" ]
+	then
+		DRIVER=""
+		VENDOR=$(DIALOG_MESSAGE="Choose vendor for printer $DIALOG_PRINTER." ${dialog_interface}_printer_configure_vendor)
+		[ -n "$VENDOR" ] && DRIVER=$(DIALOG_MESSAGE="Choose driver for printer $DIALOG_PRINTER." ${dialog_interface}_printer_configure_driver "$VENDOR" "${OLD_DRIVER:-invalid}")
+		# set the new printer driver
+		if [ -n "$DRIVER" ]
+		then
+			DESC=$(utility_printer getdesc "$DRIVER")
+			utility_printer set "$DIALOG_PRINTER" "$DRIVER" "$DESC"
+		fi
+	else
+		DRIVER="$OLD_DRIVER"
+	fi
+
+	# echo the choosen <ppdfile> to stdout
+	[ -n "$DRIVER" ] && echo "$DRIVER"
+	[ -z "$DRIVER" ] && echo "cancel: aborted" && exit 2
+			
+	exit 0
+}
+
+#
+# main case statement
+#
+
+case $DIALOG_TYPE in 
+	ok)
+		${dialog_interface}_ok
+	;;
+	yesno)
+		${dialog_interface}_yesno
+	;;
+	yesnosuspend)
+		${dialog_interface}_yesnosuspend
+	;;
+	panic)
+		${dialog_interface}_panic
+	;;
+	quit)
+		${dialog_interface}_quit
+	;;
+	printer)
+		helper_dialog_printer
+	;;
+esac
+
+#
+# Time for exit code checks :)
+#
+
+RC=$?
+	[ $RC -eq 2 ] && kill -TERM $PPID
+	[ $RC -eq 3 ] && kill -HUP $PPID
+exit 0


Property changes on: freenx-server/nxclient
___________________________________________________________________
Name: svn:executable
   + 

Added: freenx-server/nxkeygen
===================================================================
--- freenx-server/nxkeygen	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/nxkeygen	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,69 @@
+#!/bin/bash
+#
+# /usr/NX/bin/nxkeygen
+#		Create a new client/server key pair
+#
+#		Originally written for Gentoo Linux
+#
+# Author	Stuart Herbert
+#		(stuart at gentoo.org)
+#
+# Copyright	(c) 2004 Gentoo Foundation
+#		Released under v2 of the GNU GPL
+#
+# CVS: $Id: nxkeygen,v 1.12 2005/05/05 08:04:24 jonno Exp $
+#
+# ========================================================================
+
+# Read the config file
+. $(PATH=$(cd $(dirname $0) && pwd):$PATH which nxloadconfig) --
+
+NX_KEY_DIR="$NX_HOME_DIR/.ssh"
+DATE="`date '+%Y%m%d-%H%M%S'`"
+NX_CLIENT_KEY="${NX_KEY_DIR}/client.id_dsa.key"
+NX_SERVER_KEY="${NX_KEY_DIR}/server.id_dsa.pub.key"
+
+main ()
+{
+	# create a new key
+	umask 177
+	$COMMAND_SSH_KEYGEN -q -t dsa -N '' -f ${NX_KEY_DIR}/local.id_dsa
+
+	# backup the existing keys
+	
+	if [ -f "${NX_SERVER_KEY}" ]; then
+		echo "Backing up existing server key to ${NX_SERVER_KEY}.${DATE}"
+		mv -f "${NX_SERVER_KEY}" "${NX_SERVER_KEY}.${DATE}"
+	fi
+
+	if [ -f "${NX_CLIENT_KEY}" ]; then
+		echo "Backing up existing client key to ${NX_CLIENT_KEY}.${DATE}"
+		mv -f "${NX_CLIENT_KEY}" "${NX_CLIENT_KEY}.${DATE}"
+	fi
+
+	# put the new keys in place
+
+	mv -f "${NX_KEY_DIR}/local.id_dsa" "${NX_CLIENT_KEY}"
+	mv -f "${NX_KEY_DIR}/local.id_dsa.pub" "${NX_SERVER_KEY}"
+
+	for x in ${NX_CLIENT_KEY} ${NX_SERVER_KEY} ; do
+		chmod 600 $x
+		chown nx:root $x
+	done
+	
+	# copy the key to the authorized_keys2 file
+	rm -f $NX_KEY_DIR/$SSH_AUTHORIZED_KEYS
+	echo -n "no-port-forwarding,no-X11-forwarding,no-agent-forwarding,command=\"$PATH_BIN/nxserver\" " >$NX_KEY_DIR/$SSH_AUTHORIZED_KEYS
+	cat ${NX_SERVER_KEY} >> $NX_KEY_DIR/$SSH_AUTHORIZED_KEYS
+
+	# now tell the user what to do
+
+	echo "Unique key generated; your users must install"
+	echo
+	echo "    ${NX_CLIENT_KEY}"
+	echo
+	echo "on their computers."
+}
+
+main "$@"
+


Property changes on: freenx-server/nxkeygen
___________________________________________________________________
Name: svn:executable
   + 

Added: freenx-server/nxloadconfig
===================================================================
--- freenx-server/nxloadconfig	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/nxloadconfig	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,455 @@
+#!/bin/bash
+#
+# Copyright (c) 2005 by Fabian Franz <freenx at fabian-franz.de>
+#           (c) 2005 by Jon Severinsson <jonno at users.berlios.de>
+#
+# License: GPL, version 2
+#
+# CVS: $Id: nxloadconfig,v 1.33 2005/05/05 08:34:20 jonno Exp $
+#
+# ========================================================================
+
+#########################################################################
+# Commandline support for --help, --check and --userconf
+#########################################################################
+
+HELP="no"
+CHECK="no"
+USERCONF="no"
+
+while [ "$1" ]
+do
+	case "$1" in
+		--help) HELP="yes"; shift ;;
+		--check) CHECK="yes"; shift ;;
+		--userconf) USERCONF="yes" ; 
+					case "$2" in
+						"" | --*) shift ;;
+						*) USER=$2 ; shift 2 ;;
+					esac ;;
+		--) shift ; break ;;
+		*) echo "Invalid flag $1" ; HELP="yes"; shift ; break ;;
+	esac
+done
+
+if [ "$HELP" = "yes" ]
+then
+	echo "nxloadconfig - Load the FreeNX configuration variables into the environment."
+	echo "Syntax: nxloadconfig --help"
+	echo "        nxloadconfig [--check] [--userconf [<username>]]"
+	echo
+	echo "  --check                  Write errors to standard output."
+	echo "  --userconf [<username>]  Parse <username>.node.conf as well as node.conf."
+	echo "                           Assume current user if no username is specified."
+	exit 0
+fi
+
+#########################################################################
+# INTERNAL STUFF
+# DO NOT TOUCH unless you REALLY know what you are doing
+#########################################################################
+
+NX_VERSION=1.4.0-04-CVS
+NX_LICENSE="OS (GPL)"
+
+# Where can different nx components be found
+NX_DIR=/usr
+PATH_BIN=$NX_DIR/bin # if you change that, be sure to also change the public keys
+PATH_LIB=$NX_DIR/lib
+NX_ETC_DIR=/etc/nxserver
+NX_SESS_DIR=/var/lib/nxserver/db
+NX_HOME_DIR=/var/lib/nxserver/home
+
+# Advanced users ONLY
+AGENT_LIBRARY_PATH="" #Calculated
+PROXY_LIBRARY_PATH="" #Calculated
+APPLICATION_LIBRARY_PATH="" #Calculated
+APPLICATION_LIBRARY_PRELOAD="" #Calculated
+
+# the name of the authorized keys file for ssh
+SSH_AUTHORIZED_KEYS="authorized_keys2"
+
+#########################################################################
+# Default Values
+# A user should NEVER touch this, edit $NX_ETC_DIR/node.conf instead
+#########################################################################
+
+# General FreeNX directives
+
+SERVER_NAME="$(hostname)"
+SSHD_PORT=22
+
+
+# Authentication / Security directives
+
+ENABLE_PASSDB_AUTHENTICATION="1"
+ENABLE_SSH_AUTHENTICATION="1"
+ENABLE_SU_AUTHENTICATION="0"
+ENABLE_USER_DB="0"
+
+ENABLE_FORCE_ENCRYPTION="0"
+SSHD_CHECK_IP="0"
+
+
+# Restriction directives
+
+DISPLAY_BASE=1000
+SESSION_LIMIT=200
+SESSION_USER_LIMIT="" #Calculated
+DISPLAY_LIMIT=200
+
+ENABLE_PERSISTENT_SESSION="all"
+DISABLE_PERSISTENT_SESSION=""
+
+
+# Logging directives
+
+NX_LOG_LEVEL=0
+NX_LOGFILE=/var/log/nxserver.log
+SESSION_LOG_CLEAN=1
+SESSION_HISTORY=2592000
+
+
+# Forwarding directives
+
+ENABLE_SERVER_FORWARD="0"
+SERVER_FORWARD_HOST=""
+SERVER_FORWARD_PORT=22
+SERVER_FORWARD_KEY="/usr/NX/share/client.id_dsa.key"
+
+ENABLE_NOMACHINE_FORWARD_USER="0"
+NOMACHINE_SERVER="/usr/NX/bin/nxserver"
+NOMACHINE_NX_HOME_DIR="/usr/NX/home/nx"
+
+ENABLE_NOMACHINE_FORWARD_PORT="0"
+NOMACHINE_FORWARD_PORT="22"
+
+
+# Services directives
+
+ENABLE_ESD_PRELOAD="0"
+ESD_BIN_PRELOAD="esddsp"
+ENABLE_ARTSD_PRELOAD="0"
+ARTSD_BIN_PRELOAD="artsdsp"
+
+ENABLE_KDE_CUPS="0"
+KDE_PRINTRC="" # Calculated
+CUPS_ETC="/etc/cups/"
+
+# Path directives
+
+USER_FAKE_HOME="" #Calculated
+SET_LD_LIBRARY_PATH="1"
+
+DEFAULT_X_WM=""
+KILL_DEFAULT_X_WM="1"
+USER_X_STARTUP_SCRIPT=.Xclients
+DEFAULT_X_SESSION=/etc/X11/xdm/Xsession
+COMMAND_START_KDE=startkde
+COMMAND_START_GNOME=gnome-session
+COMMAND_START_CDE=cdwm
+COMMAND_XTERM=xterm
+COMMAND_XAUTH=/usr/X11R6/bin/xauth
+COMMAND_SMBMOUNT=smbmount
+COMMAND_SMBUMOUNT=smbumount
+COMMAND_NETCAT=netcat
+COMMAND_SSH=ssh
+COMMAND_SSH_KEYGEN=ssh-keygen
+COMMAND_CUPSD=/usr/sbin/cupsd
+
+
+# Misc directives
+
+ENABLE_AUTORECONNECT="0"
+ENABLE_AUTORECONNECT_BEFORE_140="1"
+EXPORT_USERIP="0"
+EXPORT_SESSIONID="0"
+NODE_AUTOSTART=""
+ENABLE_ROOTLESS_MODE="0"
+ENABLE_USESSION="0"
+COMMAND_SESSREG="sessreg"
+AGENT_EXTRA_OPTIONS_RFB=""
+AGENT_EXTRA_OPTIONS_RDP=""
+AGENT_EXTRA_OPTIONS_X=""
+AGENT_FONT_SERVER=""
+PROXY_TCP_NODELAY="0"
+PROXY_EXTRA_OPTIONS=""
+
+
+#########################################################################
+# node.conf file evaluation
+#########################################################################
+
+[ -e $NX_ETC_DIR/node.conf ] && . $NX_ETC_DIR/node.conf
+[ "$USERCONF" = "yes" -a -e $NX_ETC_DIR/$USER.node.conf ] && . $NX_ETC_DIR/$USER.node.conf
+
+
+#########################################################################
+# Calculated values
+#########################################################################
+
+[ -z "$SESSION_USER_LIMIT" ] && SESSION_USER_LIMIT=$SESSION_LIMIT
+[ -z "$USER_FAKE_HOME" ] && USER_FAKE_HOME=$HOME
+
+[ -z "$AGENT_LIBRARY_PATH" ] && AGENT_LIBRARY_PATH=$PATH_LIB
+[ -z "$PROXY_LIBRARY_PATH" ] && PROXY_LIBRARY_PATH=$PATH_LIB
+[ -z "$APPLICATION_LIBRARY_PATH" ] && APPLICATION_LIBRARY_PATH=$PATH_LIB
+[ -z "$APPLICATION_LIBRARY_PRELOAD" ] && APPLICATION_LIBRARY_PRELOAD="$APPLICATION_LIBRARY_PATH/libX11.so.6.2:$APPLICATION_LIBRARY_PATH/libXext.so.6.4:$APPLICATION_LIBRARY_PATH/libXcomp.so.1:$APPLICATION_LIBRARY_PATH/libXcompext.so.1:$APPLICATION_LIBRARY_PATH/libXrender.so.1.2"
+
+[ -z "$KDE_PRINTRC" -a -n "$KDEHOME" ] && KDE_PRINTRC="$KDEHOME/share/config/kdeprintrc"
+[ -z "$KDE_PRINTRC" -a -z "$KDEHOME" ] && KDE_PRINTRC="$HOME/.kde/share/config/kdeprintrc"
+
+#########################################################################
+# Support for --check
+#########################################################################
+
+if [ "$CHECK" = "yes" ]
+then
+	ERROR="no"
+	WARNING="no"
+	
+	# Internal Stuff
+	
+	[ ! -d "$PATH_BIN" ] && \
+		ERROR="yes" && echo "Error: Invalid value \"PATH_BIN=$PATH_BIN\""
+	[ ! -d "$PATH_LIB" ] && \
+		ERROR="yes" && echo "Error: Invalid value \"PATH_LIB=$PATH_LIB\""
+	[ ! -d "$NX_ETC_DIR" ] && \
+		ERROR="yes" && echo "Error: Invalid value \"NX_ETC_DIR=$NX_ETC_DIR\""
+	[ ! -d "$NX_SESS_DIR" ] && \
+		ERROR="yes" && echo "Error: Invalid value \"NX_SESS_DIR=$NX_SESS_DIR\""
+	[ ! -d "$NX_HOME_DIR" ] && \
+		ERROR="yes" && echo "Error: Invalid value \"NX_HOME_DIR=$NX_HOME_DIR\""
+
+	[ ! -d "$AGENT_LIBRARY_PATH" ] && \
+		ERROR="yes" && echo "Error: Invalid value \"AGENT_LIBRARY_PATH=$AGENT_LIBRARY_PATH\""
+	[ ! -d "$PROXY_LIBRARY_PATH" ] && \
+		ERROR="yes" && echo "Error: Invalid value \"PROXY_LIBRARY_PATH=$PROXY_LIBRARY_PATH\""
+	[ ! -d "$APPLICATION_LIBRARY_PATH" ] && \
+		ERROR="yes" && echo "Error: Invalid value \"APPLICATION_LIBRARY_PATH=$APPLICATION_LIBRARY_PATH\""
+	
+	OLD_IFS=$IFS
+	IFS=":"
+	for LIBRARY in $APPLICATION_LIBRARY_PRELOAD; do
+		[ ! -e $LIBRARY ] && \
+			ERROR="yes" && echo "Error: Invalid value \"APPLICATION_LIBRARY_PRELOAD=$APPLICATION_LIBRARY_PRELOAD\"" && break ;
+	done
+	IFS=$OLD_IFS
+	
+	[ -z "$SSH_AUTHORIZED_KEYS" ] && \
+		ERROR="yes" && echo "Error: Invalid value \"SSH_AUTHORIZED_KEYS=$SSH_AUTHORIZED_KEYS\""
+	
+	
+	# General FreeNX directives
+	
+	[ -z "$SERVER_NAME" ] && \
+		ERROR="yes" && echo "Error: Invalid value \"SERVER_NAME=$SERVER_NAME\""
+	[ -z $(echo "$SSHD_PORT" | egrep "^[1-9][0-9]{0,4}$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"SSHD_PORT=$SSHD_PORT\""
+	
+	
+	# Authentication / Security directives
+	
+	[ -z $(echo "$ENABLE_PASSDB_AUTHENTICATION" | egrep "^[0|1]$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"ENABLE_PASSDB_AUTHENTICATION=$ENABLE_PASSDB_AUTHENTICATION\""
+	[ -z $(echo "$ENABLE_SSH_AUTHENTICATION" | egrep "^[0|1]$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"ENABLE_SSH_AUTHENTICATION=$ENABLE_SSH_AUTHENTICATION:\""
+	[ -z $(echo "$ENABLE_SU_AUTHENTICATION" | egrep "^[0|1]$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"ENABLE_SU_AUTHENTICATION=$NENABLE_SU_AUTHENTICATION\""
+	[ -z $(echo "$ENABLE_USER_DB" | egrep "^[0|1]$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"ENABLE_USER_DB=$ENABLE_USER_DB\""
+	
+	[ -z $(echo "$ENABLE_FORCE_ENCRYPTION" | egrep "^[0|1]$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"ENABLE_FORCE_ENCRYPTION=$ENABLE_FORCE_ENCRYPTION\""
+	[ -z $(echo "$SSHD_CHECK_IP" | egrep "^[0|1]$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"SSHD_CHECK_IP=$SSHD_CHECK_IP\""
+	
+	
+	# Restriction directives
+	
+	[ -z $(echo "$DISPLAY_BASE" | egrep "^[1-9][0-9]{0,4}$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"DISPLAY_BASE=$DISPLAY_BASE\""
+	[ -z $(echo "$SESSION_LIMIT" | egrep "^[1-9][0-9]{0,4}$") ] &&  \
+		ERROR="yes" && echo "Error: Invalid value \"SESSION_LIMIT=$SESSION_LIMIT\""
+	[ -z $(echo "$SESSION_USER_LIMIT" | egrep "^[1-9][0-9]{0,4}$") -o $SESSION_USER_LIMIT -gt $SESSION_LIMIT ] && \
+		ERROR="yes" && echo "Error: Invalid value \"SESSION_USER_LIMIT=$SESSION_USER_LIMIT\""
+	[ -z $(echo "$DISPLAY_LIMIT" | egrep "^[1-9][0-9]{0,4}$") -o $DISPLAY_LIMIT -lt $SESSION_LIMIT ] && \
+		ERROR="yes" && echo "Error: Invalid value \"DISPLAY_LIMIT=$DISPLAY_LIMIT\""
+	
+	OLD_IFS=$IFS
+	IFS=","
+	if [ "$ENABLE_PERSISTENT_SESSION" != "all" ]
+	then
+		for USERNAME in $ENABLE_PERSISTENT_SESSION; do
+			[ "${USERNAME:0:1}" != "@" ] && [ -z $(getent passwd | egrep "^$USERNAME:") ] && \
+				ERROR="yes" && echo "Error: Invalid value \"ENABLE_PERSISTENT_SESSION=$ENABLE_PERSISTENT_SESSION\"" && break ;
+			[ "${USERNAME:0:1}" = "@" ] && [ -z $(getent group | egrep "^${USERNAME:1}:") ] && \
+				ERROR="yes" && echo "Error: Invalid value \"ENABLE_PERSISTENT_SESSION=$ENABLE_PERSISTENT_SESSION\"" && break ;
+		done
+	fi
+	for USERNAME in $DISABLE_PERSISTENT_SESSION; do
+		[ "${USERNAME:0:1}" != "@" ] && [ -z $(getent passwd | egrep "^$USERNAME:") ] && \
+			ERROR="yes" && echo "Error: Invalid value \"DISABLE_PERSISTENT_SESSION=$DISABLE_PERSISTENT_SESSION\"" && break ;
+		[ "${USERNAME:0:1}" = "@" ] && [ -z $(getent group | egrep "^${USERNAME:1}:") ] && \
+			ERROR="yes" && echo "Error: Invalid value \"DISABLE_PERSISTENT_SESSION=$DISABLE_PERSISTENT_SESSION\"" && break ;
+	done
+	IFS=$OLD_IFS
+	
+	
+	# Logging directives
+	
+	[ -z $(echo "$NX_LOG_LEVEL" | egrep "^[0-7]$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"NX_LOG_LEVEL=$NX_LOG_LEVEL\""
+	[ "$NX_LOG_LEVEL" != "0" -a ! -e "$NX_LOGFILE" ] && \
+		WARNING="yes" && echo "Warning: Invalid value \"NX_LOGFILE=$NX_LOGFILE\"" \
+					  && echo "         No loggfile will be kept."
+		# How do I check if another user might write to a file? ( -w checks only current user)
+	[ -z $(echo "$SESSION_LOG_CLEAN" | egrep "^[0|1]$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"SESSION_LOG_CLEAN=$SESSION_LOG_CLEAN\""
+	[ -z $(echo "$SESSION_HISTORY" | egrep "^-?[0-9]+$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"SESSION_HISTORY=$SESSION_HISTORY\""
+	
+	
+	# Forwarding directives
+	
+	[ -z $(echo "$ENABLE_SERVER_FORWARD" | egrep "^[0|1]$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"ENABLE_SERVER_FORWARD=$ENABLE_SERVER_FORWARD\""
+	[ "$ENABLE_SERVER_FORWARD" = "1" -a -z "$SERVER_FORWARD_HOST" ] && \
+		ERROR="yes" && echo "Error: Invalid value \"SERVER_FORWARD_HOST=$SERVER_FORWARD_HOST\"" 
+		# Any ideas on how I can check for a VALID host is velcome!
+		# In my private scripts I use 'resolveip -q' and check if output conforms to [0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}, 
+		# but resolveip is part of mysql, and I don't think I should add that dependancy...
+	[ "$ENABLE_SERVER_FORWARD" = "1" -a -z $(echo "$SERVER_FORWARD_PORT" | egrep "^[1-9][0-9]{0,4}$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"SERVER_FORWARD_PORT=$SERVER_FORWARD_PORT\""
+	[ "$ENABLE_SERVER_FORWARD" = "1" -a ! -e "$SERVER_FORWARD_KEY" ] && \
+		ERROR="yes" && echo "Error: Invalid value \"SERVER_FORWARD_KEY=$SERVER_FORWARD_KEY\""
+	
+	[ -z $(echo "$ENABLE_NOMACHINE_FORWARD_USER" | egrep "^[0|1]$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"ENABLE_NOMACHINE_FORWARD_USER=$ENABLE_NOMACHINE_FORWARD_USER\""
+	[ -z $(echo "$ENABLE_NOMACHINE_FORWARD_PORT" | egrep "^[0|1]$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"ENABLE_NOMACHINE_FORWARD_PORT=$ENABLE_NOMACHINE_FORWARD_PORT\""
+	[ "$ENABLE_NOMACHINE_FORWARD_USER" = "1" -o "$ENABLE_NOMACHINE_FORWARD_PORT" = "1" ] && ! which "$NOMACHINE_SERVER" >/dev/null 2>&1 && \
+		ERROR="yes" && echo "Error: Invalid value \"NOMACHINE_SERVER=$NOMACHINE_SERVER\""
+	[ "$ENABLE_NOMACHINE_FORWARD_USER" = "1" -a ! -d "$NOMACHINE_NX_HOME_DIR" ] && \
+		ERROR="yes" && echo "Error: Invalid value \"NOMACHINE_NX_HOME_DIR=$NOMACHINE_NX_HOME_DIR\""
+	[ "$ENABLE_NOMACHINE_FORWARD_PORT" = "1" -a -z $(echo "$NOMACHINE_FORWARD_PORT" | egrep "^[1-9][0-9]{0,4}$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"NOMACHINE_FORWARD_PORT=$NOMACHINE_FORWARD_PORT\""
+	
+	
+	# Services directives
+	
+	[ -z $(echo "$ENABLE_ESD_PRELOAD" | egrep "^[0|1]$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"ENABLE_ESD_PRELOAD=$ENABLE_ESD_PRELOAD\""
+	[ "$ENABLE_ESD_PRELOAD" = "1" ] && ! which "$ESD_BIN_PRELOAD" >/dev/null 2>&1 && \
+		WARNING="yes" && echo "Warning: Invalid value \"ESD_BIN_PRELOAD=$ESD_BIN_PRELOAD\"" \
+					  && echo "         No esd preload will be performed."
+	
+	[ -z $(echo "$ENABLE_ARTSD_PRELOAD" | egrep "^[0|1]$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"ENABLE_ARTSD_PRELOAD=$ENABLE_ARTSD_PRELOAD\""
+	[ "$ARTSD_BIN_PRELOAD" = "1" ] && ! which "$ARTSD_BIN_PRELOAD" >/dev/null 2>&1 && \
+		WARNING="yes" && echo "Warning: Invalid value \"ARTSD_BIN_PRELOAD=$ARTSD_BIN_PRELOAD\"" \
+					  && echo "         No arts preload will be performed."
+	
+	[ -z $(echo "$ENABLE_KDE_CUPS" | egrep "^[0|1]$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"ENABLE_KDE_CUPS=$ENABLE_KDE_CUPS\""
+	[ "$ENABLE_KDE_CUPS" = "1" -a ! -e "$KDE_PRINTRC" ] && \
+		ERROR="yes" && echo "Error: Invalid value \"KDE_PRINTRC=$KDE_PRINTRC\""
+	[ ! -e "$CUPS_ETC/mime.types" -o ! -e "$CUPS_ETC/mime.convs" ] && \
+		WARNING="yes" && echo "Warning: Invalid value \"CUPS_ETC=$CUPS_ETC\"" \
+					  && echo "         Users will not be able to enable printing."
+	
+	# Path directives
+	
+	[ ! -d "$USER_FAKE_HOME" ] && \
+		ERROR="yes" && echo "Error: Invalid value \"USER_FAKE_HOME=$USER_FAKE_HOME\""
+	[ -z $(echo "$SET_LD_LIBRARY_PATH" | egrep "^[0|1]$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"SET_LD_LIBRARY_PATH=$SET_LD_LIBRARY_PATH\""
+	
+	[ "$DEFAULT_X_WM" != "" ] && ! which "$DEFAULT_X_WM" >/dev/null 2>&1 && \
+		ERROR="yes" && echo "Error: Invalid value \"DEFAULT_X_WM=$DEFAULT_X_WM\""
+	[ "$DEFAULT_X_WM" != "" -a  -z $(echo "$KILL_DEFAULT_X_WM" | egrep "^[0|1]$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"KILL_DEFAULT_X_WM=$KILL_DEFAULT_X_WM\""
+	[ -z "$USER_X_STARTUP_SCRIPT" ] && \
+		ERROR="yes" && echo "Error: Invalid value \"USER_X_STARTUP_SCRIPT=$USER_X_STARTUP_SCRIPT\""
+	! which "$DEFAULT_X_SESSION" >/dev/null 2>&1 && \
+		WARNING="yes" && echo "Warning: Invalid value \"DEFAULT_X_SESSION=$DEFAULT_X_SESSION\"" \
+					  && echo "         Users might not be able to request a default X session."
+	! which "$COMMAND_START_KDE" >/dev/null 2>&1 && \
+		WARNING="yes" && echo "Warning: Invalid value \"COMMAND_START_KDE=$COMMAND_START_KDE\"" \
+					  && echo "         Users will not be able to request a KDE session."
+	! which "$COMMAND_START_GNOME" >/dev/null 2>&1 && \
+		WARNING="yes" && echo "Warning: Invalid value \"COMMAND_START_GNOME=$COMMAND_START_GNOME\"" \
+					  && echo "         Users will not be able to request a Gnome session."
+	! which "$COMMAND_START_CDE" >/dev/null 2>&1 && \
+		WARNING="yes" && echo "Warning: Invalid value \"COMMAND_START_CDE=$COMMAND_START_CDE\"" \
+					  && echo "         Users will not be able to request a CDE session."
+	! which "$COMMAND_XTERM" >/dev/null 2>&1 && \
+		WARNING="yes" && echo "Warning: Invalid value \"COMMAND_XTERM=$COMMAND_XTERM\"" \
+					  && echo "         Users will not be able to request an xterm session."
+	! which "$COMMAND_XAUTH" >/dev/null 2>&1 && \
+		ERROR="yes" && echo "Error: Invalid value \"COMMAND_XAUTH=$COMMAND_XAUTH\""
+	! which "$COMMAND_SMBMOUNT" >/dev/null 2>&1 && \
+		ERROR="yes" && echo "Error: Invalid value \"COMMAND_SMBMOUNT=$COMMAND_SMBMOUNT\""
+	! which "$COMMAND_SMBUMOUNT" >/dev/null 2>&1 && \
+		ERROR="yes" && echo "Error: Invalid value \"COMMAND_SMBUMOUNT=$COMMAND_SMBUMOUNT\""
+	! which "$COMMAND_NETCAT" >/dev/null 2>&1 && \
+		ERROR="yes" && echo "Error: Invalid value \"COMMAND_NETCAT=$COMMAND_NETCAT\""
+	! which "$COMMAND_SSH" >/dev/null 2>&1 && \
+		ERROR="yes" && echo "Error: Invalid value \"COMMAND_SSH=$COMMAND_SSH\""
+	! which "$COMMAND_SSH_KEYGEN" >/dev/null 2>&1 && \
+		ERROR="yes" && echo "Error: Invalid value \"COMMAND_SSH_KEYGEN=$COMMAND_SSH_KEYGEN\""
+	! which "$COMMAND_CUPSD" >/dev/null 2>&1 && \
+		WARNING="yes" && echo "Warning: Invalid value \"COMMAND_CUPSD=$COMMAND_CUPSD\"" \
+					  && echo "         Users will not be able to enable printing."
+
+	# Misc directives
+	
+	[ -z $(echo "$ENABLE_AUTORECONNECT" | egrep "^[0|1]$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"ENABLE_AUTORECONNECT=$ENABLE_AUTORECONNECT\""
+	[ -z $(echo "$ENABLE_AUTORECONNECT_BEFORE_140" | egrep "^[0|1]$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"ENABLE_AUTORECONNECT_BEFORE_140=$ENABLE_AUTORECONNECT_BEFORE_140\""
+	
+	[ -z $(echo "$EXPORT_USERIP" | egrep "^[0|1]$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"EXPORT_USERIP=$EXPORT_USERIP\""
+	[ -z $(echo "$EXPORT_SESSIONID" | egrep "^[0|1]$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"EXPORT_SESSIONID=$EXPORT_SESSIONID\""
+	[ -n "$NODE_AUTOSTART" ] && ! which "$NODE_AUTOSTART" >/dev/null 2>&1 && \
+		WARNING="yes" && echo "Warning: Invalid value \"NODE_AUTOSTART=$NODE_AUTOSTART\"" \
+					  && echo "         No autostart will be performed."
+
+	[ -z $(echo "$ENABLE_ROOTLESS_MODE" | egrep "^[0|1]$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"ENABLE_ROOTLESS_MODE=$ENABLE_ROOTLESS_MODE\""
+
+	[ -z $(echo "$ENABLE_USESSION" | egrep "^[0|1]$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"ENABLE_USESSION=$ENABLE_USESSION\""
+	[ "$ENABLE_USESSION" = "1" ] && ! which "$COMMAND_SESSREG" >/dev/null 2>&1 && \
+		WARNING="yes" && echo "Warning: Invalid value \"COMMAND_SESSREG=$COMMAND_SESSREG\"" \
+					  && echo "         Logged in users will not be registered with sessreg."
+	
+	#AGENT_EXTRA_OPTIONS_RFB=""
+	#AGENT_EXTRA_OPTIONS_RDP=""
+	#AGENT_EXTRA_OPTIONS_X=""
+	#PROXY_EXTRA_OPTIONS=""
+		#Can these be checked???
+	
+	#AGENT_FONT_SERVER=""
+		#Any ideas on how I can check for a VALID host is velcome!
+	
+	[ -z $(echo "$PROXY_TCP_NODELAY" | egrep "^[0|1]$") ] && \
+		ERROR="yes" && echo "Error: Invalid value \"PROXY_TCP_NODELAY=$PROXY_TCP_NODELAY\""
+	
+	
+	if [ "$ERROR" = "yes" ]
+	then
+		echo
+		echo "  Errors occured during config check."
+		echo "  Please correct the configuration file."
+		echo
+	elif [ "$WARNING" = "yes" ]
+	then
+		echo
+		echo "  Warnings occured during config check."
+		echo "  To enable these features please correct the configuration file."
+		echo
+	fi
+fi


Property changes on: freenx-server/nxloadconfig
___________________________________________________________________
Name: svn:executable
   + 

Added: freenx-server/nxnode
===================================================================
--- freenx-server/nxnode	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/nxnode	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,818 @@
+#!/bin/bash
+
+# Free implementation of nxserver components
+#
+# nxnode does accept (for now):
+# 
+#	--startsession
+#	--terminate
+#	--smbmount 
+#		(smbmount is not implemented yet)
+#
+# Copyright (c) 2004 by Fabian Franz.
+#
+# License: GNU GPL, version 2
+#
+# CVS: $Id: nxnode,v 1.60 2005/06/23 15:42:52 fabianx Exp $
+#
+# 21.06.2004: - Full reconnection support
+
+# Read the config file
+. $(PATH=$(cd $(dirname $0) && pwd):$PATH which nxloadconfig) --userconf
+
+echo "NX> 1000 NXNODE - Version $NX_VERSION $NX_LICENSE"
+
+if [ "$1" != "--check" -a "$1" != "--setkey" ]
+then 
+	read CMDLINE
+
+	CMDLINE="a=b&$CMDLINE"
+fi
+
+# --------
+
+# following two functions are Copyright by Klaus Knopper
+
+# same for strings
+stringinstring(){
+case "$2" in *$1*) return 0;; esac
+return 1
+}
+
+# Reread boot command line; echo last parameter's argument or return false.
+getparam(){
+stringinstring "&$1=" "$CMDLINE" || return 1
+echo "$CMDLINE" | awk "/^$1=/"' { VAL=$2 } END { print VAL }' FS="=" RS="(&|\n)"
+return 0
+}
+
+find_app()
+{
+	set -- $*
+	which $1 2>/dev/null
+}
+
+getparam_user()
+{
+	[ $UID -eq 0 ] && echo $(getparam user)
+	[ $UID -eq 0 ] || $(whoami)
+}
+
+node_abort()
+{
+	echo "$@" 1>&2
+	exit 1
+}
+
+getparam_sessionid()
+{
+	sessionid=$(getparam sessionid)
+	
+	[ -n "$sessionid" ] || sessionid=$(getparam session_id)
+	[ -n "$sessionid" ] || node_abort "NX> 500 Error: missing parameter session id"
+	echo $sessionid
+}
+
+
+node_terminate_agent()
+{
+	AGENT_PID=$(cat $USER_FAKE_HOME/.nx/C-$1/pids/agent 2>/dev/null)
+	[ -n "$AGENT_PID" ] && kill $AGENT_PID 2>/dev/null
+}
+
+node_terminate_session()
+{
+	[ -d "$USER_FAKE_HOME/.nx/C-$1/" ] || return
+	AGENT_PID=$(cat $USER_FAKE_HOME/.nx/C-$1/pids/agent 2>/dev/null)
+	if [ -n "$AGENT_PID" ]
+	then 
+		kill $AGENT_PID 2>/dev/null
+		if ! [ "$virtualdesktop" = "0" -a "$ENABLE_ROOTLESS_MODE" != "1" ]
+		then
+			sleep 1
+			kill -9 $AGENT_PID 2>/dev/null
+		fi
+	fi
+	# remove possible leftover display ...
+	display=$(echo $1 | cut -d"-" -f2)
+	rm -f /tmp/.X$display-lock
+	rm -f /tmp/.X11-unix/X$display
+	
+	# remove cookie
+	$COMMAND_XAUTH -v source $USER_FAKE_HOME/.nx/C-$sess_id/scripts/authority >/dev/null 2>&1
+	# FIXME: What to do on errors ... ?
+	[ "$SESSION_LOG_CLEAN" = "1" ] && rm -rf $USER_FAKE_HOME/.nx/C-$1/
+	[ "$SESSION_LOG_CLEAN" = "0" -a "$2" = "failed" ] && mv $USER_FAKE_HOME/.nx/C-$1/ $USER_FAKE_HOME/.nx/F-C-$1/
+	[ "$SESSION_LOG_CLEAN" = "0" -a "$2" != "failed" ] && mv $USER_FAKE_HOME/.nx/C-$1/ $USER_FAKE_HOME/.nx/T-C-$1/
+}
+
+node_fail_restore_session()
+{
+	echo "NX> 1004 Error: Could not resume session. nxagent process could not be found."
+	node_terminate_session "$sess_id" "failed"
+	exit 1
+}
+
+node_suspend_session()
+{
+	AGENT_PID=$(cat $USER_FAKE_HOME/.nx/C-$1/pids/agent 2>/dev/null)
+	if [ -n "$AGENT_PID" ]
+	then 
+		kill -0 $AGENT_PID || return 1
+		kill -HUP $AGENT_PID && return 0
+	fi
+	return 1
+}
+
+# ---------
+#stringinstring "$CMD"
+
+node_start_applications()
+{
+	# close input and output file descriptors
+	exec 0<&-
+	exec 1>&-
+	exec 2>&-
+	
+	. /etc/profile
+	[ -f ~/.bash_profile ] && . ~/.bash_profile
+
+	mkdir -p $USER_FAKE_HOME/.nx/C-$sess_id/pids/
+
+	STARTX=""
+	case $type in
+		unix-kde)
+			STARTX=$COMMAND_START_KDE
+		;;
+		unix-gnome)
+			STARTX=$COMMAND_START_GNOME
+		;;
+		unix-cde)
+			STARTX=$COMMAND_START_CDE
+		;;
+		unix-application)
+			[ "$application" = "xterm" ] && application="$COMMAND_XTERM"
+			STARTX=$application
+		;;
+		unix-default)
+			if [ -x "$HOME/$USER_X_STARTUP_SCRIPT" ]; then
+				STARTX="$HOME/$USER_X_STARTUP_SCRIPT"
+			elif which "$DEFAULT_X_SESSION" >/dev/null 2>&1 ; then
+				STARTX="$DEFAULT_X_SESSION"
+			fi
+		;;
+	esac
+	[ -n "$STARTX" ] || return
+
+	if [ "$mediahelper" = "esd" ]
+	then
+		# Set Espeaker variable
+		let ESPEAKER=$display+7000
+		export ESPEAKER="127.0.0.1:$ESPEAKER"
+		
+		# Check for config file directive
+		if [ "$ENABLE_ESD_PRELOAD" = "1" -a -x "$(find_app $ESD_BIN_PRELOAD)" ]
+		then
+			STARTX="$ESD_BIN_PRELOAD $STARTX"
+			
+			# Do not spawn new ESD daemons
+			export ESD_NO_SPAWN="yes"
+			
+			echo "Info: NXNODE - Using $ESD_BIN_PRELOAD wrapper script." >> $USER_FAKE_HOME/.nx/C-$sess_id/session
+		fi
+	elif [ "$mediahelper" = "artsd" ]
+	then
+		# Overwrite users mcoprc
+		echo -n "GlobalComm=Arts::X11GlobalComm" > $HOME/.mcoprc
+		if [ "$ENABLE_ARTSD_PRELOAD" = "1" -a -x "$(find_app $ARTSD_BIN_PRELOAD)" ]
+		then
+			STARTX="$ARTSD_BIN_PRELOAD $STARTX"
+			echo "Info: NXNODE - Using $ARTSD_BIN_PRELOAD wrapper script." >> $USER_FAKE_HOME/.nx/C-$sess_id/session
+		fi
+	fi
+
+	[ "$virtualdesktop" = "0" -a "$ENABLE_ROOTLESS_MODE" != "1" ] && export LD_PRELOAD="$APPLICATION_LIBRARY_PRELOAD:$LD_PRELOAD"
+	if [ "$virtualdesktop" = "1" -a "$type" = "unix-application" -a "$DEFAULT_X_WM" != "" -a -x "$(find_app $DEFAULT_X_WM)" ]
+	then
+		DISPLAY=unix:$display $DEFAULT_X_WM 2>>$USER_FAKE_HOME/.nx/C-$sess_id/session &
+		WM_PID=$!
+	fi
+	DISPLAY=unix:$display $STARTX 2>>$USER_FAKE_HOME/.nx/C-$sess_id/session &
+	APP_PID=$!
+	mkdir -p $USER_FAKE_HOME/.nx/C-$sess_id/pids/
+	echo "$APP_PID" > $USER_FAKE_HOME/.nx/C-$sess_id/pids/applications
+	wait $APP_PID
+	if [ -n "$WM_PID" ]
+	then
+		# kill the WM after application is finished?
+		[ "$KILL_DEFAULT_X_WM" = "1" ] && kill $WM_PID 2>/dev/null
+		# or just wait until it finishes?
+		[ "$KILL_DEFAULT_X_WM" = "1" ] || wait $WM_PID
+	fi
+	rm -f $USER_FAKE_HOME/.nx/C-$sess_id/pids/applications
+	node_terminate_agent $sess_id
+}
+
+node_start_agent()
+{
+	# close input and output file descriptors
+	exec 0<&-
+	exec 1>&-
+	exec 2>&-
+	
+	export DISPLAY="nx/nx,options=$USER_FAKE_HOME/.nx/C-$sess_id/options:$display"
+	export XAUTHORITY="$USER_FAKE_HOME/.nx/C-$sess_id/authority"
+	export HOME="$USER_FAKE_HOME"
+	
+	# backwards compatibility
+	K=""
+	[ -n "$keyboard" ] && K="-keyboard $keyboard"
+	[ -n "$kbtype" ] && K="-kbtype $kbtype"
+	B=""
+	[ -n "$backingstore" ] && B="-bs $backingstore"
+	G=""
+	[ -n "$geometry" ] && G="-geometry $geometry"
+	R=""
+	[ "$virtualdesktop" = "0" ] && R="-R"
+	vncfullscreen=""
+	[ "$geometry" = "fullscreen" -a "$type" = "vnc" ] && vncfullscreen="-fullscreen" && G=""
+
+	if [ "$type" = "windows" ]
+	then
+		# nxdesktop session (Windows RDP)
+		[ "$SET_LD_LIBRARY_PATH" = "1" ] && export LD_LIBRARY_PATH="$AGENT_LIBRARY_PATH:$LD_LIBRARY_PATH"
+		U=""
+		P=""
+		[ -n "$agent_user" ] && U="-u $agent_user"
+		[ -n "$agent_password" ] && P="-p -"
+		echo "$agent_password" | $PATH_BIN/nxdesktop -name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" -option "$USER_FAKE_HOME/.nx/C-$sess_id/options" $K $G $U $P $agent_server $AGENT_EXTRA_OPTIONS_RDP 2>>$USER_FAKE_HOME/.nx/C-$sess_id/session &
+	elif [ "$type" = "vnc" ]
+	then
+		# nxviewer session (VNC RFP)
+		[ "$SET_LD_LIBRARY_PATH" = "1" ] && export LD_LIBRARY_PATH="$AGENT_LIBRARY_PATH:$LD_LIBRARY_PATH"
+		mkdir -p $USER_FAKE_HOME/.nx/C-$sess_id/scripts/
+		echo "$agent_password" | $PATH_BIN/nxpasswd $USER_FAKE_HOME/.nx/C-$sess_id/scripts/.passwd doit
+		$PATH_BIN/nxviewer -encodings tight hextile copyrect raw -passwd $USER_FAKE_HOME/.nx/C-$sess_id/scripts/.passwd -name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" -option "$USER_FAKE_HOME/.nx/C-$sess_id/options" $vncfullscreen $G $K $agent_server $AGENT_EXTRA_OPTIONS_RFB 2>>$USER_FAKE_HOME/.nx/C-$sess_id/session &
+	elif [ -n "$R" -a "$ENABLE_ROOTLESS_MODE" != "1" ]
+	then
+		# nxproxy single application mode session
+		[ "$SET_LD_LIBRARY_PATH" = "1" ] && export LD_LIBRARY_PATH="$PROXY_LIBRARY_PATH:$LD_LIBRARY_PATH"
+		$PATH_BIN/nxproxy -C :$display $PROXY_EXTRA_OPTIONS 2>>$USER_FAKE_HOME/.nx/C-$sess_id/session &
+	else
+		# nxagent session (X11)
+		[ "$SET_LD_LIBRARY_PATH" = "1" ] && export LD_LIBRARY_PATH="$AGENT_LIBRARY_PATH:$LD_LIBRARY_PATH"
+		P="-nopersistent"
+		OLD_IFS=$IFS
+		IFS=","
+		[ "$ENABLE_PERSISTENT_SESSION" = "all" ] && P="-persistent"
+		[ "$ENABLE_PERSISTENT_SESSION" = "all" ] || for USERNAME in $ENABLE_PERSISTENT_SESSION; do
+			[ "${USERNAME:0:1}" != "@" ] && [ "$USER" = "$USERNAME" ] && P="-persistent" && break ;
+			[ "${USERNAME:0:1}" = "@" ] && [ -z $(groups "$USER" | egrep "^${USERNAME:1}:") ] && P="-persistent" && break ;
+		done
+		for USERNAME in $DISABLE_PERSISTENT_SESSION; do
+			[ "${USERNAME:0:1}" != "@" ] && [ "$USER" = "$USERNAME" ] && P="-nopersistent" && break ;
+			[ "${USERNAME:0:1}" = "@" ] && [ -z $(groups "$USER" | egrep "^${USERNAME:1}:") ] && P="-nopersistent" && break ;
+		done
+		IFS=$OLD_IFS
+		FP=""
+		[ -n "$AGENT_FONT_SERVER" ] && FP="-fp $AGENT_FONT_SERVER"
+		$PATH_BIN/nxagent $P $R -name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" -option "$USER_FAKE_HOME/.nx/C-$sess_id/options" $K $G $B $FP :$display $AGENT_EXTRA_OPTIONS_X 2>>$USER_FAKE_HOME/.nx/C-$sess_id/session &
+	fi
+	PID=$!
+	mkdir -p $USER_FAKE_HOME/.nx/C-$sess_id/pids/
+	echo "$PID" > $USER_FAKE_HOME/.nx/C-$sess_id/pids/agent
+	wait $PID
+	rm -f $USER_FAKE_HOME/.nx/C-$sess_id/pids/agent
+	[ "$type" = "windows" -o "$type" = "vnc" ] && node_terminate_session "$sess_id"
+}
+
+node_kill_proxy()
+{
+	# Info: Proxy running in server mode with pid '5279'.
+	PROXY_PID=$(grep "Info: Proxy running in server mode with pid" $USER_FAKE_HOME/.nx/C-$1/session | cut -d"'" -f2)
+	sleep 2
+	[ -n "$PROXY_PID" ] && kill $PROXY_PID 2>/dev/null
+}
+
+node_cupsd_stop()
+{
+	[ -e "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd" ] || return
+	NODE_CUPSD_PID=$(cat "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd")
+	# Check for a running userspace cupsd, look if its still active 
+	# and kill it if so
+	( [ -n "$NODE_CUPSD_PID" ] && kill -0 $NODE_CUPSD_PID && kill $NODE_CUPSD_PID && sleep 2 && kill -0 $NODE_CUPSD_PID && kill -9 $NODE_CUPSD_PID ) 2>/dev/null
+	# delete pid file
+	rm -f "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd"
+	# remove all printers
+	echo >"$USER_FAKE_HOME/.nx/C-$sess_id/cups/printers.conf"
+}
+
+node_cupsd_setup()
+{
+	let NODE_CUPSD_PORT=$display+9000 # offset 9000 for userspace cupsd's
+	export NODE_CUPSD_PORT
+	mkdir -p "$USER_FAKE_HOME/.nx/C-$sess_id/pids/"
+	[ -e "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd" ] && return
+	touch "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd"
+	
+	mkdir -p $USER_FAKE_HOME/.nx/C-$sess_id/cups/spool/tmp $USER_FAKE_HOME/.nx/C-$sess_id/cups/spool/certs $USER_FAKE_HOME/.nx/C-$sess_id/cups/ppd
+	ln -sf spool/certs $USER_FAKE_HOME/.nx/C-$sess_id/cups/certs
+cat <<EOF > $USER_FAKE_HOME/.nx/C-$sess_id/cups/cupsd.conf
+AccessLog /dev/null
+ErrorLog error_log
+PageLog page_log
+LogLevel info
+TempDir $USER_FAKE_HOME/.nx/C-$sess_id/cups/spool/tmp
+RequestRoot $USER_FAKE_HOME/.nx/C-$sess_id/cups/spool
+ServerRoot $USER_FAKE_HOME/.nx/C-$sess_id/cups/
+Port $NODE_CUPSD_PORT
+Browsing Off
+ServerName localhost
+
+<Location />
+Order Deny,Allow
+Deny From All
+Allow from 127.0.0.1
+</Location>
+EOF
+	touch $USER_FAKE_HOME/.nx/C-$sess_id/cups/printers.conf $USER_FAKE_HOME/.nx/C-$sess_id/cups/classes.conf
+
+	# copy mime.* files
+	cp "$CUPS_ETC"/mime.* "$USER_FAKE_HOME/.nx/C-$sess_id/cups/"
+
+	# start cupsd
+	$COMMAND_CUPSD -f -c "$USER_FAKE_HOME/.nx/C-$sess_id/cups/cupsd.conf" &>/dev/null </dev/null &
+	CUPSD_PID=$!
+	sleep 3
+	echo $CUPSD_PID >"$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd"
+	# setup KDE
+	if [ "$ENABLE_KDE_CUPS" = "1" -a -e "$KDE_PRINTRC" ]
+	then
+		if egrep -q "^Port=" "$KDE_PRINTRC"
+		then
+			perl -pi -e 's/^Port=.*/Port='"$NODE_CUPSD_PORT"'/g' "$KDE_PRINTRC"
+		else
+			echo "[CUPS]" >> "$KDE_PRINTRC"
+			echo "Port=$NODE_CUPSD_PORT" >> "$KDE_PRINTRC"
+		fi
+	fi
+}
+
+node_cupsd_reload()
+{
+	[ -e "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd" ] || return
+	NODE_CUPSD_PID=$(cat "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd")
+	[ -n "$NODE_CUPSD_PID" ] && kill -0 $NODE_CUPSD_PID && kill -HUP $NODE_CUPSD_PID
+}
+
+node_cupsd_get_port()
+{
+	node_cupsd_setup
+	echo $NODE_CUPSD_PORT
+}
+
+node_umount_smb()
+{
+	[ -e "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/mpoint" ] || return
+	cat "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/mpoint" | while read mpoint
+	do
+		$COMMAND_SMBUMOUNT "$mpoint" >/dev/null 2>/dev/null
+	done
+}
+
+node_stop_services()
+{
+	node_umount_smb
+	node_cupsd_stop
+}
+
+
+#
+# Monitoring the nxagent: Its also kind of a "state-machine" 
+#                         as it has to keep track of different 
+#                         connection states and react differently.
+#
+
+node_start_monitor()
+{
+	RUNNING=0
+	RECONNECT=0
+	TAIL_PID=""
+	TIMEOUT_PID=""
+	
+	sh -c 'echo "Info: tail -f running with pid '\'\$$\''."; exec tail -n1 -f '$USER_FAKE_HOME'/.nx/C-'$sess_id'/session' | while read line 
+	do
+		#
+		# Catch tail pid
+		#
+		if stringinstring "Info: tail -f running with pid" "$line"
+		then
+			TAIL_PID=$(echo $line | cut -d"'" -f2)
+			# now set a timeout of 10 seconds ...
+			( 
+                          sleep 10
+			  if [ -d "$HOME/.nx/C-$sess_id/" ]
+			  then
+		          	echo "NX> 1004 Error: nxagent failed to start. Session timed out."
+			  	echo "                Blocking $display again ..."
+				touch /tmp/.X$display-lock
+			  	mv $HOME/.nx/C-$sess_id/ $HOME/.nx/F-C-$sess_id/ 2>/dev/null
+			  fi
+			  kill $TAIL_PID 2>/dev/null
+			) &
+			TIMEOUT_PID=$!
+			disown $TIMEOUT_PID
+		fi
+
+		#
+		# Detect nxagent syntax errors
+		#
+		
+		if stringinstring "Unrecognized option:" "$line"
+		then
+			kill $TAIL_PID 2>/dev/null
+			echo "NX> 1004 Error: nxagent failed to start with: $line"
+			break
+		fi
+
+		#
+		# Suspending possibilities
+		#
+		
+		if stringinstring "Info: Suspending session on user request." "$line"
+		then
+			kill $TAIL_PID 2>/dev/null
+			echo "NX> 1005 Session status: suspended"
+			kill -HUP $PROXY_PID 2>/dev/null
+			sleep 2
+			break
+		fi
+		
+		#if stringinstring "Info: Disconnected from user display."
+		if stringinstring "Info: Going to sleep waiting for reconnection." "$line"
+		then
+			kill $TAIL_PID 2>/dev/null
+			
+			echo "NX> 1005 Session status: suspended"
+			# umount shares & stop printers
+			node_stop_services
+			break
+		fi
+
+		if stringinstring "Error: Connection with remote peer broken." "$line"
+		then
+			kill $TAIL_PID 2>/dev/null
+			echo "NX> 1005 Session status: suspended"
+			kill -HUP $PROXY_PID 2>/dev/null
+			sleep 2
+			# time out faster for suspend
+			break
+		fi
+
+		#
+		# Session end
+		#
+		
+		if stringinstring "Info: End of session requested by " "$line" && [ "$RECONNECT" = "0" ]
+		then
+			echo "NX> 1009 Session status: terminating"
+			kill $PROXY_PID 2>/dev/null
+		fi
+		
+		if stringinstring "Info: Waiting for a further signal to complete." "$line" && [ "$RECONNECT" = "0" ]
+		then
+			kill $TAIL_PID 2>/dev/null
+			echo "NX> 1006 Session status: closed"
+			# TODO: Need a way to remove session infos ...
+			# especially for windows/vnc mode
+			kill $PROXY_PID 2>/dev/null
+			sleep 2
+			kill -9 $PROXY_PID 2>/dev/null
+
+			# umount shares & stop printers
+			node_stop_services
+
+			# kill the session
+			node_terminate_session "$sess_id"
+			
+			break
+		fi
+
+		#
+		# Session was suspended before, do not _close_ it, until
+		# it is fully resumed.
+		#
+
+		if stringinstring "Info: Going to reconnect to a new display." "$line"
+		then
+			RECONNECT=1
+		fi
+
+		#
+		# Session is running
+		#
+		
+		if stringinstring "Info: Waiting for connection from" "$line"
+		then
+			echo "NX> 710 Session status: running"
+			echo "NX> 1002 Commit"
+			echo "NX> 1006 Session status: running"
+			[ -n "$TIMEOUT_PID" ] && kill $TIMEOUT_PID 2>/dev/null
+		fi
+
+		#
+		# Status = Running - Do _not_ fail anymore.
+		#
+
+		if stringinstring "Info: Connection with remote proxy established." "$line"
+		then
+			RUNNING=1
+		fi
+	
+		#
+		# Catch proxy pid
+		#
+		
+		if stringinstring "Info: Proxy running in server mode with pid" "$line"
+		then
+			PROXY_PID=$(echo $line | cut -d"'" -f2)
+			#echo "Got $PROXY_PID ... " >> /tmp/nxnode.log
+		fi
+		
+		#
+		# Reconnection success!
+		#
+		
+		if stringinstring "Info: Reconnection succeded." "$line"
+		then
+			echo "NX> 718 Session restore succeded"
+			RECONNECT=0 # Do no longer block "Connection Close"
+		fi
+
+		#
+		# Error handling.
+		#
+
+		if stringinstring "Error: Connection with remote host" "$line" && [ "$RUNNING" = "0" ] 
+		then
+			kill $TAIL_PID 2>/dev/null
+			echo "NX> 1004 Error:"
+			echo "Session '$sess_id' has failed after reaching usable state."
+			[ "$SESSION_LOG_CLEAN" = "1" ] && rm -rf $USER_FAKE_HOME/.nx/C-$sess_id/
+			[ "$SESSION_LOG_CLEAN" = "1" ] || mv $USER_FAKE_HOME/.nx/C-$sess_id/ $USER_FAKE_HOME/.nx/F-C-$sess_id/
+			break
+		fi
+	done 
+	node_stop_services
+	# close all open file descriptors
+	exec 0<&-
+	exec 1>&-
+	exec 2>&-
+	exit 0
+}
+
+node_startsession()
+{
+
+	# user=knoppix&userip=192.168.1.66&uniqueid=6A8269CC467264EAEF6349D062689755&display=1000&session=lappi%5ffull&type=unix%2dkde&cache=8M&images=32M&cookie=84765070afee043cf83f85d21130145f&link=lan&render=1&backingstore=when_requested&imagecompressionmethod=0&geometry=fullscreen&keyboard=fr&media=0&samba=1&agent_server=&agent_user=&agent_password=
+
+	user=$(getparam user)
+	userip=$(getparam userip)
+	uniqueid=$(getparam uniqueid)
+	display=$(getparam display)
+	session=$(getparam session)
+	type=$(getparam type | sed 's/%2d/-/g')
+	application=$(getparam application)
+	cache=$(getparam cache)
+	images=$(getparam images)
+	cookie=$(getparam cookie)
+	link=$(getparam link)
+	virtualdesktop=$(getparam virtualdesktop)
+	render=$(getparam render)
+	backingstore=$(getparam backingstore)
+	imagecompressionmethod=$(getparam imagecompressionmethod)
+	geometry=$(getparam geometry)
+	keyboard=$(getparam keyboard)
+	kbtype=$(getparam kbtype)
+	media=$(getparam media)
+	mediahelper=$(getparam mediahelper)
+	sync=$(getparam sync)
+	samba=$(getparam samba)
+	agent_server=$(getparam agent_server)
+	agent_user=$(getparam agent_user)
+	agent_password=$(getparam agent_password)
+
+	[ "$EXPORT_USERIP" = "1" ] && export NXUSERIP="$userip"
+
+	ssl_tunnel=$(getparam encryption)
+	[ -z "$ssl_tunnel" ] && ssl_tunnel=0
+	
+	[ "$ssl_tunnel" = "1" ] && userip="127.0.0.1"
+	
+	# ok, lets make the session dir first:
+	
+	sess_id="$SERVER_NAME-$display-$uniqueid"
+	[ "$EXPORT_SESSIONID" = "1" ] && export NXSESSIONID="$sess_id"
+	
+	mkdir -p $USER_FAKE_HOME/.nx/C-$sess_id
+	
+	# cache=8M,images=32M,pack=nopack,link=lan,type=unix-kde,cleanup=0,accept=192.168.1.66,cookie=E38A94A77F975443AF04EC911881B120,id=Knoppix-1000-6A8269CC467264EAEF6349D062689755,samba=1,render=1:1000
+	
+	# TODO: imagecompressionmethod ...
+	[ "$imagecompressionmethod" = "0" ] && PACK="pack=nopack,"
+	
+	proxy_cookie=$(echo $[$RANDOM*$RANDOM] | md5sum | cut -d" " -f1)
+
+	# write options file
+	[ -z "$samba" ] && samba=0
+	[ -z "$media" ] && media=0
+
+	CACHE="cache=$cache,"
+	[ -z "$cache" ] && CACHE=""
+	IMAGES="images=$images,"
+	[ -z "$images" ] && IMAGES=""
+
+	ACCEPT="accept=$userip,"
+	[ "$userip" = "*" ] && ACCEPT=""
+
+	OLD_UMASK=$(umask)
+	umask 0077
+
+cat << EOF > $USER_FAKE_HOME/.nx/C-$sess_id/options
+${kbtype:+kbtype=$kbtype,}${CACHE}${IMAGES}${PACK}link=$link,type=$type,cleanup=0,${ACCEPT}cookie=$proxy_cookie,id=$sess_id,samba=$samba,media=$media${sync:+,sync=$sync}${cups:+,cups=$cups}:$display
+EOF
+	umask $OLD_UMASK
+#samba=$samba,
+	#cache=$cache,images=$images,pack=nopack,link=$link,type=$type,cleanup=0,accept=$userip,cookie=$proxy_cookie,id=$sess_id
+#samba=$samba,media=$media,render=$render:$display
+
+	# write xauth script file
+
+$COMMAND_XAUTH >/dev/null 2>&1 <<EOF
+add localhost:$display MIT-MAGIC-COOKIE-1 $cookie
+add unix:$display MIT-MAGIC-COOKIE-1 $cookie
+exit
+EOF
+
+$COMMAND_XAUTH -f "$USER_FAKE_HOME/.nx/C-$sess_id/authority" >/dev/null 2>&1 <<EOF
+add localhost:$display MIT-MAGIC-COOKIE-1 $cookie
+add unix:$display MIT-MAGIC-COOKIE-1 $cookie
+exit
+EOF
+
+	mkdir -m700 $USER_FAKE_HOME/.nx/C-$sess_id/scripts/ 2>/dev/null || chmod 700 $USER_FAKE_HOME/.nx/C-$sess_id/scripts/
+
+cat << EOF >$USER_FAKE_HOME/.nx/C-$sess_id/scripts/authority
+remove localhost:$display
+remove unix:$display
+exit
+EOF
+
+echo > $USER_FAKE_HOME/.nx/C-$sess_id/session
+node_start_monitor &
+SPID=$!
+mkdir -p $USER_FAKE_HOME/.nx/C-$sess_id/pids/
+echo "$SPID" > $USER_FAKE_HOME/.nx/C-$sess_id/pids/monitor
+
+if [ "$1" = "restore" ]
+then
+	node_suspend_session $sess_id || node_fail_restore_session
+else
+	node_start_agent &
+	node_start_applications &
+fi
+
+which "$NODE_AUTOSTART" >/dev/null 2>&1 && "$NODE_AUTOSTART" "$1"
+	
+cat << EOF
+NX> 700 Session id: $sess_id
+NX> 705 Session display: $display
+NX> 703 Session type: $type
+NX> 701 Proxy cookie: $proxy_cookie
+NX> 702 Proxy IP: $userip
+NX> 706 Agent cookie: $cookie
+NX> 704 Session cache: $type
+NX> 707 SSL tunneling: $ssl_tunnel
+EOF
+
+# collection ...
+
+# NX> 1004 Error:
+#Session 'Knoppix-1000-40EFB9F64FA55C64C41C72CA39EBD720' has failed after reaching usable state. Session directory '/home/knoppix/.nx/F-C-Knoppix-1000-40EFB9F64FA55C64C41C72CA39EBD720' will be not deleted to allow for further investigation.
+
+wait $SPID
+rm -f $USER_FAKE_HOME/.nx/C-$sess_id/pids/monitor
+}
+
+cmd_node_terminate()
+{
+	sessionid=$(getparam_sessionid)
+	echo "NX> 716 Terminating session $sessionid on user request."
+	display=$(cd $USER_FAKE_HOME/.nx/; echo C-$SERVER_NAME-*-$sessionid | cut -d"-" -f3)
+	node_terminate_session "$SERVER_NAME-$display-$sessionid"
+}
+
+cmd_node_suspend()
+{
+	sessionid=$(getparam_sessionid)
+	echo "NX> 716 Suspending session $sessionid on user request."
+	display=$(cd $USER_FAKE_HOME/.nx/; echo C-$SERVER_NAME-*-$sessionid | cut -d"-" -f3)
+	node_suspend_session "$SERVER_NAME-$display-$sessionid"
+}
+
+cmd_node_smbmount()
+{
+	sessionid=$(getparam_sessionid)
+	port=$(getparam port)
+	username=$(getparam username)
+	password=$(getparam password)
+	share=$(getparam share)
+	computername=$(getparam computername)
+	dir=$(getparam dir | sed 's|$(SHARES)|MyShares|g')
+	rdir=$(getparam dir | sed 's|$(SHARES)/||g')
+	display=$(cd $USER_FAKE_HOME/.nx/; echo C-$SERVER_NAME-*-$sessionid | cut -d"-" -f3)
+	mkdir -p "$HOME/$dir"
+	ERROR=$(PASSWD="$password" "$COMMAND_SMBMOUNT" "//$computername/$rdir" "$HOME/$dir" -o username="$username,ip=127.0.0.1,port=$port" 2>&1)
+	if [ $? -eq 0 ]
+	then
+		$PATH_BIN/nxclient -dialog ok -caption "NXServer Message" -message "Info: Share: '//$computername/$rdir' mounted on: '$HOME/$dir'" -noautokill -display :$display &
+		echo "$HOME/$dir" >> "$USER_FAKE_HOME/.nx/C-$SERVER_NAME-$display-$sessionid/scripts/mpoint"
+	else
+		$PATH_BIN/nxclient -dialog ok -caption "NXServer Message" -message "Info: Share: '//$computername/$rdir' failed to mount: $ERROR" -noautokill -display :$display &
+	fi
+}
+
+cmd_node_addprinter()
+{
+	sessionid=$(getparam_sessionid)
+	type=$(getparam type)
+	port=$(getparam port)
+	username=$(getparam username)
+	password=$(getparam password)
+	share=$(getparam share)
+	printer=$(getparam printer)
+	computername=$(getparam computername)
+	public=$(getparam public)
+	model=$(getparam model)
+	defaultPrinter=$(getparam defaultPrinter)
+	display=$(cd $USER_FAKE_HOME/.nx/; echo C-$SERVER_NAME-*-$sessionid | cut -d"-" -f3)
+	sess_id="$SERVER_NAME-$display-$sessionid"
+	# this will also setup the userspace cupsd
+	IPP_PORT=$(node_cupsd_get_port)
+	export IPP_PORT
+	if [ "$type" = "smb" ]
+	then
+		DEVICE_URI="smb://$username:$password at localhost:$port/$share"
+		NAME="$share"
+	else
+		DEVICE_URI="ipp://localhost:$port/printers/$printer"
+		NAME="$printer"
+	fi
+	MODEL=$($PATH_BIN/nxclient -printer "$NAME" -noautokill -display :$display)
+	[ -z "$MODEL" -o "$MODEL" = "cancel: aborted" ] && return
+	
+	PUBLIC="-u allow:$USER"
+	[ "$public" == "1" ] && PUBLIC=""
+	lpadmin -p "$NAME" -E -v "$DEVICE_URI" -m "$MODEL" $PUBLIC
+	[ "$defaultPrinter" = "1" ] && lpadmin -d "$NAME"
+}
+
+
+case "$1" in 
+	--startsession)
+		node_startsession
+	;;
+	--resumesession)
+		node_startsession "restore"
+	;;
+	--terminate)
+		cmd_node_terminate
+	;;
+	--suspend)
+		cmd_node_suspend
+	;;
+	--smbmount)
+		cmd_node_smbmount &>/dev/null </dev/null &
+	;;
+	--addprinter)
+		cmd_node_addprinter &>/dev/null </dev/null &
+	;;
+	--check)
+		echo "NX> 716 finished"
+	;;
+	--setkey)
+		mkdir -m 700 -p $HOME/.ssh
+		if ! grep -q "$(cat $NX_ETC_DIR/users.id_dsa.pub)" $HOME/.ssh/$SSH_AUTHORIZED_KEYS 2>/dev/null
+		then
+			cat $NX_ETC_DIR/users.id_dsa.pub >> $HOME/.ssh/$SSH_AUTHORIZED_KEYS
+			chmod 600 $HOME/.ssh/$SSH_AUTHORIZED_KEYS
+			echo "NX> 716 Public key added to: $HOME/.ssh/$SSH_AUTHORIZED_KEYS"
+		else
+			echo "NX> 716 Public key is already present in: $HOME/.ssh/$SSH_AUTHORIZED_KEYS"
+		fi
+	;;
+	*)
+		echo "NX> 500 Error: Command not found"
+	;;
+esac
+echo "NX> 1001 Bye."


Property changes on: freenx-server/nxnode
___________________________________________________________________
Name: svn:executable
   + 

Added: freenx-server/nxnode-login
===================================================================
--- freenx-server/nxnode-login	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/nxnode-login	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,65 @@
+#!/usr/bin/expect
+# nxnode-login: spawns and controls ssh 
+# Copyright (c) 2004 by Fabian Franz.
+# License: GPL, version 2
+#
+# CVS: $Id: nxnode-login,v 1.12 2005/03/21 13:00:21 jonno Exp $
+#
+
+# Syntax: nxnode-login {ssh|su} user ssh-port executable command tosend
+
+set auth_method [lindex $argv 0]
+set user [lindex $argv 1]
+set port [lindex $argv 2]
+set executable [lindex $argv 3]
+set command [lindex $argv 4]
+set tosend [lindex $argv 5]
+set command_ssh "ssh"
+catch {set command_ssh $env(COMMAND_SSH)}
+
+expect_user -re "(.*)\n" 
+set password $expect_out(1,string)
+
+set stty_init "raw icrnl"
+
+if { "$auth_method"=="ssh" } { 
+	set pid [spawn -noecho $command_ssh -2 -x -l "$user" "127.0.0.1" -o "NumberOfPasswordPrompts 1" -p "$port" "$executable $command" ]
+} elseif { "$auth_method"=="su" } {
+	set pid [spawn -noecho su - "$user" -c "$executable $command" ]
+} else {
+	exit 1
+}
+
+while {1} {
+	expect {
+		"Are you sure you want to continue connecting (yes/no)?" { send "yes\r" }
+		"assword*:"  { sleep 0.3; send "$password\r" }
+		"Permission denied*" { exit 1 }
+		"su: Authentication failure" { exit 1 }
+		"NX> 1000 NXNODE - Version" { 
+			break
+		}
+	} 
+}
+
+if { "$tosend"!="" } { 
+	send "$tosend\r"
+}
+
+expect {
+	"NX> 716 finished" { }
+	"NX> 700" { 
+			set timeout -1
+			expect {
+				"NX> 1001 Bye." { exit 0 }
+				"NX> *" { exp_continue }
+			}
+			exit 0
+		  }
+	"NX> 716 Public key is already present in:" { }
+	"NX> 716 Public key added to:" { }
+	"NX> 716 Terminating session * on user request." { }
+	"NX> 716 Suspending session * on user request." { }
+	"NX> 500 Error: " { exit 1}
+}
+expect "NX> 1001 Bye."


Property changes on: freenx-server/nxnode-login
___________________________________________________________________
Name: svn:executable
   + 

Added: freenx-server/nxprint
===================================================================
--- freenx-server/nxprint	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/nxprint	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,67 @@
+#!/bin/bash
+#
+# nxprint - Prints a list of available drivers or printers
+# 
+# Copyright (c) 2005 by Fabian Franz <freenx at fabian-franz.de>
+#
+# License: GPL, version 2
+#
+#
+
+# disable foomatic by default
+FOOMATIC="no"
+
+HELP="no"
+DRIVERS="no"
+PRINTERS="no"
+
+while [ "$1" ]
+do
+        case "$1" in
+                --help) HELP="yes"; shift ;;
+                --drivers|-d) DRIVERS="yes"; shift ;;
+                --printers|-l) PRINTERS="yes"; shift ;;
+                --) shift ; break ;;
+                *) echo "Invalid flag $1" ; HELP="yes"; shift ; break ;;
+        esac
+done
+
+[ "$DRIVERS" = "no" -a "$PRINTERS" = "no" ] && HELP="yes"
+
+if [ "$HELP" = "yes" ]
+then
+        echo "nxprint - Prints a list of available drivers or printers"
+	echo ""
+        echo "Syntax: nxprint --help"
+        echo "        nxprint --drivers"
+        echo "        nxprint --printes"
+        echo
+        echo "  --drivers                prints a list of available CUPS drivers"
+        echo "  --printers               prints a list of available CUPS printers"
+        exit 0
+fi
+
+if [ "$DRIVERS" = "yes" ]
+then
+	echo "driver|Raw|Raw Queue|raw"
+	{ 
+        cd /usr/share/cups/model
+        awk -F '"' '/*Manufacturer:/ { a[FILENAME]=$2 }
+                    /*NickName:/ { b[FILENAME]=$2 } 
+                    END { 
+                       for (i in a) 
+                          print "driver|" (a[i]=="ESP"?substr(b[i],0,index(b[i]," ")-1):a[i]) "|"b[i]"|"i
+                    }' *.ppd
+        } | sort
+
+	if [ $FOOMATIC="yes" ]
+	then
+		# TODO: Add support for foomatic-style ppds
+		:
+	fi
+fi
+
+if [ "$PRINTERS" = "yes" ]
+then
+	lpstat -p | awk '{ print $1 "|" $2 }'
+fi


Property changes on: freenx-server/nxprint
___________________________________________________________________
Name: svn:executable
   + 

Added: freenx-server/nxserver
===================================================================
--- freenx-server/nxserver	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/nxserver	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,1379 @@
+#!/bin/bash
+
+# Free implementation of nxserver components
+#
+# To use nxserver add the user "nx" 
+# and use nxserver as default shell.
+#
+# Also make sure that hostkey based authentification works.
+# 
+# Copyright (c) 2004 by Fabian Franz <FreeNX at fabian-franz.de>.
+#
+# License: GNU GPL, version 2
+#
+# CVS: $Id: nxserver,v 1.55 2005/06/25 12:26:22 fabianx Exp $
+#
+
+# Read the config file
+. $(PATH=$(cd $(dirname $0) && pwd):$PATH which nxloadconfig) --
+
+# following two functions are Copyright by Klaus Knopper
+
+stringinstring(){
+case "$2" in *$1*) return 0;; esac
+return 1
+}
+
+# Reread boot command line; echo last parameter's argument or return false.
+getparam(){
+stringinstring "&$1=" "$CMDLINE" || return 1
+echo "$CMDLINE" | awk "/^$1=/"' { VAL=$2 } END { print VAL }' FS="=" RS="(&|\n)"
+return 0
+}
+
+
+############### PACKAGE passdb.bm #######################
+#
+# Library of passdb functions (outsource)
+#
+
+# Policy: Variable and function names _must_ start with passdb_ / PASSDB_
+
+# Needed global vars: $NX_ETC_DIR, $PATH_BIN
+
+# Needed nonstd functions: md5sum
+
+
+passdb_get_crypt_pass()
+{
+	echo "$@" | md5sum | cut -d" " -f1
+}
+
+passdb_get_pass()
+{
+	PASSDB_CHUSER="$1"
+	PASSDB_PASS=$(egrep "^$PASSDB_CHUSER:" $NX_ETC_DIR/passwords 2>/dev/null | cut -d":" -f2)
+	if [ "$ENABLE_PASSDB_AUTHENTICATION" = "1" ]
+	then
+		egrep -q "^$PASSDB_CHUSER:" $NX_ETC_DIR/passwords 2>/dev/null && echo $PASSDB_PASS
+		egrep -q "^$PASSDB_CHUSER:" $NX_ETC_DIR/passwords 2>/dev/null || echo "NOT_VALID"
+	else
+		echo "NOT_VALID"
+	fi
+}
+
+passdb_chpass()
+{
+	PASSDB_CHUSER="$1"
+	PASSDB_ENC_PASS="$2"
+	cp -f $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
+	perl -pi -e "s/$PASSDB_CHUSER:.*/$PASSDB_CHUSER:$PASSDB_ENC_PASS/g" $NX_ETC_DIR/passwords
+}
+
+passdb_user_exists()
+{
+	PASSDB_CHUSER="$1"
+	egrep -q "^$PASSDB_CHUSER:" $NX_ETC_DIR/passwords 2>/dev/null
+}
+
+
+passdb_remove_user()
+{
+	PASSDB_CHUSER="$1"
+	cp -f $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
+	perl -pi -e "s/$PASSDB_CHUSER:.*\n//g" $NX_ETC_DIR/passwords
+}
+
+passdb_add_user()
+{
+	PASSDB_CHUSER="$1"
+	cp -f $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
+	echo "$PASSDB_CHUSER:*" >> $NX_ETC_DIR/passwords
+	# deactivated to avoid problems with comm-server
+	su - $PASSDB_CHUSER -c "$PATH_BIN/nxnode --setkey"
+}
+
+passdb_list_user()
+{
+	cat $NX_ETC_DIR/passwords | cut -d":" -f1
+}
+
+#
+# End of passdb Library
+#
+
+############### PACKAGE session.bm #######################
+#
+# Library of session management functions
+#
+
+# Needed global vars: $NX_SESS_DIR
+
+session_list()
+{
+	cat $NX_SESS_DIR/running/sessionId"{$1}"
+}
+
+# Find all running session-filenames 
+
+session_find_all()
+{
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		echo $i
+	done
+}
+
+# Find all running sessions of a id
+session_find_id()
+{
+	[ -f $NX_SESS_DIR/running/sessionId"{$1}" ] && echo $NX_SESS_DIR/running/sessionId"{$1}"
+}
+
+# finds out if a session belongs to a user
+
+session_find_id_user()
+{
+	[ -f $NX_SESS_DIR/running/sessionId"{$1}" ] && egrep -q "^userName=$2$" $NX_SESS_DIR/running/sessionId"{$1}" && return 0
+	return 1
+}
+
+# Find all running sessions of a user
+session_find_user()
+{
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		egrep -q "^userName=$1$" $i && echo $i
+	done
+}
+
+# Find all running sessions of a display
+session_find_display()
+{	
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		egrep -q "^display=$1$" $i && echo $i
+	done
+}
+
+# session_get_cmdline <session filename>
+
+session_get_cmdline()
+{
+	echo "a=b" | cat - $1 | tr '\n' '&'
+}
+
+# session_get <uniqueid>
+
+session_get()
+{
+	session_get_cmdline $NX_SESS_DIR/running/sessionId"{$1}"
+}
+
+
+# Get the first session, which can be resumed
+
+session_get_user_suspended()
+{
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		if egrep -q "^userName=$1$" $i && egrep -q "^status=$2$" $i
+		then
+			CMDLINE=$(session_get_cmdline $i)
+			echo "$(getparam sessionId)"
+			break
+		fi
+	done
+}
+
+# Count all sessions of a user
+# and save it in SESSION_COUNT and SESSION_COUNT_USER
+
+session_count_user()
+{
+	SESSION_COUNT=0
+	SESSION_COUNT_USER=0
+
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		let SESSION_COUNT=$SESSION_COUNT+1
+		egrep -q "^userName=$1$" $i && let SESSION_COUNT_USER=$SESSION_COUNT_USER+1
+	done
+}
+
+# List all sessions of a user
+
+session_list_user_suspended()
+{
+	SESSION_COUNT=0
+	SESSION_COUNT_USER=0
+
+	TMPFILE=$(mktemp /tmp/nxserver_tmp.XXXXXXXXX)
+	echo "NX> 127 Sessions list of user '$1' for reconnect:" > $TMPFILE
+	echo >> $TMPFILE
+	if [ -z "$4" ]
+	then
+		
+		echo "Display Type             Session ID                       Options  Depth Screensize     Available Session Name" >> $TMPFILE
+		echo "------- ---------------- -------------------------------- -------- ----- -------------- --------- ----------------------" >> $TMPFILE
+	else
+		echo "Display Type             Session ID                       Options  Depth Screen         Status      Session Name" >> $TMPFILE
+		echo " ------- ---------------- -------------------------------- -------- ----- -------------- ----------- ------------------------------" >> $TMPFILE
+	fi
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		let SESSION_COUNT=$SESSION_COUNT+1
+		if egrep -q "^userName=$1$" $i && egrep -q "^status=$2$" $i #&& grep -q "screeninfo=$3" $i
+		then
+			CMDLINE=$(session_get_cmdline $i)
+			depth=$(getparam screeninfo | cut -d "x" -f3 | cut -d "+" -f1 )
+			geom=$(getparam screeninfo | cut -d "x" -f1,2) 
+			render=$(getparam screeninfo | cut -d "+" -f2 )
+			available="N/A"
+			udepth=$(echo $3 | cut -d "x" -f3 | cut -d "+" -f1 )
+			urender=$(echo $3 | cut -d "+" -f2 )
+			options="-"
+			stringinstring "fullscreen" "$3" && options="F"
+			[ "$(getparam geometry)" = "fullscreen" ] || options="-"
+			[ "$urender" = "render" ] && options="${options}R---PSA"
+			[ "$urender" = "render" ] || options="${options}----PSA"
+			[ "$udepth" = "$depth" -a "$urender" = "$render" ] && available=$(getparam status)
+			# FIXME: HACK !!! to keep compatibility with old snapshot version (Knoppix 3.6 based for example)
+			if [ -z "$4" -a "$available" != "N/A" ] 
+			then
+				available="Yes"
+			fi
+			echo -e "$(getparam display)\t$(getparam type)\t$(getparam sessionId)\t$options\t$depth\t$geom\t$available\t$(getparam sessionName)" >> $TMPFILE
+		fi
+		egrep -q "^userName=$1$" $i && let SESSION_COUNT_USER=$SESSION_COUNT_USER+1
+	done
+	echo "" >> $TMPFILE
+	echo "" >> $TMPFILE
+	cat $TMPFILE
+	rm -f $TMPFILE
+	if [ "$SESSION_COUNT" -ge "$SESSION_LIMIT" -o "$SESSION_COUNT_USER" -ge "$SESSION_USER_LIMIT" ]
+	then
+		echo "NX> 147 Server capacity: reached for user: $1"
+	else
+		echo "NX> 148 Server capacity: not reached for user: $1"
+	fi
+}
+
+session_list_user()
+{
+	echo "NX> 127 Sessions list of user '$1'"
+	echo
+	echo "Display Username        Remote IP       Session ID"
+	echo "------- --------------- --------------- --------------------------------"
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		if egrep -q "^userName=$1$" $i
+		then
+			CMDLINE=$(session_get_cmdline $i)
+			echo -e "$(getparam display)\t$(getparam userName)\t$(getparam foreignAddress)\t$(getparam sessionId)"
+		fi
+	done
+}
+
+session_history()
+{
+	userName=$1
+	sessionId=$2
+	echo "NX> 127 Session list:"
+	echo
+	echo "Display Username        Remote IP       Session ID                       Date                Status"
+	echo "------- --------------- --------------- -------------------------------- ------------------- -----------"
+	for j in $(ls --time-style +%s -la "$NX_SESS_DIR"/{closed,failed,running} | awk '/sessionId/ { print $6 " " $7 }' | sort -n | cut -d" " -f2)
+	do
+		if [ -n "$sessionId" ]
+		then
+			[ "$j" = "sessionId{$sessionId}" ] || continue
+		fi
+		i="$NX_SESS_DIR"/*/"$j"
+		[ -f $i ] || break
+		CMDLINE=$(session_get_cmdline $i)
+		if [ -n "$userName" ]
+		then
+			[ "$userName" = "$(getparam userName)" ] || continue
+		fi
+		echo -e "$(getparam display)\t$(getparam userName)\t$(getparam foreignAddress)\t$(getparam sessionId)\t$(ls --time-style="+%F %X" -l $i | awk '/sessionId/ { print $6 " " $7 }')\t$(getparam status)"
+	done
+}
+
+# remove all sessions older than $SESSION_HISTORY seconds in failed/closed.
+
+session_cleanup()
+{
+	[ "$SESSION_HISTORY" -gt "-1" ] || return
+	let SESSION_HISTORY_MINUTES=$SESSION_HISTORY/60
+	find $NX_SESS_DIR/closed/ $NX_SESS_DIR/failed/ -type f -mmin +"$SESSION_HISTORY_MINUTES" -exec rm -f '{}' ';'
+}
+
+session_list_all()
+{
+	echo "NX> 127 Sessions list:"
+	echo
+	echo "Display Username        Remote IP       Session ID"
+	echo "------- --------------- --------------- --------------------------------"
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		CMDLINE=$(session_get_cmdline $i)
+		echo -e "$(getparam display)\t$(getparam userName)\t$(getparam foreignAddress)\t$(getparam sessionId)"
+	done
+}
+
+
+# session_add <session_id> <options>
+
+session_add()
+{
+	id=$1
+	shift
+	echo "$@" | tr '&' '\n' > $NX_SESS_DIR/running/sessionId'{'$id'}'
+}
+
+# session_change <session_id> <parameter> <new_value>
+
+session_change()
+{
+	[ -f $NX_SESS_DIR/running/sessionId'{'$1'}' ] && perl -pi -e "s/$2=.*/$2=$3/" $NX_SESS_DIR/running/sessionId'{'$1'}'
+}
+
+# session_id <new status>
+
+session_status()
+{
+	session_change "$1" "status" "$2"
+}
+
+# session_close <session_id> <end-time>
+
+session_close()
+{
+	perl -pi -e "s/startTime=\(.*\)/startTime=\1\nendTime=$(date +%s)/" $NX_SESS_DIR/running/sessionId'{'$1'}'
+	session_status $1 "Finished"
+	[ "$SESSION_HISTORY" = "0" ] && rm -f $NX_SESS_DIR/running/sessionId'{'$1'}'
+	[ "$SESSION_HISTORY" = "0" ] || mv -f $NX_SESS_DIR/running/sessionId'{'$1'}' $NX_SESS_DIR/closed/sessionId'{'$1'}'
+}
+
+session_fail()
+{
+	perl -pi -e "s/startTime=\(.*\)/startTime=\1\nendTime=$(date +%s)/" $NX_SESS_DIR/running/sessionId'{'$1'}'
+	session_status $1 "Failed"
+	[ "$SESSION_HISTORY" = "0" ] && rm -f $NX_SESS_DIR/running/sessionId'{'$1'}'
+	[ "$SESSION_HISTORY" = "0" ] || mv -f $NX_SESS_DIR/running/sessionId'{'$1'}' $NX_SESS_DIR/failed/sessionId'{'$1'}'
+}
+
+session_suspend()
+{
+	session_status $1 "Suspended"
+	session_change $1 foreignAddress "-"
+}
+
+#
+# end of library
+#
+
+
+#
+# Main nxserver <-> nxclient communication module
+#
+
+if [ $USER = "nxfree" -o "$USER" = "nx" ]
+then
+
+# Loglevels:
+# 1: Errors
+# 2: Warnings
+# 3: Important information
+# 4: Server - Client communication
+# 5: Information
+# 6: Debugging information
+# 7: stderror-channel of some applications
+
+log()
+{
+	[ "$NX_LOG_LEVEL" -ge "$1" -a -w "$NX_LOGFILE" ] && shift && echo "$@" >> "$NX_LOGFILE"
+}
+
+log_tee()
+{
+	[ "$NX_LOG_LEVEL" -ge "4" -a -w "$NX_LOGFILE" ] && exec tee -a "$NX_LOGFILE"
+	[ "$NX_LOG_LEVEL" -ge "4" -a -w "$NX_LOGFILE" ] || exec cat -
+}
+
+log_error()
+{
+	[ "$NX_LOG_LEVEL" -ge "7" -a -w "$NX_LOGFILE" ] && exec tee -a "$NX_LOGFILE"
+	[ "$NX_LOG_LEVEL" -ge "7" -a -w "$NX_LOGFILE" ] || exec cat - 
+}
+
+echo_x()
+{
+	log "4" "$@"
+	echo "$@"
+}
+
+# Forward the connection to the commercial NoMachine server
+server_forward_nomachine()
+{
+	set -- "${RECORD_CMD[@]}"
+	
+	# setup the FIFOs
+	SERVER_IN=~/server.in.$$
+	SERVER_OUT=~/server.out.$$
+	rm -f $SERVER_IN $SERVER_OUT
+	mkfifo $SERVER_IN $SERVER_OUT
+	exec 3<>$SERVER_IN
+	exec 4<>$SERVER_OUT
+	
+	$NOMACHINE_SERVER <&3 >&4 &
+	NX_PID=$!
+	
+	while true
+	do
+		read -n7 opcode <&4
+		line=""
+		case "$opcode" in
+			"NX> 105")
+				echo $1 >&3
+				shift
+			;;
+			"NX> 101")
+				echo $USER >&3
+				read line <&4
+				break
+			;;
+			*)
+				read line <&4
+			;;
+		esac
+	done
+	log 5 "Info: Forwarding connection to NoMachine server done."
+	cat <&4 &
+	CAT_PID=$!
+	cat - >&3
+	rm -f $SERVER_IN $SERVER_OUT
+	kill $CAT_PID
+	kill $NX_PID
+	exit 0
+}
+
+# Start!
+log 3 "-- NX SERVER START: $@"
+
+if [ "$ENABLE_SERVER_FORWARD" = "1" -a -n "$SERVER_FORWARD_HOST" ]
+then
+	log 3 "Info: Forwarding connection to $SERVER_FORWARD_HOST with secret key $SERVER_FORWARD_KEY."
+	$COMMAND_SSH -i "$SERVER_FORWARD_KEY" "nx@$SERVER_FORWARD_HOST:$SERVER_FORWARD_PORT"
+	exit 0
+fi
+
+# forward the connection to commercial NoMachine server?
+if [ "$ENABLE_NOMACHINE_FORWARD_PORT" = "1" -a "$NOMACHINE_FORWARD_PORT" = "$(echo $SSH_CLIENT | cut -d' ' -f3)" -a -n "$NOMACHINE_SERVER" ]
+then
+	log 3 "Info: Detected SSH destination port $NOMACHINE_FORWARD_PORT. Forwarding connection to commercial NoMachine server."
+	exec $NOMACHINE_SERVER
+	log 1 "Error: Forwarding to NoMachine Server $NOMACHINE_SERVER failed. Using FreeNX server instead."
+fi
+
+echo_x "HELLO NXSERVER - Version $NX_VERSION $NX_LICENSE"
+
+[ "$ENABLE_NOMACHINE_FORWARD_USER" = "1" ] && RECORD_CMD=()
+
+# Login stage
+while true
+do
+	echo_x -n "NX> 105 "
+	read CMD
+	# FIXME?
+	[ "$CMD" = "" ] && CMD="quit"
+	echo_x "$CMD"
+	
+	# record $CMD in RECORD_CMD array
+	[ "$ENABLE_NOMACHINE_FORWARD_USER" = "1" ] && RECORD_CMD=( "${RECORD_CMD[@]}" "$CMD" )
+	
+	case "$CMD" in 
+		quit|QUIT)
+			echo_x "Quit"
+			echo_x "NX> 999 Bye"
+			exit 0
+		;;
+		exit|EXIT)
+			echo_x "Exit"
+			echo_x "NX> 999 Bye"
+			exit 0
+		;;
+		bye|BYE)
+			echo_x "Bye"
+			echo_x "NX> 999 Bye"
+			exit 0
+		;;
+		hello*|HELLO*)
+			PROTO=$(echo $CMD | sed 's/.*Version \(.*\)/\1/g')
+			echo_x "NX> 134 Accepted protocol: $PROTO"
+			if [ "$PROTO" = "1.3.0" -o "$PROTO" = "1.3.2" ]
+			then
+				[ "$ENABLE_AUTORECONNECT_BEFORE_140" = "1" ] && ENABLE_AUTORECONNECT="1"
+			fi
+		;;
+		"set auth_mode*"|"SET AUTH_MODE*")
+			if [ "$CMD" = "set auth_mode password" -o "$CMD" = "SET AUTH_MODE PASSWORD" ]
+			then
+				echo_x "Set auth_mode: password"
+			else
+				echo_x "NX> 500 ERROR: unknown auth mode ''"
+			fi
+		;;
+		login|LOGIN)
+			LOGIN_SUCCESS="0"
+			
+			echo_x -n "NX> 101 User: "
+			read USER
+			echo_x $USER
+			
+			# forward the connection to commercial NoMachine server?
+			if [ "$ENABLE_NOMACHINE_FORWARD_USER" = "1" -a -n "$NOMACHINE_SERVER" ]
+			then
+				case "$USER" in
+					freenx.*)
+						log 3 "Info: Not forwarding connection. FreeNX user found."
+						USER=${USER##freenx.}
+					;;
+					*)
+						log 3 "Info: Forwarding connection to NoMachine server"
+						server_forward_nomachine
+						log 1 "Error: Forwarding connection to NoMachine server failed."
+					;;
+				esac
+			fi
+			
+			echo_x -n "NX> 102 Password: "
+			read -s PASS
+			echo_x ""
+			log 6 -n "Info: Auth method: "
+			
+			# PASSDB based auth
+			if [ "$ENABLE_PASSDB_AUTHENTICATION" = "1" -a "$LOGIN_SUCCESS" = "0" ]
+			then
+				log 6 -n "passdb "
+				if [ $(passdb_get_crypt_pass "$PASS") = $(passdb_get_pass "$USER") ]
+				then
+					LOGIN_SUCCESS="1"
+					LOGIN_METHOD="PASSDB"
+				fi
+			fi
+
+			# SSH based auth
+			if [ "$ENABLE_SSH_AUTHENTICATION" = "1" -a "$LOGIN_SUCCESS" = "0" ]
+			then
+				log 6 -n "ssh "
+				export COMMAND_SSH			
+				echo "$PASS" | $PATH_BIN/nxnode-login -- ssh "$USER" "$SSHD_PORT" "$PATH_BIN/nxnode" --check 2>&1 >/dev/null
+				if [ $? -eq 0 ]
+				then
+					LOGIN_SUCCESS="1"
+					LOGIN_METHOD="SSH"
+				fi
+			fi
+			
+			# SU based auth
+			if [ "$ENABLE_SU_AUTHENTICATION" = "1" -a "$LOGIN_SUCCESS" = "0" ]
+			then
+				log 6 -n "su "
+				echo "$PASS" | $PATH_BIN/nxnode-login -- su "$USER" "" "$PATH_BIN/nxnode" --check 2>&1 >/dev/null
+				if [ $? -eq 0 ]
+				then
+					LOGIN_SUCCESS="1"
+					LOGIN_METHOD="SU"
+				fi
+			fi
+			
+			# Check if user in passdb
+			if [ "$ENABLE_USER_DB" = "1" ]
+			then
+				log 6 "userdb check"
+				passdb_user_exists "$USER" || LOGIN_SUCCESS="0"
+			fi
+			log 6 ""
+
+			if [ "$LOGIN_SUCCESS" = "1" ]
+			then
+				# Reread the config files (so that $USER.node.conf get sourced)
+				. $(PATH=$(cd $(dirname $0) && pwd):$PATH which nxloadconfig) --userconf
+				echo_x "NX> 103 Welcome to: $SERVER_NAME user: $USER"
+				break
+			else
+				echo_x "NX> 404 ERROR: wrong password or login"
+				echo_x "NX> 999 Bye"
+				exit 1
+			fi
+		;;
+	esac
+done
+
+# remove old session infos from history
+session_cleanup
+
+#
+# call it with: server_get_params $CMD # no ""!
+#
+
+server_get_params()
+{
+	SERVER_PARAMS=$(echo "$@" | sed "s/^$1/\"/g; s/\" --/\&/g; s/\"//g")
+	if [ "$SERVER_PARAMS" = "" ]
+	then
+		echo_x -n "NX> 106 Parameters: "
+		read SERVER_PARAMS2
+		SERVER_PARAMS=$(echo $SERVER_PARAMS2 | sed 's/%2B/+/g')
+		echo_x
+	fi
+}
+
+nxnode_start()
+{
+	:
+	#CMD="$1"
+	#shift
+	#echo "$@" | $PATH_BIN/nxnode "$CMD"
+}
+
+#NX> 1002 Commit
+#NX> 1006 Session status: running
+
+server_nxnode_start()
+{
+	CMD="$1"
+	USER="$2"
+	shift
+	shift
+	# Use nxnode-login?
+	if [ "$LOGIN_METHOD" = "SSH" ]
+	then
+	    export COMMAND_SSH
+	    echo "$PASS" | $PATH_BIN/nxnode-login -- ssh "$USER" "$SSHD_PORT" "$PATH_BIN/nxnode" "$CMD" "$@" 2>&1 | log_tee
+	elif [ "$LOGIN_METHOD" = "SU" ]
+	then
+	    echo "$PASS" | $PATH_BIN/nxnode-login -- su "$USER" "" "$PATH_BIN/nxnode" "$CMD" "$@" 2>&1 | log_tee
+	else 
+	    echo "$@" | $COMMAND_SSH -l "$USER" 127.0.0.1 -p $SSHD_PORT -x -2 -i $NX_ETC_DIR/users.id_dsa -o 'PubkeyAuthentication yes' -o 'RSAAuthentication yes' -o 'RhostsAuthentication no' -o 'PasswordAuthentication no' -o 'RhostsRSAAuthentication no' -o 'StrictHostKeyChecking no' $PATH_BIN/nxnode "$CMD" | log_tee
+	fi
+}
+
+server_add_usession()
+{
+	[ "$ENABLE_USESSION" = "1" ] || return
+	
+	$COMMAND_SESSREG -l ":$SESS_DISPLAY" -h "$USERIP" -a $USER 2>&1 | log_error
+}
+
+server_remove_usession()
+{
+	[ "$ENABLE_USESSION" = "1" ] || return
+	$COMMAND_SESSREG -l ":$SESS_DISPLAY" -h "$USERIP" -d $USER 2>&1 | log_error
+}
+
+server_nxnode_start_wait()
+{
+	server_add_usession
+	
+	STOP_SEND=""
+	server_nxnode_start "$@" | while read CMD
+	do
+		case "$CMD" in 
+			"NX> 1006"*|"NX> 1005"*|"NX> 1009"*)
+				case "$CMD" in 
+					*running*)
+						rm -f $WAIT
+						session_status $uniqueid "Running"
+					;;
+					*closed*)
+						session_close $uniqueid
+					;;
+					*suspended*)
+						session_suspend $uniqueid
+					;;
+					*terminating*)
+						session_status $uniqueid "Terminating"
+						# we need to stop sending to client as it will have already
+						# closed his side of the channel and this will lead to not 
+						# closed sessions.
+						STOP_SEND="1"
+				esac
+			;;
+			"NX> 1004"*)
+				session_fail $uniqueid
+				# FIXME: Need correct error code.
+				echo_x "NX> 504 Session startup failed."
+			;;
+		esac
+
+		case $CMD in
+			"NX> 718"*)
+				[ -z "$STOP_SEND" ] && echo $CMD >&2
+				#echo "NX> 1006 Session status: running" 1>&2
+				#echo "NX> 1001 Bye." 1>&2
+
+			;;
+			"NX> "*)
+				[ -z "$STOP_SEND" ] && echo $CMD
+			;;
+		esac
+	done
+	
+	server_remove_usession
+
+	# remove lock file
+	[ -e "/tmp/.nX$SESS_DISPLAY-lock" ] && rm -f /tmp/.nX$SESS_DISPLAY-lock
+}
+
+server_check_session_count()
+{
+	session_count_user "$USER"
+	
+	if [ "$SESSION_COUNT" -ge "$SESSION_LIMIT" ]
+	then
+		echo_x "NX> 599 Reached the maximum number of concurrent sessions on this server."
+		echo_x "NX> 500 ERROR: Last operation failed."
+		return 1
+	fi
+	
+	if [ "$SESSION_COUNT_USER" -ge "$SESSION_USER_LIMIT" ]
+	then
+		echo_x "NX> 599 Server capacity: reached for user: $USER"
+		echo_x "NX> 500 ERROR: Last operation failed."
+		return 1
+	fi
+
+	return 0
+}
+
+server_startrestore_session()
+{
+	ACTION="$1"
+	
+	server_get_params $CMD
+	PARAMS=$SERVER_PARAMS
+	CMDLINE=$PARAMS
+	echo_x
+	
+	# If we can't get the userip and SSHD_CHECK_IP is set to 1
+	# we bail out.
+	if [ -z "$SSH_CLIENT" ]
+	then 
+		if [ "$SSHD_CHECK_IP" = "1" ]
+		then
+			echo_x "NX> 504 Session startup failed. (Missing SSH_CLIENT environment variable)"
+			return 1
+		else
+			log 2 "Warning: Failed to determine the client IP."
+			log 2 "Warning: The SSH_CLIENT variable was not provided by SSHD."
+			log 2 "Warning: Please set SSHD_CHECK_IP=1 if you want to refuse the connection."
+		fi
+	fi
+	
+	export ENCRYPTION=$(getparam encryption)
+	
+	if [ "$ENABLE_FORCE_ENCRYPTION" = "1" -a "$ENCRYPTION" != "1" ]
+	then
+			echo_x "NX> 504 Unencrypted sessions are not allowed."
+			return 1
+	fi
+
+	# check if there is a suspended session, which we could resume
+	if [ "$ENABLE_AUTORECONNECT" = "1" -a "$ACTION" = "start" ]
+	then
+		restore=$(session_get_user_suspended "$USER" "Suspended")
+		if [ -n "$restore" ]
+		then
+			PARAMS="$PARAMS&restore=$restore"
+			CMDLINE=$PARAMS
+			ACTION="resume"
+		fi
+	fi
+
+	USERIP=$(echo $SSH_CLIENT | cut -d" " -f1 | sed 's/::ffff://g')
+	[ -z "$USERIP" ] && USERIP="*"
+	if [ "$ACTION" = "start" ]
+	then
+		server_check_session_count || return 1
+		
+		# start nxnode
+		SESS_DISPLAY=$DISPLAY_BASE
+		let SESS_DISPLAY_LIMIT=$DISPLAY_BASE+$DISPLAY_LIMIT
+	
+		# stupid but working algo ...
+			
+		# TODO: need to check for _all_ offset and ports :-/
+			
+		while true
+		do
+			while [ -e /tmp/.X$SESS_DISPLAY-lock -o -e "/tmp/.nX$SESS_DISPLAY-lock" ]
+			do
+				let SESS_DISPLAY=$SESS_DISPLAY+1
+			done
+
+			SESS_LOCKFILE=$(mktemp "/tmp/.nX$SESS_DISPLAY-lock.XXXXXXXXX")
+			# ln is an atomic operation
+			ln "$SESS_LOCKFILE" "/tmp/.nX$SESS_DISPLAY-lock" 2>/dev/null && break
+		done
+		
+		if [ "$SESS_DISPLAY" -gt "$SESS_DISPLAY_LIMIT" ]
+		then
+			# fixme we need the correct error code
+			echo_x "NX> 504 Error: Display limit exceeded. Please remove some files from /tmp/.X*-lock."
+			return
+		fi
+
+		rm -f "$SESS_LOCKFILE"
+	
+		uniqueid=$(echo $[$RANDOM*$RANDOM] | md5sum | cut -d" " -f1 | tr "[a-z]" "[A-Z]")
+		FULL_PARAMS="user=$USER&userip=$USERIP&uniqueid=$uniqueid&display=$SESS_DISPLAY&$PARAMS"
+		log 6 "$FULL_PARAMS"
+
+		# now update the session listing
+		CMDLINE="a=b&$FULL_PARAMS"
+		session_add $uniqueid "sessionName=$(getparam session)&display=$(getparam display)&status=Running&startTime=$(date +%s)&foreignAddress=$(getparam userip)&type=$(getparam type)&sessionId=$uniqueid&creationTime=$(date +%s)&userName=$USER&serverPid=$SERVER_PID&screeninfo=$(getparam screeninfo)&geometry=$(getparam geometry)"
+	else
+		uniqueid=$(getparam restore)
+		[ -z "$uniqueid" ] && uniqueid=$(getparam id) # 1.4.0-5 compatibility
+		session_change "$uniqueid" "foreignAddress" "$USERIP"
+
+		CMDLINE=$(session_get "$uniqueid")
+		FULL_PARAMS="user=$USER&userip=$(getparam foreignAddress)&uniqueid=$uniqueid&display=$(getparam display)$PARAMS"
+		SESS_DISPLAY=$(getparam display)
+	fi
+
+	# now start the node
+	export WAIT=$(mktemp /tmp/nxserver_wait.XXXXXXXXX)
+	touch $WAIT
+	(sleep 10; rm -f $WAIT) &
+	server_nxnode_start_wait --"$ACTION"session $USER "$FULL_PARAMS" &
+	SERVER_PID=$!
+	disown $SERVER_PID
+	while [ -f "$WAIT" ]
+	do
+		sleep 1
+	done
+}
+
+# Session stage
+while true
+do
+	echo_x -n "NX> 105 "
+	unset CMD
+	read CMD 2>/dev/null
+	# FIXME?
+	[ "$CMD" = "" ] && CMD="quit"
+	echo_x "$CMD"
+	case "$CMD" in 
+		quit|QUIT)
+			echo_x "Quit"
+			echo_x "NX> 999 Bye"
+			exit 0
+		;;
+		exit|EXIT)
+			echo_x "Exit"
+			echo_x "NX> 999 Bye"
+			exit 0
+		;;
+		bye|BYE)
+			echo_x "Bye" 1>&2
+			echo_x "NX> 999 Bye" 1>&2
+			if [ "$ENCRYPTION" = "1" ] 
+			then 
+				let PROXY_DISPLAY=$SESS_DISPLAY+4000
+				$COMMAND_NETCAT 127.0.0.1 $PROXY_DISPLAY
+				exit 0
+			else
+				echo_x "NX> 1001 Bye."
+			fi
+		;;
+		startsession*)
+			server_startrestore_session "start"
+		;;
+		list*)
+			server_get_params $CMD
+			PARAMS=$SERVER_PARAMS
+			CMDLINE=$PARAMS
+			
+			# FIXME: To NX-Node!
+
+			status=$(getparam status)
+
+			if [ "$status" = "Suspended" -a -n "$(getparam screeninfo)" ]
+			then
+				session_list_user_suspended "$USER" "Suspended" "$(getparam screeninfo)" "$(getparam type)" | log_tee
+			elif [ "$status" = "Suspended,Running" -o "$status" = "Suspended" ] # since 1.4.0-5
+			then
+				# disabled due to problems with 1.4.0-5 client
+				#session_list_user_suspended "$USER" 'Suspended$|^status=Running$' "$(getparam geometry)" "$(getparam type)" | log_tee
+				session_list_user_suspended "$USER" 'Suspended' "$(getparam geometry)" "$(getparam type)" | log_tee
+			else
+				session_list_user "$USER" | log_tee
+			fi
+		;;
+		suspend*)
+			server_get_params $CMD
+			PARAMS=$SERVER_PARAMS
+			CMDLINE=$PARAMS
+			if session_find_id_user "$(getparam sessionid)" "$USER"
+			then
+				# FIXME: Check for success/error
+				server_nxnode_start --suspend "$USER" "$PARAMS"
+				session_suspend $(getparam sessionid)
+			fi
+		;;
+		terminate*)
+			server_get_params $CMD
+			PARAMS=$SERVER_PARAMS
+			CMDLINE=$PARAMS
+			if session_find_id_user "$(getparam sessionid)" "$USER"
+			then
+				# FIXME: Check for success/error
+				server_nxnode_start --terminate "$USER" "$PARAMS"
+				session_close $(getparam sessionid)
+			fi
+		;;
+		restoresession*)
+			server_startrestore_session "resume"
+		;;
+		passwd)
+			echo_x "NX> 113 Changing password of user '$USER'"
+			echo_x -n "NX> 102 Current password:"
+			read -s PASS
+			ENC_PASS=$(passdb_get_crypt_pass "$PASS")
+			REAL_PASS=$(passdb_get_pass "$USER")
+			echo_x
+			if [ "$ENC_PASS" = "$REAL_PASS" ]
+			then
+				echo_x -n "NX> 102 Password:"
+				read -s NEW_PASS1
+				
+				if [ ${#NEW_PASS1} -lt 5 ]
+				then
+					echo_x "NX> 500 ERROR: incorrect password format, password must be long at least five characters"
+					continue
+				fi
+
+				echo_x
+				echo_x -n "NX> 102 Confirm password:"
+				read -s NEW_PASS1
+				echo_x
+				if [ "$NEW_PASS1" = "$NEW_PASS2" ]
+				then
+					ENC_PASS=$(passdb_get_crypt_pass "$NEW_PASS1")
+					passdb_chpass "$USER" "$ENC_PASS"
+					echo_x "NX> 114 Password of user '$USER' changed"
+				else
+					echo_x "NX> 537 ERROR: passwords do not match"
+				fi
+			else
+				echo_x "NX> 500 ERROR: current password doesn't match"
+			fi
+		;;
+		addmount*)
+			server_get_params $CMD
+			PARAMS=$SERVER_PARAMS
+			server_nxnode_start --smbmount "$USER" "$PARAMS" 2>&1 | log_error >/dev/null
+			echo_x "NX> 719 SMB filesystem: running"
+		;;
+		addprinter*)
+			server_get_params $CMD
+			PARAMS=$SERVER_PARAMS
+			server_nxnode_start --addprinter "$USER" "$PARAMS" 2>&1 | log_error >/dev/null
+		;;
+		*)
+			# disabled for 1.4.0-5 snapshot client
+			#echo_x "NX> 503 Error: undefined command: '$CMD'"
+		;;
+	esac
+done
+
+fi
+
+#
+# End of Main nxserver <--> nxclient communication module
+#
+
+################### PACKAGE cmd.bm ############################
+
+#
+# library functions for nxserver-commandline cmds
+#
+
+# Policy: All functions and variables need to start with CMD_ / cmd_
+
+# Needed global vars: $NX_VERSION, $NX_LICENSE, $NX_ETC_DIR, $PATH_BIN, $NX_HOME_DIR, $SSH_AUTHORIZED_KEYS
+
+# Needed package: passdb
+
+cmd_usage()
+{
+	echo "NXSERVER - Version $NX_VERSION $NX_LICENSE"
+	echo "Usage: nxserver <option>" 1>&2
+
+	if [ "$1" = "root" ]
+	then
+		echo "--adduser <user>: Add a new user" 1>&2
+		echo "--passwd <user>: Change password of <user>" 1>&2
+		echo "--deluser <user>: Remove a user from nx" 1>&2
+		echo "--listuser: List enabled users" 1>&2
+		echo "" 1>&2
+		echo "--start: Start the nx server" 1>&2
+		echo "--stop: Stop the nx server" 1>&2
+		echo "--status: Show status of nx server" 1>&2
+		echo "--restart: Restart the nx server and terminate all running sessions" 1>&2
+		echo "" 1>&2
+		echo "--list [ user | sessionid ]: List running sessions of user or sessionid " 1>&2
+		echo "--history [ user | sessionid | clear ]: Show history [ of user | sessionid ] or clear the history" 1>&2
+		echo "--terminate <user | :display | sessionid>: Terminate the session pointed to by" 1>&2
+		echo "       sessionid or display, or all sessions of the specified user." 1>&2
+		echo "--suspend <user | :display | sessionid>: Suspend the session pointed to by" 1>&2
+		echo "       sessionid or display, or all sessions of the specified user." 1>&2
+		echo "" 1>&2
+		echo "--broadcast <message>: Send a message to all users" 1>&2
+		echo "--send <user | :display | sessionid> <message>: Send a message to the specified user or sessionid" 1>&2
+	else
+		echo "--passwd: Change password" 1>&2
+	fi
+	exit 1
+}
+
+
+cmd_abort()
+{
+	echo "NX> 500" "$@" 1>&2
+	echo "NX> 999 Bye" 1>&2
+	exit 1
+}
+
+cmd_user_passwd()
+{
+	echo "NX> 100 NXSERVER - Version $NX_VERSION $NX_LICENSE"
+	echo "Sorry: Password changing for user is _not_ implemented, yet."
+	echo "Please login to NX-Server to change password"
+	echo "or ask your local system administrator."
+	#echo "NX> 113 Changing password of user '$USER'"
+	#echo "Old password:"
+	#read -s OLDPASS
+	#echo "New password:"
+	#read -s NEWPASS1
+	#echo "Repeat:"
+	#read -s NEWPASS2
+
+}
+
+cmd_passwd()
+{
+	CMD_CHUSER=$2
+	egrep -q "^$CMD_CHUSER:" $NX_ETC_DIR/passwords || cmd_abort "Error: User $CMD_CHUSER not found in database."
+	echo -n "New password: "
+	read -s CMD_NEWPASS
+	echo
+	CMD_ENC_PASS=$(passdb_get_crypt_pass "$CMD_NEWPASS")
+	passdb_chpass "$CMD_CHUSER" "$CMD_ENC_PASS"
+	echo "Password changed."
+}
+
+cmd_adduser()
+{
+	CMD_CHUSER=$2
+	
+	[ ${#CMD_CHUSER} -ge 32 ] && cmd_abort "Error: User $CMD_CHUSER must be shorter than 32 characters."
+	egrep -q "^$CMD_CHUSER:" $NX_ETC_DIR/passwords && cmd_abort "Error: User $CMD_CHUSER already in database."
+	getent passwd | egrep -q "^$CMD_CHUSER:" || cmd_abort "Error: User $CMD_CHUSER not existing on local system. Can't add."
+	passdb_add_user "$CMD_CHUSER"
+}
+
+cmd_deluser()
+{
+	CMD_CHUSER=$2
+	egrep -q "^$CMD_CHUSER:" $NX_ETC_DIR/passwords || cmd_abort "Error: User $CMD_CHUSER not found in database."
+	passdb_remove_user "$CMD_CHUSER"
+}
+
+cmd_listuser()
+{
+	echo "NX> 146 NX users list"
+	echo
+	echo "Username"
+	echo "---------------"
+	echo
+	passdb_list_user
+	echo
+}
+
+cmd_start()
+{
+	
+	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] && cmd_abort "ERROR: Service already running"
+	mv $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS.disabled $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS
+	echo "NX> 122 Service started"
+}
+
+cmd_stop()
+{
+	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] || cmd_abort "Service was already stopped"
+	mv $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS.disabled
+	# TODO: Stop all running sessions
+	echo "NX> 123 Service stopped"
+}
+
+cmd_status()
+{
+	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] && echo "NX> 110 NX Server is running"
+	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] || echo "NX> 110 NX Server is stopped"
+}
+
+cmd_restart()
+{
+	cmd_stop
+	cmd_start
+}
+
+cmd_parse_2_params()
+{
+	if [ ${#1} -eq 32 ]
+	then
+		CMD_APARAMS="sessionid=sessionId{$1}"
+	else
+	if [ "$1" != "" ]
+	then
+		#egrep -q "^$1:" $NX_ETC_DIR/passwords || cmd_abort "Error: User $1 not found in database."
+		CMD_APARAMS="user=$1"
+	fi
+	fi
+	echo $CMD_APARAMS
+
+}
+
+cmd_parse_3_params()
+{
+	if [ ${#1} -eq 32 ]
+	then
+		CMD_APARAMS=$(session_find_id $1)
+		[ -n "$CMD_APARAMS" ] || cmd_abort "Error: Session $1 could not be found."
+	else
+	if [ "${1:0:1}" = ":" ]
+	then
+		CMD_APARAMS=$(session_find_display "${1:1}")
+		[ -n "$CMD_APARAMS" ] || cmd_abort "Error: No running sessions found for display $1."
+	else
+	if [ "$1" != "" ]
+	then
+		#egrep -q "^$1:" $NX_ETC_DIR/passwords || cmd_abort "Error: User $1 not found in database."
+		CMD_APARAMS=$(session_find_user "$1")
+		[ -n "$CMD_APARAMS" ] || cmd_abort "Error: No running sessions found for user $1."
+	else
+		cmd_abort "Error: Not enough parameters."
+	fi
+	fi
+	fi
+	echo $CMD_APARAMS
+}
+
+cmd_list_suspended()
+{
+	CMD_PARAMS=$(cmd_parse_2_params "$2")
+	[ -n "$2" -a -z "$CMD_PARAMS" ] && exit 1
+	case $CMD_PARAMS in
+		user=*)
+			session_list_user_suspended $2 "Suspended"
+		;;
+	esac
+}
+cmd_list()
+{
+	CMD_PARAMS=$(cmd_parse_2_params "$2")
+	[ -n "$2" -a -z "$CMD_PARAMS" ] && exit 1
+	case $CMD_PARAMS in
+		user=*)
+			session_list_user $2
+		;;
+		sessionid=*)
+			session_list $2
+		;;
+		*)
+			session_list_all
+		;;
+	esac
+}
+
+cmd_history_clear()
+{
+	rm -f $NX_SESS_DIR/closed/*
+	rm -f $NX_SESS_DIR/failed/*
+}
+
+cmd_history()
+{
+	if [ "$2" = "clear" ]
+	then
+		cmd_history_clear
+	fi
+	
+	CMD_PARAMS=$(cmd_parse_2_params "$2")
+	user=""
+	sessid=""
+	case $CMD_PARAMS in
+		user=*)
+			user="$2"
+		;;
+		sessionid=*)
+			sessid="$2"
+		;;
+	esac
+
+	session_history "$user" "$sessid"
+}
+
+cmd_terminate()
+{
+	CMD_PARAMS=$(cmd_parse_3_params "$2")
+	[ -z "$CMD_PARAMS" ] && exit 1
+	for i in $CMD_PARAMS;
+	do
+			CMDLINE=$(session_get_cmdline $i)
+			cmd_sessionid=$(getparam sessionId)
+			cmd_user=$(getparam userName)
+			cmd_type=$(getparam type)
+			cmd_status=$(getparam status)
+
+			# is it a "good" session?
+			case "$1" in 
+			--suspend)
+				if [ "$cmd_status" = "Running" ] && stringinstring "unix-" "$cmd_type"
+				then
+					echo "sessionid=$cmd_sessionid" | su - "$cmd_user" -c "$PATH_BIN/nxnode --suspend"
+					session_suspend $cmd_sessionid
+				fi
+				;;
+			--terminate)
+			#if stringinstring "unix-" "$cmd_type"
+			#	then
+					echo "sessionid=$cmd_sessionid" | su - "$cmd_user" -c "$PATH_BIN/nxnode --terminate"
+					session_close $cmd_sessionid
+			#	fi
+
+			;;
+			esac
+	done
+
+}
+
+cmd_send()
+{
+	if [ "$1" = "--broadcast" ]
+	then
+	  CMD_PARAMS=$(session_find_all)
+	  [ -z "$CMD_PARAMS" ] && cmd_abort "Error: No running session could be found."
+	else
+	  CMD_PARAMS=$(cmd_parse_3_params "$2")
+	  [ -z "$CMD_PARAMS" ] && exit 1
+	fi
+	shift
+	shift
+	for i in $CMD_PARAMS;
+	do
+			CMDLINE=$(session_get_cmdline $i)
+			cmd_display=$(getparam display)
+			cmd_user=$(getparam userName)
+			cmd_type=$(getparam type)
+			cmd_status=$(getparam status)
+
+			# is it a "good" session?
+			if [ "$cmd_status" = "Running" ] && stringinstring "unix-" "$cmd_type"
+			then
+				su - "$cmd_user" -c "$PATH_BIN/nxclient --dialog ok --caption \"NX Administrator Message\" --message \"$@\" --noautokill 
+-display \":$cmd_display\"" &
+				disown $!
+			fi
+	done
+	#nxnode_start --send "$CMD_PARAMS"
+}
+
+#
+# user mode available functions
+#
+
+if [ $UID -ne 0 ]
+then
+	[ "$1" != "--passwd" ] && cmd_usage
+	cmd_user_passwd
+	exit 0
+fi
+
+#
+# root mode available functions
+#
+
+[ $# -lt 1 ] && cmd_usage "root"
+[ "$1" = "--help" ] && cmd_usage "root"
+
+if [ "$1" = "--version" ]
+then
+  echo "NXSERVER - Version $NX_VERSION $NX_LICENSE"
+  exit 0
+fi
+
+CMD=$1
+
+echo "NX> 100 NXSERVER - Version $NX_VERSION $NX_LICENSE"
+
+case $CMD in
+	# 
+	# User functions ...
+	# 
+	--passwd)
+		cmd_passwd "$@"
+	;;
+	--adduser|--useradd)
+		cmd_adduser "$@"
+	;;
+	--deluser|--userdel)
+		cmd_deluser "$@"
+	;;
+	--listuser|--userlist)
+		cmd_listuser
+	;;
+	--start)
+		cmd_start
+	;;
+	--stop)
+		cmd_stop
+	;;
+	--status)
+		cmd_status
+	;;
+	--restart)
+		cmd_restart
+	;;
+	--list)
+		cmd_list "$@"
+	;;
+	--list-suspended)
+		cmd_list_suspended "$@"
+	;;
+	--history)
+		cmd_history "$@"
+	;;
+	--terminate|--suspend)
+		cmd_terminate "$@"
+	;;
+	--send|--broadcast)
+		cmd_send "$@"
+	;;
+	*)
+		cmd_abort "Error: Function $CMD not implemented yet."
+esac
+echo "NX> 999 Bye"


Property changes on: freenx-server/nxserver
___________________________________________________________________
Name: svn:executable
   + 

Added: freenx-server/nxserver.old
===================================================================
--- freenx-server/nxserver.old	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/nxserver.old	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,1381 @@
+#!/bin/bash
+
+# Free implementation of nxserver components
+#
+# To use nxserver add the user "nx" 
+# and use nxserver as default shell.
+#
+# Also make sure that hostkey based authentification works.
+# 
+# Copyright (c) 2004 by Fabian Franz <FreeNX at fabian-franz.de>.
+#
+# License: GNU GPL, version 2
+#
+# CVS: $Id: nxserver,v 1.42 2005/03/14 00:51:21 fabianx Exp $
+#
+
+# Read the config file
+. $(PATH=$(cd $(dirname $0) && pwd):$PATH which nxloadconfig) --
+
+if [ "$USER" = "nxuser" ]
+then
+	export NX_SESS_DIR="$HOME/.nx/db/"
+	export NX_LOGFILE="$HOME/.nx/temp/nxserver.log"
+	mkdir -p $NX_SESS_DIR/{closed,running,failed}
+	ENABLE_FAKE_AUTHENTICATION="1"
+fi
+
+# following two functions are Copyright by Klaus Knopper
+
+stringinstring(){
+case "$2" in *$1*) return 0;; esac
+return 1
+}
+
+# Reread boot command line; echo last parameter's argument or return false.
+getparam(){
+stringinstring "&$1=" "$CMDLINE" || return 1
+echo "$CMDLINE" | awk "/^$1=/"' { VAL=$2 } END { print VAL }' FS="=" RS="(&|\n)"
+return 0
+}
+
+
+############### PACKAGE passdb.bm #######################
+#
+# Library of passdb functions (outsource)
+#
+
+# Policy: Variable and function names _must_ start with passdb_ / PASSDB_
+
+# Needed global vars: $NX_ETC_DIR, $PATH_BIN
+
+# Needed nonstd functions: md5sum
+
+
+passdb_get_crypt_pass()
+{
+	echo "$@" | md5sum | cut -d" " -f1
+}
+
+passdb_get_pass()
+{
+	PASSDB_CHUSER="$1"
+	PASSDB_PASS=$(egrep "^$PASSDB_CHUSER:" $NX_ETC_DIR/passwords 2>/dev/null | cut -d":" -f2)
+	if [ "$ENABLE_PASSDB_AUTHENTICATION" = "1" ]
+	then
+		egrep -q "^$PASSDB_CHUSER:" $NX_ETC_DIR/passwords 2>/dev/null && echo $PASSDB_PASS
+		egrep -q "^$PASSDB_CHUSER:" $NX_ETC_DIR/passwords 2>/dev/null || echo "NOT_VALID"
+	else
+		echo "NOT_VALID"
+	fi
+}
+
+passdb_chpass()
+{
+	PASSDB_CHUSER="$1"
+	PASSDB_ENC_PASS="$2"
+	cp -f $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
+	perl -pi -e "s/$PASSDB_CHUSER:.*/$PASSDB_CHUSER:$PASSDB_ENC_PASS/g" $NX_ETC_DIR/passwords
+}
+
+passdb_user_exists()
+{
+	PASSDB_CHUSER="$1"
+	egrep -q "^$PASSDB_CHUSER:" $NX_ETC_DIR/passwords 2>/dev/null
+}
+
+
+passdb_remove_user()
+{
+	PASSDB_CHUSER="$1"
+	cp -f $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
+	perl -pi -e "s/$PASSDB_CHUSER:.*\n//g" $NX_ETC_DIR/passwords
+}
+
+passdb_add_user()
+{
+	PASSDB_CHUSER="$1"
+	cp -f $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
+	echo "$PASSDB_CHUSER:*" >> $NX_ETC_DIR/passwords
+	# deactivated to avoid problems with comm-server
+	su - $PASSDB_CHUSER -c "$PATH_BIN/nxnode --setkey"
+}
+
+passdb_list_user()
+{
+	cat $NX_ETC_DIR/passwords | cut -d":" -f1
+}
+
+#
+# End of passdb Library
+#
+
+############### PACKAGE session.bm #######################
+#
+# Library of session management functions
+#
+
+# Needed global vars: $NX_SESS_DIR
+
+session_list()
+{
+	cat $NX_SESS_DIR/running/sessionId"{$1}"
+}
+
+# Find all running session-filenames 
+
+session_find_all()
+{
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		echo $i
+	done
+}
+
+# Find all running sessions of a id
+session_find_id()
+{
+	[ -f $NX_SESS_DIR/running/sessionId"{$1}" ] && echo $NX_SESS_DIR/running/sessionId"{$1}"
+}
+
+# finds out if a session belongs to a user
+
+session_find_id_user()
+{
+	[ -f $NX_SESS_DIR/running/sessionId"{$1}" ] && egrep -q "^userName=$2$" $NX_SESS_DIR/running/sessionId"{$1}" && return 0
+	return 1
+}
+
+# Find all running sessions of a user
+session_find_user()
+{
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		egrep -q "^userName=$1$" $i && echo $i
+	done
+}
+
+# Find all running sessions of a display
+session_find_display()
+{	
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		egrep -q "^display=$1$" $i && echo $i
+	done
+}
+
+# session_get_cmdline <session filename>
+
+session_get_cmdline()
+{
+	echo "a=b" | cat - $1 | tr '\n' '&'
+}
+
+# session_get <uniqueid>
+
+session_get()
+{
+	session_get_cmdline $NX_SESS_DIR/running/sessionId"{$1}"
+}
+
+
+# Get the first session, which can be resumed
+
+session_get_user_suspended()
+{
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		if egrep -q "^userName=$1$" $i && egrep -q "^status=$2$" $i
+		then
+			CMDLINE=$(session_get_cmdline $i)
+			echo "$(getparam sessionId)"
+			break
+		fi
+	done
+}
+
+# Count all sessions of a user
+# and save it in SESSION_COUNT and SESSION_COUNT_USER
+
+session_count_user()
+{
+	SESSION_COUNT=0
+	SESSION_COUNT_USER=0
+
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		let SESSION_COUNT=$SESSION_COUNT+1
+		egrep -q "^userName=$1$" $i && let SESSION_COUNT_USER=$SESSION_COUNT_USER+1
+	done
+}
+
+# List all sessions of a user
+
+session_list_user_suspended()
+{
+	SESSION_COUNT=0
+	SESSION_COUNT_USER=0
+
+	TMPFILE=$(mktemp /tmp/nxserver_tmp.XXXXXXXXX)
+	echo "NX> 127 Sessions list of user '$1' for reconnect:" > $TMPFILE
+	echo >> $TMPFILE
+	if [ -z "$4" ]
+	then
+		
+		echo "Display Type             Session ID                       Options  Depth Screensize     Available Session Name" >> $TMPFILE
+		echo "------- ---------------- -------------------------------- -------- ----- -------------- --------- ----------------------" >> $TMPFILE
+	else
+		echo "Display Type             Session ID                       Options  Depth Screen         Status      Session Name" >> $TMPFILE
+		echo " ------- ---------------- -------------------------------- -------- ----- -------------- ----------- ------------------------------" >> $TMPFILE
+	fi
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		let SESSION_COUNT=$SESSION_COUNT+1
+		if egrep -q "^userName=$1$" $i && egrep -q "^status=$2$" $i #&& grep -q "screeninfo=$3" $i
+		then
+			CMDLINE=$(session_get_cmdline $i)
+			depth=$(getparam screeninfo | cut -d "x" -f3 | cut -d "+" -f1 )
+			geom=$(getparam screeninfo | cut -d "x" -f1,2) 
+			render=$(getparam screeninfo | cut -d "+" -f2 )
+			available="N/A"
+			udepth=$(echo $3 | cut -d "x" -f3 | cut -d "+" -f1 )
+			urender=$(echo $3 | cut -d "+" -f2 )
+			[ "$(getparam geometry)" = "fullscreen" ] && options="F"
+			[ "$(getparam geometry)" = "fullscreen" ] || options="-"
+			[ "$urender" = "render" ] && options="${options}R---PSA"
+			[ "$urender" = "render" ] || options="${options}----PSA"
+			[ "$udepth" = "$depth" -a "$urender" = "$render" ] && available=$(getparam status)
+			# FIXME: HACK !!! to keep compatibility with old snapshot version (Knoppix 3.6 based for example)
+			if [ -z "$4" -a "$available" != "N/A" ] 
+			then
+				available="Yes"
+			fi
+			echo -e "$(getparam display)\t$(getparam type)\t$(getparam sessionId)\t$options\t$depth\t$geom\t$available\t$(getparam sessionName)" >> $TMPFILE
+		fi
+		egrep -q "^userName=$1$" $i && let SESSION_COUNT_USER=$SESSION_COUNT_USER+1
+	done
+	echo "" >> $TMPFILE
+	echo "" >> $TMPFILE
+	cat $TMPFILE
+	rm -f $TMPFILE
+	if [ "$SESSION_COUNT" -ge "$SESSION_LIMIT" -o "$SESSION_COUNT_USER" -ge "$SESSION_USER_LIMIT" ]
+	then
+		echo "NX> 147 Server capacity: reached for user: $1"
+	else
+		echo "NX> 148 Server capacity: not reached for user: $1"
+	fi
+}
+
+session_list_user()
+{
+	echo "NX> 127 Sessions list of user '$1'"
+	echo
+	echo "Display Username        Remote IP       Session ID"
+	echo "------- --------------- --------------- --------------------------------"
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		if egrep -q "^userName=$1$" $i
+		then
+			CMDLINE=$(session_get_cmdline $i)
+			echo -e "$(getparam display)\t$(getparam userName)\t$(getparam foreignAddress)\t$(getparam sessionId)"
+		fi
+	done
+}
+
+session_history()
+{
+	userName=$1
+	sessionId=$2
+	echo "NX> 127 Session list:"
+	echo
+	echo "Display Username        Remote IP       Session ID                       Date                Status"
+	echo "------- --------------- --------------- -------------------------------- ------------------- -----------"
+	for j in $(ls --time-style +%s -la "$NX_SESS_DIR"/{closed,failed,running} | awk '/sessionId/ { print $6 " " $7 }' | sort -n | cut -d" " -f2)
+	do
+		if [ -n "$sessionId" ]
+		then
+			[ "$j" = "sessionId{$sessionId}" ] || continue
+		fi
+		i="$NX_SESS_DIR"/*/"$j"
+		[ -f $i ] || break
+		CMDLINE=$(session_get_cmdline $i)
+		if [ -n "$userName" ]
+		then
+			[ "$userName" = "$(getparam userName)" ] || continue
+		fi
+		echo -e "$(getparam display)\t$(getparam userName)\t$(getparam foreignAddress)\t$(getparam sessionId)\t$(ls --time-style="+%F %X" -l $i | awk '/sessionId/ { print $6 " " $7 }')\t$(getparam status)"
+	done
+}
+
+# remove all sessions older than $SESSION_HISTORY seconds in failed/closed.
+
+session_cleanup()
+{
+	[ "$SESSION_HISTORY" -gt "-1" ] || return
+	let SESSION_HISTORY_MINUTES=$SESSION_HISTORY/60
+	find $NX_SESS_DIR/closed/ $NX_SESS_DIR/failed/ -type f -mmin +"$SESSION_HISTORY_MINUTES" -exec rm -f '{}' ';'
+}
+
+session_list_all()
+{
+	echo "NX> 127 Sessions list:"
+	echo
+	echo "Display Username        Remote IP       Session ID"
+	echo "------- --------------- --------------- --------------------------------"
+	for i in $NX_SESS_DIR/running/*
+	do
+		[ -f $i ] || break
+		CMDLINE=$(session_get_cmdline $i)
+		echo -e "$(getparam display)\t$(getparam userName)\t$(getparam foreignAddress)\t$(getparam sessionId)"
+	done
+}
+
+
+# session_add <session_id> <options>
+
+session_add()
+{
+	id=$1
+	shift
+	echo "$@" | tr '&' '\n' > $NX_SESS_DIR/running/sessionId'{'$id'}'
+}
+
+# session_change <session_id> <parameter> <new_value>
+
+session_change()
+{
+	[ -f $NX_SESS_DIR/running/sessionId'{'$1'}' ] && perl -pi -e "s/$2=.*/$2=$3/" $NX_SESS_DIR/running/sessionId'{'$1'}'
+}
+
+# session_id <new status>
+
+session_status()
+{
+	session_change "$1" "status" "$2"
+}
+
+# session_close <session_id> <end-time>
+
+session_close()
+{
+	perl -pi -e "s/startTime=\(.*\)/startTime=\1\nendTime=$(date +%s)/" $NX_SESS_DIR/running/sessionId'{'$1'}'
+	session_status $1 "Finished"
+	[ "$SESSION_HISTORY" = "0" ] && rm -f $NX_SESS_DIR/running/sessionId'{'$1'}'
+	[ "$SESSION_HISTORY" = "0" ] || mv -f $NX_SESS_DIR/running/sessionId'{'$1'}' $NX_SESS_DIR/closed/sessionId'{'$1'}'
+}
+
+session_fail()
+{
+	perl -pi -e "s/startTime=\(.*\)/startTime=\1\nendTime=$(date +%s)/" $NX_SESS_DIR/running/sessionId'{'$1'}'
+	session_status $1 "Failed"
+	[ "$SESSION_HISTORY" = "0" ] && rm -f $NX_SESS_DIR/running/sessionId'{'$1'}'
+	[ "$SESSION_HISTORY" = "0" ] || mv -f $NX_SESS_DIR/running/sessionId'{'$1'}' $NX_SESS_DIR/failed/sessionId'{'$1'}'
+}
+
+session_suspend()
+{
+	session_status $1 "Suspended"
+}
+
+#
+# end of library
+#
+
+
+#
+# Main nxserver <-> nxclient communication module
+#
+
+if [ $USER = "nxuser" -o "$USER" = "nx" ]
+then
+	
+log()
+{
+	[ "$NX_LOGGING" = "1" -a -w "$NX_LOGFILE" ] && echo "$@" >> "$NX_LOGFILE"
+}
+
+log_tee()
+{
+	[ "$NX_LOGGING" = "1" -a -w "$NX_LOGFILE" ] && exec tee -a "$NX_LOGFILE"
+	[ "$NX_LOGGING" = "1" -a -w "$NX_LOGFILE" ] || exec cat -
+}
+
+echo_x()
+{
+	log "$@"
+	echo "$@"
+}
+
+# Forward the connection to the commercial NoMachine server
+server_forward_nomachine()
+{
+	set -- "${RECORD_CMD[@]}"
+	
+	# setup the FIFOs
+	SERVER_IN=~/server.in.$$
+	SERVER_OUT=~/server.out.$$
+	rm -f $SERVER_IN $SERVER_OUT
+	mkfifo $SERVER_IN $SERVER_OUT
+	exec 3<>$SERVER_IN
+	exec 4<>$SERVER_OUT
+	
+	$NOMACHINE_SERVER <&3 >&4 &
+	NX_PID=$!
+	
+	while true
+	do
+		read -n7 opcode <&4
+		line=""
+		case "$opcode" in
+			"NX> 105")
+				echo $1 >&3
+				shift
+			;;
+			"NX> 101")
+				echo $USER >&3
+				read line <&4
+				break
+			;;
+			*)
+				read line <&4
+			;;
+		esac
+	done
+	log "done."
+	cat <&4 &
+	CAT_PID=$!
+	cat - >&3
+	rm -f $SERVER_IN $SERVER_OUT
+	kill $CAT_PID
+	kill $NX_PID
+	exit 0
+}
+
+# Start!
+log "-- NX SERVER START: $@"
+
+if [ "$ENABLE_SERVER_FORWARD" = "1" -a -n "$SERVER_FORWARD_HOST" ]
+then
+	log "Forwarding connection to $SERVER_FORWARD_HOST with secret key $SERVER_FORWARD_KEY."
+	ssh -i "$SERVER_FORWARD_KEY" "nx@$SERVER_FORWARD_HOST:$SERVER_FORWARD_PORT"
+	exit 0
+fi
+
+# forward the connection to commercial NoMachine server?
+if [ "$ENABLE_NOMACHINE_FORWARD_PORT" = "1" -a "$NOMACHINE_FORWARD_PORT" = "$(echo $SSH_CLIENT | cut -d' ' -f3)" -a -n "$NOMACHINE_SERVER" ]
+then
+	log "Info: Detected SSH destination port $NOMACHINE_FORWARD_PORT. Forwarding connection to commercial NoMachine server."
+	exec $NOMACHINE_SERVER
+	log "Error: Forwarding to NoMachine Server $NOMACHINE_SERVER failed. Using FreeNX server instead."
+fi
+
+echo_x "HELLO NXSERVER - Version $NX_VERSION $NX_LICENSE"
+
+[ "$ENABLE_NOMACHINE_FORWARD_USER" = "1" ] && RECORD_CMD=()
+
+# Login stage
+while true
+do
+	echo_x -n "NX> 105 "
+	read CMD
+	# FIXME?
+	[ "$CMD" = "" ] && CMD="quit"
+	echo_x "$CMD"
+	
+	# record $CMD in RECORD_CMD array
+	[ "$ENABLE_NOMACHINE_FORWARD_USER" = "1" ] && RECORD_CMD=( "${RECORD_CMD[@]}" "$CMD" )
+	
+	case "$CMD" in 
+		quit|QUIT)
+			echo_x "Quit"
+			echo_x "NX> 999 Bye"
+			exit 0
+		;;
+		exit|EXIT)
+			echo_x "Exit"
+			echo_x "NX> 999 Bye"
+			exit 0
+		;;
+		bye|BYE)
+			echo_x "Bye"
+			echo_x "NX> 999 Bye"
+			exit 0
+		;;
+		hello*|HELLO*)
+			PROTO=$(echo $CMD | sed 's/.*Version \(.*\)/\1/g')
+			echo_x "NX> 134 Accepted protocol: $PROTO"
+			if [ "$PROTO" = "1.3.0" -o "$PROTO" = "1.3.2" ]
+			then
+				[ "$ENABLE_AUTORECONNECT_BEFORE_140" = "1" ] && ENABLE_AUTORECONNECT="1"
+			fi
+		;;
+		set*|SET)
+			if [ "$CMD" = "set auth_mode password" -o "$CMD" = "SET AUTH_MODE PASSWORD" ]
+			then
+				echo_x "Set auth_mode: password"
+			else
+				echo_x "NX> 500 ERROR: unknown auth mode ''"
+			fi
+		;;
+		login|LOGIN)
+			LOGIN_SUCCESS="0"
+			
+			echo_x -n "NX> 101 User: "
+			read USER
+			echo_x $USER
+			
+			# forward the connection to commercial NoMachine server?
+			if [ "$ENABLE_NOMACHINE_FORWARD_USER" = "1" -a -n "$NOMACHINE_SERVER" ]
+			then
+				case "$USER" in
+					freenx.*)
+						log "Not forwarding connection. FreeNX user found."
+						USER=${USER##freenx.}
+					;;
+					*)
+						log -n "Forwarding connection to NoMachine server..."
+						server_forward_nomachine
+						log "failed."
+					;;
+				esac
+			fi
+			
+			echo_x -n "NX> 102 Password: "
+			read -s PASS
+			echo_x ""
+			log -n "Auth method: "
+
+			if [ "$ENABLE_FAKE_AUTHENTICATION" = "1" ]
+			then
+				LOGIN_SUCCESS="1"
+				LOGIN_METHOD="FAKE"
+			fi
+			
+			# PASSDB based auth
+			if [ "$ENABLE_PASSDB_AUTHENTICATION" = "1" -a "$LOGIN_SUCCESS" = "0" ]
+			then
+				log -n "passdb "
+				if [ $(passdb_get_crypt_pass "$PASS") = $(passdb_get_pass "$USER") ]
+				then
+					LOGIN_SUCCESS="1"
+					LOGIN_METHOD="PASSDB"
+				fi
+			fi
+			
+			# SSH based auth
+			if [ "$ENABLE_SSH_AUTHENTICATION" = "1" -a "$LOGIN_SUCCESS" = "0" ]
+			then
+				log -n "ssh "
+				echo "$PASS" | $PATH_BIN/nxnode-login -- ssh "$USER" "$SSHD_PORT" "$PATH_BIN/nxnode" --check > /dev/null 2>/dev/null
+				if [ $? -eq 0 ]
+				then
+					LOGIN_SUCCESS="1"
+					LOGIN_METHOD="SSH"
+				fi
+			fi
+			
+			# SU based auth
+			if [ "$ENABLE_SU_AUTHENTICATION" = "1" -a "$LOGIN_SUCCESS" = "0" ]
+			then
+				log -n "su "
+				echo "$PASS" | $PATH_BIN/nxnode-login -- su "$USER" "" "$PATH_BIN/nxnode" --check > /dev/null 2>/dev/null
+				if [ $? -eq 0 ]
+				then
+					LOGIN_SUCCESS="1"
+					LOGIN_METHOD="SU"
+				fi
+			fi
+			log ""
+			
+			# Check if user in passdb
+			if [ "$ENABLE_USER_DB" = "1" ]
+			then
+				log "userdb check"
+				passdb_user_exists "$USER" || LOGIN_SUCCESS="0"
+			fi
+
+			if [ "$LOGIN_SUCCESS" = "1" ]
+			then
+				# Reread the config files (so that $USER.node.conf get sourced)
+				. $(PATH=$(cd $(dirname $0) && pwd):$PATH which nxloadconfig) --userconf
+
+if [ "$USER" = "nxuser" ]
+then
+	export NX_SESS_DIR="$HOME/.nx/db/"
+	export NX_LOGFILE="$HOME/.nx/temp/nxserver.log"
+	mkdir -p $NX_SESS_DIR/{closed,running,failed}
+	ENABLE_FAKE_AUTHENTICATION="1"
+fi
+
+
+				echo_x "NX> 103 Welcome to: $SERVER_NAME user: $USER"
+				break
+			else
+				echo_x "NX> 404 ERROR: wrong password or login"
+				echo_x "NX> 999 Bye"
+				exit 1
+			fi
+		;;
+	esac
+done
+
+# remove old session infos from history
+session_cleanup
+
+#
+# call it with: server_get_params $CMD # no ""!
+#
+
+server_get_params()
+{
+	SERVER_PARAMS=$(echo "$@" | sed "s/^$1/\"/g; s/\" --/\&/g; s/\"//g")
+	if [ "$SERVER_PARAMS" = "" ]
+	then
+		echo_x -n "NX> 106 Parameters: "
+		read SERVER_PARAMS2
+		SERVER_PARAMS=$(echo $SERVER_PARAMS2 | sed 's/%2B/+/g')
+		echo_x
+	fi
+}
+
+nxnode_start()
+{
+	:
+	#CMD="$1"
+	#shift
+	#echo "$@" | $PATH_BIN/nxnode "$CMD"
+}
+
+#NX> 1002 Commit
+#NX> 1006 Session status: running
+
+server_nxnode_start()
+{
+	CMD="$1"
+	USER="$2"
+	shift
+	shift
+	# Use nxnode-login?
+	if [ "$LOGIN_METHOD" = "SSH" ]
+	then
+	    echo "$PASS" | $PATH_BIN/nxnode-login -- ssh "$USER" "$SSHD_PORT" "$PATH_BIN/nxnode" "$CMD" "$@" 2>&1 | log_tee
+	elif [ "$LOGIN_METHOD" = "SU" ]
+	then
+	    echo "$PASS" | $PATH_BIN/nxnode-login -- su "$USER" "" "$PATH_BIN/nxnode" "$CMD" "$@" 2>&1 | log_tee
+	elif [ "$LOGIN_METHOD" = "FAKE" ]
+	then
+	    echo "$@" | $PATH_BIN/nxnode "$CMD" 2>&1 | log_tee
+	else 
+	    echo "$@" | ssh -l "$USER" 127.0.0.1 -p $SSHD_PORT -x -2 -i $NX_ETC_DIR/users.id_dsa -o 'PubkeyAuthentication yes' -o 'RSAAuthentication yes' -o 'RhostsAuthentication no' -o 'PasswordAuthentication no' -o 'RhostsRSAAuthentication no' -o 'StrictHostKeyChecking no' $PATH_BIN/nxnode "$CMD" | log_tee
+	fi
+}
+
+server_add_usession()
+{
+	[ "$ENABLE_USESSION" = "1" ] || return
+	
+	$COMMAND_SESSREG -l ":$SESS_DISPLAY" -h "$USERIP" -a $USER 2>/dev/null
+}
+
+server_remove_usession()
+{
+	[ "$ENABLE_USESSION" = "1" ] || return
+	$COMMAND_SESSREG -l ":$SESS_DISPLAY" -h "$USERIP" -d $USER 2>/dev/null
+}
+
+server_nxnode_start_wait()
+{
+	server_add_usession
+	
+	STOP_SEND=""
+	server_nxnode_start "$@" | while read CMD
+	do
+		case "$CMD" in 
+			"NX> 1006"*|"NX> 1005"*|"NX> 1009"*)
+				case "$CMD" in 
+					*running*)
+						rm -f $WAIT
+						session_status $uniqueid "Running"
+					;;
+					*closed*)
+						session_close $uniqueid
+					;;
+					*suspended*)
+						session_suspend $uniqueid
+					;;
+					*terminating*)
+						session_status $uniqueid "Terminating"
+						# we need to stop sending to client as it will have already
+						# closed his side of the channel and this will lead to not 
+						# closed sessions.
+						STOP_SEND="1"
+				esac
+			;;
+			"NX> 1004"*)
+				session_fail $uniqueid
+				# FIXME: Need correct error code.
+				echo_x "NX> 504 Session startup failed."
+			;;
+		esac
+
+		case $CMD in
+			"NX> 718"*)
+				[ -z "$STOP_SEND" ] && echo $CMD >&2
+				#echo "NX> 1006 Session status: running" 1>&2
+				#echo "NX> 1001 Bye." 1>&2
+
+			;;
+			"NX> "*)
+				[ -z "$STOP_SEND" ] && echo $CMD
+			;;
+		esac
+	done
+	
+	server_remove_usession
+
+	# remove lock file
+	[ -e "/tmp/.nX$SESS_DISPLAY-lock" ] && rm -f /tmp/.nX$SESS_DISPLAY-lock
+}
+
+server_check_session_count()
+{
+	session_count_user "$USER"
+	
+	if [ "$SESSION_COUNT" -ge "$SESSION_LIMIT" ]
+	then
+		echo_x "NX> 599 Reached the maximum number of concurrent sessions on this server."
+		echo_x "NX> 500 ERROR: Last operation failed."
+		return 1
+	fi
+	
+	if [ "$SESSION_COUNT_USER" -ge "$SESSION_USER_LIMIT" ]
+	then
+		echo_x "NX> 599 Server capacity: reached for user: $USER"
+		echo_x "NX> 500 ERROR: Last operation failed."
+		return 1
+	fi
+
+	return 0
+}
+
+server_startrestore_session()
+{
+	ACTION="$1"
+	
+	server_get_params $CMD
+	PARAMS=$SERVER_PARAMS
+	CMDLINE=$PARAMS
+	echo_x
+	
+	# If we can't get the userip and SSHD_CHECK_IP is set to 1
+	# we bail out.
+	if [ -z "$SSH_CLIENT" ]
+	then 
+		if [ "$SSHD_CHECK_IP" = "1" ]
+		then
+			echo "NX> 504 Session startup failed. (Missing SSH_CLIENT environment variable)"
+			return 1
+		else
+			log "WARNING: Failed to determine the client IP."
+			log "WARNING: The SSH_CLIENT variable was not provided by SSHD."
+			log "WARNING: Please set SSHD_CHECK_IP=1 if you want to refuse the connection."
+		fi
+	fi
+
+	# check if there is a suspended session, which we could resume
+	if [ "$ENABLE_AUTORECONNECT" = "1" -a "$ACTION" = "start" ]
+	then
+		restore=$(session_get_user_suspended "$USER" "Suspended")
+		if [ -n "$restore" ]
+		then
+			PARAMS="$PARAMS&restore=$restore"
+			CMDLINE=$PARAMS
+			ACTION="resume"
+		fi
+	fi
+
+	USERIP=$(echo $SSH_CLIENT | cut -d" " -f1 | sed 's/::ffff://g')
+	[ -z "$USERIP" ] && USERIP="*"
+	if [ "$ACTION" = "start" ]
+	then
+		server_check_session_count || return 1
+		
+		# start nxnode
+		SESS_DISPLAY=$DISPLAY_BASE
+		let SESS_DISPLAY_LIMIT=$DISPLAY_BASE+$DISPLAY_LIMIT
+	
+		# stupid but working algo ...
+			
+		# TODO: need to check for _all_ offset and ports :-/
+			
+		while true
+		do
+			while [ -e /tmp/.X$SESS_DISPLAY-lock -o -e "/tmp/.nX$SESS_DISPLAY-lock" ]
+			do
+				let SESS_DISPLAY=$SESS_DISPLAY+1
+			done
+
+			SESS_LOCKFILE=$(mktemp "/tmp/.nX$SESS_DISPLAY-lock.XXXXXXXXX")
+			# ln is an atomic operation
+			ln "$SESS_LOCKFILE" "/tmp/.nX$SESS_DISPLAY-lock" 2>/dev/null && break
+		done
+		
+		if [ "$SESS_DISPLAY" -gt "$SESS_DISPLAY_LIMIT" ]
+		then
+			# fixme we need the correct error code
+			echo_x "NX> 504 Error: Display limit exceeded. Please remove some files from /tmp/.X*-lock."
+			return
+		fi
+
+		rm -f "$SESS_LOCKFILE"
+	
+		uniqueid=$(echo $[$RANDOM*$RANDOM] | md5sum | cut -d" " -f1 | tr "[a-z]" "[A-Z]")
+		FULL_PARAMS="user=$USER&userip=$USERIP&uniqueid=$uniqueid&display=$SESS_DISPLAY&$PARAMS"
+		log "$FULL_PARAMS"
+
+		# now update the session listing
+		CMDLINE="a=b&$FULL_PARAMS"
+		session_add $uniqueid "sessionName=$(getparam session)&display=$(getparam display)&status=Running&startTime=$(date +%s)&foreignAddress=$(getparam userip)&type=$(getparam type)&sessionId=$uniqueid&creationTime=$(date +%s)&userName=$USER&serverPid=$SERVER_PID&screeninfo=$(getparam screeninfo)&geometry=$(getparam geometry)"
+		export ENCRYPTION=$(getparam encryption)
+	else
+		uniqueid=$(getparam restore)
+		[ -z "$uniqueid" ] && uniqueid=$(getparam id) # 1.4.0-5 compatibility
+		export ENCRYPTION=$(getparam encryption)
+		session_change "$uniqueid" "foreignAddress" "$USERIP"
+
+		CMDLINE=$(session_get "$uniqueid")
+		FULL_PARAMS="user=$USER&userip=$(getparam foreignAddress)&uniqueid=$uniqueid&display=$(getparam display)$PARAMS"
+		SESS_DISPLAY=$(getparam display)
+	fi
+
+	# now start the node
+	export WAIT=$(mktemp /tmp/nxserver_wait.XXXXXXXXX)
+	touch $WAIT
+	(sleep 10; rm -f $WAIT) &
+	server_nxnode_start_wait --"$ACTION"session $USER "$FULL_PARAMS" &
+	SERVER_PID=$!
+	disown $SERVER_PID
+	while [ -f "$WAIT" ]
+	do
+		sleep 1
+	done
+}
+
+# Session stage
+while true
+do
+	echo_x -n "NX> 105 "
+	unset CMD
+	read CMD 2>/dev/null
+	# FIXME?
+	[ "$CMD" = "" ] && CMD="quit"
+	echo_x "$CMD"
+	case "$CMD" in 
+		quit|QUIT)
+			echo_x "Quit"
+			echo_x "NX> 999 Bye"
+			exit 0
+		;;
+		exit|EXIT)
+			echo_x "Exit"
+			echo_x "NX> 999 Bye"
+			exit 0
+		;;
+		bye|BYE)
+			echo_x "Bye"
+			echo_x "NX> 999 Bye"
+			if [ "$ENCRYPTION" = "1" ] 
+			then 
+				let PROXY_DISPLAY=$SESS_DISPLAY+4000
+				$COMMAND_NETCAT 127.0.0.1 $PROXY_DISPLAY
+				exit 0
+			else
+				echo_x "NX> 1001 Bye."
+			fi
+		;;
+		startsession*)
+			server_startrestore_session "start"
+		;;
+		list*)
+			server_get_params $CMD
+			PARAMS=$SERVER_PARAMS
+			CMDLINE=$PARAMS
+			
+			# FIXME: To NX-Node!
+
+			status=$(getparam status)
+
+			if [ "$status" = "Suspended" ]
+			then
+				session_list_user_suspended "$USER" "Suspended" "$(getparam screeninfo)" "$(getparam type)" | log_tee
+			elif [ "$status" = "Suspended,Running" ] # since 1.4.0-5
+			then
+				# disabled due to problems with 1.4.0-5 client
+				session_list_user_suspended "$USER" 'Suspended$|^status=Running$' "$(getparam geometry)" "$(getparam type)" | log_tee
+				#session_list_user_suspended "$USER" 'Suspended' "$(getparam geometry)" "$(getparam type)" | log_tee
+			else
+				session_list_user "$USER" | log_tee
+			fi
+		;;
+		suspend*)
+			server_get_params $CMD
+			PARAMS=$SERVER_PARAMS
+			CMDLINE=$PARAMS
+			if session_find_id_user "$(getparam sessionid)" "$USER"
+			then
+				# FIXME: Check for success/error
+				server_nxnode_start --suspend "$USER" "$PARAMS"
+				session_suspend $(getparam sessionid)
+			fi
+		;;
+		terminate*)
+			server_get_params $CMD
+			PARAMS=$SERVER_PARAMS
+			CMDLINE=$PARAMS
+			if session_find_id_user "$(getparam sessionid)" "$USER"
+			then
+				# FIXME: Check for success/error
+				server_nxnode_start --terminate "$USER" "$PARAMS"
+				session_close $(getparam sessionid)
+			fi
+		;;
+		restoresession*)
+			server_startrestore_session "resume"
+		;;
+		passwd)
+			echo "NX> 113 Changing password of user '$USER'"
+			echo -n "NX> 102 Current password:"
+			read -s PASS
+			ENC_PASS=$(passdb_get_crypt_pass "$PASS")
+			REAL_PASS=$(passdb_get_pass "$USER")
+			echo_x
+			if [ "$ENC_PASS" = "$REAL_PASS" ]
+			then
+				echo_x -n "NX> 102 Password:"
+				read -s NEW_PASS1
+				
+				if [ ${#NEW_PASS1} -lt 5 ]
+				then
+					echo_x "NX> 500 ERROR: incorrect password format, password must be long at least five characters"
+					continue
+				fi
+
+				echo_x
+				echo_x -n "NX> 102 Confirm password:"
+				read -s NEW_PASS1
+				echo_x
+				if [ "$NEW_PASS1" = "$NEW_PASS2" ]
+				then
+					ENC_PASS=$(passdb_get_crypt_pass "$NEW_PASS1")
+					passdb_chpass "$USER" "$ENC_PASS"
+					echo_x "NX> 114 Password of user '$USER' changed"
+				else
+					echo_x "NX> 537 ERROR: passwords do not match"
+				fi
+			else
+				echo_x "NX> 500 ERROR: current password doesn't match"
+			fi
+		;;
+		addmount*)
+			server_get_params $CMD
+			PARAMS=$SERVER_PARAMS
+			server_nxnode_start --smbmount "$USER" "$PARAMS" >/dev/null 2>&1
+			echo_x "NX> 719 SMB filesystem: running"
+		;;
+		addprintercups*)
+			server_get_params $CMD
+			PARAMS=$SERVER_PARAMS
+			server_nxnode_start --addprintercups "$USER" "$PARAMS" >/dev/null 2>&1
+		;;
+		*)
+			# disabled for 1.4.0-5 snapshot client
+			#echo_x "NX> 503 Error: undefined command: '$CMD'"
+		;;
+	esac
+done
+
+fi
+
+#
+# End of Main nxserver <--> nxclient communication module
+#
+
+################### PACKAGE cmd.bm ############################
+
+#
+# library functions for nxserver-commandline cmds
+#
+
+# Policy: All functions and variables need to start with CMD_ / cmd_
+
+# Needed global vars: $NX_VERSION, $NX_LICENSE, $NX_ETC_DIR, $PATH_BIN, $NX_HOME_DIR, $SSH_AUTHORIZED_KEYS
+
+# Needed package: passdb
+
+cmd_usage()
+{
+	echo "NXSERVER - Version $NX_VERSION $NX_LICENSE"
+	echo "Usage: nxserver <option>" 1>&2
+
+	if [ "$1" = "root" ]
+	then
+		echo "--adduser <user>: Add a new user" 1>&2
+		echo "--passwd <user>: Change password of <user>" 1>&2
+		echo "--deluser <user>: Remove a user from nx" 1>&2
+		echo "--listuser: List enabled users" 1>&2
+		echo "" 1>&2
+		echo "--start: Start the nx server" 1>&2
+		echo "--stop: Stop the nx server" 1>&2
+		echo "--status: Show status of nx server" 1>&2
+		echo "--restart: Restart the nx server and terminate all running sessions" 1>&2
+		echo "" 1>&2
+		echo "--list [ user | sessionid ]: List running sessions of user or sessionid " 1>&2
+		echo "--history [ user | sessionid | clear ]: Show history [ of user | sessionid ] or clear the history" 1>&2
+		echo "--terminate <user | :display | sessionid>: Terminate the session pointed to by" 1>&2
+		echo "       sessionid or display, or all sessions of the specified user." 1>&2
+		echo "--suspend <user | :display | sessionid>: Suspend the session pointed to by" 1>&2
+		echo "       sessionid or display, or all sessions of the specified user." 1>&2
+		echo "" 1>&2
+		echo "--broadcast <message>: Send a message to all users" 1>&2
+		echo "--send <user | :display | sessionid> <message>: Send a message to the specified user or sessionid" 1>&2
+	else
+		echo "--passwd: Change password" 1>&2
+	fi
+	exit 1
+}
+
+
+cmd_abort()
+{
+	echo "NX> 500" "$@" 1>&2
+	echo "NX> 999 Bye" 1>&2
+	exit 1
+}
+
+cmd_user_passwd()
+{
+	echo "NX> 100 NXSERVER - Version $NX_VERSION $NX_LICENSE"
+	echo "Sorry: Password changing for user is _not_ implemented, yet."
+	echo "Please login to NX-Server to change password"
+	echo "or ask your local system administrator."
+	#echo "NX> 113 Changing password of user '$USER'"
+	#echo "Old password:"
+	#read -s OLDPASS
+	#echo "New password:"
+	#read -s NEWPASS1
+	#echo "Repeat:"
+	#read -s NEWPASS2
+
+}
+
+cmd_passwd()
+{
+	CMD_CHUSER=$2
+	egrep -q "^$CMD_CHUSER:" $NX_ETC_DIR/passwords || cmd_abort "Error: User $CMD_CHUSER not found in database."
+	echo -n "New password: "
+	read -s CMD_NEWPASS
+	echo
+	CMD_ENC_PASS=$(passdb_get_crypt_pass "$CMD_NEWPASS")
+	passdb_chpass "$CMD_CHUSER" "$CMD_ENC_PASS"
+	echo "Password changed."
+}
+
+cmd_adduser()
+{
+	CMD_CHUSER=$2
+	
+	[ ${#CMD_CHUSER} -ge 32 ] && cmd_abort "Error: User $CMD_CHUSER must be shorter than 32 characters."
+	egrep -q "^$CMD_CHUSER:" $NX_ETC_DIR/passwords && cmd_abort "Error: User $CMD_CHUSER already in database."
+	getent passwd | egrep -q "^$CMD_CHUSER:" || cmd_abort "Error: User $CMD_CHUSER not existing on local system. Can't add."
+	passdb_add_user "$CMD_CHUSER"
+}
+
+cmd_deluser()
+{
+	CMD_CHUSER=$2
+	egrep -q "^$CMD_CHUSER:" $NX_ETC_DIR/passwords || cmd_abort "Error: User $CMD_CHUSER not found in database."
+	passdb_remove_user "$CMD_CHUSER"
+}
+
+cmd_listuser()
+{
+	echo "NX> 146 NX users list"
+	echo
+	echo "Username"
+	echo "---------------"
+	echo
+	passdb_list_user
+	echo
+}
+
+cmd_start()
+{
+	
+	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] && cmd_abort "ERROR: Service already running"
+	mv $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS.disabled $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS
+	echo "NX> 122 Service started"
+}
+
+cmd_stop()
+{
+	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] || cmd_abort "Service was already stopped"
+	mv $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS.disabled
+	# TODO: Stop all running sessions
+	echo "NX> 123 Service stopped"
+}
+
+cmd_status()
+{
+	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] && echo "NX> 110 NX Server is running"
+	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] || echo "NX> 110 NX Server is stopped"
+}
+
+cmd_restart()
+{
+	cmd_stop
+	cmd_start
+}
+
+cmd_parse_2_params()
+{
+	if [ ${#1} -eq 32 ]
+	then
+		CMD_APARAMS="sessionid=sessionId{$1}"
+	else
+	if [ "$1" != "" ]
+	then
+		#egrep -q "^$1:" $NX_ETC_DIR/passwords || cmd_abort "Error: User $1 not found in database."
+		CMD_APARAMS="user=$1"
+	fi
+	fi
+	echo $CMD_APARAMS
+
+}
+
+cmd_parse_3_params()
+{
+	if [ ${#1} -eq 32 ]
+	then
+		CMD_APARAMS=$(session_find_id $1)
+		[ -n "$CMD_APARAMS" ] || cmd_abort "Error: Session $1 could not be found."
+	else
+	if [ "${1:0:1}" = ":" ]
+	then
+		CMD_APARAMS=$(session_find_display "${1:1}")
+		[ -n "$CMD_APARAMS" ] || cmd_abort "Error: No running sessions found for display $1."
+	else
+	if [ "$1" != "" ]
+	then
+		#egrep -q "^$1:" $NX_ETC_DIR/passwords || cmd_abort "Error: User $1 not found in database."
+		CMD_APARAMS=$(session_find_user "$1")
+		[ -n "$CMD_APARAMS" ] || cmd_abort "Error: No running sessions found for user $1."
+	else
+		cmd_abort "Error: Not enough parameters."
+	fi
+	fi
+	fi
+	echo $CMD_APARAMS
+}
+
+cmd_list_suspended()
+{
+	CMD_PARAMS=$(cmd_parse_2_params "$2")
+	[ -n "$2" -a -z "$CMD_PARAMS" ] && exit 1
+	case $CMD_PARAMS in
+		user=*)
+			session_list_user_suspended $2 "Suspended"
+		;;
+	esac
+}
+cmd_list()
+{
+	CMD_PARAMS=$(cmd_parse_2_params "$2")
+	[ -n "$2" -a -z "$CMD_PARAMS" ] && exit 1
+	case $CMD_PARAMS in
+		user=*)
+			session_list_user $2
+		;;
+		sessionid=*)
+			session_list $2
+		;;
+		*)
+			session_list_all
+		;;
+	esac
+}
+
+cmd_history_clear()
+{
+	rm -f $NX_SESS_DIR/closed/*
+	rm -f $NX_SESS_DIR/failed/*
+}
+
+cmd_history()
+{
+	if [ "$2" = "clear" ]
+	then
+		cmd_history_clear
+	fi
+	
+	CMD_PARAMS=$(cmd_parse_2_params "$2")
+	user=""
+	sessid=""
+	case $CMD_PARAMS in
+		user=*)
+			user="$2"
+		;;
+		sessionid=*)
+			sessid="$2"
+		;;
+	esac
+
+	session_history "$user" "$sessid"
+}
+
+cmd_terminate()
+{
+	CMD_PARAMS=$(cmd_parse_3_params "$2")
+	[ -z "$CMD_PARAMS" ] && exit 1
+	for i in $CMD_PARAMS;
+	do
+			CMDLINE=$(session_get_cmdline $i)
+			cmd_sessionid=$(getparam sessionId)
+			cmd_user=$(getparam userName)
+			cmd_type=$(getparam type)
+			cmd_status=$(getparam status)
+
+			# is it a "good" session?
+			case "$1" in 
+			--suspend)
+				if [ "$cmd_status" = "Running" ] && stringinstring "unix-" "$cmd_type"
+				then
+					echo "sessionid=$cmd_sessionid" | su - "$cmd_user" -c "$PATH_BIN/nxnode --suspend"
+					session_suspend $cmd_sessionid
+				fi
+				;;
+			--terminate)
+			#if stringinstring "unix-" "$cmd_type"
+			#	then
+					echo "sessionid=$cmd_sessionid" | su - "$cmd_user" -c "$PATH_BIN/nxnode --terminate"
+					session_close $cmd_sessionid
+			#	fi
+
+			;;
+			esac
+	done
+
+}
+
+cmd_send()
+{
+	if [ "$1" = "--broadcast" ]
+	then
+	  CMD_PARAMS=$(session_find_all)
+	  [ -z "$CMD_PARAMS" ] && cmd_abort "Error: No running session could be found."
+	else
+	  CMD_PARAMS=$(cmd_parse_3_params "$2")
+	  [ -z "$CMD_PARAMS" ] && exit 1
+	fi
+	shift
+	shift
+	for i in $CMD_PARAMS;
+	do
+			CMDLINE=$(session_get_cmdline $i)
+			cmd_display=$(getparam display)
+			cmd_user=$(getparam userName)
+			cmd_type=$(getparam type)
+			cmd_status=$(getparam status)
+
+			# is it a "good" session?
+			if [ "$cmd_status" = "Running" ] && stringinstring "unix-" "$cmd_type"
+			then
+				su - "$cmd_user" -c "$PATH_BIN/nxclient --dialog ok --caption \"NX Administrator Message\" --message \"$@\" --noautokill 
+-display \":$cmd_display\"" &
+				disown $!
+			fi
+	done
+	#nxnode_start --send "$CMD_PARAMS"
+}
+
+#
+# user mode available functions
+#
+
+if [ $UID -ne 0 ]
+then
+	[ "$1" != "--passwd" ] && cmd_usage
+	cmd_user_passwd
+	exit 0
+fi
+
+#
+# root mode available functions
+#
+
+[ $# -lt 1 ] && cmd_usage "root"
+[ "$1" = "--help" ] && cmd_usage "root"
+
+if [ "$1" = "--version" ]
+then
+  echo "NXSERVER - Version $NX_VERSION $NX_LICENSE"
+  exit 0
+fi
+
+CMD=$1
+
+echo "NX> 100 NXSERVER - Version $NX_VERSION $NX_LICENSE"
+
+case $CMD in
+	# 
+	# User functions ...
+	# 
+	--passwd)
+		cmd_passwd "$@"
+	;;
+	--adduser|--useradd)
+		cmd_adduser "$@"
+	;;
+	--deluser|--userdel)
+		cmd_deluser "$@"
+	;;
+	--listuser|--userlist)
+		cmd_listuser
+	;;
+	--start)
+		cmd_start
+	;;
+	--stop)
+		cmd_stop
+	;;
+	--status)
+		cmd_status
+	;;
+	--restart)
+		cmd_restart
+	;;
+	--list)
+		cmd_list "$@"
+	;;
+	--list-suspended)
+		cmd_list_suspended "$@"
+	;;
+	--history)
+		cmd_history "$@"
+	;;
+	--terminate|--suspend)
+		cmd_terminate "$@"
+	;;
+	--send|--broadcast)
+		cmd_send "$@"
+	;;
+	*)
+		cmd_abort "Error: Function $CMD not implemented yet."
+esac
+echo "NX> 999 Bye"


Property changes on: freenx-server/nxserver.old
___________________________________________________________________
Name: svn:executable
   + 

Added: freenx-server/nxsetup
===================================================================
--- freenx-server/nxsetup	2005-03-31 01:12:31 UTC (rev 61)
+++ freenx-server/nxsetup	2005-07-03 14:35:34 UTC (rev 62)
@@ -0,0 +1,349 @@
+#!/bin/bash
+
+# Coypright (c) 2004-2005 by Fabian Franz <freenx at fabian-franz.de>.
+#                    2005 by Jon Severinsson <jonno at users.berlios.de>.
+#
+# License: GNU GPL, version 2
+#
+# CVS: $Id: nxsetup,v 1.28 2005/05/05 08:04:24 jonno Exp $ 
+#
+
+HELP="no"
+INSTALL="no"
+SETUP_NOMACHINE_KEY="no"
+SETUP_UID=""
+CLEAN="no"
+UNINSTALL="no"
+PURGE="no"
+SETUP_SSH2_KEY="no"
+BUILD_KNOWN_HOSTS="yes"
+
+while [ "$1" ]
+do
+	case "$1" in
+		--help) HELP="yes"; shift ;;
+		--install) INSTALL="yes"; shift ;;
+		--setup-nomachine-key) SETUP_NOMACHINE_KEY="yes"; shift ;;
+		--ssh2) SETUP_SSH2_KEY="yes"; shift;;
+		--dont-build-known-hosts) BUILD_KNOWN_HOSTS="no"; shift;;
+		--uid) SETUP_UID=$2; shift 2 ;;
+		--clean) CLEAN="yes"; shift ;;
+		--uninstall) UNINSTALL="yes"; shift ;;
+		--purge) PURGE="yes"; shift ;;
+		--) shift ; break ;;
+		*) echo "Invalid flag $1" ; HELP="yes"; shift ; break ;;
+	esac
+done
+
+#Check for invalid combinations:
+[ "$INSTALL" = "yes" -a "$UNINSTALL" = "yes" ] && HELP="yes"
+[ "$INSTALL" = "no" -a "$UNINSTALL" = "no" ] && HELP="yes"
+[ "$INSTALL" = "yes" -a "$CLEAN" = "no" -a "$PURGE" = "yes" ] && HELP="yes"
+[ "$UNINSTALL" = "yes" ] && [ "$SETUP_NOMACHINE_KEY" = "yes" -o -n "$SETUP_UID" -o "$CLEAN" = "yes" ] && HELP="yes"
+[ "$UNINSTALL" = "yes" -a "$CLEAN" = "yes" ] && HELP="yes"
+[ "$SETUP_SSH2_KEY" = "yes" -a "$SETUP_NOMACHINE_KEY" = "no" ] && HELP="yes"
+
+if [ "$HELP" = "yes" ]
+then
+	echo "nxsetup - Setup the FreeNX server."
+	echo "Syntax: nxsetup --help"
+	echo "        nxsetup --install [--setup-nomachine-key] [--uid <nummber>] [--clean [--purge]]"
+	echo "        nxsetup --uninstall [--purge]"
+	echo
+	echo "  --help                 Displays this help message"
+	echo "  --install              Install nessesary files and add the nx user"
+	echo "  --setup-nomachine-key  Allow login with the key shipped with the NoMachine"
+	echo "                         client. This is not as secure, but it simplifies the "
+	echo "                         configuration of clients."
+	echo "                         Use this option at your own risk."
+	echo "  --ssh2		       Additionally create commercial pubkey-support, beware"
+	echo "			       own _commercial_ ssh2-key is not supported!."
+	echo "  --uid <number>         The nx user will be given the uid <number>."
+	echo "  --clean                Performs an uninstall prior to the installation"
+	echo "  --uninstall            Remove log and session files, as well as the nx user"
+	echo "  --purge                Uninstall will remove extra configuration files and ssh"
+	echo "                         keys as well. Note that node.conf will always be saved."
+	exit 0
+fi
+#Undocumented
+#
+#    --dont-build-known-hosts		For system without /etc/ssh/ssh_host_key.rsa.pub and anyway
+#					expect should handle nx-users known-hosts keys so why borther
+#					in nxsetup?
+
+if [ $UID -ne 0 ]
+then
+	echo "You need to be root to use this program." 
+	exit 1
+fi
+
+# Read the config file
+. $(PATH=$(cd $(dirname $0) && pwd):$PATH which nxloadconfig) --
+
+# Tries to add a system user
+useradd_nx()
+{
+	# In any case create the basedir of the HOME directory before, 
+	# because useradd will fail to make more than one directory
+	mkdir -p $(dirname "$NX_HOME_DIR")
+	
+	# Are uid specified
+	if [ -n "$SETUP_UID" ]
+	then
+		useradd -u $SETUP_UID -d $NX_HOME_DIR -s $PATH_BIN/nxserver nx
+	# Is it a debian?
+	elif [ -f /etc/debian_version ]
+	then
+		adduser --system --home $NX_HOME_DIR --shell $PATH_BIN/nxserver nx
+	# or is it a SuSE?
+	elif [ -f /etc/SuSE-release ]
+	then
+		useradd -r -d $NX_HOME_DIR -s $PATH_BIN/nxserver nx
+	# we don't know the system, fallback
+	else
+		useradd -d $NX_HOME_DIR -s $PATH_BIN/nxserver nx
+	fi
+}
+
+install_nx()
+{
+	set -e
+	
+	if [ "$(pidof sshd)" = "" ]
+	then 
+		echo -n "Starting ssh service ..."
+		# Generate Host keys if they are not available, yet
+		[ -e /etc/ssh/ssh_host_rsa_key ] || $COMMAND_SSH_KEYGEN -q -t rsa -f /etc/ssh/ssh_host_rsa_key -C '' -N ''
+		[ -e /etc/ssh/ssh_host_dsa_key ] || $COMMAND_SSH_KEYGEN -q -t dsa -f /etc/ssh/ssh_host_dsa_key -C '' -N ''
+		[ -x /etc/init.d/sshd ] && /etc/init.d/sshd start
+		[ -x /etc/init.d/ssh ] && /etc/init.d/ssh start
+		echo "done"
+	fi
+	
+	echo -n "Setting up $NX_ETC_DIR ..."
+	mkdir -p $NX_ETC_DIR
+	touch $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
+	chmod 600 $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
+	echo "done"
+	
+	if [ ! -f $NX_ETC_DIR/users.id_dsa ]
+	then
+		$COMMAND_SSH_KEYGEN -f $NX_ETC_DIR/users.id_dsa -t dsa -N ""
+	fi
+	
+	echo -n "Setting up $NX_SESS_DIR ..."
+	mkdir -p $NX_SESS_DIR/closed $NX_SESS_DIR/running $NX_SESS_DIR/failed
+	chmod 700 $NX_SESS_DIR/*
+	echo "done"
+	
+	echo -n "Setting up $NX_LOGFILE ..."
+	mkdir -p $(dirname "$NX_LOGFILE")
+	touch "$NX_LOGFILE"
+	chmod 600 "$NX_LOGFILE"
+	echo "done"
+	
+	if ! { getent passwd | egrep -q "^nx:"; }
+	then
+		echo -n "Setting up user nx ..."
+		useradd_nx
+		echo "done"
+	fi
+	
+	if [ "$ENABLE_NOMACHINE_FORWARD" = "1" -a -x "$NOMACHINE_SERVER" ]
+	then
+		echo -n "Setting up NoMachine forwarding ..."
+		usermod -s "$PATH_BIN/nxserver" -d "$NOMACHINE_NX_HOME_DIR" nx
+		echo "done"
+	fi
+	
+	echo -n "Setting up known_hosts and $SSH_AUTHORIZED_KEYS ..."
+	
+	SETUP_NX_KEY="no"
+	
+	mkdir -p $NX_HOME_DIR/.ssh
+	chmod 700 $NX_HOME_DIR/ $NX_HOME_DIR/.ssh
+	
+	if [ ! -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ]
+	then
+		SETUP_NX_KEY="yes"
+		if [ "$SETUP_NOMACHINE_KEY" = "yes" ]
+		then
+			cat << EOF >$NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS
+no-port-forwarding,no-X11-forwarding,no-agent-forwarding,command="$PATH_BIN/nxserver" ssh-dss AAAAB3NzaC1kc3MAAACBAJe/0DNBePG9dYLWq7cJ0SqyRf1iiZN/IbzrmBvgPTZnBa5FT/0Lcj39sRYt1paAlhchwUmwwIiSZaON5JnJOZ6jKkjWIuJ9MdTGfdvtY1aLwDMpxUVoGwEaKWOyin02IPWYSkDQb6cceuG9NfPulS9iuytdx0zIzqvGqfvudtufAAAAFQCwosRXR2QA8OSgFWSO6+kGrRJKiwAAAIEAjgvVNAYWSrnFD+cghyJbyx60AAjKtxZ0r/Pn9k94Qt2rvQoMnGgt/zU0v/y4hzg+g3JNEmO1PdHh/wDPVOxlZ6Hb5F4IQnENaAZ9uTZiFGqhBO1c8Wwjiq/MFZy3jZaidarLJvVs8EeT4mZcWxwm7nIVD4lRU2wQ2lj4aTPcepMAAACANlgcCuA4wrC+3Cic9CFkqiwO/Rn1vk8dvGuEQqFJ6f6LVfPfRTfaQU7TGVLk2CzY4dasrwxJ1f6FsT8DHTNGnxELPKRuLstGrFY/PR7KeafeFZDf+fJ3mbX5nxrld3wi5titTnX+8s4IKv29HJguPvOK/SI7cjzA+SqNfD7qEo8= root at nettuno
+EOF
+			chmod 600 $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS
+		else
+			# generate a new key, backup the old and copy it to $SSH_AUTHORIZED_KEYS
+			$PATH_BIN/nxkeygen
+		fi
+	fi
+
+	# commercial ssh2-server uses other authentification-files
+	# as they are more or less static, I don't integrated these variable
+	# in node.conf, you have to change them here, if you like
+	SSH2_AUTHORIZATION="authorization"
+	SSH2_PUBKEY="nx_user.id.pub"
+	SSH2_HOME_DIR="$NX_HOME_DIR/.ssh2"
+	if [ ! -f "${SSH2_HOME_DIR}/$SSH2_PUBKEY" -a "$SETUP_SSH2_KEY" = "yes" -a "$SETUP_NOMACHINE_KEY" = "yes" ]
+	then
+		mkdir -p $SSH2_HOME_DIR
+		chmod 700 $SSH2_HOME_DIR
+		
+		cat >  ${SSH2_HOME_DIR}/$SSH2_PUBKEY <<EOF
+---- BEGIN SSH2 PUBLIC KEY ----
+Comment: "1024-bit DSA, converted from OpenSSH by root at localhost"
+AAAAB3NzaC1kc3MAAACBAJe/0DNBePG9dYLWq7cJ0SqyRf1iiZN/IbzrmBvgPTZnBa5FT/
+0Lcj39sRYt1paAlhchwUmwwIiSZaON5JnJOZ6jKkjWIuJ9MdTGfdvtY1aLwDMpxUVoGwEa
+KWOyin02IPWYSkDQb6cceuG9NfPulS9iuytdx0zIzqvGqfvudtufAAAAFQCwosRXR2QA8O
+SgFWSO6+kGrRJKiwAAAIEAjgvVNAYWSrnFD+cghyJbyx60AAjKtxZ0r/Pn9k94Qt2rvQoM
+nGgt/zU0v/y4hzg+g3JNEmO1PdHh/wDPVOxlZ6Hb5F4IQnENaAZ9uTZiFGqhBO1c8Wwjiq
+/MFZy3jZaidarLJvVs8EeT4mZcWxwm7nIVD4lRU2wQ2lj4aTPcepMAAACANlgcCuA4wrC+
+3Cic9CFkqiwO/Rn1vk8dvGuEQqFJ6f6LVfPfRTfaQU7TGVLk2CzY4dasrwxJ1f6FsT8DHT
+NGnxELPKRuLstGrFY/PR7KeafeFZDf+fJ3mbX5nxrld3wi5titTnX+8s4IKv29HJguPvOK
+/SI7cjzA+SqNfD7qEo8=
+---- END SSH2 PUBLIC KEY ----
+EOF
+		echo "Key $SSH2_PUBKEY" >> ${SSH2_HOME_DIR}/$SSH2_AUTHORIZATION
+		echo "Options no-port-forwarding,no-x11-forwarding,no-agent-forwarding,command=\"$PATH_BIN/nxserver\"" >> ${SSH2_HOME_DIR}/$SSH2_AUTHORIZATION
+		chmod 600 ${SSH2_HOME_DIR}/$SSH2_AUTHORIZATION ${SSH2_HOME_DIR}/$SSH2_PUBKEY
+	fi
+	
+	if [ ! -f $NX_HOME_DIR/.ssh/known_hosts -a "$BUILD_KNOWN_HOSTS" = "yes" ]
+	then
+		echo -n "127.0.0.1 " > $NX_HOME_DIR/.ssh/known_hosts
+		cat /etc/ssh/ssh_host_rsa_key.pub >> $NX_HOME_DIR/.ssh/known_hosts
+	fi
+	
+	echo "done"
+	
+	echo -n "Setting up permissions ..."
+	chown -R nx:root $NX_SESS_DIR
+	chown -R nx:root $NX_ETC_DIR
+	chown -R nx:root $NX_HOME_DIR
+	chown nx:root "$NX_LOGFILE"
+	echo "done"
+}
+
+uninstall_nx() 
+{
+	if { getent passwd | egrep -q "^nx:"; }
+	then
+		echo -n "Removing user nx ..."
+		userdel nx
+		echo "done"
+	fi
+	
+	if [ -e "$NX_SESS_DIR" ]
+	then
+		echo -n "Removing session database ..."
+		rm -f -r $NX_SESS_DIR/closed $NX_SESS_DIR/running $NX_SESS_DIR/failed 2>/dev/null
+		rmdir -p $NX_SESS_DIR 2>/dev/null
+		echo "done"
+	fi
+	
+	if [ -e "$NX_LOGFILE" ] 
+	then
+		echo -n "Removing logfile ..."
+		rm -f "$NX_LOGFILE" 2>/dev/null
+		rmdir -p $(dirname "$NX_LOGFILE") 2>/dev/null
+		echo "done"
+	fi
+	
+	if [ "$PURGE" = "yes" -a -e "$NX_HOME_DIR" ]
+	then
+		echo -n "Removing nx home directory ..."
+		rm -f -r "$NX_HOME_DIR" 2>/dev/null
+		rmdir -p $(dirname "$NX_HOME_DIR") 2>/dev/null
+		echo "done"
+	fi
+	
+	if [ "$PURGE" = "yes" -a -e "$NX_ETC_DIR" ]
+	then
+		echo -n "Removing configuration files ..."
+		rm -f "$NX_ETC_DIR/passwords" "$NX_ETC_DIR/passwords.orig" "$NX_ETC_DIR/users.id_dsa" "$NX_ETC_DIR/users.id_dsa.pub" 2>/dev/null
+		for i in `ls $NX_ETC_DIR/*.node.conf 2>/dev/null` ;
+		do
+			rm -f "$i" 2>/dev/null;
+		done
+		echo "done"
+	fi
+}
+
+if [ "$INSTALL" = "yes" ]
+then
+	#Perform cleanup?
+	[ "$CLEAN" = "yes" ] && uninstall_nx
+	
+	install_nx
+	
+	echo "Ok, nxserver is ready."
+	echo 
+	if [ "$ENABLE_SSH_AUTHENTICATION" = "1" -o "$ENABLE_SU_AUTHENTICATION" = "1" ]
+	then
+		echo "PAM authentication enabled:"
+		if [ "$ENABLE_USER_DB" = "1" ]
+		then
+			echo "  Users will be able to login with their normal passwords,"
+			echo "  but they have to be registered in the nx database to do so."
+			echo "  To add new users to the nx database do:"
+			echo "    nxserver --adduser <username>"
+		else
+			echo "  All users will be able to login with their normal passwords."
+		fi
+		echo
+		if [ "$ENABLE_SSH_AUTHENTICATION" = "1" -a "$ENABLE_SU_AUTHENTICATION" = "1" ]
+		then
+			echo "  Both SSH and SU authentication is enabled."
+			echo "  This does work, but is redundant."
+			echo "  Please check if this is really what you intended."
+		elif [ "$ENABLE_SSH_AUTHENTICATION" = "1" ]
+		then
+			echo "  PAM authentication will be done through SSH."
+			echo "  Please ensure that SSHD on localhost accepts password authentication."
+		else
+			echo "  PAM authentication will be done through SU."
+			echo "  Please ensure that the user "nx" is a member of the wheel group."
+		fi
+	else
+		echo "PAM authentication disabled."
+		echo "  Only users in the nx database will be able to log in."
+		echo
+		echo "  To add new users to the nx database do:"
+		echo "    nxserver --adduser <username>"
+		echo "  Afterwards change the password with:"
+		echo "    nxserver --passwd <username>"
+	fi
+	echo
+	echo "  You can change this behaviour in the $NX_ETC_DIR/node.conf file."
+	
+	if [ "$SETUP_NOMACHINE_KEY" = "no" -a "$SETUP_NX_KEY" = "yes" ]
+	then
+		echo
+		echo "Warning: Clients will not be able to login to this server with the standard key."
+		echo "         Please replace /usr/NX/share/client.id_dsa.key on all clients you want"
+		echo "         to use with $NX_HOME_DIR/.ssh/client.id_dsa.key"
+		echo "         and protect it accordingly."
+		echo
+		echo "         If you really want to use the NoMachine key please remove"
+		echo "         '$NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS'"
+		echo "         and then run this script with the --setup-nomachine-key parameter."
+	fi
+	
+	echo "Have Fun!"
+elif [ "$UNINSTALL" = "yes" ]
+then
+	uninstall_nx
+	
+	echo "Ok, nxserver is uninstalled"
+	echo 
+	if [ "$PURGE" = "yes" ]
+	then
+		echo "To complete the uninstallation process, remove the nx scripts in $PATH_BIN"
+		echo "and the $NX_ETC_DIR/node.conf configuration file."
+	else
+		echo "To complete the uninstallation process, remove the nx scripts in $PATH_BIN"
+		echo
+		echo "Configuration files and ssh keys are saved in case you would like to reinstall"
+		echo "freenx at a later time. To remove them, please run 'nxsetup --uninstall --purge'"
+	fi
+fi


Property changes on: freenx-server/nxsetup
___________________________________________________________________
Name: svn:executable
   + 



From fabianx at berlios.de  Sun Jul  3 16:38:26 2005
From: fabianx at berlios.de (Fabian Franz at BerliOS)
Date: Sun, 3 Jul 2005 16:38:26 +0200
Subject: [Freenx-cvs] r63 - freenx-server
Message-ID: <200507031438.j63EcQ5A005615@sheep.berlios.de>

Author: fabianx
Date: 2005-07-03 16:38:23 +0200 (Sun, 03 Jul 2005)
New Revision: 63

Removed:
   freenx-server/RoadMap
   freenx-server/nxserver.old
Log:
Deleted two superflous files.


Deleted: freenx-server/RoadMap
===================================================================
--- freenx-server/RoadMap	2005-07-03 14:35:34 UTC (rev 62)
+++ freenx-server/RoadMap	2005-07-03 14:38:23 UTC (rev 63)
@@ -1,21 +0,0 @@
-0.4.0
-	- Samba File and Printer sharing
-	- Sound via SOUNDSERVER
-
-0.4.1
-	- Bugfixes
-	
-0.4.2
-	- Solaris Support
-	- Stability Support
-
-[Between]
-	- Umfrage zu NX (Ask Slashdot?)
-	- Dokumentation
-	
-0.5.0
-	- "Rewrite" of Session-Management
-	- Transparent Socks-Implementation
-		- Seamless printing
-		- Seamless FileSharing (fish)
-	- Transparent tunnel of devices

Deleted: freenx-server/nxserver.old
===================================================================
--- freenx-server/nxserver.old	2005-07-03 14:35:34 UTC (rev 62)
+++ freenx-server/nxserver.old	2005-07-03 14:38:23 UTC (rev 63)
@@ -1,1381 +0,0 @@
-#!/bin/bash
-
-# Free implementation of nxserver components
-#
-# To use nxserver add the user "nx" 
-# and use nxserver as default shell.
-#
-# Also make sure that hostkey based authentification works.
-# 
-# Copyright (c) 2004 by Fabian Franz <FreeNX at fabian-franz.de>.
-#
-# License: GNU GPL, version 2
-#
-# CVS: $Id: nxserver,v 1.42 2005/03/14 00:51:21 fabianx Exp $
-#
-
-# Read the config file
-. $(PATH=$(cd $(dirname $0) && pwd):$PATH which nxloadconfig) --
-
-if [ "$USER" = "nxuser" ]
-then
-	export NX_SESS_DIR="$HOME/.nx/db/"
-	export NX_LOGFILE="$HOME/.nx/temp/nxserver.log"
-	mkdir -p $NX_SESS_DIR/{closed,running,failed}
-	ENABLE_FAKE_AUTHENTICATION="1"
-fi
-
-# following two functions are Copyright by Klaus Knopper
-
-stringinstring(){
-case "$2" in *$1*) return 0;; esac
-return 1
-}
-
-# Reread boot command line; echo last parameter's argument or return false.
-getparam(){
-stringinstring "&$1=" "$CMDLINE" || return 1
-echo "$CMDLINE" | awk "/^$1=/"' { VAL=$2 } END { print VAL }' FS="=" RS="(&|\n)"
-return 0
-}
-
-
-############### PACKAGE passdb.bm #######################
-#
-# Library of passdb functions (outsource)
-#
-
-# Policy: Variable and function names _must_ start with passdb_ / PASSDB_
-
-# Needed global vars: $NX_ETC_DIR, $PATH_BIN
-
-# Needed nonstd functions: md5sum
-
-
-passdb_get_crypt_pass()
-{
-	echo "$@" | md5sum | cut -d" " -f1
-}
-
-passdb_get_pass()
-{
-	PASSDB_CHUSER="$1"
-	PASSDB_PASS=$(egrep "^$PASSDB_CHUSER:" $NX_ETC_DIR/passwords 2>/dev/null | cut -d":" -f2)
-	if [ "$ENABLE_PASSDB_AUTHENTICATION" = "1" ]
-	then
-		egrep -q "^$PASSDB_CHUSER:" $NX_ETC_DIR/passwords 2>/dev/null && echo $PASSDB_PASS
-		egrep -q "^$PASSDB_CHUSER:" $NX_ETC_DIR/passwords 2>/dev/null || echo "NOT_VALID"
-	else
-		echo "NOT_VALID"
-	fi
-}
-
-passdb_chpass()
-{
-	PASSDB_CHUSER="$1"
-	PASSDB_ENC_PASS="$2"
-	cp -f $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
-	perl -pi -e "s/$PASSDB_CHUSER:.*/$PASSDB_CHUSER:$PASSDB_ENC_PASS/g" $NX_ETC_DIR/passwords
-}
-
-passdb_user_exists()
-{
-	PASSDB_CHUSER="$1"
-	egrep -q "^$PASSDB_CHUSER:" $NX_ETC_DIR/passwords 2>/dev/null
-}
-
-
-passdb_remove_user()
-{
-	PASSDB_CHUSER="$1"
-	cp -f $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
-	perl -pi -e "s/$PASSDB_CHUSER:.*\n//g" $NX_ETC_DIR/passwords
-}
-
-passdb_add_user()
-{
-	PASSDB_CHUSER="$1"
-	cp -f $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
-	echo "$PASSDB_CHUSER:*" >> $NX_ETC_DIR/passwords
-	# deactivated to avoid problems with comm-server
-	su - $PASSDB_CHUSER -c "$PATH_BIN/nxnode --setkey"
-}
-
-passdb_list_user()
-{
-	cat $NX_ETC_DIR/passwords | cut -d":" -f1
-}
-
-#
-# End of passdb Library
-#
-
-############### PACKAGE session.bm #######################
-#
-# Library of session management functions
-#
-
-# Needed global vars: $NX_SESS_DIR
-
-session_list()
-{
-	cat $NX_SESS_DIR/running/sessionId"{$1}"
-}
-
-# Find all running session-filenames 
-
-session_find_all()
-{
-	for i in $NX_SESS_DIR/running/*
-	do
-		[ -f $i ] || break
-		echo $i
-	done
-}
-
-# Find all running sessions of a id
-session_find_id()
-{
-	[ -f $NX_SESS_DIR/running/sessionId"{$1}" ] && echo $NX_SESS_DIR/running/sessionId"{$1}"
-}
-
-# finds out if a session belongs to a user
-
-session_find_id_user()
-{
-	[ -f $NX_SESS_DIR/running/sessionId"{$1}" ] && egrep -q "^userName=$2$" $NX_SESS_DIR/running/sessionId"{$1}" && return 0
-	return 1
-}
-
-# Find all running sessions of a user
-session_find_user()
-{
-	for i in $NX_SESS_DIR/running/*
-	do
-		[ -f $i ] || break
-		egrep -q "^userName=$1$" $i && echo $i
-	done
-}
-
-# Find all running sessions of a display
-session_find_display()
-{	
-	for i in $NX_SESS_DIR/running/*
-	do
-		[ -f $i ] || break
-		egrep -q "^display=$1$" $i && echo $i
-	done
-}
-
-# session_get_cmdline <session filename>
-
-session_get_cmdline()
-{
-	echo "a=b" | cat - $1 | tr '\n' '&'
-}
-
-# session_get <uniqueid>
-
-session_get()
-{
-	session_get_cmdline $NX_SESS_DIR/running/sessionId"{$1}"
-}
-
-
-# Get the first session, which can be resumed
-
-session_get_user_suspended()
-{
-	for i in $NX_SESS_DIR/running/*
-	do
-		[ -f $i ] || break
-		if egrep -q "^userName=$1$" $i && egrep -q "^status=$2$" $i
-		then
-			CMDLINE=$(session_get_cmdline $i)
-			echo "$(getparam sessionId)"
-			break
-		fi
-	done
-}
-
-# Count all sessions of a user
-# and save it in SESSION_COUNT and SESSION_COUNT_USER
-
-session_count_user()
-{
-	SESSION_COUNT=0
-	SESSION_COUNT_USER=0
-
-	for i in $NX_SESS_DIR/running/*
-	do
-		[ -f $i ] || break
-		let SESSION_COUNT=$SESSION_COUNT+1
-		egrep -q "^userName=$1$" $i && let SESSION_COUNT_USER=$SESSION_COUNT_USER+1
-	done
-}
-
-# List all sessions of a user
-
-session_list_user_suspended()
-{
-	SESSION_COUNT=0
-	SESSION_COUNT_USER=0
-
-	TMPFILE=$(mktemp /tmp/nxserver_tmp.XXXXXXXXX)
-	echo "NX> 127 Sessions list of user '$1' for reconnect:" > $TMPFILE
-	echo >> $TMPFILE
-	if [ -z "$4" ]
-	then
-		
-		echo "Display Type             Session ID                       Options  Depth Screensize     Available Session Name" >> $TMPFILE
-		echo "------- ---------------- -------------------------------- -------- ----- -------------- --------- ----------------------" >> $TMPFILE
-	else
-		echo "Display Type             Session ID                       Options  Depth Screen         Status      Session Name" >> $TMPFILE
-		echo " ------- ---------------- -------------------------------- -------- ----- -------------- ----------- ------------------------------" >> $TMPFILE
-	fi
-	for i in $NX_SESS_DIR/running/*
-	do
-		[ -f $i ] || break
-		let SESSION_COUNT=$SESSION_COUNT+1
-		if egrep -q "^userName=$1$" $i && egrep -q "^status=$2$" $i #&& grep -q "screeninfo=$3" $i
-		then
-			CMDLINE=$(session_get_cmdline $i)
-			depth=$(getparam screeninfo | cut -d "x" -f3 | cut -d "+" -f1 )
-			geom=$(getparam screeninfo | cut -d "x" -f1,2) 
-			render=$(getparam screeninfo | cut -d "+" -f2 )
-			available="N/A"
-			udepth=$(echo $3 | cut -d "x" -f3 | cut -d "+" -f1 )
-			urender=$(echo $3 | cut -d "+" -f2 )
-			[ "$(getparam geometry)" = "fullscreen" ] && options="F"
-			[ "$(getparam geometry)" = "fullscreen" ] || options="-"
-			[ "$urender" = "render" ] && options="${options}R---PSA"
-			[ "$urender" = "render" ] || options="${options}----PSA"
-			[ "$udepth" = "$depth" -a "$urender" = "$render" ] && available=$(getparam status)
-			# FIXME: HACK !!! to keep compatibility with old snapshot version (Knoppix 3.6 based for example)
-			if [ -z "$4" -a "$available" != "N/A" ] 
-			then
-				available="Yes"
-			fi
-			echo -e "$(getparam display)\t$(getparam type)\t$(getparam sessionId)\t$options\t$depth\t$geom\t$available\t$(getparam sessionName)" >> $TMPFILE
-		fi
-		egrep -q "^userName=$1$" $i && let SESSION_COUNT_USER=$SESSION_COUNT_USER+1
-	done
-	echo "" >> $TMPFILE
-	echo "" >> $TMPFILE
-	cat $TMPFILE
-	rm -f $TMPFILE
-	if [ "$SESSION_COUNT" -ge "$SESSION_LIMIT" -o "$SESSION_COUNT_USER" -ge "$SESSION_USER_LIMIT" ]
-	then
-		echo "NX> 147 Server capacity: reached for user: $1"
-	else
-		echo "NX> 148 Server capacity: not reached for user: $1"
-	fi
-}
-
-session_list_user()
-{
-	echo "NX> 127 Sessions list of user '$1'"
-	echo
-	echo "Display Username        Remote IP       Session ID"
-	echo "------- --------------- --------------- --------------------------------"
-	for i in $NX_SESS_DIR/running/*
-	do
-		[ -f $i ] || break
-		if egrep -q "^userName=$1$" $i
-		then
-			CMDLINE=$(session_get_cmdline $i)
-			echo -e "$(getparam display)\t$(getparam userName)\t$(getparam foreignAddress)\t$(getparam sessionId)"
-		fi
-	done
-}
-
-session_history()
-{
-	userName=$1
-	sessionId=$2
-	echo "NX> 127 Session list:"
-	echo
-	echo "Display Username        Remote IP       Session ID                       Date                Status"
-	echo "------- --------------- --------------- -------------------------------- ------------------- -----------"
-	for j in $(ls --time-style +%s -la "$NX_SESS_DIR"/{closed,failed,running} | awk '/sessionId/ { print $6 " " $7 }' | sort -n | cut -d" " -f2)
-	do
-		if [ -n "$sessionId" ]
-		then
-			[ "$j" = "sessionId{$sessionId}" ] || continue
-		fi
-		i="$NX_SESS_DIR"/*/"$j"
-		[ -f $i ] || break
-		CMDLINE=$(session_get_cmdline $i)
-		if [ -n "$userName" ]
-		then
-			[ "$userName" = "$(getparam userName)" ] || continue
-		fi
-		echo -e "$(getparam display)\t$(getparam userName)\t$(getparam foreignAddress)\t$(getparam sessionId)\t$(ls --time-style="+%F %X" -l $i | awk '/sessionId/ { print $6 " " $7 }')\t$(getparam status)"
-	done
-}
-
-# remove all sessions older than $SESSION_HISTORY seconds in failed/closed.
-
-session_cleanup()
-{
-	[ "$SESSION_HISTORY" -gt "-1" ] || return
-	let SESSION_HISTORY_MINUTES=$SESSION_HISTORY/60
-	find $NX_SESS_DIR/closed/ $NX_SESS_DIR/failed/ -type f -mmin +"$SESSION_HISTORY_MINUTES" -exec rm -f '{}' ';'
-}
-
-session_list_all()
-{
-	echo "NX> 127 Sessions list:"
-	echo
-	echo "Display Username        Remote IP       Session ID"
-	echo "------- --------------- --------------- --------------------------------"
-	for i in $NX_SESS_DIR/running/*
-	do
-		[ -f $i ] || break
-		CMDLINE=$(session_get_cmdline $i)
-		echo -e "$(getparam display)\t$(getparam userName)\t$(getparam foreignAddress)\t$(getparam sessionId)"
-	done
-}
-
-
-# session_add <session_id> <options>
-
-session_add()
-{
-	id=$1
-	shift
-	echo "$@" | tr '&' '\n' > $NX_SESS_DIR/running/sessionId'{'$id'}'
-}
-
-# session_change <session_id> <parameter> <new_value>
-
-session_change()
-{
-	[ -f $NX_SESS_DIR/running/sessionId'{'$1'}' ] && perl -pi -e "s/$2=.*/$2=$3/" $NX_SESS_DIR/running/sessionId'{'$1'}'
-}
-
-# session_id <new status>
-
-session_status()
-{
-	session_change "$1" "status" "$2"
-}
-
-# session_close <session_id> <end-time>
-
-session_close()
-{
-	perl -pi -e "s/startTime=\(.*\)/startTime=\1\nendTime=$(date +%s)/" $NX_SESS_DIR/running/sessionId'{'$1'}'
-	session_status $1 "Finished"
-	[ "$SESSION_HISTORY" = "0" ] && rm -f $NX_SESS_DIR/running/sessionId'{'$1'}'
-	[ "$SESSION_HISTORY" = "0" ] || mv -f $NX_SESS_DIR/running/sessionId'{'$1'}' $NX_SESS_DIR/closed/sessionId'{'$1'}'
-}
-
-session_fail()
-{
-	perl -pi -e "s/startTime=\(.*\)/startTime=\1\nendTime=$(date +%s)/" $NX_SESS_DIR/running/sessionId'{'$1'}'
-	session_status $1 "Failed"
-	[ "$SESSION_HISTORY" = "0" ] && rm -f $NX_SESS_DIR/running/sessionId'{'$1'}'
-	[ "$SESSION_HISTORY" = "0" ] || mv -f $NX_SESS_DIR/running/sessionId'{'$1'}' $NX_SESS_DIR/failed/sessionId'{'$1'}'
-}
-
-session_suspend()
-{
-	session_status $1 "Suspended"
-}
-
-#
-# end of library
-#
-
-
-#
-# Main nxserver <-> nxclient communication module
-#
-
-if [ $USER = "nxuser" -o "$USER" = "nx" ]
-then
-	
-log()
-{
-	[ "$NX_LOGGING" = "1" -a -w "$NX_LOGFILE" ] && echo "$@" >> "$NX_LOGFILE"
-}
-
-log_tee()
-{
-	[ "$NX_LOGGING" = "1" -a -w "$NX_LOGFILE" ] && exec tee -a "$NX_LOGFILE"
-	[ "$NX_LOGGING" = "1" -a -w "$NX_LOGFILE" ] || exec cat -
-}
-
-echo_x()
-{
-	log "$@"
-	echo "$@"
-}
-
-# Forward the connection to the commercial NoMachine server
-server_forward_nomachine()
-{
-	set -- "${RECORD_CMD[@]}"
-	
-	# setup the FIFOs
-	SERVER_IN=~/server.in.$$
-	SERVER_OUT=~/server.out.$$
-	rm -f $SERVER_IN $SERVER_OUT
-	mkfifo $SERVER_IN $SERVER_OUT
-	exec 3<>$SERVER_IN
-	exec 4<>$SERVER_OUT
-	
-	$NOMACHINE_SERVER <&3 >&4 &
-	NX_PID=$!
-	
-	while true
-	do
-		read -n7 opcode <&4
-		line=""
-		case "$opcode" in
-			"NX> 105")
-				echo $1 >&3
-				shift
-			;;
-			"NX> 101")
-				echo $USER >&3
-				read line <&4
-				break
-			;;
-			*)
-				read line <&4
-			;;
-		esac
-	done
-	log "done."
-	cat <&4 &
-	CAT_PID=$!
-	cat - >&3
-	rm -f $SERVER_IN $SERVER_OUT
-	kill $CAT_PID
-	kill $NX_PID
-	exit 0
-}
-
-# Start!
-log "-- NX SERVER START: $@"
-
-if [ "$ENABLE_SERVER_FORWARD" = "1" -a -n "$SERVER_FORWARD_HOST" ]
-then
-	log "Forwarding connection to $SERVER_FORWARD_HOST with secret key $SERVER_FORWARD_KEY."
-	ssh -i "$SERVER_FORWARD_KEY" "nx@$SERVER_FORWARD_HOST:$SERVER_FORWARD_PORT"
-	exit 0
-fi
-
-# forward the connection to commercial NoMachine server?
-if [ "$ENABLE_NOMACHINE_FORWARD_PORT" = "1" -a "$NOMACHINE_FORWARD_PORT" = "$(echo $SSH_CLIENT | cut -d' ' -f3)" -a -n "$NOMACHINE_SERVER" ]
-then
-	log "Info: Detected SSH destination port $NOMACHINE_FORWARD_PORT. Forwarding connection to commercial NoMachine server."
-	exec $NOMACHINE_SERVER
-	log "Error: Forwarding to NoMachine Server $NOMACHINE_SERVER failed. Using FreeNX server instead."
-fi
-
-echo_x "HELLO NXSERVER - Version $NX_VERSION $NX_LICENSE"
-
-[ "$ENABLE_NOMACHINE_FORWARD_USER" = "1" ] && RECORD_CMD=()
-
-# Login stage
-while true
-do
-	echo_x -n "NX> 105 "
-	read CMD
-	# FIXME?
-	[ "$CMD" = "" ] && CMD="quit"
-	echo_x "$CMD"
-	
-	# record $CMD in RECORD_CMD array
-	[ "$ENABLE_NOMACHINE_FORWARD_USER" = "1" ] && RECORD_CMD=( "${RECORD_CMD[@]}" "$CMD" )
-	
-	case "$CMD" in 
-		quit|QUIT)
-			echo_x "Quit"
-			echo_x "NX> 999 Bye"
-			exit 0
-		;;
-		exit|EXIT)
-			echo_x "Exit"
-			echo_x "NX> 999 Bye"
-			exit 0
-		;;
-		bye|BYE)
-			echo_x "Bye"
-			echo_x "NX> 999 Bye"
-			exit 0
-		;;
-		hello*|HELLO*)
-			PROTO=$(echo $CMD | sed 's/.*Version \(.*\)/\1/g')
-			echo_x "NX> 134 Accepted protocol: $PROTO"
-			if [ "$PROTO" = "1.3.0" -o "$PROTO" = "1.3.2" ]
-			then
-				[ "$ENABLE_AUTORECONNECT_BEFORE_140" = "1" ] && ENABLE_AUTORECONNECT="1"
-			fi
-		;;
-		set*|SET)
-			if [ "$CMD" = "set auth_mode password" -o "$CMD" = "SET AUTH_MODE PASSWORD" ]
-			then
-				echo_x "Set auth_mode: password"
-			else
-				echo_x "NX> 500 ERROR: unknown auth mode ''"
-			fi
-		;;
-		login|LOGIN)
-			LOGIN_SUCCESS="0"
-			
-			echo_x -n "NX> 101 User: "
-			read USER
-			echo_x $USER
-			
-			# forward the connection to commercial NoMachine server?
-			if [ "$ENABLE_NOMACHINE_FORWARD_USER" = "1" -a -n "$NOMACHINE_SERVER" ]
-			then
-				case "$USER" in
-					freenx.*)
-						log "Not forwarding connection. FreeNX user found."
-						USER=${USER##freenx.}
-					;;
-					*)
-						log -n "Forwarding connection to NoMachine server..."
-						server_forward_nomachine
-						log "failed."
-					;;
-				esac
-			fi
-			
-			echo_x -n "NX> 102 Password: "
-			read -s PASS
-			echo_x ""
-			log -n "Auth method: "
-
-			if [ "$ENABLE_FAKE_AUTHENTICATION" = "1" ]
-			then
-				LOGIN_SUCCESS="1"
-				LOGIN_METHOD="FAKE"
-			fi
-			
-			# PASSDB based auth
-			if [ "$ENABLE_PASSDB_AUTHENTICATION" = "1" -a "$LOGIN_SUCCESS" = "0" ]
-			then
-				log -n "passdb "
-				if [ $(passdb_get_crypt_pass "$PASS") = $(passdb_get_pass "$USER") ]
-				then
-					LOGIN_SUCCESS="1"
-					LOGIN_METHOD="PASSDB"
-				fi
-			fi
-			
-			# SSH based auth
-			if [ "$ENABLE_SSH_AUTHENTICATION" = "1" -a "$LOGIN_SUCCESS" = "0" ]
-			then
-				log -n "ssh "
-				echo "$PASS" | $PATH_BIN/nxnode-login -- ssh "$USER" "$SSHD_PORT" "$PATH_BIN/nxnode" --check > /dev/null 2>/dev/null
-				if [ $? -eq 0 ]
-				then
-					LOGIN_SUCCESS="1"
-					LOGIN_METHOD="SSH"
-				fi
-			fi
-			
-			# SU based auth
-			if [ "$ENABLE_SU_AUTHENTICATION" = "1" -a "$LOGIN_SUCCESS" = "0" ]
-			then
-				log -n "su "
-				echo "$PASS" | $PATH_BIN/nxnode-login -- su "$USER" "" "$PATH_BIN/nxnode" --check > /dev/null 2>/dev/null
-				if [ $? -eq 0 ]
-				then
-					LOGIN_SUCCESS="1"
-					LOGIN_METHOD="SU"
-				fi
-			fi
-			log ""
-			
-			# Check if user in passdb
-			if [ "$ENABLE_USER_DB" = "1" ]
-			then
-				log "userdb check"
-				passdb_user_exists "$USER" || LOGIN_SUCCESS="0"
-			fi
-
-			if [ "$LOGIN_SUCCESS" = "1" ]
-			then
-				# Reread the config files (so that $USER.node.conf get sourced)
-				. $(PATH=$(cd $(dirname $0) && pwd):$PATH which nxloadconfig) --userconf
-
-if [ "$USER" = "nxuser" ]
-then
-	export NX_SESS_DIR="$HOME/.nx/db/"
-	export NX_LOGFILE="$HOME/.nx/temp/nxserver.log"
-	mkdir -p $NX_SESS_DIR/{closed,running,failed}
-	ENABLE_FAKE_AUTHENTICATION="1"
-fi
-
-
-				echo_x "NX> 103 Welcome to: $SERVER_NAME user: $USER"
-				break
-			else
-				echo_x "NX> 404 ERROR: wrong password or login"
-				echo_x "NX> 999 Bye"
-				exit 1
-			fi
-		;;
-	esac
-done
-
-# remove old session infos from history
-session_cleanup
-
-#
-# call it with: server_get_params $CMD # no ""!
-#
-
-server_get_params()
-{
-	SERVER_PARAMS=$(echo "$@" | sed "s/^$1/\"/g; s/\" --/\&/g; s/\"//g")
-	if [ "$SERVER_PARAMS" = "" ]
-	then
-		echo_x -n "NX> 106 Parameters: "
-		read SERVER_PARAMS2
-		SERVER_PARAMS=$(echo $SERVER_PARAMS2 | sed 's/%2B/+/g')
-		echo_x
-	fi
-}
-
-nxnode_start()
-{
-	:
-	#CMD="$1"
-	#shift
-	#echo "$@" | $PATH_BIN/nxnode "$CMD"
-}
-
-#NX> 1002 Commit
-#NX> 1006 Session status: running
-
-server_nxnode_start()
-{
-	CMD="$1"
-	USER="$2"
-	shift
-	shift
-	# Use nxnode-login?
-	if [ "$LOGIN_METHOD" = "SSH" ]
-	then
-	    echo "$PASS" | $PATH_BIN/nxnode-login -- ssh "$USER" "$SSHD_PORT" "$PATH_BIN/nxnode" "$CMD" "$@" 2>&1 | log_tee
-	elif [ "$LOGIN_METHOD" = "SU" ]
-	then
-	    echo "$PASS" | $PATH_BIN/nxnode-login -- su "$USER" "" "$PATH_BIN/nxnode" "$CMD" "$@" 2>&1 | log_tee
-	elif [ "$LOGIN_METHOD" = "FAKE" ]
-	then
-	    echo "$@" | $PATH_BIN/nxnode "$CMD" 2>&1 | log_tee
-	else 
-	    echo "$@" | ssh -l "$USER" 127.0.0.1 -p $SSHD_PORT -x -2 -i $NX_ETC_DIR/users.id_dsa -o 'PubkeyAuthentication yes' -o 'RSAAuthentication yes' -o 'RhostsAuthentication no' -o 'PasswordAuthentication no' -o 'RhostsRSAAuthentication no' -o 'StrictHostKeyChecking no' $PATH_BIN/nxnode "$CMD" | log_tee
-	fi
-}
-
-server_add_usession()
-{
-	[ "$ENABLE_USESSION" = "1" ] || return
-	
-	$COMMAND_SESSREG -l ":$SESS_DISPLAY" -h "$USERIP" -a $USER 2>/dev/null
-}
-
-server_remove_usession()
-{
-	[ "$ENABLE_USESSION" = "1" ] || return
-	$COMMAND_SESSREG -l ":$SESS_DISPLAY" -h "$USERIP" -d $USER 2>/dev/null
-}
-
-server_nxnode_start_wait()
-{
-	server_add_usession
-	
-	STOP_SEND=""
-	server_nxnode_start "$@" | while read CMD
-	do
-		case "$CMD" in 
-			"NX> 1006"*|"NX> 1005"*|"NX> 1009"*)
-				case "$CMD" in 
-					*running*)
-						rm -f $WAIT
-						session_status $uniqueid "Running"
-					;;
-					*closed*)
-						session_close $uniqueid
-					;;
-					*suspended*)
-						session_suspend $uniqueid
-					;;
-					*terminating*)
-						session_status $uniqueid "Terminating"
-						# we need to stop sending to client as it will have already
-						# closed his side of the channel and this will lead to not 
-						# closed sessions.
-						STOP_SEND="1"
-				esac
-			;;
-			"NX> 1004"*)
-				session_fail $uniqueid
-				# FIXME: Need correct error code.
-				echo_x "NX> 504 Session startup failed."
-			;;
-		esac
-
-		case $CMD in
-			"NX> 718"*)
-				[ -z "$STOP_SEND" ] && echo $CMD >&2
-				#echo "NX> 1006 Session status: running" 1>&2
-				#echo "NX> 1001 Bye." 1>&2
-
-			;;
-			"NX> "*)
-				[ -z "$STOP_SEND" ] && echo $CMD
-			;;
-		esac
-	done
-	
-	server_remove_usession
-
-	# remove lock file
-	[ -e "/tmp/.nX$SESS_DISPLAY-lock" ] && rm -f /tmp/.nX$SESS_DISPLAY-lock
-}
-
-server_check_session_count()
-{
-	session_count_user "$USER"
-	
-	if [ "$SESSION_COUNT" -ge "$SESSION_LIMIT" ]
-	then
-		echo_x "NX> 599 Reached the maximum number of concurrent sessions on this server."
-		echo_x "NX> 500 ERROR: Last operation failed."
-		return 1
-	fi
-	
-	if [ "$SESSION_COUNT_USER" -ge "$SESSION_USER_LIMIT" ]
-	then
-		echo_x "NX> 599 Server capacity: reached for user: $USER"
-		echo_x "NX> 500 ERROR: Last operation failed."
-		return 1
-	fi
-
-	return 0
-}
-
-server_startrestore_session()
-{
-	ACTION="$1"
-	
-	server_get_params $CMD
-	PARAMS=$SERVER_PARAMS
-	CMDLINE=$PARAMS
-	echo_x
-	
-	# If we can't get the userip and SSHD_CHECK_IP is set to 1
-	# we bail out.
-	if [ -z "$SSH_CLIENT" ]
-	then 
-		if [ "$SSHD_CHECK_IP" = "1" ]
-		then
-			echo "NX> 504 Session startup failed. (Missing SSH_CLIENT environment variable)"
-			return 1
-		else
-			log "WARNING: Failed to determine the client IP."
-			log "WARNING: The SSH_CLIENT variable was not provided by SSHD."
-			log "WARNING: Please set SSHD_CHECK_IP=1 if you want to refuse the connection."
-		fi
-	fi
-
-	# check if there is a suspended session, which we could resume
-	if [ "$ENABLE_AUTORECONNECT" = "1" -a "$ACTION" = "start" ]
-	then
-		restore=$(session_get_user_suspended "$USER" "Suspended")
-		if [ -n "$restore" ]
-		then
-			PARAMS="$PARAMS&restore=$restore"
-			CMDLINE=$PARAMS
-			ACTION="resume"
-		fi
-	fi
-
-	USERIP=$(echo $SSH_CLIENT | cut -d" " -f1 | sed 's/::ffff://g')
-	[ -z "$USERIP" ] && USERIP="*"
-	if [ "$ACTION" = "start" ]
-	then
-		server_check_session_count || return 1
-		
-		# start nxnode
-		SESS_DISPLAY=$DISPLAY_BASE
-		let SESS_DISPLAY_LIMIT=$DISPLAY_BASE+$DISPLAY_LIMIT
-	
-		# stupid but working algo ...
-			
-		# TODO: need to check for _all_ offset and ports :-/
-			
-		while true
-		do
-			while [ -e /tmp/.X$SESS_DISPLAY-lock -o -e "/tmp/.nX$SESS_DISPLAY-lock" ]
-			do
-				let SESS_DISPLAY=$SESS_DISPLAY+1
-			done
-
-			SESS_LOCKFILE=$(mktemp "/tmp/.nX$SESS_DISPLAY-lock.XXXXXXXXX")
-			# ln is an atomic operation
-			ln "$SESS_LOCKFILE" "/tmp/.nX$SESS_DISPLAY-lock" 2>/dev/null && break
-		done
-		
-		if [ "$SESS_DISPLAY" -gt "$SESS_DISPLAY_LIMIT" ]
-		then
-			# fixme we need the correct error code
-			echo_x "NX> 504 Error: Display limit exceeded. Please remove some files from /tmp/.X*-lock."
-			return
-		fi
-
-		rm -f "$SESS_LOCKFILE"
-	
-		uniqueid=$(echo $[$RANDOM*$RANDOM] | md5sum | cut -d" " -f1 | tr "[a-z]" "[A-Z]")
-		FULL_PARAMS="user=$USER&userip=$USERIP&uniqueid=$uniqueid&display=$SESS_DISPLAY&$PARAMS"
-		log "$FULL_PARAMS"
-
-		# now update the session listing
-		CMDLINE="a=b&$FULL_PARAMS"
-		session_add $uniqueid "sessionName=$(getparam session)&display=$(getparam display)&status=Running&startTime=$(date +%s)&foreignAddress=$(getparam userip)&type=$(getparam type)&sessionId=$uniqueid&creationTime=$(date +%s)&userName=$USER&serverPid=$SERVER_PID&screeninfo=$(getparam screeninfo)&geometry=$(getparam geometry)"
-		export ENCRYPTION=$(getparam encryption)
-	else
-		uniqueid=$(getparam restore)
-		[ -z "$uniqueid" ] && uniqueid=$(getparam id) # 1.4.0-5 compatibility
-		export ENCRYPTION=$(getparam encryption)
-		session_change "$uniqueid" "foreignAddress" "$USERIP"
-
-		CMDLINE=$(session_get "$uniqueid")
-		FULL_PARAMS="user=$USER&userip=$(getparam foreignAddress)&uniqueid=$uniqueid&display=$(getparam display)$PARAMS"
-		SESS_DISPLAY=$(getparam display)
-	fi
-
-	# now start the node
-	export WAIT=$(mktemp /tmp/nxserver_wait.XXXXXXXXX)
-	touch $WAIT
-	(sleep 10; rm -f $WAIT) &
-	server_nxnode_start_wait --"$ACTION"session $USER "$FULL_PARAMS" &
-	SERVER_PID=$!
-	disown $SERVER_PID
-	while [ -f "$WAIT" ]
-	do
-		sleep 1
-	done
-}
-
-# Session stage
-while true
-do
-	echo_x -n "NX> 105 "
-	unset CMD
-	read CMD 2>/dev/null
-	# FIXME?
-	[ "$CMD" = "" ] && CMD="quit"
-	echo_x "$CMD"
-	case "$CMD" in 
-		quit|QUIT)
-			echo_x "Quit"
-			echo_x "NX> 999 Bye"
-			exit 0
-		;;
-		exit|EXIT)
-			echo_x "Exit"
-			echo_x "NX> 999 Bye"
-			exit 0
-		;;
-		bye|BYE)
-			echo_x "Bye"
-			echo_x "NX> 999 Bye"
-			if [ "$ENCRYPTION" = "1" ] 
-			then 
-				let PROXY_DISPLAY=$SESS_DISPLAY+4000
-				$COMMAND_NETCAT 127.0.0.1 $PROXY_DISPLAY
-				exit 0
-			else
-				echo_x "NX> 1001 Bye."
-			fi
-		;;
-		startsession*)
-			server_startrestore_session "start"
-		;;
-		list*)
-			server_get_params $CMD
-			PARAMS=$SERVER_PARAMS
-			CMDLINE=$PARAMS
-			
-			# FIXME: To NX-Node!
-
-			status=$(getparam status)
-
-			if [ "$status" = "Suspended" ]
-			then
-				session_list_user_suspended "$USER" "Suspended" "$(getparam screeninfo)" "$(getparam type)" | log_tee
-			elif [ "$status" = "Suspended,Running" ] # since 1.4.0-5
-			then
-				# disabled due to problems with 1.4.0-5 client
-				session_list_user_suspended "$USER" 'Suspended$|^status=Running$' "$(getparam geometry)" "$(getparam type)" | log_tee
-				#session_list_user_suspended "$USER" 'Suspended' "$(getparam geometry)" "$(getparam type)" | log_tee
-			else
-				session_list_user "$USER" | log_tee
-			fi
-		;;
-		suspend*)
-			server_get_params $CMD
-			PARAMS=$SERVER_PARAMS
-			CMDLINE=$PARAMS
-			if session_find_id_user "$(getparam sessionid)" "$USER"
-			then
-				# FIXME: Check for success/error
-				server_nxnode_start --suspend "$USER" "$PARAMS"
-				session_suspend $(getparam sessionid)
-			fi
-		;;
-		terminate*)
-			server_get_params $CMD
-			PARAMS=$SERVER_PARAMS
-			CMDLINE=$PARAMS
-			if session_find_id_user "$(getparam sessionid)" "$USER"
-			then
-				# FIXME: Check for success/error
-				server_nxnode_start --terminate "$USER" "$PARAMS"
-				session_close $(getparam sessionid)
-			fi
-		;;
-		restoresession*)
-			server_startrestore_session "resume"
-		;;
-		passwd)
-			echo "NX> 113 Changing password of user '$USER'"
-			echo -n "NX> 102 Current password:"
-			read -s PASS
-			ENC_PASS=$(passdb_get_crypt_pass "$PASS")
-			REAL_PASS=$(passdb_get_pass "$USER")
-			echo_x
-			if [ "$ENC_PASS" = "$REAL_PASS" ]
-			then
-				echo_x -n "NX> 102 Password:"
-				read -s NEW_PASS1
-				
-				if [ ${#NEW_PASS1} -lt 5 ]
-				then
-					echo_x "NX> 500 ERROR: incorrect password format, password must be long at least five characters"
-					continue
-				fi
-
-				echo_x
-				echo_x -n "NX> 102 Confirm password:"
-				read -s NEW_PASS1
-				echo_x
-				if [ "$NEW_PASS1" = "$NEW_PASS2" ]
-				then
-					ENC_PASS=$(passdb_get_crypt_pass "$NEW_PASS1")
-					passdb_chpass "$USER" "$ENC_PASS"
-					echo_x "NX> 114 Password of user '$USER' changed"
-				else
-					echo_x "NX> 537 ERROR: passwords do not match"
-				fi
-			else
-				echo_x "NX> 500 ERROR: current password doesn't match"
-			fi
-		;;
-		addmount*)
-			server_get_params $CMD
-			PARAMS=$SERVER_PARAMS
-			server_nxnode_start --smbmount "$USER" "$PARAMS" >/dev/null 2>&1
-			echo_x "NX> 719 SMB filesystem: running"
-		;;
-		addprintercups*)
-			server_get_params $CMD
-			PARAMS=$SERVER_PARAMS
-			server_nxnode_start --addprintercups "$USER" "$PARAMS" >/dev/null 2>&1
-		;;
-		*)
-			# disabled for 1.4.0-5 snapshot client
-			#echo_x "NX> 503 Error: undefined command: '$CMD'"
-		;;
-	esac
-done
-
-fi
-
-#
-# End of Main nxserver <--> nxclient communication module
-#
-
-################### PACKAGE cmd.bm ############################
-
-#
-# library functions for nxserver-commandline cmds
-#
-
-# Policy: All functions and variables need to start with CMD_ / cmd_
-
-# Needed global vars: $NX_VERSION, $NX_LICENSE, $NX_ETC_DIR, $PATH_BIN, $NX_HOME_DIR, $SSH_AUTHORIZED_KEYS
-
-# Needed package: passdb
-
-cmd_usage()
-{
-	echo "NXSERVER - Version $NX_VERSION $NX_LICENSE"
-	echo "Usage: nxserver <option>" 1>&2
-
-	if [ "$1" = "root" ]
-	then
-		echo "--adduser <user>: Add a new user" 1>&2
-		echo "--passwd <user>: Change password of <user>" 1>&2
-		echo "--deluser <user>: Remove a user from nx" 1>&2
-		echo "--listuser: List enabled users" 1>&2
-		echo "" 1>&2
-		echo "--start: Start the nx server" 1>&2
-		echo "--stop: Stop the nx server" 1>&2
-		echo "--status: Show status of nx server" 1>&2
-		echo "--restart: Restart the nx server and terminate all running sessions" 1>&2
-		echo "" 1>&2
-		echo "--list [ user | sessionid ]: List running sessions of user or sessionid " 1>&2
-		echo "--history [ user | sessionid | clear ]: Show history [ of user | sessionid ] or clear the history" 1>&2
-		echo "--terminate <user | :display | sessionid>: Terminate the session pointed to by" 1>&2
-		echo "       sessionid or display, or all sessions of the specified user." 1>&2
-		echo "--suspend <user | :display | sessionid>: Suspend the session pointed to by" 1>&2
-		echo "       sessionid or display, or all sessions of the specified user." 1>&2
-		echo "" 1>&2
-		echo "--broadcast <message>: Send a message to all users" 1>&2
-		echo "--send <user | :display | sessionid> <message>: Send a message to the specified user or sessionid" 1>&2
-	else
-		echo "--passwd: Change password" 1>&2
-	fi
-	exit 1
-}
-
-
-cmd_abort()
-{
-	echo "NX> 500" "$@" 1>&2
-	echo "NX> 999 Bye" 1>&2
-	exit 1
-}
-
-cmd_user_passwd()
-{
-	echo "NX> 100 NXSERVER - Version $NX_VERSION $NX_LICENSE"
-	echo "Sorry: Password changing for user is _not_ implemented, yet."
-	echo "Please login to NX-Server to change password"
-	echo "or ask your local system administrator."
-	#echo "NX> 113 Changing password of user '$USER'"
-	#echo "Old password:"
-	#read -s OLDPASS
-	#echo "New password:"
-	#read -s NEWPASS1
-	#echo "Repeat:"
-	#read -s NEWPASS2
-
-}
-
-cmd_passwd()
-{
-	CMD_CHUSER=$2
-	egrep -q "^$CMD_CHUSER:" $NX_ETC_DIR/passwords || cmd_abort "Error: User $CMD_CHUSER not found in database."
-	echo -n "New password: "
-	read -s CMD_NEWPASS
-	echo
-	CMD_ENC_PASS=$(passdb_get_crypt_pass "$CMD_NEWPASS")
-	passdb_chpass "$CMD_CHUSER" "$CMD_ENC_PASS"
-	echo "Password changed."
-}
-
-cmd_adduser()
-{
-	CMD_CHUSER=$2
-	
-	[ ${#CMD_CHUSER} -ge 32 ] && cmd_abort "Error: User $CMD_CHUSER must be shorter than 32 characters."
-	egrep -q "^$CMD_CHUSER:" $NX_ETC_DIR/passwords && cmd_abort "Error: User $CMD_CHUSER already in database."
-	getent passwd | egrep -q "^$CMD_CHUSER:" || cmd_abort "Error: User $CMD_CHUSER not existing on local system. Can't add."
-	passdb_add_user "$CMD_CHUSER"
-}
-
-cmd_deluser()
-{
-	CMD_CHUSER=$2
-	egrep -q "^$CMD_CHUSER:" $NX_ETC_DIR/passwords || cmd_abort "Error: User $CMD_CHUSER not found in database."
-	passdb_remove_user "$CMD_CHUSER"
-}
-
-cmd_listuser()
-{
-	echo "NX> 146 NX users list"
-	echo
-	echo "Username"
-	echo "---------------"
-	echo
-	passdb_list_user
-	echo
-}
-
-cmd_start()
-{
-	
-	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] && cmd_abort "ERROR: Service already running"
-	mv $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS.disabled $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS
-	echo "NX> 122 Service started"
-}
-
-cmd_stop()
-{
-	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] || cmd_abort "Service was already stopped"
-	mv $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS.disabled
-	# TODO: Stop all running sessions
-	echo "NX> 123 Service stopped"
-}
-
-cmd_status()
-{
-	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] && echo "NX> 110 NX Server is running"
-	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] || echo "NX> 110 NX Server is stopped"
-}
-
-cmd_restart()
-{
-	cmd_stop
-	cmd_start
-}
-
-cmd_parse_2_params()
-{
-	if [ ${#1} -eq 32 ]
-	then
-		CMD_APARAMS="sessionid=sessionId{$1}"
-	else
-	if [ "$1" != "" ]
-	then
-		#egrep -q "^$1:" $NX_ETC_DIR/passwords || cmd_abort "Error: User $1 not found in database."
-		CMD_APARAMS="user=$1"
-	fi
-	fi
-	echo $CMD_APARAMS
-
-}
-
-cmd_parse_3_params()
-{
-	if [ ${#1} -eq 32 ]
-	then
-		CMD_APARAMS=$(session_find_id $1)
-		[ -n "$CMD_APARAMS" ] || cmd_abort "Error: Session $1 could not be found."
-	else
-	if [ "${1:0:1}" = ":" ]
-	then
-		CMD_APARAMS=$(session_find_display "${1:1}")
-		[ -n "$CMD_APARAMS" ] || cmd_abort "Error: No running sessions found for display $1."
-	else
-	if [ "$1" != "" ]
-	then
-		#egrep -q "^$1:" $NX_ETC_DIR/passwords || cmd_abort "Error: User $1 not found in database."
-		CMD_APARAMS=$(session_find_user "$1")
-		[ -n "$CMD_APARAMS" ] || cmd_abort "Error: No running sessions found for user $1."
-	else
-		cmd_abort "Error: Not enough parameters."
-	fi
-	fi
-	fi
-	echo $CMD_APARAMS
-}
-
-cmd_list_suspended()
-{
-	CMD_PARAMS=$(cmd_parse_2_params "$2")
-	[ -n "$2" -a -z "$CMD_PARAMS" ] && exit 1
-	case $CMD_PARAMS in
-		user=*)
-			session_list_user_suspended $2 "Suspended"
-		;;
-	esac
-}
-cmd_list()
-{
-	CMD_PARAMS=$(cmd_parse_2_params "$2")
-	[ -n "$2" -a -z "$CMD_PARAMS" ] && exit 1
-	case $CMD_PARAMS in
-		user=*)
-			session_list_user $2
-		;;
-		sessionid=*)
-			session_list $2
-		;;
-		*)
-			session_list_all
-		;;
-	esac
-}
-
-cmd_history_clear()
-{
-	rm -f $NX_SESS_DIR/closed/*
-	rm -f $NX_SESS_DIR/failed/*
-}
-
-cmd_history()
-{
-	if [ "$2" = "clear" ]
-	then
-		cmd_history_clear
-	fi
-	
-	CMD_PARAMS=$(cmd_parse_2_params "$2")
-	user=""
-	sessid=""
-	case $CMD_PARAMS in
-		user=*)
-			user="$2"
-		;;
-		sessionid=*)
-			sessid="$2"
-		;;
-	esac
-
-	session_history "$user" "$sessid"
-}
-
-cmd_terminate()
-{
-	CMD_PARAMS=$(cmd_parse_3_params "$2")
-	[ -z "$CMD_PARAMS" ] && exit 1
-	for i in $CMD_PARAMS;
-	do
-			CMDLINE=$(session_get_cmdline $i)
-			cmd_sessionid=$(getparam sessionId)
-			cmd_user=$(getparam userName)
-			cmd_type=$(getparam type)
-			cmd_status=$(getparam status)
-
-			# is it a "good" session?
-			case "$1" in 
-			--suspend)
-				if [ "$cmd_status" = "Running" ] && stringinstring "unix-" "$cmd_type"
-				then
-					echo "sessionid=$cmd_sessionid" | su - "$cmd_user" -c "$PATH_BIN/nxnode --suspend"
-					session_suspend $cmd_sessionid
-				fi
-				;;
-			--terminate)
-			#if stringinstring "unix-" "$cmd_type"
-			#	then
-					echo "sessionid=$cmd_sessionid" | su - "$cmd_user" -c "$PATH_BIN/nxnode --terminate"
-					session_close $cmd_sessionid
-			#	fi
-
-			;;
-			esac
-	done
-
-}
-
-cmd_send()
-{
-	if [ "$1" = "--broadcast" ]
-	then
-	  CMD_PARAMS=$(session_find_all)
-	  [ -z "$CMD_PARAMS" ] && cmd_abort "Error: No running session could be found."
-	else
-	  CMD_PARAMS=$(cmd_parse_3_params "$2")
-	  [ -z "$CMD_PARAMS" ] && exit 1
-	fi
-	shift
-	shift
-	for i in $CMD_PARAMS;
-	do
-			CMDLINE=$(session_get_cmdline $i)
-			cmd_display=$(getparam display)
-			cmd_user=$(getparam userName)
-			cmd_type=$(getparam type)
-			cmd_status=$(getparam status)
-
-			# is it a "good" session?
-			if [ "$cmd_status" = "Running" ] && stringinstring "unix-" "$cmd_type"
-			then
-				su - "$cmd_user" -c "$PATH_BIN/nxclient --dialog ok --caption \"NX Administrator Message\" --message \"$@\" --noautokill 
--display \":$cmd_display\"" &
-				disown $!
-			fi
-	done
-	#nxnode_start --send "$CMD_PARAMS"
-}
-
-#
-# user mode available functions
-#
-
-if [ $UID -ne 0 ]
-then
-	[ "$1" != "--passwd" ] && cmd_usage
-	cmd_user_passwd
-	exit 0
-fi
-
-#
-# root mode available functions
-#
-
-[ $# -lt 1 ] && cmd_usage "root"
-[ "$1" = "--help" ] && cmd_usage "root"
-
-if [ "$1" = "--version" ]
-then
-  echo "NXSERVER - Version $NX_VERSION $NX_LICENSE"
-  exit 0
-fi
-
-CMD=$1
-
-echo "NX> 100 NXSERVER - Version $NX_VERSION $NX_LICENSE"
-
-case $CMD in
-	# 
-	# User functions ...
-	# 
-	--passwd)
-		cmd_passwd "$@"
-	;;
-	--adduser|--useradd)
-		cmd_adduser "$@"
-	;;
-	--deluser|--userdel)
-		cmd_deluser "$@"
-	;;
-	--listuser|--userlist)
-		cmd_listuser
-	;;
-	--start)
-		cmd_start
-	;;
-	--stop)
-		cmd_stop
-	;;
-	--status)
-		cmd_status
-	;;
-	--restart)
-		cmd_restart
-	;;
-	--list)
-		cmd_list "$@"
-	;;
-	--list-suspended)
-		cmd_list_suspended "$@"
-	;;
-	--history)
-		cmd_history "$@"
-	;;
-	--terminate|--suspend)
-		cmd_terminate "$@"
-	;;
-	--send|--broadcast)
-		cmd_send "$@"
-	;;
-	*)
-		cmd_abort "Error: Function $CMD not implemented yet."
-esac
-echo "NX> 999 Bye"



From fabianx at berlios.de  Sun Jul  3 16:39:49 2005
From: fabianx at berlios.de (Fabian Franz at BerliOS)
Date: Sun, 3 Jul 2005 16:39:49 +0200
Subject: [Freenx-cvs] r64 - freenx-server
Message-ID: <200507031439.j63EdnB2005691@sheep.berlios.de>

Author: fabianx
Date: 2005-07-03 16:39:45 +0200 (Sun, 03 Jul 2005)
New Revision: 64

Removed:
   freenx-server/CVS/
Log:
Deleted superflous CVS directory.




From fabianx at berlios.de  Sun Jul  3 17:44:34 2005
From: fabianx at berlios.de (Fabian Franz at BerliOS)
Date: Sun, 3 Jul 2005 17:44:34 +0200
Subject: [Freenx-cvs] r65 - freenx-server
Message-ID: <200507031544.j63FiYXm009030@sheep.berlios.de>

Author: fabianx
Date: 2005-07-03 17:44:33 +0200 (Sun, 03 Jul 2005)
New Revision: 65

Modified:
   freenx-server/ChangeLog
   freenx-server/node.conf.sample
   freenx-server/nxloadconfig
   freenx-server/nxnode-login
   freenx-server/nxserver
Log:
Initial support for loadbalancing.


Modified: freenx-server/ChangeLog
===================================================================
--- freenx-server/ChangeLog	2005-07-03 14:39:45 UTC (rev 64)
+++ freenx-server/ChangeLog	2005-07-03 15:44:33 UTC (rev 65)
@@ -1,3 +1,6 @@
+XX.07.2005 FreeNX 0.5.0
+	* Initial support for load-balancing.
+
 24.06.2005 FreeNX 0.4.1 "LinuxTag Edition"
 	* Fixed a small security problem giving access to session database.
 	* Added support for 1.5.0 OSS components. (especially rootless mode)

Modified: freenx-server/node.conf.sample
===================================================================
--- freenx-server/node.conf.sample	2005-07-03 14:39:45 UTC (rev 64)
+++ freenx-server/node.conf.sample	2005-07-03 15:44:33 UTC (rev 65)
@@ -190,7 +190,22 @@
 #ENABLE_NOMACHINE_FORWARD_PORT="0"
 #NOMACHINE_FORWARD_PORT="22"
 
+# To do loadbalancing setup some hosts in SERVER_LOADBALANCING and
+# make:
+#
+#   - either sure that all incoming connections are sent to the master
+#     server by using forwarding directives on the "slave" servers.
+#
+#   - or share the session database space via NFS between the servers.
+#
+# By setting ENABLE_LOADBALANCE="1" you can let users choose their
+# preferred host, while being forwarded to another server. Of course
+# this is just a preference. The loadbalancing algorithm can completely
+# choose to ignore the users choice.
 
+#SERVER_LOADBALANCING=""
+#ENABLE_LOADBALANCE_PREFERENCE="0"
+
 #########################################################################
 # Services directives
 #########################################################################

Modified: freenx-server/nxloadconfig
===================================================================
--- freenx-server/nxloadconfig	2005-07-03 14:39:45 UTC (rev 64)
+++ freenx-server/nxloadconfig	2005-07-03 15:44:33 UTC (rev 65)
@@ -124,6 +124,8 @@
 ENABLE_NOMACHINE_FORWARD_PORT="0"
 NOMACHINE_FORWARD_PORT="22"
 
+SERVER_LOADBALANCING=""
+ENABLE_LOADBALANCE_PREFERENCE="0"
 
 # Services directives
 

Modified: freenx-server/nxnode-login
===================================================================
--- freenx-server/nxnode-login	2005-07-03 14:39:45 UTC (rev 64)
+++ freenx-server/nxnode-login	2005-07-03 15:44:33 UTC (rev 65)
@@ -16,6 +16,8 @@
 set tosend [lindex $argv 5]
 set command_ssh "ssh"
 catch {set command_ssh $env(COMMAND_SSH)}
+set host "127.0.0.1"
+catch {set host $env(NODE_HOSTNAME)}
 
 expect_user -re "(.*)\n" 
 set password $expect_out(1,string)
@@ -23,7 +25,7 @@
 set stty_init "raw icrnl"
 
 if { "$auth_method"=="ssh" } { 
-	set pid [spawn -noecho $command_ssh -2 -x -l "$user" "127.0.0.1" -o "NumberOfPasswordPrompts 1" -p "$port" "$executable $command" ]
+	set pid [spawn -noecho $command_ssh -2 -x -l "$user" "$host" -o "NumberOfPasswordPrompts 1" -p "$port" "$executable $command" ]
 } elseif { "$auth_method"=="su" } {
 	set pid [spawn -noecho su - "$user" -c "$executable $command" ]
 } else {

Modified: freenx-server/nxserver
===================================================================
--- freenx-server/nxserver	2005-07-03 14:39:45 UTC (rev 64)
+++ freenx-server/nxserver	2005-07-03 15:44:33 UTC (rev 65)
@@ -468,15 +468,18 @@
 }
 
 # Start!
-log 3 "-- NX SERVER START: $@"
+log 3 "-- NX SERVER START: $@ - ORIG_COMMAND=$SSH_ORIGINAL_COMMAND"
 
 if [ "$ENABLE_SERVER_FORWARD" = "1" -a -n "$SERVER_FORWARD_HOST" ]
 then
 	log 3 "Info: Forwarding connection to $SERVER_FORWARD_HOST with secret key $SERVER_FORWARD_KEY."
-	$COMMAND_SSH -i "$SERVER_FORWARD_KEY" "nx@$SERVER_FORWARD_HOST:$SERVER_FORWARD_PORT"
+	$COMMAND_SSH -i "$SERVER_FORWARD_KEY" "-p$SERVER_FORWARD_PORT" "nx@$SERVER_FORWARD_HOST" "host=$SERVER_NAME"
 	exit 0
 fi
 
+# Get the hostname out of SSH_ORIGINAL_COMMAND
+PREFERRED_HOST=$(echo $SSH_ORIGINAL_COMMAND | tr '&' '\n' | grep "^host=" | cut -d'=' -f2)
+
 # forward the connection to commercial NoMachine server?
 if [ "$ENABLE_NOMACHINE_FORWARD_PORT" = "1" -a "$NOMACHINE_FORWARD_PORT" = "$(echo $SSH_CLIENT | cut -d' ' -f3)" -a -n "$NOMACHINE_SERVER" ]
 then
@@ -656,6 +659,20 @@
 	USER="$2"
 	shift
 	shift
+
+	# Find NODE_HOSTNAME
+	
+	NODE_HOSTNAME=""
+	CMDLINE="$@"
+	uniqueid=$(getparam uniqueid)
+	[ -z "$uniqueid" ] && uniqueid=$(getparam sessionid)
+	[ -z "$uniqueid" ] && uniqueid=$(getparam session_id)
+	CMDLINE=$(session_get "$uniqueid")
+	
+	NODE_HOSTNAME="$(getparam host)"
+	[ -z "$NODE_HOSTNAME" ] && NODE_HOSTNAME="127.0.0.1"
+	export NODE_HOSTNAME
+	
 	# Use nxnode-login?
 	if [ "$LOGIN_METHOD" = "SSH" ]
 	then
@@ -665,7 +682,7 @@
 	then
 	    echo "$PASS" | $PATH_BIN/nxnode-login -- su "$USER" "" "$PATH_BIN/nxnode" "$CMD" "$@" 2>&1 | log_tee
 	else 
-	    echo "$@" | $COMMAND_SSH -l "$USER" 127.0.0.1 -p $SSHD_PORT -x -2 -i $NX_ETC_DIR/users.id_dsa -o 'PubkeyAuthentication yes' -o 'RSAAuthentication yes' -o 'RhostsAuthentication no' -o 'PasswordAuthentication no' -o 'RhostsRSAAuthentication no' -o 'StrictHostKeyChecking no' $PATH_BIN/nxnode "$CMD" | log_tee
+	    echo "$@" | $COMMAND_SSH -l "$USER" "$NODE_HOSTNAME" -p $SSHD_PORT -x -2 -i $NX_ETC_DIR/users.id_dsa -o 'PubkeyAuthentication yes' -o 'RSAAuthentication yes' -o 'RhostsAuthentication no' -o 'PasswordAuthentication no' -o 'RhostsRSAAuthentication no' -o 'StrictHostKeyChecking no' $PATH_BIN/nxnode "$CMD" | log_tee
 	fi
 }
 
@@ -757,6 +774,36 @@
 	return 0
 }
 
+# FIXME: Add round-robin algorithm
+server_loadbalance_random_rr()
+{
+	# Pick one based on "round-robin random"
+	SERVER_HOSTS=( $SERVER_LOADBALANCING )
+	SERVER_NR_OF_HOSTS=${#SERVER_HOSTS[@]}
+	let SERVER_NR=(RANDOM % SERVER_NR_OF_HOSTS)
+	SERVER_HOST_RR=${SERVER_HOSTS[$SERVER_NR]}
+	echo $SERVER_HOST_RR
+}
+
+server_loadbalance()
+{
+	SERVER_HOST="127.0.0.1"
+	if [ -n "$SERVER_LOADBALANCING" ]
+	then
+		# FIXME: Add preference host
+		SERVER_HOST=""
+		if [ -n "$PREFERRED_HOST" -a "$ENABLE_LOADBALANCE_PREFERENCE" = "1" ]
+		then
+			stringinstring " $PREFERRED_HOST " " $SERVER_LOADBALANCING " && SERVER_HOST="$PREFERRED_HOST"
+		fi
+		# Fallback if still empty
+		[ -z "$SERVER_HOST" ] && SERVER_HOST=$(server_loadbalance_random_rr)
+		[ -n "$SERVER_HOST" ] && log 5 "Info: Load-Balancing (if possible) to $SERVER_HOST ..."
+		[ -z "$SERVER_HOST" ] && SERVER_HOST="127.0.0.1"
+	fi
+	echo "$SERVER_HOST"
+}	
+
 server_startrestore_session()
 {
 	ACTION="$1"
@@ -840,9 +887,13 @@
 		FULL_PARAMS="user=$USER&userip=$USERIP&uniqueid=$uniqueid&display=$SESS_DISPLAY&$PARAMS"
 		log 6 "$FULL_PARAMS"
 
+		# Possibly do loadbalancing
+		
+		SERVER_HOST=$(server_loadbalance)
+
 		# now update the session listing
 		CMDLINE="a=b&$FULL_PARAMS"
-		session_add $uniqueid "sessionName=$(getparam session)&display=$(getparam display)&status=Running&startTime=$(date +%s)&foreignAddress=$(getparam userip)&type=$(getparam type)&sessionId=$uniqueid&creationTime=$(date +%s)&userName=$USER&serverPid=$SERVER_PID&screeninfo=$(getparam screeninfo)&geometry=$(getparam geometry)"
+		session_add $uniqueid "sessionName=$(getparam session)&display=$(getparam display)&status=Running&startTime=$(date +%s)&foreignAddress=$(getparam userip)&type=$(getparam type)&sessionId=$uniqueid&creationTime=$(date +%s)&userName=$USER&serverPid=$SERVER_PID&screeninfo=$(getparam screeninfo)&geometry=$(getparam geometry)&host=$SERVER_HOST"
 	else
 		uniqueid=$(getparam restore)
 		[ -z "$uniqueid" ] && uniqueid=$(getparam id) # 1.4.0-5 compatibility
@@ -851,6 +902,8 @@
 		CMDLINE=$(session_get "$uniqueid")
 		FULL_PARAMS="user=$USER&userip=$(getparam foreignAddress)&uniqueid=$uniqueid&display=$(getparam display)$PARAMS"
 		SESS_DISPLAY=$(getparam display)
+		SERVER_HOST=$(getparam host)
+		[ -z "$SERVER_HOST" ] && SERVER_HOST="127.0.0.1"
 	fi
 
 	# now start the node
@@ -892,7 +945,7 @@
 			if [ "$ENCRYPTION" = "1" ] 
 			then 
 				let PROXY_DISPLAY=$SESS_DISPLAY+4000
-				$COMMAND_NETCAT 127.0.0.1 $PROXY_DISPLAY
+				$COMMAND_NETCAT $SERVER_HOST $PROXY_DISPLAY
 				exit 0
 			else
 				echo_x "NX> 1001 Bye."



From fabianx at berlios.de  Sun Jul  3 18:08:13 2005
From: fabianx at berlios.de (Fabian Franz at BerliOS)
Date: Sun, 3 Jul 2005 18:08:13 +0200
Subject: [Freenx-cvs] r66 - / nx-utils nx-utils/nxfish
Message-ID: <200507031608.j63G8D6X010241@sheep.berlios.de>

Author: fabianx
Date: 2005-07-03 18:08:12 +0200 (Sun, 03 Jul 2005)
New Revision: 66

Added:
   nx-utils/
   nx-utils/nxfish/
   nx-utils/nxfish/Makefile.am
   nx-utils/nxfish/fish.cpp
   nx-utils/nxfish/nx-fishsrv.pl
   nx-utils/nxfish/nxfish.protocol
Log:
Initial import into SVN.


Added: nx-utils/nxfish/Makefile.am
===================================================================
--- nx-utils/nxfish/Makefile.am	2005-07-03 15:44:33 UTC (rev 65)
+++ nx-utils/nxfish/Makefile.am	2005-07-03 16:08:12 UTC (rev 66)
@@ -0,0 +1,33 @@
+kde_module_LTLIBRARIES = kio_nxfish.la
+
+INCLUDES = $(all_includes)
+AM_LDFLAGS = $(all_libraries) $(KDE_RPATH)
+
+kio_nxfish_la_SOURCES = fish.cpp
+kio_nxfish_la_LIBADD = $(LIB_KSYCOCA) #$(LIBUTIL) 
+kio_nxfish_la_LDFLAGS = $(all_libraries) -module $(KDE_PLUGIN)
+noinst_HEADERS = fishcode.h fish.h
+
+EXTRA_DIST = AUTHORS COPYING ChangeLog INSTALL README TODO FAQ fish.pl
+
+DISTCLEANFILES = fishcode.h
+
+kdelnk_DATA = nxfish.protocol
+kdelnkdir = $(kde_servicesdir)
+
+METASOURCES = AUTO
+
+fish.lo: fishcode.h
+
+fishcode.h: fish.pl
+	SUM=`$(MD5SUM) $(srcdir)/fish.pl | cut -d ' ' $(MD5SUM_CUT)`; \
+	echo '#define CHECKSUM "'$$SUM'"' > $@; \
+	echo 'static const char *fishCode(' >> $@; \
+	sed -e 's/\\/\\\\/g;s/"/\\"/g;s/^[ 	]*/"/;/^"# /d;s/[ 	]*$$/\\n"/;/^"\\n"$$/d;s/{CHECKSUM}/'$$SUM'/;' $(srcdir)/fish.pl >> $@; \
+	echo ');' >> $@;
+
+messages:
+	$(XGETTEXT) *.cpp -o $(podir)/kio_fish.pot
+
+
+

Added: nx-utils/nxfish/fish.cpp
===================================================================
--- nx-utils/nxfish/fish.cpp	2005-07-03 15:44:33 UTC (rev 65)
+++ nx-utils/nxfish/fish.cpp	2005-07-03 16:08:12 UTC (rev 66)
@@ -0,0 +1,1618 @@
+/***************************************************************************
+                          fish.cpp  -  a FISH kioslave
+                             -------------------
+    begin                : Thu Oct  4 17:09:14 CEST 2001
+    copyright            : (C) 2001-2003 by J?rg Walter
+    email                : jwalt-kde at garni.ch
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation, version 2 of the License                *
+ *                                                                         *
+ ***************************************************************************/
+
+/*
+  This code contains fragments and ideas from the ftp kioslave
+  done by David Faure <faure at kde.org>.
+
+  Structure is a bit complicated, since I made the mistake to use
+  KProcess... now there is a lightweight homebrew async IO system
+  inside, but if signals/slots become available for ioslaves, switching
+  back to KProcess should be easy.
+*/
+
+#include "config.h"
+
+#include <qcstring.h>
+#include <qfile.h>
+#include <qsocket.h>
+#include <qdatetime.h>
+#include <qbitarray.h>
+#include <qregexp.h>
+
+#include <stdlib.h>
+#ifdef HAVE_PTY_H
+#include <pty.h>
+#endif
+#ifdef HAVE_TERMIOS_H
+#include <termios.h>
+#endif
+#include <math.h>
+#include <unistd.h>
+#include <signal.h>
+#include <sys/wait.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#include <sys/types.h>
+#ifdef HAVE_STROPTS
+#include <stropts.h>
+#endif
+#ifdef HAVE_SYS_IOCTL_H
+#include <sys/ioctl.h>
+#endif
+#ifdef HAVE_LIBUTIL_H
+#include <libutil.h>
+#endif
+#ifdef HAVE_UTIL_H
+#include <util.h>
+#endif
+
+#include <kdebug.h>
+#include <kmessagebox.h>
+#include <kinstance.h>
+#include <kglobal.h>
+#include <kstandarddirs.h>
+#include <klocale.h>
+#include <kremoteencoding.h>
+#include <kurl.h>
+#include <ksock.h>
+#include <stdarg.h>
+#include <time.h>
+#include <sys/stat.h>
+#include <kmimetype.h>
+#include <kmimemagic.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <errno.h>
+#include <sys/resource.h>
+
+#include "fish.h"
+#include "fishcode.h"
+
+#ifndef NDEBUG 
+#define myDebug(x) kdDebug(7127) << __LINE__ << ": " x
+#define connected() do{myDebug( << "_______ emitting connected()" << endl); connected();}while(0)
+#define dataReq() do{myDebug( << "_______ emitting dataReq()" << endl); dataReq();}while(0)
+#define needSubURLData() do{myDebug( << "_______ emitting needSubURLData()" << endl); needSubURLData();}while(0)
+#define slaveStatus(x,y) do{myDebug( << "_______ emitting slaveStatus(" << x << ", " << y << ")" << endl); slaveStatus(x,y);}while(0)
+#define statEntry(x) do{myDebug( << "_______ emitting statEntry("<<x.size()<<")" << endl); statEntry(x);}while(0)
+#define listEntries(x) do{myDebug( << "_______ emitting listEntries(...)" << endl); listEntries(x);}while(0)
+#define canResume(x) do{myDebug( << "_______ emitting canResume("<<(int)x<<")" << endl); canResume(x);}while(0)
+#define totalSize(x) do{myDebug( << "_______ emitting totalSize("<<(int)x<<")" << endl); totalSize(x);}while(0)
+#define processedSize(x) do{myDebug( << "_______ emitting processedSize("<<x<<")" << endl); processedSize(x);}while(0)
+#define speed(x) do{myDebug( << "_______ emitting speed("<<(int)x<<")" << endl); speed(x);}while(0)
+#define redirection(x) do{myDebug( << "_______ emitting redirection("<<x<<")" << endl); redirection(x);}while(0)
+#define errorPage() do{myDebug( << "_______ emitting errorPage()" << endl); errorPage();}while(0)
+#define sendmimeType(x) do{myDebug( << "_______ emitting mimeType("<<x<<")" << endl); mimeType(x);}while(0)
+#define warning(x) do{myDebug( << "_______ emitting warning("<<x<<")" << endl); warning(x);}while(0)
+#define infoMessage(x) do{myDebug( << "_______ emitting infoMessage("<<x<<")" << endl); infoMessage(x);}while(0)
+#else
+#define myDebug(x)
+#define sendmimeType(x) mimeType(x)
+#endif
+
+static char *sshPath = NULL;
+static char *suPath = NULL;
+// disabled: currently not needed. Didn't work reliably.
+// static int isOpenSSH = 0;
+
+#define E(x) ((const char*)remoteEncoding()->encode(x).data())
+
+using namespace KIO;
+extern "C" {
+
+static void ripper(int)
+{
+    while (waitpid(-1,0,WNOHANG) > 0) {
+      // do nothing, go on
+    }
+}
+
+int KDE_EXPORT kdemain( int argc, char **argv )
+{
+    KLocale::setMainCatalogue("kio_fish");
+    KInstance instance("fish");
+
+    myDebug( << "*** Starting fish " << endl);
+    if (argc != 4) {
+        myDebug( << "Usage: fish  protocol domain-socket1 domain-socket2" << endl);
+        exit(-1);
+    }
+
+    struct sigaction act;
+    memset(&act,0,sizeof(act));
+    act.sa_handler = ripper;
+    act.sa_flags = 0
+#ifdef SA_NOCLDSTOP
+    | SA_NOCLDSTOP
+#endif
+#ifdef SA_RESTART
+    | SA_RESTART
+#endif
+    ;
+    sigaction(SIGCHLD,&act,NULL);
+
+    fishProtocol slave(argv[2], argv[3]);
+    slave.dispatchLoop();
+
+    myDebug( << "*** fish Done" << endl);
+    return 0;
+}
+
+}
+
+const struct fishProtocol::fish_info fishProtocol::fishInfo[] = {
+    { ("FISH"), 0,
+      ("echo; /bin/sh -c start_fish_server > /dev/null 2>/dev/null; perl .fishsrv.pl " CHECKSUM " 2>/dev/null; perl -e '$|=1; print \"### 100 transfer fish server\\n\"; while(<STDIN>) { last if /^__END__/; $code.=$_; } exit(eval($code));' 2>/dev/null;"),
+      1 },
+    { ("VER 0.0.3 copy append lscount lslinks lsmime exec stat"), 0,
+      ("echo 'VER 0.0.3 copy append lscount lslinks lsmime exec stat'"),
+      1 },
+    { ("PWD"), 0,
+      ("pwd"),
+      1 },
+    { ("LIST"), 1,
+      ("echo `ls -Lla %1 2> /dev/null | grep '^[-dsplcb]' | wc -l`; ls -Lla %1 2>/dev/null | grep '^[-dspl]' | ( while read -r p x u g s m d y n; do file -b -i $n 2>/dev/null | sed -e '\\,^[^/]*$,d;s/^/M/;s,/.*[ \t],/,'; FILE=%1; if [ -e %1\"/$n\" ]; then FILE=%1\"/$n\"; fi; if [ -L \"$FILE\" ]; then echo \":$n\"; ls -lad \"$FILE\" | sed -e 's/.* -> /L/'; else echo \":$n\" | sed -e 's/ -> /\\\nL/'; fi; echo \"P$p $u.$g\nS$s\nd$m $d $y\n\"; done; );"
+                "ls -Lla %1 2>/dev/null | grep '^[cb]' | ( while read -r p x u g a i m d y n; do echo \"P$p $u.$g\nE$a$i\nd$m $d $y\n:$n\n\"; done; )"),
+      0 },
+    { ("STAT"), 1,
+      ("echo `ls -dLla %1 2> /dev/null | grep '^[-dsplcb]' | wc -l`; ls -dLla %1 2>/dev/null | grep '^[-dspl]' | ( while read -r p x u g s m d y n; do file -b -i $n 2>/dev/null | sed -e '\\,^[^/]*$,d;s/^/M/;s,/.*[ \t],/,'; FILE=%1; if [ -e %1\"/$n\" ]; then FILE=%1\"/$n\"; fi; if [ -L \"$FILE\" ]; then echo \":$n\"; ls -lad \"$FILE\" | sed -e 's/.* -> /L/'; else echo \":$n\" | sed -e 's/ -> /\\\nL/'; fi; echo \"P$p $u.$g\nS$s\nd$m $d $y\n\"; done; );"
+                "ls -dLla %1 2>/dev/null | grep '^[cb]' | ( while read -r p x u g a i m d y n; do echo \"P$p $u.$g\nE$a$i\nd$m $d $y\n:$n\n\"; done; )"),
+      0 },
+    { ("RETR"), 1,
+      ("ls -l %1 2>&1 | ( read -r a b c d x e; echo $x ) 2>&1; echo '### 001'; cat %1"),
+      1 },
+    { ("STOR"), 2,
+      ("> %2; echo '### 001'; ( [ \"`expr %1 / 4096`\" -gt 0 ] && dd bs=4096 count=`expr %1 / 4096` 2>/dev/null;"
+              "[ \"`expr %1 % 4096`\" -gt 0 ] && dd bs=`expr %1 % 4096` count=1 2>/dev/null; ) | ( cat > %2 || echo Error $?; cat > /dev/null )"),
+      0 },
+    { ("CWD"), 1,
+      ("cd %1"),
+      0 },
+    { ("CHMOD"), 2,
+      ("chmod %1 %2"),
+      0 },
+    { ("DELE"), 1,
+      ("rm -f %1"),
+      0 },
+    { ("MKD"), 1,
+      ("mkdir %1"),
+      0 },
+    { ("RMD"), 1,
+      ("rmdir %1"),
+      0 },
+    { ("RENAME"), 2,
+      ("mv -f %1 %2"),
+      0 },
+    { ("LINK"), 2,
+      ("ln -f %1 %2"),
+      0 },
+    { ("SYMLINK"), 2,
+      ("ln -sf %1 %2"),
+      0 },
+    { ("CHOWN"), 2,
+      ("chown %1 %2"),
+      0 },
+    { ("CHGRP"), 2,
+      ("chgrp %1 %2"),
+      0 },
+    { ("READ"), 3,
+      ("echo '### 100';cat %3 /dev/zero | ( [ \"`expr %1 / 4096`\" -gt 0 ] && dd bs=4096 count=`expr %1 / 4096` >/dev/null;"
+              "[ \"`expr %1 % 4096`\" -gt 0 ] && dd bs=`expr %1 % 4096` count=1 >/dev/null;"
+              "dd bs=%2 count=1; ) 2>/dev/null;"),
+      0 },
+    // Yes, this is "ibs=1", since dd "count" is input blocks.
+    // On network connections, read() may not fill the buffer
+    // completely (no more data immediately available), but dd
+    // does ignore that fact by design. Sorry, writes are slow.
+    // OTOH, WRITE is not used by the current ioslave methods,
+    // we use APPEND.
+    { ("WRITE"), 3,
+      (">> %3; echo '### 001'; ( [ %2 -gt 0 ] && dd ibs=1 obs=%2 count=%2 2>/dev/null ) | "
+              "( dd ibs=32768 obs=%1 seek=1 of=%3 2>/dev/null || echo Error $?; cat >/dev/null; )"),
+      0 },
+    { ("COPY"), 2,
+      ("if [ -L %1 ]; then if cp -pdf %1 %2 2>/dev/null; then :; else LINK=\"`readlink %1`\"; ln -sf $LINK %2; fi; else cp -pf %1 %2; fi"),
+      0 },
+    { ("APPEND"), 2,
+      (">> %2; echo '### 001'; ( [ %1 -gt 0 ] && dd ibs=1 obs=%1 count=%1 2> /dev/null; ) | ( cat >> %2 || echo Error $?; cat >/dev/null; )"),
+      0 },
+    { ("EXEC"), 2,
+      ("UMASK=`umask`; umask 077; touch %2; umask $UMASK; eval %1 < /dev/null > %2 2>&1; echo \"###RESULT: $?\" >> %2"),
+      0 }
+};
+
+fishProtocol::fishProtocol(const QCString &pool_socket, const QCString &app_socket)
+  : SlaveBase("fish", pool_socket, app_socket), mimeBuffer(1024),
+    mimeTypeSent(false)
+{
+    myDebug( << "fishProtocol::fishProtocol()" << endl);
+    if (sshPath == NULL) {
+        // disabled: currently not needed. Didn't work reliably.
+        // isOpenSSH = !system("ssh -V 2>&1 | grep OpenSSH > /dev/null");
+        sshPath = strdup(QFile::encodeName(KStandardDirs::findExe("nxfish")));
+    }
+    if (suPath == NULL) {
+        suPath = strdup(QFile::encodeName(KStandardDirs::findExe("su")));
+    }
+    childPid = 0;
+    connectionPort = 0;
+    isLoggedIn = false;
+    writeReady = true;
+    isRunning = false;
+    firstLogin = true;
+    errorCount = 0;
+    rawRead = 0;
+    rawWrite = -1;
+    recvLen = -1;
+    sendLen = -1;
+    setMultipleAuthCaching( true );
+    connectionAuth.keepPassword = true;
+    connectionAuth.url.setProtocol("fish");
+    epoch.setTime_t(0, Qt::UTC);
+    outBufPos = -1;
+    outBuf = NULL;
+    outBufLen = 0;
+    typeAtom.m_uds = UDS_FILE_TYPE;
+    typeAtom.m_long = 0;
+    mimeAtom.m_uds = UDS_MIME_TYPE;
+    mimeAtom.m_long = 0;
+    mimeAtom.m_str = QString::null;
+    
+    hasAppend = false;
+    
+    isStat = false; // FIXME: just a workaround for konq deficiencies
+    redirectUser = ""; // FIXME: just a workaround for konq deficiencies
+    redirectPass = ""; // FIXME: just a workaround for konq deficiencies
+    fishCodeLen = strlen(fishCode);
+}
+/* ---------------------------------------------------------------------------------- */
+
+
+fishProtocol::~fishProtocol()
+{
+    myDebug( << "fishProtocol::~fishProtocol()" << endl);
+    shutdownConnection(true);
+}
+
+/* --------------------------------------------------------------------------- */
+
+/**
+Connects to a server and logs us in via SSH. Then starts FISH protocol.
+*/
+void fishProtocol::openConnection() {
+    if (childPid) return;
+
+    /*if (connectionHost.isEmpty())
+    {
+       error( KIO::ERR_UNKNOWN_HOST, QString::null );
+       return;
+    }*/
+
+    infoMessage(i18n("Connecting..."));
+
+    myDebug( << "connecting to: " << connectionUser << "@" << connectionHost << ":" << connectionPort << endl);
+    sendCommand(FISH_FISH);
+    sendCommand(FISH_VER);
+    if (connectionStart()) {
+        error(ERR_COULD_NOT_CONNECT,connectionHost);
+        shutdownConnection();
+        return;
+    };
+    myDebug( << "subprocess is running" << endl);
+}
+
+static int open_pty_pair(int fd[2])
+{
+#if defined(HAVE_TERMIOS_H) && defined(HAVE_GRANTPT) && !defined(HAVE_OPENPTY)
+/** with kind regards to The GNU C Library
+Reference Manual for Version 2.2.x of the GNU C Library */
+    int master, slave;
+    char *name;
+    struct ::termios ti;
+    memset(&ti,0,sizeof(ti));
+
+    ti.c_cflag = CLOCAL|CREAD|CS8;
+    ti.c_cc[VMIN] = 1;
+
+#ifdef HAVE_GETPT
+    master = getpt();
+#else
+    master = open("/dev/ptmx", O_RDWR);
+#endif
+    if (master < 0) return 0;
+
+    if (grantpt(master) < 0 || unlockpt(master) < 0) goto close_master;
+
+    name = ptsname(master);
+    if (name == NULL) goto close_master;
+
+    slave = open(name, O_RDWR);
+    if (slave == -1) goto close_master;
+
+#if (defined(HAVE_ISASTREAM) || defined(isastream)) && defined(I_PUSH)
+    if (isastream(slave) &&
+        (ioctl(slave, I_PUSH, "ptem") < 0 ||
+         ioctl(slave, I_PUSH, "ldterm") < 0))
+            goto close_slave;
+#endif
+
+    tcsetattr(slave, TCSANOW, &ti);
+    fd[0] = master;
+    fd[1] = slave;
+    return 0;
+
+#if (defined(HAVE_ISASTREAM) || defined(isastream)) && defined(I_PUSH)
+close_slave:
+#endif
+    close(slave);
+
+close_master:
+    close(master);
+    return -1;
+#else
+#ifdef HAVE_OPENPTY
+    struct ::termios ti;
+    memset(&ti,0,sizeof(ti));
+
+    ti.c_cflag = CLOCAL|CREAD|CS8;
+    ti.c_cc[VMIN] = 1;
+
+    return openpty(fd,fd+1,NULL,&ti,NULL);
+#else
+#ifdef __GNUC__
+#warning "No tty support available. Password dialog won't work."
+#endif
+    return socketpair(PF_UNIX,SOCK_STREAM,0,fd);
+#endif
+#endif
+}
+/**
+creates the subprocess
+*/
+bool fishProtocol::connectionStart() {
+    int fd[2];
+    int rc, flags;
+    thisFn = QString::null;
+
+    rc = open_pty_pair(fd);
+    if (rc == -1) {
+        myDebug( << "socketpair failed, error: " << strerror(errno) << endl);
+        return true;
+    }
+
+    if (!requestNetwork()) return true;
+    myDebug( << "Exec: " << (local ? suPath : sshPath) << " Port: " << connectionPort << " User: " << connectionUser << endl);
+    childPid = fork();
+    if (childPid == -1) {
+        myDebug( << "fork failed, error: " << strerror(errno) << endl);
+        close(fd[0]);
+        close(fd[1]);
+        childPid = 0;
+        dropNetwork();
+        return true;
+    }
+    if (childPid == 0) {
+        // taken from konsole, see TEPty.C for details
+        // note: if we're running on socket pairs,
+        // this will fail, but thats what we expect
+
+        for (int sig = 1; sig < NSIG; sig++) signal(sig,SIG_DFL);
+
+        struct rlimit rlp;
+        getrlimit(RLIMIT_NOFILE, &rlp);
+        for (int i = 0; i < (int)rlp.rlim_cur; i++)
+            if (i != fd[1]) close(i);
+
+        dup2(fd[1],0);
+        dup2(fd[1],1);
+        dup2(fd[1],2);
+        if (fd[1] > 2) close(fd[1]);
+
+        setsid();
+
+#if defined(TIOCSCTTY)
+        ioctl(0, TIOCSCTTY, 0);
+#endif
+
+        int pgrp = getpid();
+#if defined( _AIX) || defined( __hpux)
+        tcsetpgrp(0, pgrp);
+#else
+        ioctl(0, TIOCSPGRP, (char *)&pgrp);
+#endif
+
+        const char *dev = ttyname(0);
+        setpgid(0,0);
+        if (dev) close(open(dev, O_WRONLY, 0));
+        setpgid(0,0);
+
+        if (local) {
+            execl(suPath, "su", "-", connectionUser.latin1(), "-c", "cd ~;echo FISH:;exec /bin/sh -c \"if env true 2>/dev/null; then env PS1= PS2= TZ=UTC LANG=C LC_ALL=C LOCALE=C /bin/sh; else PS1= PS2= TZ=UTC LANG=C LC_ALL=C LOCALE=C /bin/sh; fi\"", (void *)0);
+        } else {
+            #define common_args "-l", connectionUser.latin1(), "-x", "-e", "none", \
+                "-q", connectionHost.latin1(), \
+                "echo FISH:;exec /bin/sh -c \"if env true 2>/dev/null; then env PS1= PS2= TZ=UTC LANG=C LC_ALL=C LOCALE=C /bin/sh; else PS1= PS2= TZ=UTC LANG=C LC_ALL=C LOCALE=C /bin/sh; fi\"", (void *)0
+            // disabled: leave compression up to the client.
+            // (isOpenSSH?"-C":"+C"),
+
+            if (connectionPort)
+                execl(sshPath, "ssh", "-p", QString::number(connectionPort).latin1(), common_args);
+            else
+                execl(sshPath, "ssh", common_args);
+            #undef common_args
+        }
+        myDebug( << "could not exec! " << strerror(errno) << endl);
+        ::exit(-1);
+    }
+    close(fd[1]);
+    rc = fcntl(fd[0],F_GETFL,&flags);
+    rc = fcntl(fd[0],F_SETFL,flags|O_NONBLOCK);
+    childFd = fd[0];
+
+    fd_set rfds, wfds;
+    FD_ZERO(&rfds);
+    FD_ZERO(&wfds);
+    char buf[32768];
+    int offset = 0;
+    while (!isLoggedIn) {
+        FD_SET(childFd,&rfds);
+        FD_ZERO(&wfds);
+        if (outBufPos >= 0) FD_SET(childFd,&wfds);
+        rc = select(childFd+1, &rfds, &wfds, NULL, NULL);
+        if (rc < 0) {
+            if (errno == EINTR)
+                continue;
+            myDebug( << "select failed, rc: " << rc << ", error: " << strerror(errno) << endl);
+            return true;
+        }
+        if (FD_ISSET(childFd,&wfds) && outBufPos >= 0) {
+            if (outBuf > 0) rc = write(childFd,outBuf+outBufPos,outBufLen-outBufPos);
+            else rc = 0;
+            if (rc >= 0) outBufPos += rc;
+            else {
+                if (errno == EINTR)
+                    continue;
+                myDebug( << "write failed, rc: " << rc << ", error: " << strerror(errno) << endl);
+                outBufPos = -1;
+                //return true;
+            }
+            if (outBufPos >= outBufLen) {
+                outBufPos = -1;
+                outBuf = NULL;
+                outBufLen = 0;
+            }
+        }
+        if (FD_ISSET(childFd,&rfds)) {
+            rc = read(childFd,buf+offset,32768-offset);
+            if (rc > 0) {
+                int noff = establishConnection(buf,rc+offset);
+                if (noff < 0) return false;
+                if (noff > 0) memmove(buf,buf+offset+rc-noff,noff);
+                offset = noff;
+            } else {
+                if (errno == EINTR)
+                    continue;
+                myDebug( << "read failed, rc: " << rc << ", error: " << strerror(errno) << endl);
+                return true;
+            }
+        }
+    }
+    return false;
+}
+
+/**
+writes one chunk of data to stdin of child process
+*/
+void fishProtocol::writeChild(const char *buf, int len) {
+    if (outBufPos >= 0 && outBuf) {
+        QString debug;
+        debug.setLatin1(outBuf,outBufLen);
+        if (len > 0) myDebug( << "write request while old one is pending, throwing away input (" << outBufLen << "," << outBufPos << "," << debug.left(10) << "...)" << endl);
+        return;
+    }
+    outBuf = buf;
+    outBufPos = 0;
+    outBufLen = len;
+}
+
+/**
+manages initial communication setup including password queries
+*/
+int fishProtocol::establishConnection(char *buffer, int len) {
+    QString buf;
+    buf.setLatin1(buffer,len);
+    int pos;
+    // Strip trailing whitespace
+    while (buf.length() && (buf[buf.length()-1] == ' '))
+       buf.truncate(buf.length()-1);
+
+    myDebug( << "establishing: got " << buf << endl);
+    while (childPid && ((pos = buf.find('\n')) >= 0 ||
+            buf.endsWith(":") || buf.endsWith("?"))) {
+        pos++;
+        QString str = buf.left(pos);
+        buf = buf.mid(pos);
+        if (str == "\n")
+            continue;
+        if (str == "FISH:\n") {
+            thisFn = QString::null;
+            infoMessage(i18n("Initiating protocol..."));
+            if (!connectionAuth.password.isEmpty()) {
+                connectionAuth.password = connectionAuth.password.left(connectionAuth.password.length()-1);
+                cacheAuthentication(connectionAuth);
+            }
+            isLoggedIn = true;
+            return 0;
+        } else if (!str.isEmpty()) {
+            thisFn += str;
+        } else if (buf.endsWith(":")) {
+            if (!redirectUser.isEmpty() && connectionUser != redirectUser) {
+                KURL dest = url;
+                dest.setUser(redirectUser);
+                dest.setPass(redirectPass);
+                redirection(dest);
+                commandList.clear();
+                commandCodes.clear();
+                finished();
+                redirectUser = "";
+                redirectPass = "";
+                return -1;
+            } else if (!connectionPassword.isEmpty()) {
+                myDebug( << "sending cpass" << endl);
+                connectionAuth.password = connectionPassword+"\n";
+                connectionPassword = QString::null;
+                // su does not like receiving a password directly after sending
+                // the password prompt so we wait a while.
+                if (local)
+                    sleep(1);
+                writeChild(connectionAuth.password.latin1(),connectionAuth.password.length());
+            } else {
+                myDebug( << "sending mpass" << endl);
+                connectionAuth.prompt = thisFn+buf;
+                if (local)
+                    connectionAuth.caption = i18n("Local Login");
+                else
+                    connectionAuth.caption = i18n("SSH Authorization");
+                if ((!firstLogin || !checkCachedAuthentication(connectionAuth)) && !openPassDlg(connectionAuth)) {
+                    error(ERR_USER_CANCELED,connectionHost);
+                    shutdownConnection();
+                    return -1;
+                }
+                firstLogin = false;
+                connectionAuth.password += "\n";
+                if (connectionAuth.username != connectionUser) {
+                    KURL dest = url;
+                    dest.setUser(connectionAuth.username);
+                    dest.setPass(connectionAuth.password);
+                    redirection(dest);
+                    if (isStat) { // FIXME: just a workaround for konq deficiencies
+                        redirectUser = connectionAuth.username;
+                        redirectPass = connectionAuth.password;
+                    }
+                    commandList.clear();
+                    commandCodes.clear();
+                    finished();
+                    return -1;
+                }
+                myDebug( << "sending pass" << endl);
+                if (local)
+                    sleep(1);
+                writeChild(connectionAuth.password.latin1(),connectionAuth.password.length());
+            }
+            thisFn = QString::null;
+            return 0;
+        } else if (buf.endsWith("?")) {
+            int rc = messageBox(QuestionYesNo,thisFn+buf);
+            if (rc == KMessageBox::Yes) {
+                writeChild("yes\n",4);
+            } else {
+                writeChild("no\n",3);
+            }
+            thisFn = QString::null;
+            return 0;
+        } else {
+            myDebug( << "unmatched case in initial handling! shouldn't happen!" << endl);
+          }
+    }
+    return buf.length();
+}
+/**
+sets connection information for subsequent commands
+*/
+void fishProtocol::setHost(const QString & host, int port, const QString & u, const QString & pass){
+    QString user(u);
+
+    //local = (host == "localhost" && port == 0);
+
+    local = 0;
+
+    if (port <= 0) port = 0;
+    if (user.isEmpty()) user = getenv("LOGNAME");
+
+    if (host == connectionHost && port == connectionPort && user == connectionUser)
+        return;
+    myDebug( << "setHost " << u << "@" << host << endl);
+
+    if (childPid) shutdownConnection();
+
+    connectionHost = host;
+    connectionAuth.url.setHost(host);
+
+    connectionUser = user;
+    connectionAuth.username = user;
+    connectionAuth.url.setUser(user);
+
+    connectionPort = port;
+    connectionPassword = pass;
+    firstLogin = true;
+}
+
+/**
+Forced close of the connection
+
+This function gets called from the application side of the universe,
+it shouldn't send any response.
+ */
+void fishProtocol::closeConnection(){
+    myDebug( << "closeConnection()" << endl);
+    shutdownConnection(true);
+}
+
+/**
+Closes the connection
+ */
+void fishProtocol::shutdownConnection(bool forced){
+    if (childPid) {
+        kill(childPid,SIGTERM); // We may not have permission...
+        childPid = 0;
+        close(childFd); // ...in which case this should do the trick
+        childFd = -1;
+        if (!forced)
+        {
+           dropNetwork();
+           infoMessage(i18n("Disconnected."));
+        }
+    }
+    outBufPos = -1;
+    outBuf = NULL;
+    outBufLen = 0;
+    qlist.clear();
+    commandList.clear();
+    commandCodes.clear();
+    isLoggedIn = false;
+    writeReady = true;
+    isRunning = false;
+    rawRead = 0;
+    rawWrite = -1;
+    recvLen = -1;
+    sendLen = -1;
+}
+/**
+builds each FISH request and sets the error counter
+*/
+bool fishProtocol::sendCommand(fish_command_type cmd, ...) {
+    const fish_info &info = fishInfo[cmd];
+    myDebug( << "queueing: cmd="<< cmd << "['" << info.command << "'](" << info.params <<"), alt=['" << info.alt << "'], lines=" << info.lines << endl);
+
+    va_list list;
+    va_start(list, cmd);
+    QString realCmd = info.command;
+    QString realAlt = info.alt;
+    static QRegExp rx("[][\\\\\n $`#!()*?{}~&<>;'\"%^@|\t]");
+    for (int i = 0; i < info.params; i++) {
+        QString arg(va_arg(list, const char *));
+        int pos = -2;
+        while ((pos = rx.search(arg,pos+2)) >= 0) {
+            arg.replace(pos,0,QString("\\"));
+        }
+        //myDebug( << "arg " << i << ": " << arg << endl);
+        realCmd.append(" ").append(arg);
+        realAlt.replace(QRegExp("%"+QString::number(i+1)),arg);
+    }
+    QString s("#");
+    s.append(realCmd).append("\n ").append(realAlt).append(" 2>&1;echo '### 000'\n");
+    if (realCmd == "FISH")
+        s.prepend(" ");
+    commandList.append(s);
+    commandCodes.append(cmd);
+    return true;
+}
+
+/**
+checks response string for result code, converting 000 and 001 appropriately
+*/
+int fishProtocol::handleResponse(const QString &str){
+    myDebug( << "handling: " << str << endl);
+    if (str.startsWith("### ")) {
+        bool isOk = false;
+        int result = str.mid(4,3).toInt(&isOk);
+        if (!isOk) result = 500;
+        if (result == 0) result = (errorCount != 0?500:200);
+        if (result == 1) result = (errorCount != 0?500:100);
+        myDebug( << "result: " << result << ", errorCount: " << errorCount << endl);
+        return result;
+    } else {
+        errorCount++;
+        return 0;
+    }
+}
+
+int fishProtocol::makeTimeFromLs(const QString &monthStr, const QString &dayStr, const QString &timeyearStr)
+{
+    QDateTime dt;
+    dt.setTime_t(time(0));
+    dt.setTime(QTime());
+    int year = dt.date().year();
+    int month = dt.date().month();
+    int currentMonth = month;
+    int day = dayStr.toInt();
+
+    static const char * const monthNames[12] = {
+          "Jan", "Feb", "Mar", "Apr", "May", "Jun",
+        "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
+    };
+
+    for (int i=0; i < 12; i++) if (monthStr.startsWith(monthNames[i])) {
+        month = i+1;
+        break;
+    }
+
+    int pos = timeyearStr.find(':');
+    if (timeyearStr.length() == 4 && pos == -1) {
+        year = timeyearStr.toInt();
+    } else if (pos == -1) {
+        return 0;
+    } else {
+        if (month > currentMonth + 1) year--;
+        dt.time().setHMS(timeyearStr.left(pos).toInt(),timeyearStr.mid(pos+1).toInt(),0);
+    }
+    dt.date().setYMD(year,month,day);
+
+    return epoch.secsTo(dt);
+}
+
+/**
+parses response from server and acts accordingly
+*/
+void fishProtocol::manageConnection(const QString &l) {
+    QString line(l);
+    int rc = handleResponse(line);
+    UDSAtom atom;
+    QDateTime dt;
+    int pos, pos2, pos3;
+    bool isOk = false;
+    if (!rc) {
+        switch (fishCommand) {
+        case FISH_VER:
+            if (line.startsWith("VER 0.0.3")) {
+                line.append(" ");
+                hasAppend = line.contains(" append ");
+            } else {
+                error(ERR_UNSUPPORTED_PROTOCOL,line);
+                shutdownConnection();
+            }
+            break;
+        case FISH_PWD:
+            url.setPath(line);
+            redirection(url);
+            break;
+        case FISH_LIST:
+            myDebug( << "listReason: " << listReason << endl);
+            /* Fall through */
+        case FISH_STAT:
+            if (line.length() > 0) {
+                switch (line[0].cell()) {
+                case '0':
+                case '1':
+                case '2':
+                case '3':
+                case '4':
+                case '5':
+                case '6':
+                case '7':
+                case '8':
+                case '9':
+                    pos = line.toInt(&isOk);
+                    if (pos > 0 && isOk) errorCount--;
+                    if ((fishCommand == FISH_LIST) && (listReason == LIST))
+                        totalSize(pos);
+                    break;
+
+                case 'P':
+                    errorCount--;
+                    if (line[1] == 'd') {
+                        mimeAtom.m_str = "inode/directory";
+                        typeAtom.m_long = S_IFDIR;
+                    } else {
+                        if (line[1] == '-') {
+                            typeAtom.m_long = S_IFREG;
+                        } else if (line[1] == 'l') {
+                            typeAtom.m_long = S_IFLNK;
+                        } else if (line[1] == 'c') {
+                            typeAtom.m_long = S_IFCHR;
+                        } else if (line[1] == 'b') {
+                            typeAtom.m_long = S_IFBLK;
+                        } else if (line[1] == 's') {
+                            typeAtom.m_long = S_IFSOCK;
+                        } else if (line[1] == 'p') {
+                            typeAtom.m_long = S_IFIFO;
+                        } else {
+                            myDebug( << "unknown file type: " << line[1].cell() << endl);
+                            errorCount++;
+                            break;
+                        }
+                    }
+                    //myDebug( << "file type: " << atom.m_long << endl);
+                    //udsEntry.append(atom);
+
+                    atom.m_uds = UDS_ACCESS;
+                    atom.m_long = 0;
+                    if (line[2] == 'r') atom.m_long |= S_IRUSR;
+                    if (line[3] == 'w') atom.m_long |= S_IWUSR;
+                    if (line[4] == 'x' || line[4] == 's') atom.m_long |= S_IXUSR;
+                    if (line[4] == 'S' || line[4] == 's') atom.m_long |= S_ISUID;
+                    if (line[5] == 'r') atom.m_long |= S_IRGRP;
+                    if (line[6] == 'w') atom.m_long |= S_IWGRP;
+                    if (line[7] == 'x' || line[7] == 's') atom.m_long |= S_IXGRP;
+                    if (line[7] == 'S' || line[7] == 's') atom.m_long |= S_ISGID;
+                    if (line[8] == 'r') atom.m_long |= S_IROTH;
+                    if (line[9] == 'w') atom.m_long |= S_IWOTH;
+                    if (line[10] == 'x' || line[10] == 't') atom.m_long |= S_IXOTH;
+                    if (line[10] == 'T' || line[10] == 't') atom.m_long |= S_ISVTX;
+                    udsEntry.append(atom);
+
+                    atom.m_uds = UDS_USER;
+                    atom.m_long = 0;
+                    pos = line.find('.',12);
+                    if (pos < 0) {
+                        errorCount++;
+                        break;
+                    }
+                    atom.m_str = line.mid(12,pos-12);
+                    udsEntry.append(atom);
+
+                    atom.m_uds = UDS_GROUP;
+                    atom.m_long = 0;
+                    atom.m_str = line.mid(pos+1);
+                    udsEntry.append(atom);
+                    break;
+
+                case 'd':
+                    atom.m_uds = UDS_MODIFICATION_TIME;
+                    pos = line.find(' ');
+                    pos2 = line.find(' ',pos+1);
+                    if (pos < 0 || pos2 < 0) break;
+                    errorCount--;
+                    atom.m_long = makeTimeFromLs(line.mid(1,pos-1), line.mid(pos+1,pos2-pos), line.mid(pos2+1));
+                    udsEntry.append(atom);
+                    break;
+
+                case 'D':
+                    atom.m_uds = UDS_MODIFICATION_TIME;
+                    pos = line.find(' ');
+                    pos2 = line.find(' ',pos+1);
+                    pos3 = line.find(' ',pos2+1);
+                    if (pos < 0 || pos2 < 0 || pos3 < 0) break;
+                    dt.setDate(QDate(line.mid(1,pos-1).toInt(),line.mid(pos+1,pos2-pos-1).toInt(),line.mid(pos2+1,pos3-pos2-1).toInt()));
+                    pos = pos3;
+                    pos2 = line.find(' ',pos+1);
+                    pos3 = line.find(' ',pos2+1);
+                    if (pos < 0 || pos2 < 0 || pos3 < 0) break;
+                    dt.setTime(QTime(line.mid(pos+1,pos2-pos-1).toInt(),line.mid(pos2+1,pos3-pos2-1).toInt(),line.mid(pos3+1).toInt()));
+                    errorCount--;
+                    atom.m_long = epoch.secsTo(dt);
+                    udsEntry.append(atom);
+                    break;
+
+                case 'S':
+                    atom.m_uds = UDS_SIZE;
+                    atom.m_long = line.mid(1).toLongLong(&isOk);
+                    if (!isOk) break;
+                    errorCount--;
+                    udsEntry.append(atom);
+                    break;
+
+                case 'E':
+                    errorCount--;
+                    break;
+
+                case ':':
+                    atom.m_uds = UDS_NAME;
+                    atom.m_long = 0;
+                    pos = line.findRev('/');
+                    atom.m_str = thisFn = line.mid(pos < 0?1:pos+1);
+                    if (fishCommand == FISH_LIST)
+                        udsEntry.append(atom);
+                    // By default, the mimetype comes from the extension
+                    // We'll use the file(1) result only as fallback [like the rest of KDE does]
+                    {
+                      KMimeType::Ptr mime = KMimeType::findByURL( KURL("fish://host/" + thisFn) );
+                      if ( mime->name() != KMimeType::defaultMimeType() )
+                          mimeAtom.m_str = mime->name();
+                    }
+                    errorCount--;
+                    break;
+
+                case 'M':
+                    // This is getting ugly. file(1) makes some uneducated
+                    // guesses, so we must try to ignore them (#51274)
+                    if (mimeAtom.m_str.isEmpty() && line.right(8) != "/unknown" &&
+                            (thisFn.find('.') < 0 || (line.left(8) != "Mtext/x-"
+                                                  && line != "Mtext/plain"))) {
+                        mimeAtom.m_str = line.mid(1);
+                        if ( mimeAtom.m_str == "inode/directory" ) // a symlink to a dir is a dir
+                          typeAtom.m_long = S_IFDIR;
+                    }
+                    errorCount--;
+                    break;
+
+                case 'L':
+                    atom.m_uds = UDS_LINK_DEST;
+                    atom.m_long = 0;
+                    atom.m_str = line.mid(1);
+                    udsEntry.append(atom);
+                    if (!typeAtom.m_long) typeAtom.m_long = S_IFLNK;
+                    errorCount--;
+                    break;
+                }
+            } else {
+                if (!mimeAtom.m_str.isNull())
+                    udsEntry.append(mimeAtom);
+                mimeAtom.m_str = QString::null;
+
+                udsEntry.append(typeAtom);
+                typeAtom.m_long = 0;
+
+                if (fishCommand == FISH_STAT)
+                    udsStatEntry = udsEntry;
+                else if (listReason == LIST) {
+                    listEntry(udsEntry, false); //1
+                } else if (listReason == CHECK) checkExist = true; //0
+                errorCount--;
+                udsEntry.clear();
+            }
+            break;
+
+        case FISH_RETR:
+            if (line.length() == 0) {
+                error(ERR_IS_DIRECTORY,url.prettyURL());
+                recvLen = 0;
+                break;
+            }
+            recvLen = line.toInt(&isOk);
+            if (!isOk) {
+                error(ERR_COULD_NOT_READ,url.prettyURL());
+                shutdownConnection();
+                break;
+            }
+            break;
+        default : break;
+        }
+
+    } else if (rc == 100) {
+        switch (fishCommand) {
+        case FISH_FISH:
+            writeChild(fishCode, fishCodeLen);
+            break;
+        case FISH_READ:
+            recvLen = 1024;
+            /* fall through */
+        case FISH_RETR:
+            myDebug( << "reading " << recvLen << endl);
+            if (recvLen == -1) {
+                error(ERR_COULD_NOT_READ,url.prettyURL());
+                shutdownConnection();
+            } else {
+                rawRead = recvLen;
+                t_start = t_last = time(NULL);
+                dataRead = 0;
+                mimeTypeSent = false;
+                if (recvLen == 0)
+                {
+                    mimeType("application/x-zerosize");
+                    mimeTypeSent = true;
+                }
+            }
+            break;
+        case FISH_STOR:
+        case FISH_WRITE:
+        case FISH_APPEND:
+            rawWrite = sendLen;
+            //myDebug( << "sending " << sendLen << endl);
+            writeChild(NULL,0);
+            break;
+        default : break;
+        }
+    } else if (rc/100 != 2) {
+        switch (fishCommand) {
+        case FISH_STOR:
+        case FISH_WRITE:
+        case FISH_APPEND:
+            error(ERR_COULD_NOT_WRITE,url.prettyURL());
+            shutdownConnection();
+            break;
+        case FISH_RETR:
+            error(ERR_COULD_NOT_READ,url.prettyURL());
+            shutdownConnection();
+            break;
+        case FISH_READ:
+            if ( rc == 501 )
+            {
+               mimeType("inode/directory");
+               mimeTypeSent = true;
+               recvLen = 0;
+               finished();
+            }
+            else
+            {
+               error(ERR_COULD_NOT_READ,url.prettyURL());
+               shutdownConnection();
+            }
+            break;
+        case FISH_FISH:
+        case FISH_VER:
+            error(ERR_SLAVE_DEFINED,line);
+            shutdownConnection();
+            break;
+        case FISH_PWD:
+        case FISH_CWD:
+            error(ERR_CANNOT_ENTER_DIRECTORY,url.prettyURL());
+            break;
+        case FISH_LIST:
+            myDebug( << "list error. reason: " << listReason << endl);
+            if (listReason == LIST) error(ERR_CANNOT_ENTER_DIRECTORY,url.prettyURL());
+            else if (listReason == CHECK) {
+                checkExist = false;
+                finished();
+            }
+            break;
+        case FISH_STAT:
+            error(ERR_DOES_NOT_EXIST,url.prettyURL());
+            udsStatEntry.clear();
+            break;
+        case FISH_CHMOD:
+            error(ERR_CANNOT_CHMOD,url.prettyURL());
+            break;
+        case FISH_CHOWN:
+        case FISH_CHGRP:
+            error(ERR_ACCESS_DENIED,url.prettyURL());
+            break;
+        case FISH_MKD:
+            if ( rc == 501 )
+                error(ERR_DIR_ALREADY_EXIST,url.prettyURL());
+            else
+                error(ERR_COULD_NOT_MKDIR,url.prettyURL());
+            break;
+        case FISH_RMD:
+            error(ERR_COULD_NOT_RMDIR,url.prettyURL());
+            break;
+        case FISH_DELE:
+            error(ERR_CANNOT_DELETE,url.prettyURL());
+            break;
+        case FISH_RENAME:
+            error(ERR_CANNOT_RENAME,url.prettyURL());
+            break;
+        case FISH_COPY:
+        case FISH_LINK:
+        case FISH_SYMLINK:
+            error(ERR_COULD_NOT_WRITE,url.prettyURL());
+            break;
+        default : break;
+        }
+    } else {
+        if (fishCommand == FISH_STOR) fishCommand = (hasAppend?FISH_APPEND:FISH_WRITE);
+        if (fishCommand == FISH_FISH) {
+            connected();
+        } else if (fishCommand == FISH_LIST) {
+            if (listReason == LIST) {
+                listEntry(UDSEntry(),true);
+            } else if (listReason == CHECK) {
+                if (!checkOverwrite && checkExist)
+                {
+                    error(ERR_FILE_ALREADY_EXIST,url.prettyURL());
+                    return; // Don't call finished!
+                }
+            }
+        } else if (fishCommand == FISH_STAT) {
+            UDSAtom atom;
+
+            atom.m_uds = KIO::UDS_NAME;
+            atom.m_str = url.fileName();
+            udsStatEntry.append( atom );
+            statEntry(udsStatEntry);
+        } else if (fishCommand == FISH_APPEND) {
+            dataReq();
+            if (readData(rawData) > 0) sendCommand(FISH_APPEND,E(QString::number(rawData.size())),E(url.path()));
+            else if (!checkExist && putPerm > -1) sendCommand(FISH_CHMOD,E(QString::number(putPerm,8)),E(url.path()));
+            sendLen = rawData.size();
+        } else if (fishCommand == FISH_WRITE) {
+            dataReq();
+            if (readData(rawData) > 0) sendCommand(FISH_WRITE,E(QString::number(putPos)),E(QString::number(rawData.size())),E(url.path()));
+            else if (!checkExist && putPerm > -1) sendCommand(FISH_CHMOD,E(QString::number(putPerm,8)),E(url.path()));
+            putPos += rawData.size();
+            sendLen = rawData.size();
+        } else if (fishCommand == FISH_RETR) {
+            data(QByteArray());
+        }
+        finished();
+    }
+}
+
+void fishProtocol::writeStdin(const QString &line)
+{
+    qlist.append(line);
+
+    if (writeReady) {
+        writeReady = false;
+        //myDebug( << "Writing: " << qlist.first().mid(0,qlist.first().find('\n')) << endl);
+        myDebug( << "Writing: " << qlist.first() << endl);
+        myDebug( << "---------" << endl);
+        writeChild((const char *)qlist.first().latin1(), qlist.first().length());
+    }
+}
+
+void fishProtocol::sent()
+{
+    if (rawWrite > 0) {
+        myDebug( << "writing raw: " << rawData.size() << "/" << rawWrite << endl);
+        writeChild(rawData.data(),((unsigned int)rawWrite > rawData.size()?rawData.size():rawWrite));
+        rawWrite -= rawData.size();
+        if (rawWrite > 0) {
+            dataReq();
+            if (readData(rawData) <= 0) {
+                shutdownConnection();
+            }
+        }
+        return;
+    } else if (rawWrite == 0) {
+        // workaround: some dd's insist in reading multiples of
+        // 8 bytes, swallowing up to seven bytes. Sending
+        // newlines is safe even when a sane dd is used
+        writeChild("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",15);
+        rawWrite = -1;
+        return;
+    }
+    if (qlist.count() > 0) qlist.remove(qlist.begin());
+    if (qlist.count() == 0) {
+        writeReady = true;
+    } else {
+        //myDebug( << "Writing: " << qlist.first().mid(0,qlist.first().find('\n')) << endl);
+        myDebug( << "Writing: " << qlist.first() << endl);
+        myDebug( << "---------" << endl);
+        writeChild((const char *)qlist.first().latin1(),qlist.first().length());
+    }
+}
+
+int fishProtocol::received(const char *buffer, int buflen)
+{
+    int pos = 0;
+    do {
+        if (buflen <= 0) break;
+
+        if (rawRead > 0) {
+            myDebug( << "processedSize " << dataRead << ", len " << buflen << "/" << rawRead << endl);
+            int dataSize = (rawRead > buflen?buflen:rawRead);
+            if (!mimeTypeSent)
+            {
+                int mimeSize = QMIN(dataSize, (int)mimeBuffer.size()-dataRead);
+                memcpy(mimeBuffer.data()+dataRead,buffer,mimeSize);
+                dataRead += mimeSize;
+                rawRead -= mimeSize;
+                buffer += mimeSize;
+                buflen -= mimeSize;
+                if (rawRead == 0) // End of data
+                    mimeBuffer.resize(dataRead);
+                if (dataRead < (int)mimeBuffer.size())
+                {
+                    myDebug( << "wait for more" << endl);
+                    break;
+                }
+                sendmimeType(KMimeMagic::self()->findBufferFileType(mimeBuffer,url.path())->mimeType());
+                mimeTypeSent = true;
+                if (fishCommand != FISH_READ) {
+                    totalSize(dataRead + rawRead);
+                    data(mimeBuffer);
+                    processedSize(dataRead);
+                }
+                mimeBuffer.resize(1024);
+                pos = 0;
+                continue; // Process rest of buffer/buflen
+            }
+
+            QByteArray bdata;
+            bdata.duplicate(buffer,dataSize);
+            data(bdata);
+            
+            dataRead += dataSize;
+            rawRead -= dataSize;
+            time_t t = time(NULL);
+            if (t-t_last >= 1) {
+                processedSize(dataRead);
+                //speed(dataRead/(t-t_start));
+                t_last = t;
+            }
+            if (rawRead <= 0) {
+                buffer += dataSize;
+                buflen -= dataSize;
+            } else {
+                return 0;
+            }
+        }
+
+        if (buflen <= 0) break;
+
+        pos = 0;
+        // Find newline
+        while((pos < buflen) && (buffer[pos] != '\n'))
+            ++pos;
+        
+        if (pos < buflen)
+        {
+           QString s = remoteEncoding()->decode(QCString(buffer,pos+1));
+        
+           buffer += pos+1;
+           buflen -= pos+1;
+
+           manageConnection(s);
+           
+           pos = 0;
+           // Find next newline
+           while((pos < buflen) && (buffer[pos] != '\n'))
+               ++pos;
+        }
+    } while (childPid && buflen && (rawRead > 0 || pos < buflen));
+    return buflen;
+}
+/** get a file */
+void fishProtocol::get(const KURL& u){
+    myDebug( << "@@@@@@@@@ get " << u << endl);
+    setHost(u.host(),u.port(),u.user(),u.pass());
+    url = u;
+    openConnection();
+    if (!isLoggedIn) return;
+    url.cleanPath();
+    if (!url.hasPath()) {
+        sendCommand(FISH_PWD);
+    } else {
+        recvLen = -1;
+        sendCommand(FISH_RETR,E(url.path()));
+    }
+    run();
+}
+
+/** put a file */
+void fishProtocol::put(const KURL& u, int permissions, bool overwrite, bool /*resume*/){
+    myDebug( << "@@@@@@@@@ put " << u << " " << permissions << " " << overwrite << " " /* << resume */ << endl);
+    setHost(u.host(),u.port(),u.user(),u.pass());
+    url = u;
+    openConnection();
+    if (!isLoggedIn) return;
+    url.cleanPath();
+    if (!url.hasPath()) {
+        sendCommand(FISH_PWD);
+    } else {
+        putPerm = permissions;
+        checkOverwrite = overwrite;
+        checkExist = false;
+        putPos = 0;
+        listReason = CHECK;
+        sendCommand(FISH_LIST,E(url.path()));
+        sendCommand(FISH_STOR,"0",E(url.path()));
+    }
+    run();
+}
+/** executes next command in sequence or calls finished() if all is done */
+void fishProtocol::finished() {
+    if (commandList.count() > 0) {
+        fishCommand = (fish_command_type)commandCodes.first();
+        errorCount = -fishInfo[fishCommand].lines;
+        rawRead = 0;
+        rawWrite = -1;
+        udsEntry.clear();
+        udsStatEntry.clear();
+        writeStdin(commandList.first());
+        //if (fishCommand != FISH_APPEND && fishCommand != FISH_WRITE) infoMessage("Sending "+(commandList.first().mid(1,commandList.first().find("\n")-1))+"...");
+        commandList.remove(commandList.begin());
+        commandCodes.remove(commandCodes.begin());
+    } else {
+        myDebug( << "_______ emitting finished()" << endl);
+        SlaveBase::finished();
+        isRunning = false;
+    }
+}
+/** aborts command sequence and calls error() */
+void fishProtocol::error(int type, const QString &detail) {
+    commandList.clear();
+    commandCodes.clear();
+    myDebug( << "ERROR: " << type << " - " << detail << endl);
+    SlaveBase::error(type,detail);
+    isRunning = false;
+}
+/** executes a chain of commands */
+void fishProtocol::run() {
+    if (!isRunning) {
+        int rc;
+        isRunning = true;
+        finished();
+        fd_set rfds, wfds;
+        FD_ZERO(&rfds);
+        char buf[32768];
+        int offset = 0;
+        while (isRunning) {
+            FD_SET(childFd,&rfds);
+            FD_ZERO(&wfds);
+            if (outBufPos >= 0) FD_SET(childFd,&wfds);
+            rc = select(childFd+1, &rfds, &wfds, NULL, NULL);
+            if (rc < 0) {
+                if (errno == EINTR)
+                    continue;
+                myDebug( << "select failed, rc: " << rc << ", error: " << strerror(errno) << endl);
+                error(ERR_CONNECTION_BROKEN,connectionHost);
+                shutdownConnection();
+                return;
+            }
+            if (FD_ISSET(childFd,&wfds) && outBufPos >= 0) {
+                QString debug;
+                debug.setLatin1(outBuf+outBufPos,outBufLen-outBufPos);
+                myDebug( << "now writing " << (outBufLen-outBufPos) << " " << debug.left(40) << "..." << endl);
+                if (outBufLen-outBufPos > 0) rc = write(childFd,outBuf+outBufPos,outBufLen-outBufPos);
+                else rc = 0;
+                if (rc >= 0) outBufPos += rc;
+                else {
+                    if (errno == EINTR)
+                        continue;
+                    myDebug( << "write failed, rc: " << rc << ", error: " << strerror(errno) << endl);
+                    error(ERR_CONNECTION_BROKEN,connectionHost);
+                    shutdownConnection();
+                    return;
+                }
+                if (outBufPos >= outBufLen) {
+                    outBufPos = -1;
+                    outBuf = NULL;
+                    sent();
+                }
+            }
+            if (FD_ISSET(childFd,&rfds)) {
+                rc = read(childFd,buf+offset,32768-offset);
+                //myDebug( << "read " << rc << " bytes" << endl);
+                if (rc > 0) {
+                    int noff = received(buf,rc+offset);
+                    if (noff > 0) memmove(buf,buf+offset+rc-noff,noff);
+                    //myDebug( << "left " << noff << " bytes: " << QString::fromLatin1(buf,offset) << endl);
+                    offset = noff;
+                } else {
+                    if (errno == EINTR)
+                        continue;
+                    myDebug( << "read failed, rc: " << rc << ", error: " << strerror(errno) << endl);
+                    error(ERR_CONNECTION_BROKEN,connectionHost);
+                    shutdownConnection();
+                    return;
+                }
+            }
+            if (wasKilled())
+                return;
+        }
+    }
+}
+/** stat a file */
+void fishProtocol::stat(const KURL& u){
+    myDebug( << "@@@@@@@@@ stat " << u << endl);
+    setHost(u.host(),u.port(),u.user(),u.pass());
+    url = u;
+    isStat = true; // FIXME: just a workaround for konq deficiencies
+    openConnection();
+    isStat = false; // FIXME: just a workaround for konq deficiencies
+    if (!isLoggedIn) return;
+    url.cleanPath();
+    if (!url.hasPath()) {
+        sendCommand(FISH_PWD);
+    } else {
+        sendCommand(FISH_STAT,E(url.path(-1)));
+    }
+    run();
+}
+/** find mimetype for a file */
+void fishProtocol::mimetype(const KURL& u){
+    myDebug( << "@@@@@@@@@ mimetype " << u << endl);
+    setHost(u.host(),u.port(),u.user(),u.pass());
+    url = u;
+    openConnection();
+    if (!isLoggedIn) return;
+    url.cleanPath();
+    if (!url.hasPath()) {
+        sendCommand(FISH_PWD);
+    } else {
+        recvLen = 1024;
+        sendCommand(FISH_READ,"0","1024",E(url.path()));
+    }
+    run();
+}
+/** list a directory */
+void fishProtocol::listDir(const KURL& u){
+    myDebug( << "@@@@@@@@@ listDir " << u << endl);
+    setHost(u.host(),u.port(),u.user(),u.pass());
+    url = u;
+    openConnection();
+    if (!isLoggedIn) return;
+    url.cleanPath();
+    if (!url.hasPath()) {
+        sendCommand(FISH_PWD);
+    } else {
+        listReason = LIST;
+        sendCommand(FISH_LIST,E(url.path()));
+    }
+    run();
+}
+/** create a directory */
+void fishProtocol::mkdir(const KURL& u, int permissions) {
+    myDebug( << "@@@@@@@@@ mkdir " << u << " " << permissions << endl);
+    setHost(u.host(),u.port(),u.user(),u.pass());
+    url = u;
+    openConnection();
+    if (!isLoggedIn) return;
+    url.cleanPath();
+    if (!url.hasPath()) {
+        sendCommand(FISH_PWD);
+    } else {
+        sendCommand(FISH_MKD,E(url.path()));
+        if (permissions > -1) sendCommand(FISH_CHMOD,E(QString::number(permissions,8)),E(url.path()));
+    }
+    run();
+}
+/** rename a file */
+void fishProtocol::rename(const KURL& s, const KURL& d, bool overwrite) {
+    myDebug( << "@@@@@@@@@ rename " << s << " " << d << " " << overwrite << endl);
+    if (s.host() != d.host() || s.port() != d.port() || s.user() != d.user()) {
+        error(ERR_UNSUPPORTED_ACTION,s.prettyURL());
+        return;
+    }
+    setHost(s.host(),s.port(),s.user(),s.pass());
+    url = d;
+    openConnection();
+    if (!isLoggedIn) return;
+    KURL src = s;
+    url.cleanPath();
+    src.cleanPath();
+    if (!url.hasPath()) {
+        sendCommand(FISH_PWD);
+    } else {
+        if (!overwrite) {
+            listReason = CHECK;
+            checkOverwrite = false;
+            sendCommand(FISH_LIST,E(url.path()));
+        }
+        sendCommand(FISH_RENAME,E(src.path()),E(url.path()));
+    }
+    run();
+}
+/** create a symlink */
+void fishProtocol::symlink(const QString& target, const KURL& u, bool overwrite) {
+    myDebug( << "@@@@@@@@@ symlink " << target << " " << u << " " << overwrite << endl);
+    setHost(u.host(),u.port(),u.user(),u.pass());
+    url = u;
+    openConnection();
+    if (!isLoggedIn) return;
+    url.cleanPath();
+    if (!url.hasPath()) {
+        sendCommand(FISH_PWD);
+    } else {
+        if (!overwrite) {
+            listReason = CHECK;
+            checkOverwrite = false;
+            sendCommand(FISH_LIST,E(url.path()));
+        }
+        sendCommand(FISH_SYMLINK,E(target),E(url.path()));
+    }
+    run();
+}
+/** change file permissions */
+void fishProtocol::chmod(const KURL& u, int permissions){
+    myDebug( << "@@@@@@@@@ chmod " << u << " " << permissions << endl);
+    setHost(u.host(),u.port(),u.user(),u.pass());
+    url = u;
+    openConnection();
+    if (!isLoggedIn) return;
+    url.cleanPath();
+    if (!url.hasPath()) {
+        sendCommand(FISH_PWD);
+    } else {
+        if (permissions > -1) sendCommand(FISH_CHMOD,E(QString::number(permissions,8)),E(url.path()));
+    }
+    run();
+}
+/** copies a file */
+void fishProtocol::copy(const KURL &s, const KURL &d, int permissions, bool overwrite) {
+    myDebug( << "@@@@@@@@@ copy " << s << " " << d << " " << permissions << " " << overwrite << endl);
+    if (s.host() != d.host() || s.port() != d.port() || s.user() != d.user()) {
+        error(ERR_UNSUPPORTED_ACTION,s.prettyURL());
+        return;
+    }
+    //myDebug( << s << endl << d << endl);
+    setHost(s.host(),s.port(),s.user(),s.pass());
+    url = d;
+    openConnection();
+    if (!isLoggedIn) return;
+    KURL src = s;
+    url.cleanPath();
+    src.cleanPath();
+    if (!src.hasPath()) {
+        sendCommand(FISH_PWD);
+    } else {
+        if (!overwrite) {
+            listReason = CHECK;
+            checkOverwrite = false;
+            sendCommand(FISH_LIST,E(url.path()));
+        }
+        sendCommand(FISH_COPY,E(src.path()),E(url.path()));
+        if (permissions > -1) sendCommand(FISH_CHMOD,E(QString::number(permissions,8)),E(url.path()));
+    }
+    run();
+}
+/** removes a file or directory */
+void fishProtocol::del(const KURL &u, bool isFile){
+    myDebug( << "@@@@@@@@@ del " << u << " " << isFile << endl);
+    setHost(u.host(),u.port(),u.user(),u.pass());
+    url = u;
+    openConnection();
+    if (!isLoggedIn) return;
+    url.cleanPath();
+    if (!url.hasPath()) {
+        sendCommand(FISH_PWD);
+    } else {
+        sendCommand((isFile?FISH_DELE:FISH_RMD),E(url.path()));
+    }
+    run();
+}
+/** special like background execute */
+void fishProtocol::special( const QByteArray &data ){
+    int tmp;
+
+    QDataStream stream(data, IO_ReadOnly);
+
+    stream >> tmp;
+    switch (tmp) {
+        case FISH_EXEC_CMD: // SSH EXEC
+        {
+            KURL u;
+            QString command;
+            QString tempfile;
+            stream >> u;
+            stream >> command;
+            myDebug( << "@@@@@@@@@ exec " << u << " " << command << endl);
+            setHost(u.host(),u.port(),u.user(),u.pass());
+            url = u;
+            openConnection();
+            if (!isLoggedIn) return;
+            sendCommand(FISH_EXEC,E(command),E(url.path()));
+            run();
+            break;
+        }
+        default:
+            // Some command we don't understand.
+            error(ERR_UNSUPPORTED_ACTION,QString().setNum(tmp));
+            break;
+    }
+}
+/** report status */
+void fishProtocol::slave_status() {
+    myDebug( << "@@@@@@@@@ slave_status" << endl);
+    if (childPid > 0)
+        slaveStatus(connectionHost,isLoggedIn);
+    else
+        slaveStatus(QString::null,false);
+}

Added: nx-utils/nxfish/nx-fishsrv.pl
===================================================================
--- nx-utils/nxfish/nx-fishsrv.pl	2005-07-03 15:44:33 UTC (rev 65)
+++ nx-utils/nxfish/nx-fishsrv.pl	2005-07-03 16:08:12 UTC (rev 66)
@@ -0,0 +1,342 @@
+#!/usr/bin/perl
+
+=pod
+=cut
+
+use Fcntl;
+$|++;
+
+my $substpath=$ARGV[0];
+
+use strict;
+use POSIX qw(getcwd dup2 strftime);
+$SIG{'CHLD'} = 'IGNORE';
+$| = 1;
+MAIN: while (<STDIN>) {
+    chomp;
+    chomp;
+    /\#FISH/ && do {
+	print "### 200\n";
+	next;
+    };
+
+    next if !length($_) || substr( $_, 0, 1 ) ne '#';
+    s/^#//;
+    /^VER / && do {
+        print "VER 0.0.3 copy lscount lslinks lsmime stat\n### 200\n";
+        next;
+    };
+    /^PWD$/ && do {
+        print "/", "\n### 200\n";
+        next;
+    };
+    /^SYMLINK\s+((?:\\.|[^\\])*?)\s+((?:\\.|[^\\])*?)\s*$/ && do {
+        my $ofn = unquote($1);
+        my $fn  = unquote($2);
+        print( symlink( $ofn, $fn ) ? "### 200\n" : "### 500 $!\n" );
+        next;
+    };
+    /^COPY\s+((?:\\.|[^\\])*?)\s+((?:\\.|[^\\])*?)\s*$/ && do {
+        my $ofn    = unquote($1);
+        my $fn     = unquote($2);
+        my ($size) = ( stat($ofn) )[7];
+        my $read   = 1;
+        if ( -l $ofn ) {
+            my $dest = readlink($ofn);
+            unlink($fn);
+            symlink( $dest, $fn ) || ( $read = 0 );
+        }
+        else {
+            sysopen( FH, $ofn, O_RDONLY ) || do { print "### 500 $!\n"; next; };
+            sysopen( OFH, $fn, O_WRONLY | O_CREAT | O_TRUNC )
+              || do { close(FH); print "### 500 $!\n"; next; };
+            local $/ = undef;
+            my $buffer = '';
+            while ( $size > 16384
+                && ( $read = sysread( FH, $buffer, 16384 ) ) > 0 )
+            {
+                $size -= $read;
+                if ( syswrite( OFH, $buffer, $read ) != $read ) {
+                    close(FH);
+                    close(OFH);
+                    print "### 500 $!\n";
+                    next MAIN;
+                }
+            }
+            while ( $size > 0 && ( $read = sysread( FH, $buffer, $size ) ) > 0 )
+            {
+                $size -= $read;
+                if ( syswrite( OFH, $buffer, $read ) != $read ) {
+                    close(FH);
+                    close(OFH);
+                    print "### 500 $!\n";
+                    next MAIN;
+                }
+            }
+            close(FH);
+            close(OFH);
+        }
+        if ( $read > 0 ) {
+            print "### 200\n";
+        }
+        else {
+            print "### 500 $!\n";
+        }
+        next;
+    };
+    /^LINK\s+((?:\\.|[^\\])*?)\s+((?:\\.|[^\\])*?)\s*$/ && do {
+        my $ofn = unquote($1);
+        my $fn  = unquote($2);
+        print( link( $ofn, $fn ) ? "### 200\n" : "### 500 $!\n" );
+        next;
+    };
+    /^RENAME\s+((?:\\.|[^\\])*?)\s+((?:\\.|[^\\])*?)\s*$/ && do {
+        my $ofn = unquote($1);
+        my $fn  = unquote($2);
+        print( rename( $ofn, $fn ) ? "### 200\n" : "### 500 $!\n" );
+        next;
+    };
+    /^CHGRP\s+(\d+)\s+((?:\\.|[^\\])*?)\s*$/ && do {
+        my $fn = unquote($2);
+        print( chown( -1, int($1), $fn ) ? "### 200\n" : "### 500 $!\n" );
+        next;
+    };
+    /^CHOWN\s+(\d+)\s+((?:\\.|[^\\])*?)\s*$/ && do {
+        my $fn = unquote($2);
+        print( chown( int($1), -1, $fn ) ? "### 200\n" : "### 500 $!\n" );
+        next;
+    };
+    /^CHMOD\s+([0-7]+)\s+((?:\\.|[^\\])*?)\s*$/ && do {
+        my $fn = unquote($2);
+        print( chmod( oct($1), $fn ) ? "### 200\n" : "### 500 $!\n" );
+        next;
+    };
+    /^DELE\s+((?:\\.|[^\\])*?)\s*$/ && do {
+        my $fn = unquote($1);
+        print( unlink($fn) ? "### 200\n" : "### 500 $!\n" );
+        next;
+    };
+    /^RMD\s+((?:\\.|[^\\])*?)\s*$/ && do {
+        my $dn = unquote($1);
+        print( rmdir($dn) ? "### 200\n" : "### 500 $!\n" );
+        next;
+    };
+    /^MKD\s+((?:\\.|[^\\])*?)\s*$/ && do {
+        my $dn = unquote($1);
+        if ( mkdir( $dn, 0777 ) ) {
+            print "### 200\n";
+        }
+        else {
+            my $err = $!;
+            print( chdir($dn) ? "### 501 $err\n" : "### 500 $err\n" );
+        }
+        next;
+    };
+    #/^CWD\s+((?:\\.|[^\\])*?)\s*$/ && do {
+    #    my $dn = unquote($1);
+    #    print( chdir($dn) ? "### 200\n" : "### 500 $!\n" );
+    #    next;
+    #};
+    /^LIST\s+((?:\\.|[^\\])*?)\s*$/ && do {
+        list( $1, 1 );
+        next;
+    };
+    /^STAT\s+((?:\\.|[^\\])*?)\s*$/ && do {
+        list( $1, 0 );
+        next;
+    };
+    /^WRITE\s+(\d+)\s+(\d+)\s+((?:\\.|[^\\])*?)\s*$/ && do {
+        write_loop( $2, $3, O_WRONLY | O_CREAT, $1 );
+        next;
+    };
+    /^APPEND\s+(\d+)\s+((?:\\.|[^\\])*?)\s*$/ && do {
+        write_loop( $1, $2, O_WRONLY | O_APPEND );
+        next;
+    };
+    /^STOR\s+(\d+)\s+((?:\\.|[^\\])*?)\s*$/ && do {
+        write_loop( $1, $2, O_WRONLY | O_CREAT | O_TRUNC );
+        next;
+    };
+    /^RETR\s+((?:\\.|[^\\])*?)\s*$/ && do {
+        read_loop($1);
+        next;
+    };
+    /^READ\s+(\d+)\s+(\d+)\s+((?:\\.|[^\\])*?)\s*$/ && do {
+        read_loop( $3, $2, $1 );
+        next;
+    };
+}
+exit(0);
+
+sub list {
+    my $dn = unquote( $_[0] );
+    my @entries;
+    if ( !-e $dn ) {
+        print "### 404 File does not exist\n";
+        return;
+    }
+    elsif ( $_[1] && -d _ ) {
+        opendir( DIR, $dn ) || do { print "### 500 $!\n"; return; };
+        @entries = readdir(DIR);
+        closedir(DIR);
+    }
+    else {
+        ( $dn, @entries ) = $dn =~ m{(.*)/(.*)};
+        $dn = '/' if ( !length($dn) );
+    }
+    print scalar(@entries), "\n### 100\n";
+    my $cwd = getcwd();
+    chdir($dn) || do { print "### 500 $!\n"; return; };
+    foreach (@entries) {
+        my $link = readlink;
+        my ( $mode, $uid, $gid, $size, $mtime ) = (lstat)[ 2, 4, 5, 7, 9 ];
+        print filetype( $mode, $link, $uid, $gid );
+        print "S$size\n";
+        print strftime( "D%Y %m %d %H %M %S\n", localtime($mtime) );
+        print ":$_\n";
+        print "L$link\n" if (defined $link && ($_[0] ne "/"));
+        print mimetype($_);
+        print "\n";
+    }
+    chdir($cwd);
+    print "### 200\n";
+}
+
+sub read_loop {
+    my $fn = unquote( $_[0] );
+    my ($size) = ( $_[1] ? int( $_[1] ) : ( stat($fn) )[7] );
+    my $error = '';
+    print "### 501 Is directory\n" and return if -d $fn;
+    sysopen( FH, $fn, O_RDONLY ) || ( $error = $! );
+    if ( $_[2] ) {
+        sysseek( FH, int( $_[2] ), 0 ) || do { close(FH); $error ||= $!; };
+    }
+    print "### 500 $error\n" and return if $error;
+    if ( @_ < 2 ) {
+        print "$size\n";
+    }
+    print "### 100\n";
+    my $buffer = '';
+    my $read   = 1;
+    while ( $size > 16384 && ( $read = sysread( FH, $buffer, 16384 ) ) > 0 ) {
+        $size -= $read;
+        print $buffer;
+    }
+    while ( $size > 0 && ( $read = sysread( FH, $buffer, $size ) ) > 0 ) {
+        $size -= $read;
+        print $buffer;
+    }
+    while ( $size > 0 ) {
+        print ' ';
+        $size--;
+    }
+    $error ||= $! if $read <= 0;
+    close(FH);
+    if ( !$error ) {
+        print "### 200\n";
+    }
+    else {
+        print "### 500 $error\n";
+    }
+}
+
+sub write_loop {
+    my $size  = int( $_[0] );
+    my $fn    = unquote( $_[1] );
+    my $error = '';
+    sysopen( FH, $fn, $_[2] ) || do { print "### 400 $!\n"; return; };
+    eval { flock( FH, 2 ); };
+    if ( $_[3] ) {
+        sysseek( FH, int( $_[3] ), 0 )
+          || do { close(FH); print "### 400 $!\n"; return; };
+    }
+    <STDIN>;
+    print "### 100\n";
+    my $buffer = '';
+    my $read   = 1;
+    while ( $size > 16384 && ( $read = read( STDIN, $buffer, 16384 ) ) > 0 ) {
+        $size -= $read;
+        $error ||= $! if ( syswrite( FH, $buffer, $read ) != $read );
+    }
+    while ( $size > 0 && ( $read = read( STDIN, $buffer, $size ) ) > 0 ) {
+        $size -= $read;
+        $error ||= $! if ( syswrite( FH, $buffer, $read ) != $read );
+    }
+    close(FH);
+    if ( !$error ) {
+        print "### 200\n";
+    }
+    else {
+        print "### 500 $error\n";
+    }
+}
+
+# FIXME: Make it secure
+
+sub unquote { $_ = shift; s/\\(.)/$1/g; s/^/$substpath/g; s/\.\./\//g; return $_; }
+#sub unquote { $_ = shift; s/\\(.)/$1/g; return $_; }
+
+sub filetype {
+    my ( $mode, $link, $uid, $gid ) = @_;
+    my $result = 'P';
+    while (1) {
+        -f _           && do { $result .= '-'; last; };
+        -d _           && do { $result .= 'd'; last; };
+        defined($link) && do { $result .= 'l'; last; };
+        -c _           && do { $result .= 'c'; last; };
+        -b _           && do { $result .= 'b'; last; };
+        -S _           && do { $result .= 's'; last; };
+        -p _           && do { $result .= 'p'; last; };
+        $result .= '?';
+        last;
+    }
+    $result .= ( $mode & 0400 ? 'r' : '-' );
+    $result .= ( $mode & 0200 ? 'w' : '-' );
+    $result .=
+      ( $mode & 0100
+        ? ( $mode & 04000 ? 's' : 'x' )
+        : ( $mode & 04000 ? 'S' : '-' ) );
+    $result .= ( $mode & 0040 ? 'r' : '-' );
+    $result .= ( $mode & 0020 ? 'w' : '-' );
+    $result .=
+      ( $mode & 0010
+        ? ( $mode & 02000 ? 's' : 'x' )
+        : ( $mode & 02000 ? 'S' : '-' ) );
+    $result .= ( $mode & 0004 ? 'r' : '-' );
+    $result .= ( $mode & 0002 ? 'w' : '-' );
+    $result .=
+      ( $mode & 0001
+        ? ( $mode & 01000 ? 't' : 'x' )
+        : ( $mode & 01000 ? 'T' : '-' ) );
+    $result .= ' ';
+    $result .= ( getpwuid($uid) || $uid );
+    $result .= '.';
+    $result .= ( getgrgid($gid) || $gid );
+    $result .= "\n";
+    return $result;
+}
+
+sub mimetype {
+    my $fn = shift;
+    return "Minode/directory\n" if -d $fn;
+    pipe( IN, OUT );
+    my $pid = fork();
+    return '' if ( !defined $pid );
+    if ($pid) {
+        close(OUT);
+        my $type = <IN>;
+        close(IN);
+        chomp $type;
+        chomp $type;
+        $type =~ s/[,; ].*//;
+        return '' if ( $type !~ m/\// );
+        return "M$type\n";
+    }
+    close(IN);
+    sysopen( NULL, '/dev/null', O_RDWR );
+    dup2( fileno(NULL), fileno(STDIN) );
+    dup2( fileno(OUT),  fileno(STDOUT) );
+    dup2( fileno(NULL), fileno(STDERR) );
+    exec( '/usr/bin/file', '-i', '-b', '-L', $fn );
+    exit(0);
+}

Added: nx-utils/nxfish/nxfish.protocol
===================================================================
--- nx-utils/nxfish/nxfish.protocol	2005-07-03 15:44:33 UTC (rev 65)
+++ nx-utils/nxfish/nxfish.protocol	2005-07-03 16:08:12 UTC (rev 66)
@@ -0,0 +1,54 @@
+[Protocol]
+exec=kio_nxfish
+protocol=nxfish
+input=none
+output=filesystem
+listing=Name,Type,Size,Date,Access,Owner,Group,Link,
+reading=true
+writing=true
+makedir=true
+deleting=true
+linking=true
+moving=true
+Icon=remote
+Description=A kioslave for the FISH protocol
+Description[bn]=????????? (FISH) ????????????????????????-?????? ???????????? ???????????? kioslave
+Description[bs]=kioslave za FISH protokol
+Description[ca]=Un kioslave pel protocol FISH
+Description[cs]=Pomocn?? protokol FISH
+Description[da]=En kioslave for FISH-protokollen
+Description[de]=Ein-/Ausgabemodul f??r das FISH-Protokoll
+Description[el]=???????? kioslave ?????? ???? ???????????????????? FISH
+Description[es]=Un kioslave para el protocolo FISH
+Description[et]=Protokolli FISH IO-moodul
+Description[eu]=FISH protokolorako kioslavea
+Description[fi]=Liit??nt?? FISH-yhteysk??yt??nt??
+Description[fr]=Un kioslave pour le protocole FISH
+Description[fy]=In kioslave foar it FISH protokol
+Description[hi]=????????? ??????????????????????????? ???????????? ??????-??????-???-???????????????
+Description[hu]=KDE-protokoll a FISH protokollhoz
+Description[is]=kioslave fyrir FISH samskiptaregluna
+Description[it]=Un kioslave per il protocollo FISH
+Description[ja]=FISH ??????????????????????????? kioslave
+Description[lt]=Kiovergas FISH protokolui
+Description[nb]=En IU-slave for FISH-protokollen
+Description[nds]=En In-/Utgaavdeenst f??r dat FISH-Protokull
+Description[nl]=Een kioslave voor het protocol FISH
+Description[nn]=Ein IU-slave for FISH-protokollen
+Description[pa]=FISH ??????????????????????????? ?????? kioslave
+Description[pl]=Wtyczka protoko??u FISH
+Description[pt]=Um 'kioslave' para protocolo FISH
+Description[pt_BR]=Uma implementa????o para o protocolo FISH
+Description[ro]=Un dispozitiv de I/E pentru protocolul FISH
+Description[ru]=???????????? ???????????????? ?????????????? ?????? ?????????????????? FISH
+Description[se]=SO-??l??va FISH-protokolla v??r??s
+Description[sk]=IO klient pre protokol FISH
+Description[sl]=kioslave za protokol FISH
+Description[sr]=Kioslave ???? ???????????????? FISH
+Description[sr at Latn]=Kioslave za protokol FISH
+Description[sv]=En I/O-slav f??r protokollet FISH
+Description[ta]=FISH ??????????????????????????????????????? ????????? ??????????????????????????????
+Description[tg]=???????????? ???????????? ?????????????? ?????????? ?????????????????? FISH
+Description[tr]=FISH protokol?? i??in kioslave
+Description[uk]=?????????????????? B/?? ?????? ?????????????????? FISH
+DocPath=kioslave/fish.html



From fabianx at berlios.de  Sun Jul  3 18:44:04 2005
From: fabianx at berlios.de (Fabian Franz at BerliOS)
Date: Sun, 3 Jul 2005 18:44:04 +0200
Subject: [Freenx-cvs] r67 - in nx-utils: . nxredir
Message-ID: <200507031644.j63Gi4gZ028651@sheep.berlios.de>

Author: fabianx
Date: 2005-07-03 18:43:49 +0200 (Sun, 03 Jul 2005)
New Revision: 67

Added:
   nx-utils/nxredir/
   nx-utils/nxredir/Makefile
   nx-utils/nxredir/nxredir
   nx-utils/nxredir/nxredir.c
Log:
Initial import into CVS.


Added: nx-utils/nxredir/Makefile
===================================================================
--- nx-utils/nxredir/Makefile	2005-07-03 16:08:12 UTC (rev 66)
+++ nx-utils/nxredir/Makefile	2005-07-03 16:43:49 UTC (rev 67)
@@ -0,0 +1,18 @@
+all: libnxredir.so.0.1
+
+CC=gcc
+CFLAGS=-g -O2 -Wall
+
+libnxredir.so.0.1: nxredir.o
+	$(CC) -fPIC $(CFLAGS) -nostdlib -shared -o libnxredir.so.0.1 nxredir.o -ldl -lc
+
+clean:
+	rm -f libnxredir.so.0.1
+	rm -f *.o
+
+install:
+	cp -a libnxredir.so.0.1 $(DESTDIR)/usr/lib
+	cp -a nxredir $(DESTDIR)/usr/bin
+	ldconfig
+
+.PHONY: clean install

Added: nx-utils/nxredir/nxredir
===================================================================
--- nx-utils/nxredir/nxredir	2005-07-03 16:08:12 UTC (rev 66)
+++ nx-utils/nxredir/nxredir	2005-07-03 16:43:49 UTC (rev 67)
@@ -0,0 +1,16 @@
+#!/bin/sh
+
+if [ -z "$NXCUPS_PORT" -a -z "$NXSAMBA_PORT" ]
+then
+	echo "nxredir: Redirect standard ports to nxproxy"
+	echo ""
+	echo "Usage: export NXCUPS_PORT='where_cups_is_running'"
+	echo "       export NXSAMBA_PORT='where_samba_is_running'"
+	exit 0
+fi
+
+LD_PRELOAD="/usr/lib/libnxredir.so.0 $LD_PRELOAD"
+export LD_PRELOAD
+
+# invoke the program with the args given
+exec "$@"


Property changes on: nx-utils/nxredir/nxredir
___________________________________________________________________
Name: svn:executable
   + 

Added: nx-utils/nxredir/nxredir.c
===================================================================
--- nx-utils/nxredir/nxredir.c	2005-07-03 16:08:12 UTC (rev 66)
+++ nx-utils/nxredir/nxredir.c	2005-07-03 16:43:49 UTC (rev 67)
@@ -0,0 +1,69 @@
+/*
+ * libnxredir - Redirect certain ports to other forwarded ports.
+ *
+ * Copyright (c) 2005 by Fabian Franz.
+ *
+ * License: GPL
+ *
+ */
+
+char *progname = "libnxredir";              /* Name used in err msgs    */
+
+#define _GNU_SOURCE
+
+/* Header Files */
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <dlfcn.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <string.h>
+#include <strings.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <sys/poll.h>
+#include <sys/time.h>
+#include <pwd.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdarg.h>
+
+#include <sys/un.h>
+
+#define CONNECT_SIGNATURE int __fd, const struct sockaddr * __addr, socklen_t __len
+
+static int (*realconnect)(CONNECT_SIGNATURE);
+
+/* Exported Function Prototypes */
+void _init(void);
+
+int connect(CONNECT_SIGNATURE);
+
+void _init(void) 
+{
+        realconnect = dlsym(RTLD_NEXT, "connect");
+}
+
+int connect(CONNECT_SIGNATURE) 
+{
+	int cups, samba;
+	
+	if (realconnect == NULL) {
+                perror("Unresolved symbol: connect\n");
+                return(-1);
+        }
+
+	cups=atoi(getenv("NXCUPS_PORT"));
+	samba=atoi(getenv("NXSAMBA_PORT"));
+
+	/* CUPS */
+	if (cups != 0 && ((struct sockaddr_in*)__addr)->sin_port==htons(631))
+		((struct sockaddr_in*)__addr)->sin_port=htons(8632);
+
+	/* SAMBA */
+	if (samba != 0 && (((struct sockaddr_in*)__addr)->sin_port==htons(139) || ((struct sockaddr_in*)__addr)->sin_port==htons(445)))
+		((struct sockaddr_in*)__addr)->sin_port=htons(samba);
+
+	return realconnect(__fd, __addr, __len);
+}



From fabianx at berlios.de  Sun Jul  3 19:02:16 2005
From: fabianx at berlios.de (Fabian Franz at BerliOS)
Date: Sun, 3 Jul 2005 19:02:16 +0200
Subject: [Freenx-cvs] r68 - nx-utils/nxredir
Message-ID: <200507031702.j63H2G3c010057@sheep.berlios.de>

Author: fabianx
Date: 2005-07-03 19:02:02 +0200 (Sun, 03 Jul 2005)
New Revision: 68

Modified:
   nx-utils/nxredir/Makefile
   nx-utils/nxredir/nxredir.c
Log:
Initial bugfixes, should work now.


Modified: nx-utils/nxredir/Makefile
===================================================================
--- nx-utils/nxredir/Makefile	2005-07-03 16:43:49 UTC (rev 67)
+++ nx-utils/nxredir/Makefile	2005-07-03 17:02:02 UTC (rev 68)
@@ -1,17 +1,17 @@
-all: libnxredir.so.0.1
+all: libnxredir.so.0
 
 CC=gcc
 CFLAGS=-g -O2 -Wall
 
-libnxredir.so.0.1: nxredir.o
-	$(CC) -fPIC $(CFLAGS) -nostdlib -shared -o libnxredir.so.0.1 nxredir.o -ldl -lc
+libnxredir.so.0: nxredir.o
+	$(CC) -fPIC $(CFLAGS) -nostdlib -shared -o libnxredir.so.0 nxredir.o -ldl -lc
 
 clean:
-	rm -f libnxredir.so.0.1
+	rm -f libnxredir.so.0
 	rm -f *.o
 
-install:
-	cp -a libnxredir.so.0.1 $(DESTDIR)/usr/lib
+install: all
+	cp -a libnxredir.so.0 $(DESTDIR)/usr/lib
 	cp -a nxredir $(DESTDIR)/usr/bin
 	ldconfig
 

Modified: nx-utils/nxredir/nxredir.c
===================================================================
--- nx-utils/nxredir/nxredir.c	2005-07-03 16:43:49 UTC (rev 67)
+++ nx-utils/nxredir/nxredir.c	2005-07-03 17:02:02 UTC (rev 68)
@@ -47,23 +47,18 @@
 
 int connect(CONNECT_SIGNATURE) 
 {
-	int cups, samba;
-	
 	if (realconnect == NULL) {
                 perror("Unresolved symbol: connect\n");
                 return(-1);
         }
 
-	cups=atoi(getenv("NXCUPS_PORT"));
-	samba=atoi(getenv("NXSAMBA_PORT"));
-
 	/* CUPS */
-	if (cups != 0 && ((struct sockaddr_in*)__addr)->sin_port==htons(631))
-		((struct sockaddr_in*)__addr)->sin_port=htons(8632);
+	if ((getenv("NXCUPS_PORT") != NULL) && ((struct sockaddr_in*)__addr)->sin_port==htons(631))
+		((struct sockaddr_in*)__addr)->sin_port=htons(atoi(getenv("NXCUPS_PORT")));
 
 	/* SAMBA */
-	if (samba != 0 && (((struct sockaddr_in*)__addr)->sin_port==htons(139) || ((struct sockaddr_in*)__addr)->sin_port==htons(445)))
-		((struct sockaddr_in*)__addr)->sin_port=htons(samba);
+	if ((getenv("NXSAMBA_PORT") != NULL) && (((struct sockaddr_in*)__addr)->sin_port==htons(139) || ((struct sockaddr_in*)__addr)->sin_port==htons(445)))
+		((struct sockaddr_in*)__addr)->sin_port=htons(atoi(getenv("NXSAMBA_PORT")));
 
 	return realconnect(__fd, __addr, __len);
 }



From fabianx at berlios.de  Sun Jul  3 19:27:14 2005
From: fabianx at berlios.de (Fabian Franz at BerliOS)
Date: Sun, 3 Jul 2005 19:27:14 +0200
Subject: [Freenx-cvs] r69 - freenx-server
Message-ID: <200507031727.j63HREhm026776@sheep.berlios.de>

Author: fabianx
Date: 2005-07-03 19:27:10 +0200 (Sun, 03 Jul 2005)
New Revision: 69

Modified:
   freenx-server/nxloadconfig
Log:
Bumped version number to 0.5.0.


Modified: freenx-server/nxloadconfig
===================================================================
--- freenx-server/nxloadconfig	2005-07-03 17:02:02 UTC (rev 68)
+++ freenx-server/nxloadconfig	2005-07-03 17:27:10 UTC (rev 69)
@@ -49,7 +49,7 @@
 # DO NOT TOUCH unless you REALLY know what you are doing
 #########################################################################
 
-NX_VERSION=1.4.0-04-CVS
+NX_VERSION=1.4.0-05-SVN
 NX_LICENSE="OS (GPL)"
 
 # Where can different nx components be found



From fabianx at berlios.de  Sun Jul  3 19:29:55 2005
From: fabianx at berlios.de (Fabian Franz at BerliOS)
Date: Sun, 3 Jul 2005 19:29:55 +0200
Subject: [Freenx-cvs] r70 - freenx-server
Message-ID: <200507031729.j63HTtpF028835@sheep.berlios.de>

Author: fabianx
Date: 2005-07-03 19:29:44 +0200 (Sun, 03 Jul 2005)
New Revision: 70

Modified:
   freenx-server/node.conf.sample
Log:
Warned for using share session space via NFS, as nxserver is not yet fully ready to support it.


Modified: freenx-server/node.conf.sample
===================================================================
--- freenx-server/node.conf.sample	2005-07-03 17:27:10 UTC (rev 69)
+++ freenx-server/node.conf.sample	2005-07-03 17:29:44 UTC (rev 70)
@@ -197,6 +197,8 @@
 #     server by using forwarding directives on the "slave" servers.
 #
 #   - or share the session database space via NFS between the servers.
+#     (not recommended at the moment as race conditions for DISPLAYs can 
+#      occur)
 #
 # By setting ENABLE_LOADBALANCE="1" you can let users choose their
 # preferred host, while being forwarded to another server. Of course



From fabianx at berlios.de  Sun Jul  3 20:28:58 2005
From: fabianx at berlios.de (Fabian Franz at BerliOS)
Date: Sun, 3 Jul 2005 20:28:58 +0200
Subject: [Freenx-cvs] r71 - freenx-server
Message-ID: <200507031828.j63ISwgl000505@sheep.berlios.de>

Author: fabianx
Date: 2005-07-03 20:28:57 +0200 (Sun, 03 Jul 2005)
New Revision: 71

Modified:
   freenx-server/ChangeLog
   freenx-server/nxserver
Log:
Removed buggy forwarding support via USER.


Modified: freenx-server/ChangeLog
===================================================================
--- freenx-server/ChangeLog	2005-07-03 17:29:44 UTC (rev 70)
+++ freenx-server/ChangeLog	2005-07-03 18:28:57 UTC (rev 71)
@@ -1,6 +1,9 @@
-XX.07.2005 FreeNX 0.5.0
+XX.08.2005 FreeNX 0.5.0
 	* Initial support for load-balancing.
 
+XX.07.2005 FreeNX 0.4.2 "Bugfix Edition"
+	* Removed buggy forwarding support via USER.
+
 24.06.2005 FreeNX 0.4.1 "LinuxTag Edition"
 	* Fixed a small security problem giving access to session database.
 	* Added support for 1.5.0 OSS components. (especially rootless mode)

Modified: freenx-server/nxserver
===================================================================
--- freenx-server/nxserver	2005-07-03 17:29:44 UTC (rev 70)
+++ freenx-server/nxserver	2005-07-03 18:28:57 UTC (rev 71)
@@ -422,51 +422,6 @@
 	echo "$@"
 }
 
-# Forward the connection to the commercial NoMachine server
-server_forward_nomachine()
-{
-	set -- "${RECORD_CMD[@]}"
-	
-	# setup the FIFOs
-	SERVER_IN=~/server.in.$$
-	SERVER_OUT=~/server.out.$$
-	rm -f $SERVER_IN $SERVER_OUT
-	mkfifo $SERVER_IN $SERVER_OUT
-	exec 3<>$SERVER_IN
-	exec 4<>$SERVER_OUT
-	
-	$NOMACHINE_SERVER <&3 >&4 &
-	NX_PID=$!
-	
-	while true
-	do
-		read -n7 opcode <&4
-		line=""
-		case "$opcode" in
-			"NX> 105")
-				echo $1 >&3
-				shift
-			;;
-			"NX> 101")
-				echo $USER >&3
-				read line <&4
-				break
-			;;
-			*)
-				read line <&4
-			;;
-		esac
-	done
-	log 5 "Info: Forwarding connection to NoMachine server done."
-	cat <&4 &
-	CAT_PID=$!
-	cat - >&3
-	rm -f $SERVER_IN $SERVER_OUT
-	kill $CAT_PID
-	kill $NX_PID
-	exit 0
-}
-
 # Start!
 log 3 "-- NX SERVER START: $@ - ORIG_COMMAND=$SSH_ORIGINAL_COMMAND"
 
@@ -490,8 +445,6 @@
 
 echo_x "HELLO NXSERVER - Version $NX_VERSION $NX_LICENSE"
 
-[ "$ENABLE_NOMACHINE_FORWARD_USER" = "1" ] && RECORD_CMD=()
-
 # Login stage
 while true
 do
@@ -501,9 +454,6 @@
 	[ "$CMD" = "" ] && CMD="quit"
 	echo_x "$CMD"
 	
-	# record $CMD in RECORD_CMD array
-	[ "$ENABLE_NOMACHINE_FORWARD_USER" = "1" ] && RECORD_CMD=( "${RECORD_CMD[@]}" "$CMD" )
-	
 	case "$CMD" in 
 		quit|QUIT)
 			echo_x "Quit"
@@ -543,22 +493,6 @@
 			read USER
 			echo_x $USER
 			
-			# forward the connection to commercial NoMachine server?
-			if [ "$ENABLE_NOMACHINE_FORWARD_USER" = "1" -a -n "$NOMACHINE_SERVER" ]
-			then
-				case "$USER" in
-					freenx.*)
-						log 3 "Info: Not forwarding connection. FreeNX user found."
-						USER=${USER##freenx.}
-					;;
-					*)
-						log 3 "Info: Forwarding connection to NoMachine server"
-						server_forward_nomachine
-						log 1 "Error: Forwarding connection to NoMachine server failed."
-					;;
-				esac
-			fi
-			
 			echo_x -n "NX> 102 Password: "
 			read -s PASS
 			echo_x ""



From freenx-cvs at berlios.de  Sun Jul  3 20:28:59 2005
From: freenx-cvs at berlios.de (fabianx)
Date: Sun, 03 Jul 2005 20:28:59 +0200
Subject: [Freenx-cvs] CVS: freenx - fabianx modified 2 files
Message-ID: <42C82E6B.mailED1107DD@lists.berlios.de>

User:      fabianx
Date:      2005-07-03 18:28:59 GMT
Modified:  .        ChangeLog nxserver
Log:
Removed buggy forwarding support via USER.

Revision  Changes    Path
1.59      +3 -0      freenx/ChangeLog


rev 1.59, prev_rev 1.58
Index: ChangeLog
===================================================================
RCS file: /cvsroot/freenx/freenx/ChangeLog,v
retrieving revision 1.58
retrieving revision 1.59
diff -u -r1.58 -r1.59
--- ChangeLog	25 Jun 2005 12:26:22 -0000	1.58
+++ ChangeLog	3 Jul 2005 18:28:59 -0000	1.59
@@ -1,3 +1,6 @@
+XX.07.2005 FreeNX 0.4.2 "Bugfix Edition"
+	* Removed buggy forwarding support via USER.
+
 24.06.2005 FreeNX 0.4.1 "LinuxTag Edition"
 	* Fixed a small security problem giving access to session database.
 	* Added support for 1.5.0 OSS components. (especially rootless mode)



1.56      +1 -67     freenx/nxserver


rev 1.56, prev_rev 1.55
Index: nxserver
===================================================================
RCS file: /cvsroot/freenx/freenx/nxserver,v
retrieving revision 1.55
retrieving revision 1.56
diff -u -r1.55 -r1.56
--- nxserver	25 Jun 2005 12:26:22 -0000	1.55
+++ nxserver	3 Jul 2005 18:28:59 -0000	1.56
@@ -11,7 +11,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxserver,v 1.55 2005/06/25 12:26:22 fabianx Exp $
+# CVS: $Id: nxserver,v 1.56 2005/07/03 18:28:59 fabianx Exp $
 #
 
 # Read the config file
@@ -422,51 +422,6 @@
 	echo "$@"
 }
 
-# Forward the connection to the commercial NoMachine server
-server_forward_nomachine()
-{
-	set -- "${RECORD_CMD[@]}"
-	
-	# setup the FIFOs
-	SERVER_IN=~/server.in.$$
-	SERVER_OUT=~/server.out.$$
-	rm -f $SERVER_IN $SERVER_OUT
-	mkfifo $SERVER_IN $SERVER_OUT
-	exec 3<>$SERVER_IN
-	exec 4<>$SERVER_OUT
-	
-	$NOMACHINE_SERVER <&3 >&4 &
-	NX_PID=$!
-	
-	while true
-	do
-		read -n7 opcode <&4
-		line=""
-		case "$opcode" in
-			"NX> 105")
-				echo $1 >&3
-				shift
-			;;
-			"NX> 101")
-				echo $USER >&3
-				read line <&4
-				break
-			;;
-			*)
-				read line <&4
-			;;
-		esac
-	done
-	log 5 "Info: Forwarding connection to NoMachine server done."
-	cat <&4 &
-	CAT_PID=$!
-	cat - >&3
-	rm -f $SERVER_IN $SERVER_OUT
-	kill $CAT_PID
-	kill $NX_PID
-	exit 0
-}
-
 # Start!
 log 3 "-- NX SERVER START: $@"
 
@@ -487,8 +442,6 @@
 
 echo_x "HELLO NXSERVER - Version $NX_VERSION $NX_LICENSE"
 
-[ "$ENABLE_NOMACHINE_FORWARD_USER" = "1" ] && RECORD_CMD=()
-
 # Login stage
 while true
 do
@@ -498,9 +451,6 @@
 	[ "$CMD" = "" ] && CMD="quit"
 	echo_x "$CMD"
 	
-	# record $CMD in RECORD_CMD array
-	[ "$ENABLE_NOMACHINE_FORWARD_USER" = "1" ] && RECORD_CMD=( "${RECORD_CMD[@]}" "$CMD" )
-	
 	case "$CMD" in 
 		quit|QUIT)
 			echo_x "Quit"
@@ -539,22 +489,6 @@
 			echo_x -n "NX> 101 User: "
 			read USER
 			echo_x $USER
-			
-			# forward the connection to commercial NoMachine server?
-			if [ "$ENABLE_NOMACHINE_FORWARD_USER" = "1" -a -n "$NOMACHINE_SERVER" ]
-			then
-				case "$USER" in
-					freenx.*)
-						log 3 "Info: Not forwarding connection. FreeNX user found."
-						USER=${USER##freenx.}
-					;;
-					*)
-						log 3 "Info: Forwarding connection to NoMachine server"
-						server_forward_nomachine
-						log 1 "Error: Forwarding connection to NoMachine server failed."
-					;;
-				esac
-			fi
 			
 			echo_x -n "NX> 102 Password: "
 			read -s PASS






From freenx-cvs at berlios.de  Sun Jul  3 21:51:39 2005
From: freenx-cvs at berlios.de (fabianx)
Date: Sun, 03 Jul 2005 21:51:39 +0200
Subject: [Freenx-cvs] CVS: freenx - fabianx modified 2 files
Message-ID: <42C841CB.mail3I81WB76Z@lists.berlios.de>

User:      fabianx
Date:      2005-07-03 19:51:39 GMT
Modified:  .        ChangeLog nxserver
Log:
       * Cleaned up lots of code.
               * Fixed one case of a left over file.
               * Removed one unnecessary usage of a temporary file.

Revision  Changes    Path
1.60      +3 -0      freenx/ChangeLog


rev 1.60, prev_rev 1.59
Index: ChangeLog
===================================================================
RCS file: /cvsroot/freenx/freenx/ChangeLog,v
retrieving revision 1.59
retrieving revision 1.60
diff -u -r1.59 -r1.60
--- ChangeLog	3 Jul 2005 18:28:59 -0000	1.59
+++ ChangeLog	3 Jul 2005 19:51:39 -0000	1.60
@@ -1,5 +1,8 @@
 XX.07.2005 FreeNX 0.4.2 "Bugfix Edition"
 	* Removed buggy forwarding support via USER.
+	* Cleaned up lots of code.
+		* Fixed one case of a left over file.
+		* Removed one unnecessary usage of a temporary file.
 
 24.06.2005 FreeNX 0.4.1 "LinuxTag Edition"
 	* Fixed a small security problem giving access to session database.



1.57      +32 -23    freenx/nxserver


rev 1.57, prev_rev 1.56
Index: nxserver
===================================================================
RCS file: /cvsroot/freenx/freenx/nxserver,v
retrieving revision 1.56
retrieving revision 1.57
diff -u -r1.56 -r1.57
--- nxserver	3 Jul 2005 18:28:59 -0000	1.56
+++ nxserver	3 Jul 2005 19:51:39 -0000	1.57
@@ -11,7 +11,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxserver,v 1.56 2005/07/03 18:28:59 fabianx Exp $
+# CVS: $Id: nxserver,v 1.57 2005/07/03 19:51:39 fabianx Exp $
 #
 
 # Read the config file
@@ -616,19 +616,26 @@
 	$COMMAND_SESSREG -l ":$SESS_DISPLAY" -h "$USERIP" -d $USER 2>&1 | log_error
 }
 
+server_nxnode_echo()
+{
+	[ "$SERVER_CHANNEL" = "1" ] && echo "$@"
+	[ "$SERVER_CHANNEL" = "2" ] && echo "$@" >&2
+}
+
 server_nxnode_start_wait()
 {
 	server_add_usession
 	
-	STOP_SEND=""
+	SERVER_CHANNEL=1
 	server_nxnode_start "$@" | while read CMD
 	do
 		case "$CMD" in 
 			"NX> 1006"*|"NX> 1005"*|"NX> 1009"*)
 				case "$CMD" in 
 					*running*)
-						rm -f $WAIT
+						kill $SERVER_WAIT_PID
 						session_status $uniqueid "Running"
+						SERVER_CHANNEL=2
 					;;
 					*closed*)
 						session_close $uniqueid
@@ -641,25 +648,20 @@
 						# we need to stop sending to client as it will have already
 						# closed his side of the channel and this will lead to not 
 						# closed sessions.
-						STOP_SEND="1"
+						SERVER_CHANNEL=0
 				esac
 			;;
 			"NX> 1004"*)
 				session_fail $uniqueid
 				# FIXME: Need correct error code.
-				echo_x "NX> 504 Session startup failed."
+				server_nxnode_echo "NX> 504 Session startup failed."
+				log "NX> 504 Session startup failed."
 			;;
 		esac
 
 		case $CMD in
-			"NX> 718"*)
-				[ -z "$STOP_SEND" ] && echo $CMD >&2
-				#echo "NX> 1006 Session status: running" 1>&2
-				#echo "NX> 1001 Bye." 1>&2
-
-			;;
 			"NX> "*)
-				[ -z "$STOP_SEND" ] && echo $CMD
+				server_nxnode_echo $CMD
 			;;
 		esac
 	done
@@ -760,15 +762,16 @@
 			# ln is an atomic operation
 			ln "$SESS_LOCKFILE" "/tmp/.nX$SESS_DISPLAY-lock" 2>/dev/null && break
 		done
+
+		rm -f "$SESS_LOCKFILE"
 		
 		if [ "$SESS_DISPLAY" -gt "$SESS_DISPLAY_LIMIT" ]
 		then
 			# fixme we need the correct error code
 			echo_x "NX> 504 Error: Display limit exceeded. Please remove some files from /tmp/.X*-lock."
+			rm -f "/tmp/.nX$SESS_DISPLAY-lock"
 			return
 		fi
-
-		rm -f "$SESS_LOCKFILE"
 	
 		uniqueid=$(echo $[$RANDOM*$RANDOM] | md5sum | cut -d" " -f1 | tr "[a-z]" "[A-Z]")
 		FULL_PARAMS="user=$USER&userip=$USERIP&uniqueid=$uniqueid&display=$SESS_DISPLAY&$PARAMS"
@@ -788,16 +791,24 @@
 	fi
 
 	# now start the node
-	export WAIT=$(mktemp /tmp/nxserver_wait.XXXXXXXXX)
-	touch $WAIT
-	(sleep 10; rm -f $WAIT) &
+	(sleep 10; exit 1) &
+	SERVER_WAIT_PID=$!
 	server_nxnode_start_wait --"$ACTION"session $USER "$FULL_PARAMS" &
 	SERVER_PID=$!
 	disown $SERVER_PID
-	while [ -f "$WAIT" ]
-	do
-		sleep 1
-	done
+	wait $SERVER_WAIT_PID
+	
+	if [ $? -eq 1 ]
+	then
+		# Something went wrong ...
+		session_fail $uniqueid
+		# FIXME: Need correct error code.
+		echo_x "NX> 1004 Error: Session did not start."
+		echo_x "NX> 504 Session startup failed."
+		echo_x "NX> 999 Bye"
+		# FIXME: Send node signal to terminate
+		exit 1
+	fi
 }
 
 # Session stage
@@ -840,8 +851,6 @@
 			PARAMS=$SERVER_PARAMS
 			CMDLINE=$PARAMS
 			
-			# FIXME: To NX-Node!
-
 			status=$(getparam status)
 
 			if [ "$status" = "Suspended" -a -n "$(getparam screeninfo)" ]






From freenx-cvs at berlios.de  Sun Jul  3 22:35:50 2005
From: freenx-cvs at berlios.de (fabianx)
Date: Sun, 03 Jul 2005 22:35:50 +0200
Subject: [Freenx-cvs] CVS: freenx - fabianx modified 2 files
Message-ID: <42C84C26.mail57B1NVDEG@lists.berlios.de>

User:      fabianx
Date:      2005-07-03 20:35:50 GMT
Modified:  .        ChangeLog nxserver
Log:
Added exit handlers for more stability of the system.

Revision  Changes    Path
1.61      +1 -0      freenx/ChangeLog


rev 1.61, prev_rev 1.60
Index: ChangeLog
===================================================================
RCS file: /cvsroot/freenx/freenx/ChangeLog,v
retrieving revision 1.60
retrieving revision 1.61
diff -u -r1.60 -r1.61
--- ChangeLog	3 Jul 2005 19:51:39 -0000	1.60
+++ ChangeLog	3 Jul 2005 20:35:50 -0000	1.61
@@ -3,6 +3,7 @@
 	* Cleaned up lots of code.
 		* Fixed one case of a left over file.
 		* Removed one unnecessary usage of a temporary file.
+	* Added exit handlers for more stability on reboot of system.
 
 24.06.2005 FreeNX 0.4.1 "LinuxTag Edition"
 	* Fixed a small security problem giving access to session database.



1.58      +18 -2     freenx/nxserver


rev 1.58, prev_rev 1.57
Index: nxserver
===================================================================
RCS file: /cvsroot/freenx/freenx/nxserver,v
retrieving revision 1.57
retrieving revision 1.58
diff -u -r1.57 -r1.58
--- nxserver	3 Jul 2005 19:51:39 -0000	1.57
+++ nxserver	3 Jul 2005 20:35:50 -0000	1.58
@@ -11,7 +11,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxserver,v 1.57 2005/07/03 19:51:39 fabianx Exp $
+# CVS: $Id: nxserver,v 1.58 2005/07/03 20:35:50 fabianx Exp $
 #
 
 # Read the config file
@@ -622,9 +622,23 @@
 	[ "$SERVER_CHANNEL" = "2" ] && echo "$@" >&2
 }
 
+server_nxnode_exit_func()
+{
+	log 1 "Info: Emergency-Shutting down due to kill signal ..."
+	
+	session_fail $uniqueid
+	
+	server_remove_usession
+
+	# remove lock file
+	[ -e "/tmp/.nX$SESS_DISPLAY-lock" ] && rm -f /tmp/.nX$SESS_DISPLAY-lock
+}
+
 server_nxnode_start_wait()
 {
 	server_add_usession
+
+	trap server_nxnode_exit_func EXIT
 	
 	SERVER_CHANNEL=1
 	server_nxnode_start "$@" | while read CMD
@@ -655,7 +669,7 @@
 				session_fail $uniqueid
 				# FIXME: Need correct error code.
 				server_nxnode_echo "NX> 504 Session startup failed."
-				log "NX> 504 Session startup failed."
+				log 4 "NX> 504 Session startup failed."
 			;;
 		esac
 
@@ -665,6 +679,8 @@
 			;;
 		esac
 	done
+
+	trap "" EXIT
 	
 	server_remove_usession
 






From freenx-cvs at berlios.de  Mon Jul  4 01:19:54 2005
From: freenx-cvs at berlios.de (fabianx)
Date: Mon, 04 Jul 2005 01:19:54 +0200
Subject: [Freenx-cvs] CVS: freenx - fabianx modified 2 files
Message-ID: <42C8729A.mailG4E11ETJ9@lists.berlios.de>

User:      fabianx
Date:      2005-07-03 23:19:54 GMT
Modified:  .        ChangeLog nxnode
Log:
* Changed nxnode to be much more stable.
	* Added one missing nxagent case, which lead to
	  "zombie" sessions.

Revision  Changes    Path
1.62      +3 -0      freenx/ChangeLog


rev 1.62, prev_rev 1.61
Index: ChangeLog
===================================================================
RCS file: /cvsroot/freenx/freenx/ChangeLog,v
retrieving revision 1.61
retrieving revision 1.62
diff -u -r1.61 -r1.62
--- ChangeLog	3 Jul 2005 20:35:50 -0000	1.61
+++ ChangeLog	3 Jul 2005 23:19:53 -0000	1.62
@@ -4,6 +4,9 @@
 		* Fixed one case of a left over file.
 		* Removed one unnecessary usage of a temporary file.
 	* Added exit handlers for more stability on reboot of system.
+	* Changed nxnode to be much more stable.
+		* Added one missing nxagent case, which lead to 
+		  "zombie" sessions.
 
 24.06.2005 FreeNX 0.4.1 "LinuxTag Edition"
 	* Fixed a small security problem giving access to session database.



1.61      +25 -4     freenx/nxnode


rev 1.61, prev_rev 1.60
Index: nxnode
===================================================================
RCS file: /cvsroot/freenx/freenx/nxnode,v
retrieving revision 1.60
retrieving revision 1.61
diff -u -r1.60 -r1.61
--- nxnode	23 Jun 2005 15:42:52 -0000	1.60
+++ nxnode	3 Jul 2005 23:19:53 -0000	1.61
@@ -13,7 +13,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxnode,v 1.60 2005/06/23 15:42:52 fabianx Exp $
+# CVS: $Id: nxnode,v 1.61 2005/07/03 23:19:53 fabianx Exp $
 #
 # 21.06.2004: - Full reconnection support
 
@@ -90,7 +90,7 @@
 		if ! [ "$virtualdesktop" = "0" -a "$ENABLE_ROOTLESS_MODE" != "1" ]
 		then
 			sleep 1
-			kill -9 $AGENT_PID 2>/dev/null
+			kill -0 $AGENT_PID 2>/dev/null && kill -9 $AGENT_PID 2>/dev/null
 		fi
 	fi
 	# remove possible leftover display ...
@@ -284,6 +284,9 @@
 	wait $PID
 	rm -f $USER_FAKE_HOME/.nx/C-$sess_id/pids/agent
 	[ "$type" = "windows" -o "$type" = "vnc" ] && node_terminate_session "$sess_id"
+	# remove possible leftovers of nxagent
+	rm -f /tmp/.X$display-lock
+	rm -f /tmp/.X11-unix/X$display
 }
 
 node_kill_proxy()
@@ -386,6 +389,16 @@
 	node_cupsd_stop
 }
 
+node_emergency_exit()
+{
+	# umount shares & stop printers
+	node_stop_services
+
+	# kill the session
+	node_terminate_session "$sess_id" "failed"
+
+	echo "NX> 1004 Error: Emergency exit due to kill signal."
+}
 
 #
 # Monitoring the nxagent: Its also kind of a "state-machine" 
@@ -399,6 +412,8 @@
 	RECONNECT=0
 	TAIL_PID=""
 	TIMEOUT_PID=""
+
+	trap node_emergency_exit EXIT
 	
 	sh -c 'echo "Info: tail -f running with pid '\'\$$\''."; exec tail -n1 -f '$USER_FAKE_HOME'/.nx/C-'$sess_id'/session' | while read line 
 	do
@@ -479,7 +494,10 @@
 			kill $PROXY_PID 2>/dev/null
 		fi
 		
-		if stringinstring "Info: Waiting for a further signal to complete." "$line" && [ "$RECONNECT" = "0" ]
+		TERM=""
+		stringinstring "Info: Waiting for a further signal to complete." "$line" && TERM="yes"
+		stringinstring "Info: Aborting procedure due to signal" "$line" && TERM="yes"
+		if [ -n "$TERM" -a "$RECONNECT" = "0" ]
 		then
 			kill $TAIL_PID 2>/dev/null
 			echo "NX> 1006 Session status: closed"
@@ -487,7 +505,7 @@
 			# especially for windows/vnc mode
 			kill $PROXY_PID 2>/dev/null
 			sleep 2
-			kill -9 $PROXY_PID 2>/dev/null
+			kill -0 $PROXY_PID 2>/dev/null && kill -9 $PROXY_PID 2>/dev/null
 
 			# umount shares & stop printers
 			node_stop_services
@@ -563,6 +581,9 @@
 			break
 		fi
 	done 
+	
+	trap "" EXIT
+	
 	node_stop_services
 	# close all open file descriptors
 	exec 0<&-






From freenx-cvs at berlios.de  Mon Jul  4 01:54:51 2005
From: freenx-cvs at berlios.de (fabianx)
Date: Mon, 04 Jul 2005 01:54:51 +0200
Subject: [Freenx-cvs] CVS: freenx - fabianx modified 2 files
Message-ID: <42C87ACB.mailCK1JP7PO@lists.berlios.de>

User:      fabianx
Date:      2005-07-03 23:54:46 GMT
Modified:  .        ChangeLog nxnode
Log:
* Reworked reconnection support for more stability.
	* Added displaying of reconnection failure in
          system log / client ssh log.

A failed reconnection should now never lead to a closed session.

Revision  Changes    Path
1.63      +3 -0      freenx/ChangeLog


rev 1.63, prev_rev 1.62
Index: ChangeLog
===================================================================
RCS file: /cvsroot/freenx/freenx/ChangeLog,v
retrieving revision 1.62
retrieving revision 1.63
diff -u -r1.62 -r1.63
--- ChangeLog	3 Jul 2005 23:19:53 -0000	1.62
+++ ChangeLog	3 Jul 2005 23:54:44 -0000	1.63
@@ -7,6 +7,9 @@
 	* Changed nxnode to be much more stable.
 		* Added one missing nxagent case, which lead to 
 		  "zombie" sessions.
+	* Reworked reconnection support for more stability.
+		* Added displaying of reconnection failure in
+		  system log / client ssh log.
 
 24.06.2005 FreeNX 0.4.1 "LinuxTag Edition"
 	* Fixed a small security problem giving access to session database.



1.62      +9 -12     freenx/nxnode


rev 1.62, prev_rev 1.61
Index: nxnode
===================================================================
RCS file: /cvsroot/freenx/freenx/nxnode,v
retrieving revision 1.61
retrieving revision 1.62
diff -u -r1.61 -r1.62
--- nxnode	3 Jul 2005 23:19:53 -0000	1.61
+++ nxnode	3 Jul 2005 23:54:44 -0000	1.62
@@ -13,7 +13,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxnode,v 1.61 2005/07/03 23:19:53 fabianx Exp $
+# CVS: $Id: nxnode,v 1.62 2005/07/03 23:54:44 fabianx Exp $
 #
 # 21.06.2004: - Full reconnection support
 
@@ -453,8 +453,15 @@
 		#
 		# Suspending possibilities
 		#
+
+		SUSP=""
+		stringinstring "Info: Reconnection failed" "$line" && echo "NX> 504 $line"
+		stringinstring "Info: Reconnection failed" "$line" && SUSP="yes"
+
+		stringinstring "Info: Suspending session on user request." "$line" && SUSP="yes"
+		stringinstring "Error: Connection with remote peer broken." "$line" && SUSP="yes"
 		
-		if stringinstring "Info: Suspending session on user request." "$line"
+		if [ -n "$SUSP" ]
 		then
 			kill $TAIL_PID 2>/dev/null
 			echo "NX> 1005 Session status: suspended"
@@ -471,16 +478,6 @@
 			echo "NX> 1005 Session status: suspended"
 			# umount shares & stop printers
 			node_stop_services
-			break
-		fi
-
-		if stringinstring "Error: Connection with remote peer broken." "$line"
-		then
-			kill $TAIL_PID 2>/dev/null
-			echo "NX> 1005 Session status: suspended"
-			kill -HUP $PROXY_PID 2>/dev/null
-			sleep 2
-			# time out faster for suspend
 			break
 		fi
 






From freenx-cvs at berlios.de  Mon Jul  4 02:54:42 2005
From: freenx-cvs at berlios.de (fabianx)
Date: Mon, 04 Jul 2005 02:54:42 +0200
Subject: [Freenx-cvs] CVS: freenx - fabianx modified 3 files
Message-ID: <42C888D2.mailFYQ1FQS6Q@lists.berlios.de>

User:      fabianx
Date:      2005-07-04 00:54:42 GMT
Modified:  .        ChangeLog nxnode nxserver
Log:
* Added even more possibilities for session startup failures.

Added also some commented out features for more pack-levels.

Revision  Changes    Path
1.64      +1 -0      freenx/ChangeLog


rev 1.64, prev_rev 1.63
Index: ChangeLog
===================================================================
RCS file: /cvsroot/freenx/freenx/ChangeLog,v
retrieving revision 1.63
retrieving revision 1.64
diff -u -r1.63 -r1.64
--- ChangeLog	3 Jul 2005 23:54:44 -0000	1.63
+++ ChangeLog	4 Jul 2005 00:54:41 -0000	1.64
@@ -10,6 +10,7 @@
 	* Reworked reconnection support for more stability.
 		* Added displaying of reconnection failure in
 		  system log / client ssh log.
+	* Added even more possibilities for session startup failures.
 
 24.06.2005 FreeNX 0.4.1 "LinuxTag Edition"
 	* Fixed a small security problem giving access to session database.



1.63      +15 -3     freenx/nxnode


rev 1.63, prev_rev 1.62
Index: nxnode
===================================================================
RCS file: /cvsroot/freenx/freenx/nxnode,v
retrieving revision 1.62
retrieving revision 1.63
diff -u -r1.62 -r1.63
--- nxnode	3 Jul 2005 23:54:44 -0000	1.62
+++ nxnode	4 Jul 2005 00:54:41 -0000	1.63
@@ -13,7 +13,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxnode,v 1.62 2005/07/03 23:54:44 fabianx Exp $
+# CVS: $Id: nxnode,v 1.63 2005/07/04 00:54:41 fabianx Exp $
 #
 # 21.06.2004: - Full reconnection support
 
@@ -287,6 +287,7 @@
 	# remove possible leftovers of nxagent
 	rm -f /tmp/.X$display-lock
 	rm -f /tmp/.X11-unix/X$display
+	[ -f $USER_FAKE_HOME/.nx/C-$sess_id/pids/monitor ] || node_terminate_session "$sess_id"
 }
 
 node_kill_proxy()
@@ -443,10 +444,17 @@
 		# Detect nxagent syntax errors
 		#
 		
-		if stringinstring "Unrecognized option:" "$line"
+		SYNTAX=""
+
+		stringinstring "Unrecognized option:" "$line" && SYNTAX="yes"
+		stringinstring "NXAGENT: Fatal IO error on display" "$line" && SYNTAX="yes"
+		stringinstring "NXAGENT: Unable to open display" "$line" && SYNTAX="yes"
+		if [ -n "$SYNTAX" ]
 		then
 			kill $TAIL_PID 2>/dev/null
 			echo "NX> 1004 Error: nxagent failed to start with: $line"
+			[ "$SESSION_LOG_CLEAN" = "1" ] && rm -rf $USER_FAKE_HOME/.nx/C-$sess_id/
+			[ "$SESSION_LOG_CLEAN" = "1" ] || mv $USER_FAKE_HOME/.nx/C-$sess_id/ $USER_FAKE_HOME/.nx/F-C-$sess_id/
 			break
 		fi
 
@@ -609,6 +617,7 @@
 	render=$(getparam render)
 	backingstore=$(getparam backingstore)
 	imagecompressionmethod=$(getparam imagecompressionmethod)
+	imagecompressionlevel=$(getparam imagecompressionlevel)
 	geometry=$(getparam geometry)
 	keyboard=$(getparam keyboard)
 	kbtype=$(getparam kbtype)
@@ -636,8 +645,11 @@
 	
 	# cache=8M,images=32M,pack=nopack,link=lan,type=unix-kde,cleanup=0,accept=192.168.1.66,cookie=E38A94A77F975443AF04EC911881B120,id=Knoppix-1000-6A8269CC467264EAEF6349D062689755,samba=1,render=1:1000
 	
-	# TODO: imagecompressionmethod ...
 	[ "$imagecompressionmethod" = "0" ] && PACK="pack=nopack,"
+	
+	#[ -z "$imagecompressionlevel" ] && imagecompressionlevel="9"
+	#[ "$imagecompressionmethod" = "1" ] && PACK="pack=16m-jpeg-$imagecompressionlevel"
+	#[ "$imagecompressionmethod" = "2" ] && PACK="pack=16m-png-9"
 	
 	proxy_cookie=$(echo $[$RANDOM*$RANDOM] | md5sum | cut -d" " -f1)
 



1.59      +8 -2      freenx/nxserver


rev 1.59, prev_rev 1.58
Index: nxserver
===================================================================
RCS file: /cvsroot/freenx/freenx/nxserver,v
retrieving revision 1.58
retrieving revision 1.59
diff -u -r1.58 -r1.59
--- nxserver	3 Jul 2005 20:35:50 -0000	1.58
+++ nxserver	4 Jul 2005 00:54:41 -0000	1.59
@@ -11,7 +11,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxserver,v 1.58 2005/07/03 20:35:50 fabianx Exp $
+# CVS: $Id: nxserver,v 1.59 2005/07/04 00:54:41 fabianx Exp $
 #
 
 # Read the config file
@@ -641,13 +641,15 @@
 	trap server_nxnode_exit_func EXIT
 	
 	SERVER_CHANNEL=1
+	KILL_WAIT_PID=1
 	server_nxnode_start "$@" | while read CMD
 	do
 		case "$CMD" in 
 			"NX> 1006"*|"NX> 1005"*|"NX> 1009"*)
 				case "$CMD" in 
 					*running*)
-						kill $SERVER_WAIT_PID
+						[ "$KILL_WAIT_PID" = "1" ] && kill $SERVER_WAIT_PID
+						KILL_WAIT_PID=0
 						session_status $uniqueid "Running"
 						SERVER_CHANNEL=2
 					;;
@@ -655,6 +657,8 @@
 						session_close $uniqueid
 					;;
 					*suspended*)
+						[ "$KILL_WAIT_PID" = "1" ] && kill $SERVER_WAIT_PID
+						KILL_WAIT_PID=0
 						session_suspend $uniqueid
 					;;
 					*terminating*)
@@ -666,6 +670,8 @@
 				esac
 			;;
 			"NX> 1004"*)
+				[ "$KILL_WAIT_PID" = "1" ] && kill $SERVER_WAIT_PID
+				KILL_WAIT_PID=0
 				session_fail $uniqueid
 				# FIXME: Need correct error code.
 				server_nxnode_echo "NX> 504 Session startup failed."






From freenx-cvs at berlios.de  Mon Jul  4 03:03:27 2005
From: freenx-cvs at berlios.de (fabianx)
Date: Mon, 04 Jul 2005 03:03:27 +0200
Subject: [Freenx-cvs] CVS: freenx - fabianx modified 2 files
Message-ID: <42C88ADF.mailI151JM48Q@lists.berlios.de>

User:      fabianx
Date:      2005-07-04 01:03:20 GMT
Modified:  .        ChangeLog nxnode
Log:
* Fixed PNG and JPEG-levels pack method.

Revision  Changes    Path
1.65      +1 -0      freenx/ChangeLog


rev 1.65, prev_rev 1.64
Index: ChangeLog
===================================================================
RCS file: /cvsroot/freenx/freenx/ChangeLog,v
retrieving revision 1.64
retrieving revision 1.65
diff -u -r1.64 -r1.65
--- ChangeLog	4 Jul 2005 00:54:41 -0000	1.64
+++ ChangeLog	4 Jul 2005 01:03:19 -0000	1.65
@@ -11,6 +11,7 @@
 		* Added displaying of reconnection failure in
 		  system log / client ssh log.
 	* Added even more possibilities for session startup failures.
+	* Fixed PNG and JPEG-levels pack method.
 
 24.06.2005 FreeNX 0.4.1 "LinuxTag Edition"
 	* Fixed a small security problem giving access to session database.



1.64      +6 -5      freenx/nxnode


rev 1.64, prev_rev 1.63
Index: nxnode
===================================================================
RCS file: /cvsroot/freenx/freenx/nxnode,v
retrieving revision 1.63
retrieving revision 1.64
diff -u -r1.63 -r1.64
--- nxnode	4 Jul 2005 00:54:41 -0000	1.63
+++ nxnode	4 Jul 2005 01:03:19 -0000	1.64
@@ -13,7 +13,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxnode,v 1.63 2005/07/04 00:54:41 fabianx Exp $
+# CVS: $Id: nxnode,v 1.64 2005/07/04 01:03:19 fabianx Exp $
 #
 # 21.06.2004: - Full reconnection support
 
@@ -645,11 +645,12 @@
 	
 	# cache=8M,images=32M,pack=nopack,link=lan,type=unix-kde,cleanup=0,accept=192.168.1.66,cookie=E38A94A77F975443AF04EC911881B120,id=Knoppix-1000-6A8269CC467264EAEF6349D062689755,samba=1,render=1:1000
 	
-	[ "$imagecompressionmethod" = "0" ] && PACK="pack=nopack,"
+	PACK=""
+	[ -z "$imagecompressionlevel" ] && imagecompressionlevel="9"
 	
-	#[ -z "$imagecompressionlevel" ] && imagecompressionlevel="9"
-	#[ "$imagecompressionmethod" = "1" ] && PACK="pack=16m-jpeg-$imagecompressionlevel"
-	#[ "$imagecompressionmethod" = "2" ] && PACK="pack=16m-png-9"
+	[ "$imagecompressionmethod" = "0" ] && PACK="pack=nopack,"
+	[ "$imagecompressionmethod" = "1" ] && PACK="pack=16m-jpeg-$imagecompressionlevel,"
+	[ "$imagecompressionmethod" = "2" ] && PACK="pack=16m-png-9,"
 	
 	proxy_cookie=$(echo $[$RANDOM*$RANDOM] | md5sum | cut -d" " -f1)
 






From freenx-cvs at berlios.de  Mon Jul  4 03:26:53 2005
From: freenx-cvs at berlios.de (fabianx)
Date: Mon, 04 Jul 2005 03:26:53 +0200
Subject: [Freenx-cvs] CVS: freenx - fabianx modified 2 files
Message-ID: <42C8905D.mailN69112PPK@lists.berlios.de>

User:      fabianx
Date:      2005-07-04 01:26:46 GMT
Modified:  .        ChangeLog nxserver
Log:
* Added usage of netcat -z to check that the port is really not used by
  another agent.

If you see stray nxagent processes look into the logfile if any are reported.

Revision  Changes    Path
1.66      +2 -0      freenx/ChangeLog


rev 1.66, prev_rev 1.65
Index: ChangeLog
===================================================================
RCS file: /cvsroot/freenx/freenx/ChangeLog,v
retrieving revision 1.65
retrieving revision 1.66
diff -u -r1.65 -r1.66
--- ChangeLog	4 Jul 2005 01:03:19 -0000	1.65
+++ ChangeLog	4 Jul 2005 01:26:44 -0000	1.66
@@ -12,6 +12,8 @@
 		  system log / client ssh log.
 	* Added even more possibilities for session startup failures.
 	* Fixed PNG and JPEG-levels pack method.
+	* Added usage of netcat -z to check that the port is really not used by
+	  another agent.
 
 24.06.2005 FreeNX 0.4.1 "LinuxTag Edition"
 	* Fixed a small security problem giving access to session database.



1.60      +11 -1     freenx/nxserver


rev 1.60, prev_rev 1.59
Index: nxserver
===================================================================
RCS file: /cvsroot/freenx/freenx/nxserver,v
retrieving revision 1.59
retrieving revision 1.60
diff -u -r1.59 -r1.60
--- nxserver	4 Jul 2005 00:54:41 -0000	1.59
+++ nxserver	4 Jul 2005 01:26:44 -0000	1.60
@@ -11,7 +11,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxserver,v 1.59 2005/07/04 00:54:41 fabianx Exp $
+# CVS: $Id: nxserver,v 1.60 2005/07/04 01:26:44 fabianx Exp $
 #
 
 # Read the config file
@@ -779,6 +779,16 @@
 			do
 				let SESS_DISPLAY=$SESS_DISPLAY+1
 			done
+
+			# Check if there is already an agent running on that display
+			let AGENT_DISPLAY=$SESS_DISPLAY+6000
+			if $COMMAND_NETCAT -z 127.0.0.1 $AGENT_DISPLAY 2>/dev/null
+			then
+				log 2 "Warning: Stray nxagent without .X$SESS_DISPLAY-lock found on port $AGENT_DISPLAY."
+				let SESS_DISPLAY=$SESS_DISPLAY+1
+				continue
+			fi
+			
 
 			SESS_LOCKFILE=$(mktemp "/tmp/.nX$SESS_DISPLAY-lock.XXXXXXXXX")
 			# ln is an atomic operation






From freenx-cvs at berlios.de  Mon Jul  4 03:52:18 2005
From: freenx-cvs at berlios.de (fabianx)
Date: Mon, 04 Jul 2005 03:52:18 +0200
Subject: [Freenx-cvs] CVS: freenx - fabianx modified 2 files
Message-ID: <42C89652.mail2WD1F6E57@lists.berlios.de>

User:      fabianx
Date:      2005-07-04 01:52:18 GMT
Modified:  .        ChangeLog nxserver
Log:
* Added nxserver --cleanup, which terminates all running sessions.
  Useful after a power outage.

  nxserver --cleanup basically is like nxserver --terminate "*", which was also
  added.

Revision  Changes    Path
1.67      +2 -0      freenx/ChangeLog


rev 1.67, prev_rev 1.66
Index: ChangeLog
===================================================================
RCS file: /cvsroot/freenx/freenx/ChangeLog,v
retrieving revision 1.66
retrieving revision 1.67
diff -u -r1.66 -r1.67
--- ChangeLog	4 Jul 2005 01:26:44 -0000	1.66
+++ ChangeLog	4 Jul 2005 01:52:17 -0000	1.67
@@ -14,6 +14,8 @@
 	* Fixed PNG and JPEG-levels pack method.
 	* Added usage of netcat -z to check that the port is really not used by
 	  another agent.
+	* Added nxserver --cleanup, which terminates all running sessions.
+	  Useful after a power outage.
 
 24.06.2005 FreeNX 0.4.1 "LinuxTag Edition"
 	* Fixed a small security problem giving access to session database.



1.61      +13 -7     freenx/nxserver


rev 1.61, prev_rev 1.60
Index: nxserver
===================================================================
RCS file: /cvsroot/freenx/freenx/nxserver,v
retrieving revision 1.60
retrieving revision 1.61
diff -u -r1.60 -r1.61
--- nxserver	4 Jul 2005 01:26:44 -0000	1.60
+++ nxserver	4 Jul 2005 01:52:17 -0000	1.61
@@ -11,7 +11,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxserver,v 1.60 2005/07/04 01:26:44 fabianx Exp $
+# CVS: $Id: nxserver,v 1.61 2005/07/04 01:52:17 fabianx Exp $
 #
 
 # Read the config file
@@ -1013,8 +1013,11 @@
 		echo "--history [ user | sessionid | clear ]: Show history [ of user | sessionid ] or clear the history" 1>&2
 		echo "--terminate <user | :display | sessionid>: Terminate the session pointed to by" 1>&2
 		echo "       sessionid or display, or all sessions of the specified user." 1>&2
+		echo "       Use * for all sessions." 1>&2
 		echo "--suspend <user | :display | sessionid>: Suspend the session pointed to by" 1>&2
 		echo "       sessionid or display, or all sessions of the specified user." 1>&2
+		echo "       Use * for all sessions." 1>&2
+		echo "--cleanup: Terminates all running sessions. Useful after power-outage."
 		echo "" 1>&2
 		echo "--broadcast <message>: Send a message to all users" 1>&2
 		echo "--send <user | :display | sessionid> <message>: Send a message to the specified user or sessionid" 1>&2
@@ -1138,13 +1141,15 @@
 	then
 		CMD_APARAMS=$(session_find_id $1)
 		[ -n "$CMD_APARAMS" ] || cmd_abort "Error: Session $1 could not be found."
-	else
-	if [ "${1:0:1}" = ":" ]
+	elif [ "${1:0:1}" = ":" ]
 	then
 		CMD_APARAMS=$(session_find_display "${1:1}")
 		[ -n "$CMD_APARAMS" ] || cmd_abort "Error: No running sessions found for display $1."
-	else
-	if [ "$1" != "" ]
+	elif [ "$1" = "*" ]
+	then
+		CMD_APARAMS=$(session_find_all)
+		[ -n "$CMD_APARAMS" ] || cmd_abort "Error: No running sessions found."
+	elif [ "$1" != "" ]
 	then
 		#egrep -q "^$1:" $NX_ETC_DIR/passwords || cmd_abort "Error: User $1 not found in database."
 		CMD_APARAMS=$(session_find_user "$1")
@@ -1152,8 +1157,6 @@
 	else
 		cmd_abort "Error: Not enough parameters."
 	fi
-	fi
-	fi
 	echo $CMD_APARAMS
 }
 
@@ -1344,6 +1347,9 @@
 	;;
 	--terminate|--suspend)
 		cmd_terminate "$@"
+	;;
+	--cleanup)
+		cmd_terminate "--terminate" "*"
 	;;
 	--send|--broadcast)
 		cmd_send "$@"






From fabianx at berlios.de  Tue Jul  5 02:31:07 2005
From: fabianx at berlios.de (Fabian Franz at BerliOS)
Date: Tue, 5 Jul 2005 02:31:07 +0200
Subject: [Freenx-cvs] r72 - in nx-utils: . nxpublickey
Message-ID: <200507050031.j650V7VN017334@sheep.berlios.de>

Author: fabianx
Date: 2005-07-05 02:30:22 +0200 (Tue, 05 Jul 2005)
New Revision: 72

Added:
   nx-utils/nxpublickey/
   nx-utils/nxpublickey/allow_agent_forwarding_with_B.diff
   nx-utils/nxpublickey/nxssh
Log:
Initial import into SVN.


Added: nx-utils/nxpublickey/allow_agent_forwarding_with_B.diff
===================================================================
--- nx-utils/nxpublickey/allow_agent_forwarding_with_B.diff	2005-07-03 18:28:57 UTC (rev 71)
+++ nx-utils/nxpublickey/allow_agent_forwarding_with_B.diff	2005-07-05 00:30:22 UTC (rev 72)
@@ -0,0 +1,13 @@
+--- channels.c.old	2005-07-05 02:22:18.000000000 +0200
++++ channels.c	2005-07-05 02:14:06.000000000 +0200
+@@ -3098,6 +3098,10 @@
+ 
+ int nx_check_channel_input(Channel *channel, char *data, int *length, int limit)
+ {
++	if (strcmp(channel->ctype,"authentication agent connection")==0)
++		return 0;
++		
++	
+         debug("NX> 285 Going to check input for descriptor: %d", channel->rfd);
+ 
+         /*

Added: nx-utils/nxpublickey/nxssh
===================================================================
--- nx-utils/nxpublickey/nxssh	2005-07-03 18:28:57 UTC (rev 71)
+++ nx-utils/nxpublickey/nxssh	2005-07-05 00:30:22 UTC (rev 72)
@@ -0,0 +1,56 @@
+#!/bin/bash
+#
+# Simple wrapper for nxssh.
+#
+# Copyright (c) 2005 by Fabian Franz.
+#
+# License: GPL
+#
+
+# unset them first to avoid that we forward a "secret" key to the remote host
+unset SSH_AGENT_PID SSH_AUTH_SOCK
+
+NXSSH_REMOTE_HOST="$HOME/.ssh/nx/"$(echo "$@" | sed 's/.*nx@//g' | cut -d" " -f1)""
+
+# Are there keys for this server?
+
+if [ -e "$NXSSH_REMOTE_HOST" ]
+then
+	export SSH_AUTH_SOCK="$NXSSH_REMOTE_HOST.sock"
+	set -- "$@" -o "ForwardAgent yes"
+
+	# Check if there is already an agent running for this host
+
+	if [ -S "$SSH_AUTH_SOCK" ]
+	then
+		NXSSH_AGENT="yes"
+		# Is it still alive?
+		ssh-add -l >/dev/null 2>/dev/null 
+		[ $? -eq 2 ] && rm -f "$SSH_AUTH_SOCK"
+	fi
+
+	# So lets start one
+	if [ ! -S "$SSH_AUTH_SOCK" ]
+	then
+		ssh-agent -a "$SSH_AUTH_SOCK" >/dev/null 2>/dev/null
+
+		# Setup secret key(s)
+		if [ -d "$NXSSH_REMOTE_HOST" ]
+		then
+		(
+		
+			cd $NXSSH_REMOTE_HOST; 
+			for i in $(echo *)
+			do
+				[ -f $i ] || continue
+				ssh-add "$NXSSH_REMOTE_HOST/$i" </dev/null >/dev/null 2>/dev/null
+			done
+		
+		)
+		else
+			ssh-add "$NXSSH_REMOTE_HOST" </dev/null >/dev/null 2>/dev/null
+		fi
+	fi
+fi
+
+exec $(dirname $0)/nxssh.orig "$@"


Property changes on: nx-utils/nxpublickey/nxssh
___________________________________________________________________
Name: svn:executable
   + 



From freenx-cvs at berlios.de  Tue Jul  5 23:42:57 2005
From: freenx-cvs at berlios.de (fabianx)
Date: Tue, 05 Jul 2005 23:42:57 +0200
Subject: [Freenx-cvs] CVS: freenx - fabianx modified node.conf.sample
Message-ID: <42CAFEE1.mailAGA1ZFAF7@lists.berlios.de>

User:      fabianx
Date:      2005-07-05 21:42:57 GMT
Modified:  .        node.conf.sample
Log:
Changed incoherency in node.conf for SESSION_LOG_CLEAN. Outcommented values should always provide the default behaviour.

Revision  Changes    Path
1.29      +3 -2      freenx/node.conf.sample


rev 1.29, prev_rev 1.28
Index: node.conf.sample
===================================================================
RCS file: /cvsroot/freenx/freenx/node.conf.sample,v
retrieving revision 1.28
retrieving revision 1.29
diff -u -r1.28 -r1.29
--- node.conf.sample	5 May 2005 08:17:54 -0000	1.28
+++ node.conf.sample	5 Jul 2005 21:42:57 -0000	1.29
@@ -37,7 +37,7 @@
 #
 #           https://mail.kde.org/mailman/listinfo/freenx-knx
 #
-# CVS: $Id: node.conf.sample,v 1.28 2005/05/05 08:17:54 jonno Exp $
+# CVS: $Id: node.conf.sample,v 1.29 2005/07/05 21:42:57 fabianx Exp $
 
 #########################################################################
 # General FreeNX directives
@@ -139,7 +139,8 @@
 # session has ended. A successfully terminated session will be saved as
 # T-C-<hostname>-<display>-<session_id> while a failed session will be saved
 # as F-C-<hostname>-<display>-<session_id>.
-#SESSION_LOG_CLEAN=0
+# The default is to cleanup the directories.
+#SESSION_LOG_CLEAN=1
 
 # Amount of seconds nxserver is to keep session history. The default of 2592000
 # is equivalent to 30 days. If this is 0 no session history will be kept






From freenx-cvs at berlios.de  Wed Jul  6 12:33:56 2005
From: freenx-cvs at berlios.de (fux)
Date: Wed, 06 Jul 2005 12:33:56 +0200
Subject: [Freenx-cvs] CVS: freenx - fux modified 2 files
Message-ID: <42CBB394.mail1E717977L@lists.berlios.de>

User:      fux
Date:      2005-07-06 10:33:56 GMT
Modified:  .        ChangeLog nxloadconfig
Log:
nxlibs need to find nxclient, so set PATH accordingly

Revision  Changes    Path
1.68      +1 -0      freenx/ChangeLog


rev 1.68, prev_rev 1.67
Index: ChangeLog
===================================================================
RCS file: /cvsroot/freenx/freenx/ChangeLog,v
retrieving revision 1.67
retrieving revision 1.68
diff -u -r1.67 -r1.68
--- ChangeLog	4 Jul 2005 01:52:17 -0000	1.67
+++ ChangeLog	6 Jul 2005 10:33:56 -0000	1.68
@@ -16,6 +16,7 @@
 	  another agent.
 	* Added nxserver --cleanup, which terminates all running sessions.
 	  Useful after a power outage.
+	* Fixed nxclient invocation with non-standard installation path
 
 24.06.2005 FreeNX 0.4.1 "LinuxTag Edition"
 	* Fixed a small security problem giving access to session database.



1.34      +3 -1      freenx/nxloadconfig


rev 1.34, prev_rev 1.33
Index: nxloadconfig
===================================================================
RCS file: /cvsroot/freenx/freenx/nxloadconfig,v
retrieving revision 1.33
retrieving revision 1.34
diff -u -r1.33 -r1.34
--- nxloadconfig	5 May 2005 08:34:20 -0000	1.33
+++ nxloadconfig	6 Jul 2005 10:33:56 -0000	1.34
@@ -5,7 +5,7 @@
 #
 # License: GPL, version 2
 #
-# CVS: $Id: nxloadconfig,v 1.33 2005/05/05 08:34:20 jonno Exp $
+# CVS: $Id: nxloadconfig,v 1.34 2005/07/06 10:33:56 fux Exp $
 #
 # ========================================================================
 
@@ -79,6 +79,8 @@
 SERVER_NAME="$(hostname)"
 SSHD_PORT=22
 
+# nxlibs need to find nxclient, so set PATH according to PATH_BIN, iff not already covered.     
+if ( echo $PATH | grep -v "$PATH_BIN" ); then export PATH=$PATH_BIN:$PATH; fi
 
 # Authentication / Security directives
 






From freenx-cvs at berlios.de  Wed Jul  6 17:59:06 2005
From: freenx-cvs at berlios.de (fux)
Date: Wed, 06 Jul 2005 17:59:06 +0200
Subject: [Freenx-cvs] CVS: freenx - fux modified 2 files
Message-ID: <42CBFFCA.mailN61KCK76@lists.berlios.de>

User:      fux
Date:      2005-07-06 15:59:06 GMT
Modified:  .        ChangeLog nxserver
Log:
Added detection of SSH2_CLIENT variable

Revision  Changes    Path
1.69      +1 -0      freenx/ChangeLog


rev 1.69, prev_rev 1.68
Index: ChangeLog
===================================================================
RCS file: /cvsroot/freenx/freenx/ChangeLog,v
retrieving revision 1.68
retrieving revision 1.69
diff -u -r1.68 -r1.69
--- ChangeLog	6 Jul 2005 10:33:56 -0000	1.68
+++ ChangeLog	6 Jul 2005 15:59:05 -0000	1.69
@@ -17,6 +17,7 @@
 	* Added nxserver --cleanup, which terminates all running sessions.
 	  Useful after a power outage.
 	* Fixed nxclient invocation with non-standard installation path
+	* Added detection of SSH2_CLIENT variable (commercial ssh)
 
 24.06.2005 FreeNX 0.4.1 "LinuxTag Edition"
 	* Fixed a small security problem giving access to session database.



1.62      +6 -5      freenx/nxserver


rev 1.62, prev_rev 1.61
Index: nxserver
===================================================================
RCS file: /cvsroot/freenx/freenx/nxserver,v
retrieving revision 1.61
retrieving revision 1.62
diff -u -r1.61 -r1.62
--- nxserver	4 Jul 2005 01:52:17 -0000	1.61
+++ nxserver	6 Jul 2005 15:59:05 -0000	1.62
@@ -11,7 +11,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxserver,v 1.61 2005/07/04 01:52:17 fabianx Exp $
+# CVS: $Id: nxserver,v 1.62 2005/07/06 15:59:05 fux Exp $
 #
 
 # Read the config file
@@ -433,7 +433,7 @@
 fi
 
 # forward the connection to commercial NoMachine server?
-if [ "$ENABLE_NOMACHINE_FORWARD_PORT" = "1" -a "$NOMACHINE_FORWARD_PORT" = "$(echo $SSH_CLIENT | cut -d' ' -f3)" -a -n "$NOMACHINE_SERVER" ]
+if [ "$ENABLE_NOMACHINE_FORWARD_PORT" = "1" -a "$NOMACHINE_FORWARD_PORT" = "$(echo $SSH_CLIENT $SSH2_CLIENT| cut -d' ' -f3)" -a -n "$NOMACHINE_SERVER" ]
 then
 	log 3 "Info: Detected SSH destination port $NOMACHINE_FORWARD_PORT. Forwarding connection to commercial NoMachine server."
 	exec $NOMACHINE_SERVER
@@ -726,7 +726,7 @@
 	
 	# If we can't get the userip and SSHD_CHECK_IP is set to 1
 	# we bail out.
-	if [ -z "$SSH_CLIENT" ]
+	if [ -z "$SSH_CLIENT" -a -z "$SSH2_CLIENT" ]
 	then 
 		if [ "$SSHD_CHECK_IP" = "1" ]
 		then
@@ -734,7 +734,7 @@
 			return 1
 		else
 			log 2 "Warning: Failed to determine the client IP."
-			log 2 "Warning: The SSH_CLIENT variable was not provided by SSHD."
+			log 2 "Warning: The SSH_CLIENT or SSH2_CLIENT variable was not provided by SSHD."
 			log 2 "Warning: Please set SSHD_CHECK_IP=1 if you want to refuse the connection."
 		fi
 	fi
@@ -759,7 +759,8 @@
 		fi
 	fi
 
-	USERIP=$(echo $SSH_CLIENT | cut -d" " -f1 | sed 's/::ffff://g')
+	# as only $SSH_CLIENT or $SSH2_CLIENT will be set, this should work
+	USERIP=$(echo $SSH_CLIENT $SSH2_CLIENT | cut -d" " -f1 | sed 's/::ffff://g')
 	[ -z "$USERIP" ] && USERIP="*"
 	if [ "$ACTION" = "start" ]
 	then






From FabianFranz at gmx.de  Thu Jul  7 01:13:02 2005
From: FabianFranz at gmx.de (Fabian Franz)
Date: Thu, 7 Jul 2005 01:13:02 +0200
Subject: [Freenx-cvs] CVS: freenx - fux modified 2 files
In-Reply-To: <42CBB394.mail1E717977L@lists.berlios.de>
References: <42CBB394.mail1E717977L@lists.berlios.de>
Message-ID: <200507070113.07168.FabianFranz@gmx.de>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Am Mittwoch, 6. Juli 2005 12:33 schrieb fux:
> User:      fux
> Date:      2005-07-06 10:33:56 GMT
> Modified:  .        ChangeLog nxloadconfig
> Log:
> nxlibs need to find nxclient, so set PATH accordingly

Yeah, such a patch is needed, but I really disagree with the implementation.
	
I would like to revert that patch and add ust PATH_BIN before nxagent, because 
thats the only one that does not know about the PATH...

I really do not want to pollute the PATH of all user programs ...

Can I "revert" (just by commiting mine not by actually reverting) your patch 
and apply mine?

cu

Fabian
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.2.4 (GNU/Linux)

iD8DBQFCzGWCI0lSH7CXz7MRAnetAJ9bodYbtHqO/kMwlNIjFy8eoEHVYwCfdmYU
788ID/i9AA0Dh4aqKTGVdiY=
=P0S+
-----END PGP SIGNATURE-----



From freenx-cvs at berlios.de  Fri Jul  8 02:05:31 2005
From: freenx-cvs at berlios.de (fabianx)
Date: Fri, 08 Jul 2005 02:05:31 +0200
Subject: [Freenx-cvs] CVS: freenx - fabianx modified 2 files
Message-ID: <42CDC34B.mailH21EZQ9H@lists.berlios.de>

User:      fabianx
Date:      2005-07-08 00:05:30 GMT
Modified:  .        nxloadconfig nxnode
Log:
Removed pollution of PATH. Just nxagent needs to find the nxclient ...

Revision  Changes    Path
1.35      +1 -4      freenx/nxloadconfig


rev 1.35, prev_rev 1.34
Index: nxloadconfig
===================================================================
RCS file: /cvsroot/freenx/freenx/nxloadconfig,v
retrieving revision 1.34
retrieving revision 1.35
diff -u -r1.34 -r1.35
--- nxloadconfig	6 Jul 2005 10:33:56 -0000	1.34
+++ nxloadconfig	8 Jul 2005 00:05:29 -0000	1.35
@@ -5,7 +5,7 @@
 #
 # License: GPL, version 2
 #
-# CVS: $Id: nxloadconfig,v 1.34 2005/07/06 10:33:56 fux Exp $
+# CVS: $Id: nxloadconfig,v 1.35 2005/07/08 00:05:29 fabianx Exp $
 #
 # ========================================================================
 
@@ -78,9 +78,6 @@
 
 SERVER_NAME="$(hostname)"
 SSHD_PORT=22
-
-# nxlibs need to find nxclient, so set PATH according to PATH_BIN, iff not already covered.     
-if ( echo $PATH | grep -v "$PATH_BIN" ); then export PATH=$PATH_BIN:$PATH; fi
 
 # Authentication / Security directives
 



1.65      +2 -2      freenx/nxnode


rev 1.65, prev_rev 1.64
Index: nxnode
===================================================================
RCS file: /cvsroot/freenx/freenx/nxnode,v
retrieving revision 1.64
retrieving revision 1.65
diff -u -r1.64 -r1.65
--- nxnode	4 Jul 2005 01:03:19 -0000	1.64
+++ nxnode	8 Jul 2005 00:05:29 -0000	1.65
@@ -13,7 +13,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxnode,v 1.64 2005/07/04 01:03:19 fabianx Exp $
+# CVS: $Id: nxnode,v 1.65 2005/07/08 00:05:29 fabianx Exp $
 #
 # 21.06.2004: - Full reconnection support
 
@@ -276,7 +276,7 @@
 		IFS=$OLD_IFS
 		FP=""
 		[ -n "$AGENT_FONT_SERVER" ] && FP="-fp $AGENT_FONT_SERVER"
-		$PATH_BIN/nxagent $P $R -name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" -option "$USER_FAKE_HOME/.nx/C-$sess_id/options" $K $G $B $FP :$display $AGENT_EXTRA_OPTIONS_X 2>>$USER_FAKE_HOME/.nx/C-$sess_id/session &
+		PATH="$PATH_BIN:$PATH" $PATH_BIN/nxagent $P $R -name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" -option "$USER_FAKE_HOME/.nx/C-$sess_id/options" $K $G $B $FP :$display $AGENT_EXTRA_OPTIONS_X 2>>$USER_FAKE_HOME/.nx/C-$sess_id/session &
 	fi
 	PID=$!
 	mkdir -p $USER_FAKE_HOME/.nx/C-$sess_id/pids/






From freenx-cvs at berlios.de  Sun Jul 10 17:13:19 2005
From: freenx-cvs at berlios.de (jonno)
Date: Sun, 10 Jul 2005 17:13:19 +0200
Subject: [Freenx-cvs] CVS: freenx - jonno modified nxserver
Message-ID: <42D13B0F.mailDHT1WJPNY@lists.berlios.de>

User:      jonno
Date:      2005-07-10 15:13:19 GMT
Modified:  .        nxserver
Log:
Fixing bug #4479. NX_LOGFILE will now be created if the nx user has permision to do so (using touch)

Revision  Changes    Path
1.63      +2 -1      freenx/nxserver


rev 1.63, prev_rev 1.62
Index: nxserver
===================================================================
RCS file: /cvsroot/freenx/freenx/nxserver,v
retrieving revision 1.62
retrieving revision 1.63
diff -u -r1.62 -r1.63
--- nxserver	6 Jul 2005 15:59:05 -0000	1.62
+++ nxserver	10 Jul 2005 15:13:19 -0000	1.63
@@ -11,7 +11,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxserver,v 1.62 2005/07/06 15:59:05 fux Exp $
+# CVS: $Id: nxserver,v 1.63 2005/07/10 15:13:19 jonno Exp $
 #
 
 # Read the config file
@@ -423,6 +423,7 @@
 }
 
 # Start!
+[ "$NX_LOG_LEVEL" -ge "1" ] && touch "$NX_LOGFILE" >/dev/null 2>&1
 log 3 "-- NX SERVER START: $@"
 
 if [ "$ENABLE_SERVER_FORWARD" = "1" -a -n "$SERVER_FORWARD_HOST" ]






From freenx-cvs at berlios.de  Wed Jul 13 02:20:49 2005
From: freenx-cvs at berlios.de (fabianx)
Date: Wed, 13 Jul 2005 02:20:49 +0200
Subject: [Freenx-cvs] CVS: freenx - fabianx modified 2 files
Message-ID: <42D45E61.mailFEM11GVDX@lists.berlios.de>

User:      fabianx
Date:      2005-07-13 00:20:49 GMT
Modified:  .        ChangeLog nxnode
Log:
Finally fixed problems with GNOME.

@Jonno:

2>>file means: append stderr to 'file'.
>>file means: append stdout to the file.
>>file 2>&1 means: append stdout to 'file' and redirect stderr to stdout, which points to file, so redirect stderr to 'file'
-- AND:
2>&1 >>file means: Redirect stderr to stdout and append stdout to file (stderr is given on standard out in this example)

Revision  Changes    Path
1.70      +1 -0      freenx/ChangeLog


rev 1.70, prev_rev 1.69
Index: ChangeLog
===================================================================
RCS file: /cvsroot/freenx/freenx/ChangeLog,v
retrieving revision 1.69
retrieving revision 1.70
diff -u -r1.69 -r1.70
--- ChangeLog	6 Jul 2005 15:59:05 -0000	1.69
+++ ChangeLog	13 Jul 2005 00:20:47 -0000	1.70
@@ -18,6 +18,7 @@
 	  Useful after a power outage.
 	* Fixed nxclient invocation with non-standard installation path
 	* Added detection of SSH2_CLIENT variable (commercial ssh)
+	* Finally fixed problems with GNOME.
 
 24.06.2005 FreeNX 0.4.1 "LinuxTag Edition"
 	* Fixed a small security problem giving access to session database.



1.66      +3 -3      freenx/nxnode


rev 1.66, prev_rev 1.65
Index: nxnode
===================================================================
RCS file: /cvsroot/freenx/freenx/nxnode,v
retrieving revision 1.65
retrieving revision 1.66
diff -u -r1.65 -r1.66
--- nxnode	8 Jul 2005 00:05:29 -0000	1.65
+++ nxnode	13 Jul 2005 00:20:48 -0000	1.66
@@ -13,7 +13,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxnode,v 1.65 2005/07/08 00:05:29 fabianx Exp $
+# CVS: $Id: nxnode,v 1.66 2005/07/13 00:20:48 fabianx Exp $
 #
 # 21.06.2004: - Full reconnection support
 
@@ -194,10 +194,10 @@
 	[ "$virtualdesktop" = "0" -a "$ENABLE_ROOTLESS_MODE" != "1" ] && export LD_PRELOAD="$APPLICATION_LIBRARY_PRELOAD:$LD_PRELOAD"
 	if [ "$virtualdesktop" = "1" -a "$type" = "unix-application" -a "$DEFAULT_X_WM" != "" -a -x "$(find_app $DEFAULT_X_WM)" ]
 	then
-		DISPLAY=unix:$display $DEFAULT_X_WM 2>>$USER_FAKE_HOME/.nx/C-$sess_id/session &
+		DISPLAY=unix:$display $DEFAULT_X_WM >>$USER_FAKE_HOME/.nx/C-$sess_id/session 2>&1 &
 		WM_PID=$!
 	fi
-	DISPLAY=unix:$display $STARTX 2>>$USER_FAKE_HOME/.nx/C-$sess_id/session &
+	DISPLAY=unix:$display $STARTX >>$USER_FAKE_HOME/.nx/C-$sess_id/session 2>&1 &
 	APP_PID=$!
 	mkdir -p $USER_FAKE_HOME/.nx/C-$sess_id/pids/
 	echo "$APP_PID" > $USER_FAKE_HOME/.nx/C-$sess_id/pids/applications






From freenx-cvs at berlios.de  Sat Jul 16 17:45:37 2005
From: freenx-cvs at berlios.de (fabianx)
Date: Sat, 16 Jul 2005 17:45:37 +0200
Subject: [Freenx-cvs] CVS: freenx - fabianx modified 5 files
Message-ID: <42D92BA1.mailCH31SOS2T@lists.berlios.de>

User:      fabianx
Date:      2005-07-16 15:45:37 GMT
Modified:  .        ChangeLog nxloadconfig nxnode nxserver nxsetup
Log:
* FINALLY added Solaris Support Patch.

Revision  Changes    Path
1.71      +1 -0      freenx/ChangeLog


rev 1.71, prev_rev 1.70
Index: ChangeLog
===================================================================
RCS file: /cvsroot/freenx/freenx/ChangeLog,v
retrieving revision 1.70
retrieving revision 1.71
diff -u -r1.70 -r1.71
--- ChangeLog	13 Jul 2005 00:20:47 -0000	1.70
+++ ChangeLog	16 Jul 2005 15:45:36 -0000	1.71
@@ -19,6 +19,7 @@
 	* Fixed nxclient invocation with non-standard installation path
 	* Added detection of SSH2_CLIENT variable (commercial ssh)
 	* Finally fixed problems with GNOME.
+	* FINALLY added Solaris Support Patch.
 
 24.06.2005 FreeNX 0.4.1 "LinuxTag Edition"
 	* Fixed a small security problem giving access to session database.



1.36      +34 -1     freenx/nxloadconfig


rev 1.36, prev_rev 1.35
Index: nxloadconfig
===================================================================
RCS file: /cvsroot/freenx/freenx/nxloadconfig,v
retrieving revision 1.35
retrieving revision 1.36
diff -u -r1.35 -r1.36
--- nxloadconfig	8 Jul 2005 00:05:29 -0000	1.35
+++ nxloadconfig	16 Jul 2005 15:45:36 -0000	1.36
@@ -5,7 +5,7 @@
 #
 # License: GPL, version 2
 #
-# CVS: $Id: nxloadconfig,v 1.35 2005/07/08 00:05:29 fabianx Exp $
+# CVS: $Id: nxloadconfig,v 1.36 2005/07/16 15:45:36 fabianx Exp $
 #
 # ========================================================================
 
@@ -174,6 +174,39 @@
 PROXY_TCP_NODELAY="0"
 PROXY_EXTRA_OPTIONS=""
 
+############################################################################
+# OS specific directives
+############################################################################
+
+OS="$( uname -sr )"
+
+case "$OS" in
+	"SunOS 5.10")
+		DEFAULT_X_WM=cdwm
+		DEFAULT_X_SESSION=/etc/X11/gdm/Xsession
+		COMMAND_XTERM=/usr/openwin/bin/xterm
+		COMMAND_XAUTH=/usr/openwin/bin/xauth
+		COMMAND_CUPSD=/opt/sfw/cups/sbin/cupsd
+		PATH=/usr/xpg4/bin:/usr/openwin/bin:$PATH
+		export PATH
+		;;
+esac
+
+# replace incompatible commands
+
+case "$OS" in
+       "SunOS 5.10")
+               function which()
+               {
+                       [ -e "$1" ] && echo $1 && return 0
+                       [ -z "$1" ] && return 1
+                       for i in  $(echo $PATH | tr ":" "\n"); do
+                               [ -e $i/$1 ] && echo $i/$1 && return 0
+                       done
+                       return 1
+               }
+       ;;
+esac
 
 #########################################################################
 # node.conf file evaluation



1.67      +2 -2      freenx/nxnode


rev 1.67, prev_rev 1.66
Index: nxnode
===================================================================
RCS file: /cvsroot/freenx/freenx/nxnode,v
retrieving revision 1.66
retrieving revision 1.67
diff -u -r1.66 -r1.67
--- nxnode	13 Jul 2005 00:20:48 -0000	1.66
+++ nxnode	16 Jul 2005 15:45:37 -0000	1.67
@@ -13,7 +13,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxnode,v 1.66 2005/07/13 00:20:48 fabianx Exp $
+# CVS: $Id: nxnode,v 1.67 2005/07/16 15:45:37 fabianx Exp $
 #
 # 21.06.2004: - Full reconnection support
 
@@ -42,7 +42,7 @@
 # Reread boot command line; echo last parameter's argument or return false.
 getparam(){
 stringinstring "&$1=" "$CMDLINE" || return 1
-echo "$CMDLINE" | awk "/^$1=/"' { VAL=$2 } END { print VAL }' FS="=" RS="(&|\n)"
+echo "$CMDLINE" |  tr "&" "\n" | egrep "^"$1"=" | awk -F= '{ VAL=$2 } END { print VAL }'
 return 0
 }
 



1.64      +2 -2      freenx/nxserver


rev 1.64, prev_rev 1.63
Index: nxserver
===================================================================
RCS file: /cvsroot/freenx/freenx/nxserver,v
retrieving revision 1.63
retrieving revision 1.64
diff -u -r1.63 -r1.64
--- nxserver	10 Jul 2005 15:13:19 -0000	1.63
+++ nxserver	16 Jul 2005 15:45:37 -0000	1.64
@@ -11,7 +11,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxserver,v 1.63 2005/07/10 15:13:19 jonno Exp $
+# CVS: $Id: nxserver,v 1.64 2005/07/16 15:45:37 fabianx Exp $
 #
 
 # Read the config file
@@ -27,7 +27,7 @@
 # Reread boot command line; echo last parameter's argument or return false.
 getparam(){
 stringinstring "&$1=" "$CMDLINE" || return 1
-echo "$CMDLINE" | awk "/^$1=/"' { VAL=$2 } END { print VAL }' FS="=" RS="(&|\n)"
+echo "$CMDLINE" |  tr "&" "\n" | egrep "^"$1"=" | awk -F= '{ VAL=$2 } END { print VAL }'
 return 0
 }
 



1.29      +2 -2      freenx/nxsetup


rev 1.29, prev_rev 1.28
Index: nxsetup
===================================================================
RCS file: /cvsroot/freenx/freenx/nxsetup,v
retrieving revision 1.28
retrieving revision 1.29
diff -u -r1.28 -r1.29
--- nxsetup	5 May 2005 08:04:24 -0000	1.28
+++ nxsetup	16 Jul 2005 15:45:37 -0000	1.29
@@ -5,7 +5,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxsetup,v 1.28 2005/05/05 08:04:24 jonno Exp $ 
+# CVS: $Id: nxsetup,v 1.29 2005/07/16 15:45:37 fabianx Exp $ 
 #
 
 HELP="no"
@@ -109,7 +109,7 @@
 {
 	set -e
 	
-	if [ "$(pidof sshd)" = "" ]
+	if [ "$(pidof sshd 2>/dev/null)" = "" ]
 	then 
 		echo -n "Starting ssh service ..."
 		# Generate Host keys if they are not available, yet






From freenx-cvs at berlios.de  Sun Jul 17 01:59:40 2005
From: freenx-cvs at berlios.de (fabianx)
Date: Sun, 17 Jul 2005 01:59:40 +0200
Subject: [Freenx-cvs] CVS: freenx - fabianx modified ChangeLog
Message-ID: <42D99F6C.mailAPY115X7O@lists.berlios.de>

User:      fabianx
Date:      2005-07-16 23:59:37 GMT
Modified:  .        ChangeLog
Log:
Cleanup of ChangeLog for 0.4.2 release.

Revision  Changes    Path
1.72      +9 -6      freenx/ChangeLog


rev 1.72, prev_rev 1.71
Index: ChangeLog
===================================================================
RCS file: /cvsroot/freenx/freenx/ChangeLog,v
retrieving revision 1.71
retrieving revision 1.72
diff -u -r1.71 -r1.72
--- ChangeLog	16 Jul 2005 15:45:36 -0000	1.71
+++ ChangeLog	16 Jul 2005 23:59:35 -0000	1.72
@@ -1,16 +1,19 @@
-XX.07.2005 FreeNX 0.4.2 "Bugfix Edition"
-	* Removed buggy forwarding support via USER.
+16.07.2005 FreeNX 0.4.2 "Solaris / Bugfix / Linux Infotag Pforzheim Edition"
+	* Removed forwarding support via "freenx.<user>", because it was
+	  buggy.
 	* Cleaned up lots of code.
 		* Fixed one case of a left over file.
 		* Removed one unnecessary usage of a temporary file.
-	* Added exit handlers for more stability on reboot of system.
+	* Added exit handlers in nxserver and nxnode for more stability on 
+	  reboot of system.
 	* Changed nxnode to be much more stable.
-		* Added one missing nxagent case, which lead to 
-		  "zombie" sessions.
+		* Catched one additional "unclean termination of nxagent" 
+		  case, which lead to "zombie" sessions.
 	* Reworked reconnection support for more stability.
 		* Added displaying of reconnection failure in
 		  system log / client ssh log.
-	* Added even more possibilities for session startup failures.
+	* Added even more possibilities to catch and report session startup 
+	  failures.
 	* Fixed PNG and JPEG-levels pack method.
 	* Added usage of netcat -z to check that the port is really not used by
 	  another agent.






From freenx-cvs at berlios.de  Tue Jul 26 18:18:34 2005
From: freenx-cvs at berlios.de (fabianx)
Date: Tue, 26 Jul 2005 18:18:34 +0200
Subject: [Freenx-cvs] CVS: freenx - fabianx modified 2 files
Message-ID: <42E6625A.mailKBG11YTX8@lists.berlios.de>

User:      fabianx
Date:      2005-07-26 16:18:34 GMT
Modified:  .        ChangeLog nxserver
Log:
* Fixed reconnection problems with !M 1.5.0 client.

Revision  Changes    Path
1.73      +3 -0      freenx/ChangeLog


rev 1.73, prev_rev 1.72
Index: ChangeLog
===================================================================
RCS file: /cvsroot/freenx/freenx/ChangeLog,v
retrieving revision 1.72
retrieving revision 1.73
diff -u -r1.72 -r1.73
--- ChangeLog	16 Jul 2005 23:59:35 -0000	1.72
+++ ChangeLog	26 Jul 2005 16:18:34 -0000	1.73
@@ -1,3 +1,6 @@
+26.07.2005 FreeNX 0.4.3 "NoMachine 1.5.0 Edition"
+	* Fixed reconnection problems with !M 1.5.0 client.
+
 16.07.2005 FreeNX 0.4.2 "Solaris / Bugfix / Linux Infotag Pforzheim Edition"
 	* Removed forwarding support via "freenx.<user>", because it was
 	  buggy.



1.65      +6 -3      freenx/nxserver


rev 1.65, prev_rev 1.64
Index: nxserver
===================================================================
RCS file: /cvsroot/freenx/freenx/nxserver,v
retrieving revision 1.64
retrieving revision 1.65
diff -u -r1.64 -r1.65
--- nxserver	16 Jul 2005 15:45:37 -0000	1.64
+++ nxserver	26 Jul 2005 16:18:34 -0000	1.65
@@ -11,7 +11,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxserver,v 1.64 2005/07/16 15:45:37 fabianx Exp $
+# CVS: $Id: nxserver,v 1.65 2005/07/26 16:18:34 fabianx Exp $
 #
 
 # Read the config file
@@ -223,7 +223,7 @@
 		echo "------- ---------------- -------------------------------- -------- ----- -------------- --------- ----------------------" >> $TMPFILE
 	else
 		echo "Display Type             Session ID                       Options  Depth Screen         Status      Session Name" >> $TMPFILE
-		echo " ------- ---------------- -------------------------------- -------- ----- -------------- ----------- ------------------------------" >> $TMPFILE
+		echo "------- ---------------- -------------------------------- -------- ----- -------------- ----------- ------------------------------" >> $TMPFILE
 	fi
 	for i in $NX_SESS_DIR/running/*
 	do
@@ -249,7 +249,7 @@
 			then
 				available="Yes"
 			fi
-			echo -e "$(getparam display)\t$(getparam type)\t$(getparam sessionId)\t$options\t$depth\t$geom\t$available\t$(getparam sessionName)" >> $TMPFILE
+			printf "%-7s %-16s %32s %8s %5s %-14s %-11s %s" "$(getparam display)" "$(getparam type)" "$(getparam sessionId)" "$options" "$depth" "$geom" "$available" "$(getparam sessionName)" >> $TMPFILE
 		fi
 		egrep -q "^userName=$1$" $i && let SESSION_COUNT_USER=$SESSION_COUNT_USER+1
 	done
@@ -894,6 +894,9 @@
 			then
 				# disabled due to problems with 1.4.0-5 client
 				#session_list_user_suspended "$USER" 'Suspended$|^status=Running$' "$(getparam geometry)" "$(getparam type)" | log_tee
+				session_list_user_suspended "$USER" 'Suspended' "$(getparam geometry)" "$(getparam type)" | log_tee
+			elif [ "$status" = "suspended,running" -o "$status" = "suspended" ] # since 1.5.0
+			then
 				session_list_user_suspended "$USER" 'Suspended' "$(getparam geometry)" "$(getparam type)" | log_tee
 			else
 				session_list_user "$USER" | log_tee






From freenx-cvs at berlios.de  Wed Jul 27 00:51:42 2005
From: freenx-cvs at berlios.de (fabianx)
Date: Wed, 27 Jul 2005 00:51:42 +0200
Subject: [Freenx-cvs] CVS: freenx - fabianx modified 2 files
Message-ID: <42E6BE7E.mail8J11DL3O@lists.berlios.de>

User:      fabianx
Date:      2005-07-26 22:51:41 GMT
Modified:  .        ChangeLog nxnode
Log:
* Fixed reconnection problems with !M 1.5.0 backend:

The SIGHUP signal was propagated to the monitor as "End of session requested by", which lead to the termination of the session by FreeNX.

Fixed now by checking for SIGHUP in the line.

Revision  Changes    Path
1.74      +1 -0      freenx/ChangeLog


rev 1.74, prev_rev 1.73
Index: ChangeLog
===================================================================
RCS file: /cvsroot/freenx/freenx/ChangeLog,v
retrieving revision 1.73
retrieving revision 1.74
diff -u -r1.73 -r1.74
--- ChangeLog	26 Jul 2005 16:18:34 -0000	1.73
+++ ChangeLog	26 Jul 2005 22:51:40 -0000	1.74
@@ -1,5 +1,6 @@
 26.07.2005 FreeNX 0.4.3 "NoMachine 1.5.0 Edition"
 	* Fixed reconnection problems with !M 1.5.0 client.
+	* Fixed reconnection problems with !M 1.5.0 backend.
 
 16.07.2005 FreeNX 0.4.2 "Solaris / Bugfix / Linux Infotag Pforzheim Edition"
 	* Removed forwarding support via "freenx.<user>", because it was



1.68      +2 -2      freenx/nxnode


rev 1.68, prev_rev 1.67
Index: nxnode
===================================================================
RCS file: /cvsroot/freenx/freenx/nxnode,v
retrieving revision 1.67
retrieving revision 1.68
diff -u -r1.67 -r1.68
--- nxnode	16 Jul 2005 15:45:37 -0000	1.67
+++ nxnode	26 Jul 2005 22:51:40 -0000	1.68
@@ -13,7 +13,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxnode,v 1.67 2005/07/16 15:45:37 fabianx Exp $
+# CVS: $Id: nxnode,v 1.68 2005/07/26 22:51:40 fabianx Exp $
 #
 # 21.06.2004: - Full reconnection support
 
@@ -493,7 +493,7 @@
 		# Session end
 		#
 		
-		if stringinstring "Info: End of session requested by " "$line" && [ "$RECONNECT" = "0" ]
+		if stringinstring "Info: End of session requested by " "$line" && [ "$RECONNECT" = "0" ] || stringinstring "'SIGHUP'" "$line"
 		then
 			echo "NX> 1009 Session status: terminating"
 			kill $PROXY_PID 2>/dev/null






From freenx-cvs at berlios.de  Wed Jul 27 02:21:56 2005
From: freenx-cvs at berlios.de (fabianx)
Date: Wed, 27 Jul 2005 02:21:56 +0200
Subject: [Freenx-cvs] CVS: freenx - fabianx modified nxnode
Message-ID: <42E6D3A4.mail3PF11U5WO@lists.berlios.de>

User:      fabianx
Date:      2005-07-27 00:21:55 GMT
Modified:  .        nxnode
Log:
Commited the correct fix for 1.5.0 resume problems.

De'Morgan: "'a && !b' != 'a || b'" of course ...

Revision  Changes    Path
1.69      +2 -2      freenx/nxnode


rev 1.69, prev_rev 1.68
Index: nxnode
===================================================================
RCS file: /cvsroot/freenx/freenx/nxnode,v
retrieving revision 1.68
retrieving revision 1.69
diff -u -r1.68 -r1.69
--- nxnode	26 Jul 2005 22:51:40 -0000	1.68
+++ nxnode	27 Jul 2005 00:21:44 -0000	1.69
@@ -13,7 +13,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxnode,v 1.68 2005/07/26 22:51:40 fabianx Exp $
+# CVS: $Id: nxnode,v 1.69 2005/07/27 00:21:44 fabianx Exp $
 #
 # 21.06.2004: - Full reconnection support
 
@@ -493,7 +493,7 @@
 		# Session end
 		#
 		
-		if stringinstring "Info: End of session requested by " "$line" && [ "$RECONNECT" = "0" ] || stringinstring "'SIGHUP'" "$line"
+		if stringinstring "Info: End of session requested by " "$line" && [ "$RECONNECT" = "0" ] && ! stringinstring "'SIGHUP'" "$line"
 		then
 			echo "NX> 1009 Session status: terminating"
 			kill $PROXY_PID 2>/dev/null






From freenx-cvs at berlios.de  Wed Jul 27 02:36:53 2005
From: freenx-cvs at berlios.de (fabianx)
Date: Wed, 27 Jul 2005 02:36:53 +0200
Subject: [Freenx-cvs] CVS: freenx - fabianx modified gentoo-nomachine.diff
Message-ID: <42E6D725.mailAHC11820B@lists.berlios.de>

User:      fabianx
Date:      2005-07-27 00:36:53 GMT
Modified:  .        gentoo-nomachine.diff
Log:
Changed gentoo-nomachine.diff again.

Revision  Changes    Path
1.15      +2 -2      freenx/gentoo-nomachine.diff


rev 1.15, prev_rev 1.14
Index: gentoo-nomachine.diff
===================================================================
RCS file: /cvsroot/freenx/freenx/gentoo-nomachine.diff,v
retrieving revision 1.14
retrieving revision 1.15
diff -u -r1.14 -r1.15
--- gentoo-nomachine.diff	12 Mar 2005 17:55:13 -0000	1.14
+++ gentoo-nomachine.diff	27 Jul 2005 00:36:51 -0000	1.15
@@ -15,5 +15,5 @@
 +NX_SESS_DIR=$NX_DIR/var/db
 +NX_HOME_DIR=$NX_DIR/home/nx
  
- # the name of the authorized keys file for ssh
- SSH_AUTHORIZED_KEYS="authorized_keys2"
+ # Advanced users ONLY
+ AGENT_LIBRARY_PATH="" #Calculated






From freenx-cvs at berlios.de  Wed Jul 27 02:52:38 2005
From: freenx-cvs at berlios.de (fabianx)
Date: Wed, 27 Jul 2005 02:52:38 +0200
Subject: [Freenx-cvs] CVS: freenx - fabianx modified 2 files
Message-ID: <42E6DAD6.mailI1P118HEF@lists.berlios.de>

User:      fabianx
Date:      2005-07-27 00:52:36 GMT
Modified:  .        ChangeLog nxloadconfig
Log:
* Added evaluation of $NX_ETC_DIR/node.conf.d/* config files.

(Request and idea by Edward A. Warnicke <eaw at users.berlios.de>)

Revision  Changes    Path
1.75      +1 -0      freenx/ChangeLog


rev 1.75, prev_rev 1.74
Index: ChangeLog
===================================================================
RCS file: /cvsroot/freenx/freenx/ChangeLog,v
retrieving revision 1.74
retrieving revision 1.75
diff -u -r1.74 -r1.75
--- ChangeLog	26 Jul 2005 22:51:40 -0000	1.74
+++ ChangeLog	27 Jul 2005 00:52:29 -0000	1.75
@@ -1,6 +1,7 @@
 26.07.2005 FreeNX 0.4.3 "NoMachine 1.5.0 Edition"
 	* Fixed reconnection problems with !M 1.5.0 client.
 	* Fixed reconnection problems with !M 1.5.0 backend.
+	* Added evaluation of $NX_ETC_DIR/node.conf.d/* config files.
 
 16.07.2005 FreeNX 0.4.2 "Solaris / Bugfix / Linux Infotag Pforzheim Edition"
 	* Removed forwarding support via "freenx.<user>", because it was



1.37      +9 -1      freenx/nxloadconfig


rev 1.37, prev_rev 1.36
Index: nxloadconfig
===================================================================
RCS file: /cvsroot/freenx/freenx/nxloadconfig,v
retrieving revision 1.36
retrieving revision 1.37
diff -u -r1.36 -r1.37
--- nxloadconfig	16 Jul 2005 15:45:36 -0000	1.36
+++ nxloadconfig	27 Jul 2005 00:52:36 -0000	1.37
@@ -5,7 +5,7 @@
 #
 # License: GPL, version 2
 #
-# CVS: $Id: nxloadconfig,v 1.36 2005/07/16 15:45:36 fabianx Exp $
+# CVS: $Id: nxloadconfig,v 1.37 2005/07/27 00:52:36 fabianx Exp $
 #
 # ========================================================================
 
@@ -211,6 +211,14 @@
 #########################################################################
 # node.conf file evaluation
 #########################################################################
+
+if [ -d $NX_ETC_DIR/node.conf.d ]
+then
+	for i in $NX_ETC_DIR/node.conf.d/*
+	do
+		[ -e $i ] && . $i
+	done
+fi
 
 [ -e $NX_ETC_DIR/node.conf ] && . $NX_ETC_DIR/node.conf
 [ "$USERCONF" = "yes" -a -e $NX_ETC_DIR/$USER.node.conf ] && . $NX_ETC_DIR/$USER.node.conf






From freenx-cvs at berlios.de  Wed Jul 27 13:10:23 2005
From: freenx-cvs at berlios.de (fabianx)
Date: Wed, 27 Jul 2005 13:10:23 +0200
Subject: [Freenx-cvs] CVS: freenx - fabianx modified 2 files
Message-ID: <42E76B9F.mail9F1196YI@lists.berlios.de>

User:      fabianx
Date:      2005-07-27 11:10:23 GMT
Modified:  .        ChangeLog nxserver
Log:
* Fixed a possible security problem. (The client was able
  to overwrite parameters set by the server)

Revision  Changes    Path
1.76      +2 -0      freenx/ChangeLog


rev 1.76, prev_rev 1.75
Index: ChangeLog
===================================================================
RCS file: /cvsroot/freenx/freenx/ChangeLog,v
retrieving revision 1.75
retrieving revision 1.76
diff -u -r1.75 -r1.76
--- ChangeLog	27 Jul 2005 00:52:29 -0000	1.75
+++ ChangeLog	27 Jul 2005 11:10:22 -0000	1.76
@@ -2,6 +2,8 @@
 	* Fixed reconnection problems with !M 1.5.0 client.
 	* Fixed reconnection problems with !M 1.5.0 backend.
 	* Added evaluation of $NX_ETC_DIR/node.conf.d/* config files.
+	* Fixed a possible security problem. (The client was able 
+	  to overwrite parameters set by the server)
 
 16.07.2005 FreeNX 0.4.2 "Solaris / Bugfix / Linux Infotag Pforzheim Edition"
 	* Removed forwarding support via "freenx.<user>", because it was



1.66      +3 -3      freenx/nxserver


rev 1.66, prev_rev 1.65
Index: nxserver
===================================================================
RCS file: /cvsroot/freenx/freenx/nxserver,v
retrieving revision 1.65
retrieving revision 1.66
diff -u -r1.65 -r1.66
--- nxserver	26 Jul 2005 16:18:34 -0000	1.65
+++ nxserver	27 Jul 2005 11:10:22 -0000	1.66
@@ -11,7 +11,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxserver,v 1.65 2005/07/26 16:18:34 fabianx Exp $
+# CVS: $Id: nxserver,v 1.66 2005/07/27 11:10:22 fabianx Exp $
 #
 
 # Read the config file
@@ -808,7 +808,7 @@
 		fi
 	
 		uniqueid=$(echo $[$RANDOM*$RANDOM] | md5sum | cut -d" " -f1 | tr "[a-z]" "[A-Z]")
-		FULL_PARAMS="user=$USER&userip=$USERIP&uniqueid=$uniqueid&display=$SESS_DISPLAY&$PARAMS"
+		FULL_PARAMS="$PARAMS&user=$USER&userip=$USERIP&uniqueid=$uniqueid&display=$SESS_DISPLAY"
 		log 6 "$FULL_PARAMS"
 
 		# now update the session listing
@@ -820,7 +820,7 @@
 		session_change "$uniqueid" "foreignAddress" "$USERIP"
 
 		CMDLINE=$(session_get "$uniqueid")
-		FULL_PARAMS="user=$USER&userip=$(getparam foreignAddress)&uniqueid=$uniqueid&display=$(getparam display)$PARAMS"
+		FULL_PARAMS="$PARAMS&user=$USER&userip=$(getparam foreignAddress)&uniqueid=$uniqueid&display=$(getparam display)"
 		SESS_DISPLAY=$(getparam display)
 	fi
 






From freenx-cvs at berlios.de  Wed Jul 27 14:06:37 2005
From: freenx-cvs at berlios.de (fabianx)
Date: Wed, 27 Jul 2005 14:06:37 +0200
Subject: [Freenx-cvs] CVS: freenx - fabianx modified 5 files
Message-ID: <42E778CD.mailLOG11FMMT@lists.berlios.de>

User:      fabianx
Date:      2005-07-27 12:06:37 GMT
Modified:  .        ChangeLog node.conf.sample nxloadconfig nxnode
Modified:           nxserver
Log:
* Added support for fake cookie authentication with !M 1.5.0 client
  and 1.5.0 backend. (ENABLE_1_5_0_BACKEND configuration directive)

Revision  Changes    Path
1.77      +2 -0      freenx/ChangeLog


rev 1.77, prev_rev 1.76
Index: ChangeLog
===================================================================
RCS file: /cvsroot/freenx/freenx/ChangeLog,v
retrieving revision 1.76
retrieving revision 1.77
diff -u -r1.76 -r1.77
--- ChangeLog	27 Jul 2005 11:10:22 -0000	1.76
+++ ChangeLog	27 Jul 2005 12:06:37 -0000	1.77
@@ -4,6 +4,8 @@
 	* Added evaluation of $NX_ETC_DIR/node.conf.d/* config files.
 	* Fixed a possible security problem. (The client was able 
 	  to overwrite parameters set by the server)
+	* Added support for fake cookie authentication with !M 1.5.0 client
+	  and 1.5.0 backend. (ENABLE_1_5_0_BACKEND configuration directive)
 
 16.07.2005 FreeNX 0.4.2 "Solaris / Bugfix / Linux Infotag Pforzheim Edition"
 	* Removed forwarding support via "freenx.<user>", because it was



1.30      +5 -1      freenx/node.conf.sample


rev 1.30, prev_rev 1.29
Index: node.conf.sample
===================================================================
RCS file: /cvsroot/freenx/freenx/node.conf.sample,v
retrieving revision 1.29
retrieving revision 1.30
diff -u -r1.29 -r1.30
--- node.conf.sample	5 Jul 2005 21:42:57 -0000	1.29
+++ node.conf.sample	27 Jul 2005 12:06:37 -0000	1.30
@@ -37,7 +37,7 @@
 #
 #           https://mail.kde.org/mailman/listinfo/freenx-knx
 #
-# CVS: $Id: node.conf.sample,v 1.29 2005/07/05 21:42:57 fabianx Exp $
+# CVS: $Id: node.conf.sample,v 1.30 2005/07/27 12:06:37 fabianx Exp $
 
 #########################################################################
 # General FreeNX directives
@@ -321,6 +321,10 @@
 
 # When set to 1 will start nxagent in rootless mode.
 #ENABLE_ROOTLESS_MODE="0"
+
+# When set to 1 enables fake cookie authentication, when a 1.5.0 client 
+# connects.
+#ENABLE_1_5_0_BACKEND="0"
 
 # If enabled writes entries via the COMMAND_SESSREG program
 # into utmp/wtmp/lastlog database.



1.38      +2 -1      freenx/nxloadconfig


rev 1.38, prev_rev 1.37
Index: nxloadconfig
===================================================================
RCS file: /cvsroot/freenx/freenx/nxloadconfig,v
retrieving revision 1.37
retrieving revision 1.38
diff -u -r1.37 -r1.38
--- nxloadconfig	27 Jul 2005 00:52:36 -0000	1.37
+++ nxloadconfig	27 Jul 2005 12:06:37 -0000	1.38
@@ -5,7 +5,7 @@
 #
 # License: GPL, version 2
 #
-# CVS: $Id: nxloadconfig,v 1.37 2005/07/27 00:52:36 fabianx Exp $
+# CVS: $Id: nxloadconfig,v 1.38 2005/07/27 12:06:37 fabianx Exp $
 #
 # ========================================================================
 
@@ -165,6 +165,7 @@
 EXPORT_SESSIONID="0"
 NODE_AUTOSTART=""
 ENABLE_ROOTLESS_MODE="0"
+ENABLE_1_5_0_BACKEND="0"
 ENABLE_USESSION="0"
 COMMAND_SESSREG="sessreg"
 AGENT_EXTRA_OPTIONS_RFB=""



1.70      +9 -1      freenx/nxnode


rev 1.70, prev_rev 1.69
Index: nxnode
===================================================================
RCS file: /cvsroot/freenx/freenx/nxnode,v
retrieving revision 1.69
retrieving revision 1.70
diff -u -r1.69 -r1.70
--- nxnode	27 Jul 2005 00:21:44 -0000	1.69
+++ nxnode	27 Jul 2005 12:06:37 -0000	1.70
@@ -13,7 +13,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxnode,v 1.69 2005/07/27 00:21:44 fabianx Exp $
+# CVS: $Id: nxnode,v 1.70 2005/07/27 12:06:37 fabianx Exp $
 #
 # 21.06.2004: - Full reconnection support
 
@@ -628,6 +628,8 @@
 	agent_server=$(getparam agent_server)
 	agent_user=$(getparam agent_user)
 	agent_password=$(getparam agent_password)
+	
+	clientproto=$(getparam clientproto)
 
 	[ "$EXPORT_USERIP" = "1" ] && export NXUSERIP="$userip"
 
@@ -653,6 +655,12 @@
 	[ "$imagecompressionmethod" = "2" ] && PACK="pack=16m-png-9,"
 	
 	proxy_cookie=$(echo $[$RANDOM*$RANDOM] | md5sum | cut -d" " -f1)
+
+	if [ "$ENABLE_1_5_0_BACKEND" = "1" -a "$clientproto" = "1.5.0" ]
+	then
+		# enable fake cookie authentication
+		cookie=$proxy_cookie
+	fi
 
 	# write options file
 	[ -z "$samba" ] && samba=0



1.67      +2 -1      freenx/nxserver


rev 1.67, prev_rev 1.66
Index: nxserver
===================================================================
RCS file: /cvsroot/freenx/freenx/nxserver,v
retrieving revision 1.66
retrieving revision 1.67
diff -u -r1.66 -r1.67
--- nxserver	27 Jul 2005 11:10:22 -0000	1.66
+++ nxserver	27 Jul 2005 12:06:37 -0000	1.67
@@ -11,7 +11,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxserver,v 1.66 2005/07/27 11:10:22 fabianx Exp $
+# CVS: $Id: nxserver,v 1.67 2005/07/27 12:06:37 fabianx Exp $
 #
 
 # Read the config file
@@ -722,6 +722,7 @@
 	
 	server_get_params $CMD
 	PARAMS=$SERVER_PARAMS
+	PARAMS="$PARAMS&clientproto=$PROTO"
 	CMDLINE=$PARAMS
 	echo_x
 	






From freenx-cvs at berlios.de  Wed Jul 27 14:13:08 2005
From: freenx-cvs at berlios.de (fabianx)
Date: Wed, 27 Jul 2005 14:13:08 +0200
Subject: [Freenx-cvs] CVS: freenx - fabianx modified 2 files
Message-ID: <42E77A54.mail19319XXE6@lists.berlios.de>

User:      fabianx
Date:      2005-07-27 12:13:08 GMT
Modified:  .        ChangeLog nxnode
Log:
* Fixed nxagent termination problems with !M 1.5.0
  backend.

Revision  Changes    Path
1.78      +6 -3      freenx/ChangeLog


rev 1.78, prev_rev 1.77
Index: ChangeLog
===================================================================
RCS file: /cvsroot/freenx/freenx/ChangeLog,v
retrieving revision 1.77
retrieving revision 1.78
diff -u -r1.77 -r1.78
--- ChangeLog	27 Jul 2005 12:06:37 -0000	1.77
+++ ChangeLog	27 Jul 2005 12:13:08 -0000	1.78
@@ -2,10 +2,13 @@
 	* Fixed reconnection problems with !M 1.5.0 client.
 	* Fixed reconnection problems with !M 1.5.0 backend.
 	* Added evaluation of $NX_ETC_DIR/node.conf.d/* config files.
-	* Fixed a possible security problem. (The client was able 
+	* Fixed a possible security problem. (The client was able
 	  to overwrite parameters set by the server)
-	* Added support for fake cookie authentication with !M 1.5.0 client
-	  and 1.5.0 backend. (ENABLE_1_5_0_BACKEND configuration directive)
+	* Added ENABLE_1_5_0_BACKEND configuration directive:
+		* Added support for fake cookie authentication with
+		  !M 1.5.0 client and 1.5.0 backend.
+		* Fixed nxagent termination problems with !M 1.5.0
+		  backend.
 
 16.07.2005 FreeNX 0.4.2 "Solaris / Bugfix / Linux Infotag Pforzheim Edition"
 	* Removed forwarding support via "freenx.<user>", because it was



1.71      +3 -2      freenx/nxnode


rev 1.71, prev_rev 1.70
Index: nxnode
===================================================================
RCS file: /cvsroot/freenx/freenx/nxnode,v
retrieving revision 1.70
retrieving revision 1.71
diff -u -r1.70 -r1.71
--- nxnode	27 Jul 2005 12:06:37 -0000	1.70
+++ nxnode	27 Jul 2005 12:13:08 -0000	1.71
@@ -13,7 +13,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxnode,v 1.70 2005/07/27 12:06:37 fabianx Exp $
+# CVS: $Id: nxnode,v 1.71 2005/07/27 12:13:08 fabianx Exp $
 #
 # 21.06.2004: - Full reconnection support
 
@@ -496,7 +496,8 @@
 		if stringinstring "Info: End of session requested by " "$line" && [ "$RECONNECT" = "0" ] && ! stringinstring "'SIGHUP'" "$line"
 		then
 			echo "NX> 1009 Session status: terminating"
-			kill $PROXY_PID 2>/dev/null
+			[ "$ENABLE_1_5_0_BACKEND" = "1" ] || kill $PROXY_PID 2>/dev/null
+			[ "$ENABLE_1_5_0_BACKEND" = "1" ] && kill -HUP $PROXY_PID 2>/dev/null
 		fi
 		
 		TERM=""






From freenx-cvs at berlios.de  Wed Jul 27 14:50:54 2005
From: freenx-cvs at berlios.de (fabianx)
Date: Wed, 27 Jul 2005 14:50:54 +0200
Subject: [Freenx-cvs] CVS: freenx - fabianx modified 2 files
Message-ID: <42E7832E.mail1C51WDFFY@lists.berlios.de>

User:      fabianx
Date:      2005-07-27 12:50:54 GMT
Modified:  .        ChangeLog nxnode
Log:
* Added RDP highcolor support for !M 1.5.0 client
  with !M 1.5.0 backend.
  (ENABLE_1_5_0_BACKEND needed)

Revision  Changes    Path
1.79      +2 -0      freenx/ChangeLog


rev 1.79, prev_rev 1.78
Index: ChangeLog
===================================================================
RCS file: /cvsroot/freenx/freenx/ChangeLog,v
retrieving revision 1.78
retrieving revision 1.79
diff -u -r1.78 -r1.79
--- ChangeLog	27 Jul 2005 12:13:08 -0000	1.78
+++ ChangeLog	27 Jul 2005 12:50:54 -0000	1.79
@@ -9,6 +9,8 @@
 		  !M 1.5.0 client and 1.5.0 backend.
 		* Fixed nxagent termination problems with !M 1.5.0
 		  backend.
+		* Added RDP highcolor support for !M 1.5.0 client
+		  with !M 1.5.0 backend.
 
 16.07.2005 FreeNX 0.4.2 "Solaris / Bugfix / Linux Infotag Pforzheim Edition"
 	* Removed forwarding support via "freenx.<user>", because it was



1.72      +10 -2     freenx/nxnode


rev 1.72, prev_rev 1.71
Index: nxnode
===================================================================
RCS file: /cvsroot/freenx/freenx/nxnode,v
retrieving revision 1.71
retrieving revision 1.72
diff -u -r1.71 -r1.72
--- nxnode	27 Jul 2005 12:13:08 -0000	1.71
+++ nxnode	27 Jul 2005 12:50:54 -0000	1.72
@@ -13,7 +13,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxnode,v 1.71 2005/07/27 12:13:08 fabianx Exp $
+# CVS: $Id: nxnode,v 1.72 2005/07/27 12:50:54 fabianx Exp $
 #
 # 21.06.2004: - Full reconnection support
 
@@ -629,6 +629,14 @@
 	agent_server=$(getparam agent_server)
 	agent_user=$(getparam agent_user)
 	agent_password=$(getparam agent_password)
+
+	if [ "$ENABLE_1_5_0_BACKEND" = "1" ]
+	then
+		rdpcolors=$(getparam rdpcolors)
+		rdpcache=$(getparam rdpcache)
+	else
+		unset rdpcolors rdpcache
+	fi
 	
 	clientproto=$(getparam clientproto)
 
@@ -679,7 +687,7 @@
 	umask 0077
 
 cat << EOF > $USER_FAKE_HOME/.nx/C-$sess_id/options
-${kbtype:+kbtype=$kbtype,}${CACHE}${IMAGES}${PACK}link=$link,type=$type,cleanup=0,${ACCEPT}cookie=$proxy_cookie,id=$sess_id,samba=$samba,media=$media${sync:+,sync=$sync}${cups:+,cups=$cups}:$display
+${kbtype:+kbtype=$kbtype,}${CACHE}${IMAGES}${PACK}link=$link,type=$type,cleanup=0,${ACCEPT}cookie=$proxy_cookie,id=$sess_id,samba=$samba,media=$media${sync:+,sync=$sync}${cups:+,cups=$cups}${rdpcolors:+,rdpcolors=$rdpcolors}${rdpcache:+,rdpcache=$rdpcache}:$display
 EOF
 	umask $OLD_UMASK
 #samba=$samba,






From freenx-cvs at berlios.de  Wed Jul 27 16:35:00 2005
From: freenx-cvs at berlios.de (fabianx)
Date: Wed, 27 Jul 2005 16:35:00 +0200
Subject: [Freenx-cvs] CVS: freenx - fabianx modified 5 files
Message-ID: <42E79B94.mail6YR1A41YE@lists.berlios.de>

User:      fabianx
Date:      2005-07-27 14:35:00 GMT
Modified:  .        ChangeLog node.conf.sample nxloadconfig
Modified:           nxnode-login nxserver
Log:
* Added secure logging - Passwords are no longer shown in log files.

New configuration directive: NX_LOG_SECURE="1". Disable for more speed while using verbose logging.

* Security: Certain passwords for VNC/RDP could have been visible via?
  `ps aux`.

nxnode-login was changed to accept a environment variable instead.

@Fux: Hope you are pleased now and I've catched all "problematic" variables.

Revision  Changes    Path
1.80      +3 -0      freenx/ChangeLog


rev 1.80, prev_rev 1.79
Index: ChangeLog
===================================================================
RCS file: /cvsroot/freenx/freenx/ChangeLog,v
retrieving revision 1.79
retrieving revision 1.80
diff -u -r1.79 -r1.80
--- ChangeLog	27 Jul 2005 12:50:54 -0000	1.79
+++ ChangeLog	27 Jul 2005 14:34:59 -0000	1.80
@@ -11,6 +11,9 @@
 		  backend.
 		* Added RDP highcolor support for !M 1.5.0 client
 		  with !M 1.5.0 backend.
+	* Added secure logging - Passwords are no longer shown in log files.
+	* Security: Certain passwords for VNC/RDP could have been visible via 
+	  `ps aux`.
 
 16.07.2005 FreeNX 0.4.2 "Solaris / Bugfix / Linux Infotag Pforzheim Edition"
 	* Removed forwarding support via "freenx.<user>", because it was



1.31      +4 -1      freenx/node.conf.sample


rev 1.31, prev_rev 1.30
Index: node.conf.sample
===================================================================
RCS file: /cvsroot/freenx/freenx/node.conf.sample,v
retrieving revision 1.30
retrieving revision 1.31
diff -u -r1.30 -r1.31
--- node.conf.sample	27 Jul 2005 12:06:37 -0000	1.30
+++ node.conf.sample	27 Jul 2005 14:34:59 -0000	1.31
@@ -37,7 +37,7 @@
 #
 #           https://mail.kde.org/mailman/listinfo/freenx-knx
 #
-# CVS: $Id: node.conf.sample,v 1.30 2005/07/27 12:06:37 fabianx Exp $
+# CVS: $Id: node.conf.sample,v 1.31 2005/07/27 14:34:59 fabianx Exp $
 
 #########################################################################
 # General FreeNX directives
@@ -129,6 +129,9 @@
 # 6: Debugging information
 # 7: stderror of some applications
 #NX_LOG_LEVEL=0
+
+# By setting this to 0 the nxserver might be a bit faster, but passwords can be found in the log files.
+#NX_LOG_SECURE=1
 
 # Before turning logging on, please make sure that NX_LOGFILE is
 # writeable for the "nx" user



1.39      +2 -1      freenx/nxloadconfig


rev 1.39, prev_rev 1.38
Index: nxloadconfig
===================================================================
RCS file: /cvsroot/freenx/freenx/nxloadconfig,v
retrieving revision 1.38
retrieving revision 1.39
diff -u -r1.38 -r1.39
--- nxloadconfig	27 Jul 2005 12:06:37 -0000	1.38
+++ nxloadconfig	27 Jul 2005 14:34:59 -0000	1.39
@@ -5,7 +5,7 @@
 #
 # License: GPL, version 2
 #
-# CVS: $Id: nxloadconfig,v 1.38 2005/07/27 12:06:37 fabianx Exp $
+# CVS: $Id: nxloadconfig,v 1.39 2005/07/27 14:34:59 fabianx Exp $
 #
 # ========================================================================
 
@@ -104,6 +104,7 @@
 # Logging directives
 
 NX_LOG_LEVEL=0
+NX_LOG_SECURE=1
 NX_LOGFILE=/var/log/nxserver.log
 SESSION_LOG_CLEAN=1
 SESSION_HISTORY=2592000



1.13      +3 -2      freenx/nxnode-login


rev 1.13, prev_rev 1.12
Index: nxnode-login
===================================================================
RCS file: /cvsroot/freenx/freenx/nxnode-login,v
retrieving revision 1.12
retrieving revision 1.13
diff -u -r1.12 -r1.13
--- nxnode-login	21 Mar 2005 13:00:21 -0000	1.12
+++ nxnode-login	27 Jul 2005 14:34:59 -0000	1.13
@@ -3,7 +3,7 @@
 # Copyright (c) 2004 by Fabian Franz.
 # License: GPL, version 2
 #
-# CVS: $Id: nxnode-login,v 1.12 2005/03/21 13:00:21 jonno Exp $
+# CVS: $Id: nxnode-login,v 1.13 2005/07/27 14:34:59 fabianx Exp $
 #
 
 # Syntax: nxnode-login {ssh|su} user ssh-port executable command tosend
@@ -14,13 +14,14 @@
 set executable [lindex $argv 3]
 set command [lindex $argv 4]
 set tosend [lindex $argv 5]
+catch {set tosend $env(NXNODE_TOSEND)}
 set command_ssh "ssh"
 catch {set command_ssh $env(COMMAND_SSH)}
 
 expect_user -re "(.*)\n" 
 set password $expect_out(1,string)
 
-set stty_init "raw icrnl"
+set stty_init "raw icrnl -echo"
 
 if { "$auth_method"=="ssh" } { 
 	set pid [spawn -noecho $command_ssh -2 -x -l "$user" "127.0.0.1" -o "NumberOfPasswordPrompts 1" -p "$port" "$executable $command" ]



1.68      +31 -7     freenx/nxserver


rev 1.68, prev_rev 1.67
Index: nxserver
===================================================================
RCS file: /cvsroot/freenx/freenx/nxserver,v
retrieving revision 1.67
retrieving revision 1.68
diff -u -r1.67 -r1.68
--- nxserver	27 Jul 2005 12:06:37 -0000	1.67
+++ nxserver	27 Jul 2005 14:34:59 -0000	1.68
@@ -11,7 +11,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxserver,v 1.67 2005/07/27 12:06:37 fabianx Exp $
+# CVS: $Id: nxserver,v 1.68 2005/07/27 14:34:59 fabianx Exp $
 #
 
 # Read the config file
@@ -404,6 +404,18 @@
 	[ "$NX_LOG_LEVEL" -ge "$1" -a -w "$NX_LOGFILE" ] && shift && echo "$@" >> "$NX_LOGFILE"
 }
 
+# Log in a way that is secure for passwords / cookies / ...
+
+log_secure()
+{
+	if [ "$NX_LOG_SECURE" = "0" ]
+	then
+		log "$@"
+	else
+		[ "$NX_LOG_LEVEL" -ge "$1" -a -w "$NX_LOGFILE" ] && shift && echo "$@ " | perl -pi -e 's/--cookie=".+?"/--cookie="******"/g; s/--agent_password=".+?"/agent_password="******"/g; s/--password=".+?"/password="******"/g; s/cookie=.+?&/cookie=******&/g; s/agent_password=.+?&/agent_password=******&/g; s/password=.+?&/password=******&/g;' >> "$NX_LOGFILE"
+	fi
+}
+
 log_tee()
 {
 	[ "$NX_LOG_LEVEL" -ge "4" -a -w "$NX_LOGFILE" ] && exec tee -a "$NX_LOGFILE"
@@ -595,10 +607,10 @@
 	if [ "$LOGIN_METHOD" = "SSH" ]
 	then
 	    export COMMAND_SSH
-	    echo "$PASS" | $PATH_BIN/nxnode-login -- ssh "$USER" "$SSHD_PORT" "$PATH_BIN/nxnode" "$CMD" "$@" 2>&1 | log_tee
+	    echo "$PASS" | NXNODE_TOSEND="$@" $PATH_BIN/nxnode-login -- ssh "$USER" "$SSHD_PORT" "$PATH_BIN/nxnode" "$CMD" 2>&1 | log_tee
 	elif [ "$LOGIN_METHOD" = "SU" ]
 	then
-	    echo "$PASS" | $PATH_BIN/nxnode-login -- su "$USER" "" "$PATH_BIN/nxnode" "$CMD" "$@" 2>&1 | log_tee
+	    echo "$PASS" | NXNODE_TOSEND="$@" $PATH_BIN/nxnode-login -- su "$USER" "" "$PATH_BIN/nxnode" "$CMD" 2>&1 | log_tee
 	else 
 	    echo "$@" | $COMMAND_SSH -l "$USER" 127.0.0.1 -p $SSHD_PORT -x -2 -i $NX_ETC_DIR/users.id_dsa -o 'PubkeyAuthentication yes' -o 'RSAAuthentication yes' -o 'RhostsAuthentication no' -o 'PasswordAuthentication no' -o 'RhostsRSAAuthentication no' -o 'StrictHostKeyChecking no' $PATH_BIN/nxnode "$CMD" | log_tee
 	fi
@@ -810,7 +822,7 @@
 	
 		uniqueid=$(echo $[$RANDOM*$RANDOM] | md5sum | cut -d" " -f1 | tr "[a-z]" "[A-Z]")
 		FULL_PARAMS="$PARAMS&user=$USER&userip=$USERIP&uniqueid=$uniqueid&display=$SESS_DISPLAY"
-		log 6 "$FULL_PARAMS"
+		log_secure "6" "$FULL_PARAMS"
 
 		# now update the session listing
 		CMDLINE="a=b&$FULL_PARAMS"
@@ -854,7 +866,19 @@
 	read CMD 2>/dev/null
 	# FIXME?
 	[ "$CMD" = "" ] && CMD="quit"
-	echo_x "$CMD"
+	
+	echo "$CMD"
+	
+	# Logging 
+	case "$CMD" in
+		startsession*|restoresession*|addmount*|addprinter*)
+			log_secure "4" "$CMD"
+		;;
+		*)
+			log "4" "$CMD"
+		;;
+	esac
+	
 	case "$CMD" in 
 		quit|QUIT)
 			echo_x "Quit"
@@ -965,13 +989,13 @@
 		addmount*)
 			server_get_params $CMD
 			PARAMS=$SERVER_PARAMS
-			server_nxnode_start --smbmount "$USER" "$PARAMS" 2>&1 | log_error >/dev/null
+			server_nxnode_start --smbmount "$USER" "$PARAMS" >/dev/null 2>&1 | log_error >/dev/null
 			echo_x "NX> 719 SMB filesystem: running"
 		;;
 		addprinter*)
 			server_get_params $CMD
 			PARAMS=$SERVER_PARAMS
-			server_nxnode_start --addprinter "$USER" "$PARAMS" 2>&1 | log_error >/dev/null
+			server_nxnode_start --addprinter "$USER" "$PARAMS" >/dev/null 2>&1 | log_error >/dev/null
 		;;
 		*)
 			# disabled for 1.4.0-5 snapshot client






From freenx-cvs at berlios.de  Wed Jul 27 18:10:41 2005
From: freenx-cvs at berlios.de (fabianx)
Date: Wed, 27 Jul 2005 18:10:41 +0200
Subject: [Freenx-cvs] CVS: freenx - fabianx modified 4 files
Message-ID: <42E7B201.mailBGY1J9BSI@lists.berlios.de>

User:      fabianx
Date:      2005-07-27 16:10:41 GMT
Modified:  .        ChangeLog node.conf.sample nxloadconfig nxserver
Log:
* Added experimental usermode authentication scheme.
  (Disabled by default)

New configuration key: ENABLE_USERMODE_AUTHENTICATION

Revision  Changes    Path
1.81      +2 -0      freenx/ChangeLog


rev 1.81, prev_rev 1.80
Index: ChangeLog
===================================================================
RCS file: /cvsroot/freenx/freenx/ChangeLog,v
retrieving revision 1.80
retrieving revision 1.81
diff -u -r1.80 -r1.81
--- ChangeLog	27 Jul 2005 14:34:59 -0000	1.80
+++ ChangeLog	27 Jul 2005 16:10:41 -0000	1.81
@@ -14,6 +14,8 @@
 	* Added secure logging - Passwords are no longer shown in log files.
 	* Security: Certain passwords for VNC/RDP could have been visible via 
 	  `ps aux`.
+	* Added experimental usermode authentication scheme.
+	  (Disabled by default)
 
 16.07.2005 FreeNX 0.4.2 "Solaris / Bugfix / Linux Infotag Pforzheim Edition"
 	* Removed forwarding support via "freenx.<user>", because it was



1.32      +8 -1      freenx/node.conf.sample


rev 1.32, prev_rev 1.31
Index: node.conf.sample
===================================================================
RCS file: /cvsroot/freenx/freenx/node.conf.sample,v
retrieving revision 1.31
retrieving revision 1.32
diff -u -r1.31 -r1.32
--- node.conf.sample	27 Jul 2005 14:34:59 -0000	1.31
+++ node.conf.sample	27 Jul 2005 16:10:41 -0000	1.32
@@ -37,7 +37,7 @@
 #
 #           https://mail.kde.org/mailman/listinfo/freenx-knx
 #
-# CVS: $Id: node.conf.sample,v 1.31 2005/07/27 14:34:59 fabianx Exp $
+# CVS: $Id: node.conf.sample,v 1.32 2005/07/27 16:10:41 fabianx Exp $
 
 #########################################################################
 # General FreeNX directives
@@ -56,6 +56,13 @@
 #########################################################################
 
 # Authentication directives
+
+# This adds the usermode to the possible authentication methods
+# Usermode means that a user can start the nxserver as his shell
+# and connect directly to the right server via a custom client.
+
+#ENABLE_USERMODE_AUTHENTICATION="0"
+
 # This adds the passdb to the possible authentication methods
 #ENABLE_PASSDB_AUTHENTICATION="1"
 



1.40      +2 -1      freenx/nxloadconfig


rev 1.40, prev_rev 1.39
Index: nxloadconfig
===================================================================
RCS file: /cvsroot/freenx/freenx/nxloadconfig,v
retrieving revision 1.39
retrieving revision 1.40
diff -u -r1.39 -r1.40
--- nxloadconfig	27 Jul 2005 14:34:59 -0000	1.39
+++ nxloadconfig	27 Jul 2005 16:10:41 -0000	1.40
@@ -5,7 +5,7 @@
 #
 # License: GPL, version 2
 #
-# CVS: $Id: nxloadconfig,v 1.39 2005/07/27 14:34:59 fabianx Exp $
+# CVS: $Id: nxloadconfig,v 1.40 2005/07/27 16:10:41 fabianx Exp $
 #
 # ========================================================================
 
@@ -81,6 +81,7 @@
 
 # Authentication / Security directives
 
+ENABLE_USERMODE_AUTHENTICATION="0"
 ENABLE_PASSDB_AUTHENTICATION="1"
 ENABLE_SSH_AUTHENTICATION="1"
 ENABLE_SU_AUTHENTICATION="0"



1.69      +31 -3     freenx/nxserver


rev 1.69, prev_rev 1.68
Index: nxserver
===================================================================
RCS file: /cvsroot/freenx/freenx/nxserver,v
retrieving revision 1.68
retrieving revision 1.69
diff -u -r1.68 -r1.69
--- nxserver	27 Jul 2005 14:34:59 -0000	1.68
+++ nxserver	27 Jul 2005 16:10:41 -0000	1.69
@@ -11,7 +11,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxserver,v 1.68 2005/07/27 14:34:59 fabianx Exp $
+# CVS: $Id: nxserver,v 1.69 2005/07/27 16:10:41 fabianx Exp $
 #
 
 # Read the config file
@@ -387,9 +387,24 @@
 # Main nxserver <-> nxclient communication module
 #
 
-if [ $USER = "nxfree" -o "$USER" = "nx" ]
+if [ $USER = "nxfree" -o "$USER" = "nx" -o "$ENABLE_USERMODE_AUTHENTICATION" = "1" ]
 then
 
+setup_usermode_auth()
+{
+
+	[ $USER = "nxfree" -o "$USER" = "nx" ] && ENABLE_USERMODE_AUTHENTICATION="0"
+
+	if [ "$ENABLE_USERMODE_AUTHENTICATION" = "1" ]
+	then
+		export NX_SESS_DIR="$USER_FAKE_HOME/.nx/db/"
+		export NX_LOGFILE="$USER_FAKE_HOME/.nx/temp/nxserver.log"
+		mkdir -p $NX_SESS_DIR/{closed,running,failed}
+	fi
+}
+
+setup_usermode_auth
+
 # Loglevels:
 # 1: Errors
 # 2: Warnings
@@ -508,6 +523,14 @@
 			echo_x ""
 			log 6 -n "Info: Auth method: "
 			
+			# USER already logged in?
+			if [ "$ENABLE_USERMODE_AUTHENTICATION" = "1" ]
+			then
+				LOGIN_SUCCESS="1"
+				LOGIN_METHOD="USERMODE"
+				USER=$(whoami)
+			fi
+
 			# PASSDB based auth
 			if [ "$ENABLE_PASSDB_AUTHENTICATION" = "1" -a "$LOGIN_SUCCESS" = "0" ]
 			then
@@ -556,6 +579,8 @@
 			then
 				# Reread the config files (so that $USER.node.conf get sourced)
 				. $(PATH=$(cd $(dirname $0) && pwd):$PATH which nxloadconfig) --userconf
+				setup_usermode_auth
+
 				echo_x "NX> 103 Welcome to: $SERVER_NAME user: $USER"
 				break
 			else
@@ -611,7 +636,10 @@
 	elif [ "$LOGIN_METHOD" = "SU" ]
 	then
 	    echo "$PASS" | NXNODE_TOSEND="$@" $PATH_BIN/nxnode-login -- su "$USER" "" "$PATH_BIN/nxnode" "$CMD" 2>&1 | log_tee
-	else 
+	elif [ "$LOGIN_METHOD" = "USERMODE" ]
+	then
+	    echo "$@" | $PATH_BIN/nxnode "$CMD" 2>&1 | log_tee
+	else
 	    echo "$@" | $COMMAND_SSH -l "$USER" 127.0.0.1 -p $SSHD_PORT -x -2 -i $NX_ETC_DIR/users.id_dsa -o 'PubkeyAuthentication yes' -o 'RSAAuthentication yes' -o 'RhostsAuthentication no' -o 'PasswordAuthentication no' -o 'RhostsRSAAuthentication no' -o 'StrictHostKeyChecking no' $PATH_BIN/nxnode "$CMD" | log_tee
 	fi
 }






From fabianx at berlios.de  Wed Jul 27 18:50:32 2005
From: fabianx at berlios.de (Fabian Franz at BerliOS)
Date: Wed, 27 Jul 2005 18:50:32 +0200
Subject: [Freenx-cvs] r73 - nx-utils/nxpublickey
Message-ID: <200507271650.j6RGoWeE011083@sheep.berlios.de>

Author: fabianx
Date: 2005-07-27 18:50:01 +0200 (Wed, 27 Jul 2005)
New Revision: 73

Added:
   nx-utils/nxpublickey/nxssh-usermode
Log:
Added nxssh-usermode wrapper.


Added: nx-utils/nxpublickey/nxssh-usermode
===================================================================
--- nx-utils/nxpublickey/nxssh-usermode	2005-07-05 00:30:22 UTC (rev 72)
+++ nx-utils/nxpublickey/nxssh-usermode	2005-07-27 16:50:01 UTC (rev 73)
@@ -0,0 +1,19 @@
+#!/bin/bash
+#
+# Simple wrapper for nxssh for freenx-usermode.
+#
+# Copyright (c) 2005 by Fabian Franz.
+#
+# License: GPL
+#
+
+cat <<EOF
+NX> 203 NXSSH running with pid: $$
+NX> 200 Connected to address: 127.0.0.1 on port: 22
+NX> 202 Authenticating user: nx
+NX> 208 Using auth method: publickey
+EOF
+
+CONN=$(echo "$@" | sed 's/.*nx@//g' | cut -d" " -f1)
+
+exec $(dirname $0)/nxssh.orig $CONN -x -2 -B nxserver


Property changes on: nx-utils/nxpublickey/nxssh-usermode
___________________________________________________________________
Name: svn:executable
   + *



From freenx-cvs at berlios.de  Thu Jul 28 00:14:02 2005
From: freenx-cvs at berlios.de (fabianx)
Date: Thu, 28 Jul 2005 00:14:02 +0200
Subject: [Freenx-cvs] CVS: freenx - fabianx modified ChangeLog
Message-ID: <42E8072A.mailNBF1KYQ3L@lists.berlios.de>

User:      fabianx
Date:      2005-07-27 22:14:02 GMT
Modified:  .        ChangeLog
Log:
Prepared ChangeLog for final release.

Revision  Changes    Path
1.82      +1 -1      freenx/ChangeLog


rev 1.82, prev_rev 1.81
Index: ChangeLog
===================================================================
RCS file: /cvsroot/freenx/freenx/ChangeLog,v
retrieving revision 1.81
retrieving revision 1.82
diff -u -r1.81 -r1.82
--- ChangeLog	27 Jul 2005 16:10:41 -0000	1.81
+++ ChangeLog	27 Jul 2005 22:14:02 -0000	1.82
@@ -1,4 +1,4 @@
-26.07.2005 FreeNX 0.4.3 "NoMachine 1.5.0 Edition"
+28.07.2005 FreeNX 0.4.3 "NoMachine 1.5.0 Edition"
 	* Fixed reconnection problems with !M 1.5.0 client.
 	* Fixed reconnection problems with !M 1.5.0 backend.
 	* Added evaluation of $NX_ETC_DIR/node.conf.d/* config files.






From freenx-cvs at berlios.de  Thu Jul 28 23:16:13 2005
From: freenx-cvs at berlios.de (fux)
Date: Thu, 28 Jul 2005 23:16:13 +0200
Subject: [Freenx-cvs] CVS: freenx - fux modified 2 files
Message-ID: <42E94B1D.mail12W13KX14@lists.berlios.de>

User:      fux
Date:      2005-07-28 21:16:13 GMT
Modified:  .        ChangeLog nxnode
Log:
Fixed nxdesktop fullscreen support with nxclient 1.5.0 and 1.5.0 backend

Revision  Changes    Path
1.83      +3 -0      freenx/ChangeLog


rev 1.83, prev_rev 1.82
Index: ChangeLog
===================================================================
RCS file: /cvsroot/freenx/freenx/ChangeLog,v
retrieving revision 1.82
retrieving revision 1.83
diff -u -r1.82 -r1.83
--- ChangeLog	27 Jul 2005 22:14:02 -0000	1.82
+++ ChangeLog	28 Jul 2005 21:16:13 -0000	1.83
@@ -11,6 +11,9 @@
 		  backend.
 		* Added RDP highcolor support for !M 1.5.0 client
 		  with !M 1.5.0 backend.
+		* Fixed fullscreen support in nxdesktop (still feels more like
+		  'Available Area', but with Ctrl-Alt-F you can get "real"
+		  fullscreen)
 	* Added secure logging - Passwords are no longer shown in log files.
 	* Security: Certain passwords for VNC/RDP could have been visible via 
 	  `ps aux`.



1.73      +11 -3     freenx/nxnode


rev 1.73, prev_rev 1.72
Index: nxnode
===================================================================
RCS file: /cvsroot/freenx/freenx/nxnode,v
retrieving revision 1.72
retrieving revision 1.73
diff -u -r1.72 -r1.73
--- nxnode	27 Jul 2005 12:50:54 -0000	1.72
+++ nxnode	28 Jul 2005 21:16:13 -0000	1.73
@@ -13,7 +13,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxnode,v 1.72 2005/07/27 12:50:54 fabianx Exp $
+# CVS: $Id: nxnode,v 1.73 2005/07/28 21:16:13 fux Exp $
 #
 # 21.06.2004: - Full reconnection support
 
@@ -236,6 +236,7 @@
 	[ "$virtualdesktop" = "0" ] && R="-R"
 	vncfullscreen=""
 	[ "$geometry" = "fullscreen" -a "$type" = "vnc" ] && vncfullscreen="-fullscreen" && G=""
+	[ "$geometry" = "fullscreen" -a "$type" = "windows" -a "$ENABLE_1_5_0_BACKEND" = "1" ] && G="-geometry `echo $screeninfo | cut -d"x" -f1,2`"
 
 	if [ "$type" = "windows" ]
 	then
@@ -243,9 +244,11 @@
 		[ "$SET_LD_LIBRARY_PATH" = "1" ] && export LD_LIBRARY_PATH="$AGENT_LIBRARY_PATH:$LD_LIBRARY_PATH"
 		U=""
 		P=""
+		D=""
 		[ -n "$agent_user" ] && U="-u $agent_user"
 		[ -n "$agent_password" ] && P="-p -"
-		echo "$agent_password" | $PATH_BIN/nxdesktop -name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" -option "$USER_FAKE_HOME/.nx/C-$sess_id/options" $K $G $U $P $agent_server $AGENT_EXTRA_OPTIONS_RDP 2>>$USER_FAKE_HOME/.nx/C-$sess_id/session &
+		[ -n "$agent_domain" ] && D="-d $agent_domain"
+		echo "$agent_password" | $PATH_BIN/nxdesktop -name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" -option "$USER_FAKE_HOME/.nx/C-$sess_id/options" $K $G $U $P $D $agent_server $AGENT_EXTRA_OPTIONS_RDP 2>>$USER_FAKE_HOME/.nx/C-$sess_id/session &
 	elif [ "$type" = "vnc" ]
 	then
 		# nxviewer session (VNC RFP)
@@ -629,6 +632,8 @@
 	agent_server=$(getparam agent_server)
 	agent_user=$(getparam agent_user)
 	agent_password=$(getparam agent_password)
+	agent_domain=$(getparam agent_domain)
+	screeninfo=$(getparam screeninfo)
 
 	if [ "$ENABLE_1_5_0_BACKEND" = "1" ]
 	then
@@ -640,6 +645,9 @@
 	
 	clientproto=$(getparam clientproto)
 
+	fullscreen=""
+	[ "$geometry" = "fullscreen" -a "$ENABLE_1_5_0_BACKEND" = "1" ] && fullscreen="1"
+
 	[ "$EXPORT_USERIP" = "1" ] && export NXUSERIP="$userip"
 
 	ssl_tunnel=$(getparam encryption)
@@ -687,7 +695,7 @@
 	umask 0077
 
 cat << EOF > $USER_FAKE_HOME/.nx/C-$sess_id/options
-${kbtype:+kbtype=$kbtype,}${CACHE}${IMAGES}${PACK}link=$link,type=$type,cleanup=0,${ACCEPT}cookie=$proxy_cookie,id=$sess_id,samba=$samba,media=$media${sync:+,sync=$sync}${cups:+,cups=$cups}${rdpcolors:+,rdpcolors=$rdpcolors}${rdpcache:+,rdpcache=$rdpcache}:$display
+${kbtype:+kbtype=$kbtype,}${CACHE}${IMAGES}${PACK}link=$link,type=$type,cleanup=0,${ACCEPT}cookie=$proxy_cookie,id=$sess_id,samba=$samba,media=$media${sync:+,sync=$sync}${cups:+,cups=$cups}${rdpcolors:+,rdpcolors=$rdpcolors}${rdpcache:+,rdpcache=$rdpcache}${fullscreen:+,fullscreen=1}:$display
 EOF
 	umask $OLD_UMASK
 #samba=$samba,






From freenx-cvs at berlios.de  Fri Jul 29 00:09:43 2005
From: freenx-cvs at berlios.de (fux)
Date: Fri, 29 Jul 2005 00:09:43 +0200
Subject: [Freenx-cvs] CVS: freenx - fux modified 5 files
Message-ID: <42E957A7.mail3FV119FVB@lists.berlios.de>

User:      fux
Date:      2005-07-28 22:09:43 GMT
Modified:  .        ChangeLog node.conf.sample nxloadconfig nxnode
Modified:           nxserver
Log:
The tool to generate md5sums with $COMMAND_MD5SUM

Revision  Changes    Path
1.84      +1 -0      freenx/ChangeLog


rev 1.84, prev_rev 1.83
Index: ChangeLog
===================================================================
RCS file: /cvsroot/freenx/freenx/ChangeLog,v
retrieving revision 1.83
retrieving revision 1.84
diff -u -r1.83 -r1.84
--- ChangeLog	28 Jul 2005 21:16:13 -0000	1.83
+++ ChangeLog	28 Jul 2005 22:09:42 -0000	1.84
@@ -19,6 +19,7 @@
 	  `ps aux`.
 	* Added experimental usermode authentication scheme.
 	  (Disabled by default)
+	* Added COMMAND_MD5SUM directive
 
 16.07.2005 FreeNX 0.4.2 "Solaris / Bugfix / Linux Infotag Pforzheim Edition"
 	* Removed forwarding support via "freenx.<user>", because it was



1.33      +4 -1      freenx/node.conf.sample


rev 1.33, prev_rev 1.32
Index: node.conf.sample
===================================================================
RCS file: /cvsroot/freenx/freenx/node.conf.sample,v
retrieving revision 1.32
retrieving revision 1.33
diff -u -r1.32 -r1.33
--- node.conf.sample	27 Jul 2005 16:10:41 -0000	1.32
+++ node.conf.sample	28 Jul 2005 22:09:43 -0000	1.33
@@ -37,7 +37,7 @@
 #
 #           https://mail.kde.org/mailman/listinfo/freenx-knx
 #
-# CVS: $Id: node.conf.sample,v 1.32 2005/07/27 16:10:41 fabianx Exp $
+# CVS: $Id: node.conf.sample,v 1.33 2005/07/28 22:09:43 fux Exp $
 
 #########################################################################
 # General FreeNX directives
@@ -309,6 +309,9 @@
 
 # The key that contains the name of the complete path of the 'cupsd' command.
 #COMMAND_CUPSD=/usr/sbin/cupsd
+
+# The tool to generate md5sums with
+#COMMAND_MD5SUM=md5sum
 
 #########################################################################
 # Misc directives



1.41      +5 -1      freenx/nxloadconfig


rev 1.41, prev_rev 1.40
Index: nxloadconfig
===================================================================
RCS file: /cvsroot/freenx/freenx/nxloadconfig,v
retrieving revision 1.40
retrieving revision 1.41
diff -u -r1.40 -r1.41
--- nxloadconfig	27 Jul 2005 16:10:41 -0000	1.40
+++ nxloadconfig	28 Jul 2005 22:09:43 -0000	1.41
@@ -5,7 +5,7 @@
 #
 # License: GPL, version 2
 #
-# CVS: $Id: nxloadconfig,v 1.40 2005/07/27 16:10:41 fabianx Exp $
+# CVS: $Id: nxloadconfig,v 1.41 2005/07/28 22:09:43 fux Exp $
 #
 # ========================================================================
 
@@ -157,6 +157,7 @@
 COMMAND_SSH=ssh
 COMMAND_SSH_KEYGEN=ssh-keygen
 COMMAND_CUPSD=/usr/sbin/cupsd
+COMMAND_MD5SUM=md5sum
 
 
 # Misc directives
@@ -190,6 +191,7 @@
 		COMMAND_XTERM=/usr/openwin/bin/xterm
 		COMMAND_XAUTH=/usr/openwin/bin/xauth
 		COMMAND_CUPSD=/opt/sfw/cups/sbin/cupsd
+		COMMAND_MD5SUM=gmd5sum
 		PATH=/usr/xpg4/bin:/usr/openwin/bin:$PATH
 		export PATH
 		;;
@@ -444,6 +446,8 @@
 	! which "$COMMAND_CUPSD" >/dev/null 2>&1 && \
 		WARNING="yes" && echo "Warning: Invalid value \"COMMAND_CUPSD=$COMMAND_CUPSD\"" \
 					  && echo "         Users will not be able to enable printing."
+	! which "$COMMAND_MD5SUM" >/dev/null 2>&1 && \
+		ERROR="yes" && echo "Warning: Invalid value \"COMMAND_MD5SUM=$COMMAND_MD5SUM\""
 
 	# Misc directives
 	



1.74      +2 -2      freenx/nxnode


rev 1.74, prev_rev 1.73
Index: nxnode
===================================================================
RCS file: /cvsroot/freenx/freenx/nxnode,v
retrieving revision 1.73
retrieving revision 1.74
diff -u -r1.73 -r1.74
--- nxnode	28 Jul 2005 21:16:13 -0000	1.73
+++ nxnode	28 Jul 2005 22:09:43 -0000	1.74
@@ -13,7 +13,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxnode,v 1.73 2005/07/28 21:16:13 fux Exp $
+# CVS: $Id: nxnode,v 1.74 2005/07/28 22:09:43 fux Exp $
 #
 # 21.06.2004: - Full reconnection support
 
@@ -671,7 +671,7 @@
 	[ "$imagecompressionmethod" = "1" ] && PACK="pack=16m-jpeg-$imagecompressionlevel,"
 	[ "$imagecompressionmethod" = "2" ] && PACK="pack=16m-png-9,"
 	
-	proxy_cookie=$(echo $[$RANDOM*$RANDOM] | md5sum | cut -d" " -f1)
+	proxy_cookie=$(echo $[$RANDOM*$RANDOM] | $COMMAND_MD5SUM | cut -d" " -f1)
 
 	if [ "$ENABLE_1_5_0_BACKEND" = "1" -a "$clientproto" = "1.5.0" ]
 	then



1.70      +3 -3      freenx/nxserver


rev 1.70, prev_rev 1.69
Index: nxserver
===================================================================
RCS file: /cvsroot/freenx/freenx/nxserver,v
retrieving revision 1.69
retrieving revision 1.70
diff -u -r1.69 -r1.70
--- nxserver	27 Jul 2005 16:10:41 -0000	1.69
+++ nxserver	28 Jul 2005 22:09:43 -0000	1.70
@@ -11,7 +11,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxserver,v 1.69 2005/07/27 16:10:41 fabianx Exp $
+# CVS: $Id: nxserver,v 1.70 2005/07/28 22:09:43 fux Exp $
 #
 
 # Read the config file
@@ -46,7 +46,7 @@
 
 passdb_get_crypt_pass()
 {
-	echo "$@" | md5sum | cut -d" " -f1
+	echo "$@" | $COMMAND_MD5SUM | cut -d" " -f1
 }
 
 passdb_get_pass()
@@ -848,7 +848,7 @@
 			return
 		fi
 	
-		uniqueid=$(echo $[$RANDOM*$RANDOM] | md5sum | cut -d" " -f1 | tr "[a-z]" "[A-Z]")
+		uniqueid=$(echo $[$RANDOM*$RANDOM] | $COMMAND_MD5SUM | cut -d" " -f1 | tr "[a-z]" "[A-Z]")
 		FULL_PARAMS="$PARAMS&user=$USER&userip=$USERIP&uniqueid=$uniqueid&display=$SESS_DISPLAY"
 		log_secure "6" "$FULL_PARAMS"
 






From freenx-cvs at berlios.de  Fri Jul 29 19:01:41 2005
From: freenx-cvs at berlios.de (fux)
Date: Fri, 29 Jul 2005 19:01:41 +0200
Subject: [Freenx-cvs] CVS: freenx - fux modified 2 files
Message-ID: <42EA60F5.mail6IM1CMCOH@lists.berlios.de>

User:      fux
Date:      2005-07-29 17:01:40 GMT
Modified:  .        ChangeLog nxnode
Log:
protected USER_FAKE_HOME from other users

Revision  Changes    Path
1.85      +1 -0      freenx/ChangeLog


rev 1.85, prev_rev 1.84
Index: ChangeLog
===================================================================
RCS file: /cvsroot/freenx/freenx/ChangeLog,v
retrieving revision 1.84
retrieving revision 1.85
diff -u -r1.84 -r1.85
--- ChangeLog	28 Jul 2005 22:09:42 -0000	1.84
+++ ChangeLog	29 Jul 2005 17:01:39 -0000	1.85
@@ -20,6 +20,7 @@
 	* Added experimental usermode authentication scheme.
 	  (Disabled by default)
 	* Added COMMAND_MD5SUM directive
+	* Security: $USER_FAKE_HOME/.nx now gets 0700
 
 16.07.2005 FreeNX 0.4.2 "Solaris / Bugfix / Linux Infotag Pforzheim Edition"
 	* Removed forwarding support via "freenx.<user>", because it was



1.75      +6 -1      freenx/nxnode


rev 1.75, prev_rev 1.74
Index: nxnode
===================================================================
RCS file: /cvsroot/freenx/freenx/nxnode,v
retrieving revision 1.74
retrieving revision 1.75
diff -u -r1.74 -r1.75
--- nxnode	28 Jul 2005 22:09:43 -0000	1.74
+++ nxnode	29 Jul 2005 17:01:39 -0000	1.75
@@ -13,7 +13,7 @@
 #
 # License: GNU GPL, version 2
 #
-# CVS: $Id: nxnode,v 1.74 2005/07/28 22:09:43 fux Exp $
+# CVS: $Id: nxnode,v 1.75 2005/07/29 17:01:39 fux Exp $
 #
 # 21.06.2004: - Full reconnection support
 
@@ -660,7 +660,12 @@
 	sess_id="$SERVER_NAME-$display-$uniqueid"
 	[ "$EXPORT_SESSIONID" = "1" ] && export NXSESSIONID="$sess_id"
 	
+	OLD_UMASK=$(umask)
+	umask 0022
+	mkdir -p $USER_FAKE_HOME
+	umask 0077
 	mkdir -p $USER_FAKE_HOME/.nx/C-$sess_id
+	umask $OLD_UMASK
 	
 	# cache=8M,images=32M,pack=nopack,link=lan,type=unix-kde,cleanup=0,accept=192.168.1.66,cookie=E38A94A77F975443AF04EC911881B120,id=Knoppix-1000-6A8269CC467264EAEF6349D062689755,samba=1,render=1:1000
 	






From freenx-cvs at berlios.de  Fri Jul 29 19:05:21 2005
From: freenx-cvs at berlios.de (fux)
Date: Fri, 29 Jul 2005 19:05:21 +0200
Subject: [Freenx-cvs] CVS: freenx - fux modified node.conf.sample
Message-ID: <42EA61D1.mail7IS1WQZ4M@lists.berlios.de>

User:      fux
Date:      2005-07-29 17:05:21 GMT
Modified:  .        node.conf.sample
Log:
small newline fix

Revision  Changes    Path
1.34      +1 -2      freenx/node.conf.sample


rev 1.34, prev_rev 1.33
Index: node.conf.sample
===================================================================
RCS file: /cvsroot/freenx/freenx/node.conf.sample,v
retrieving revision 1.33
retrieving revision 1.34
diff -u -r1.33 -r1.34
--- node.conf.sample	28 Jul 2005 22:09:43 -0000	1.33
+++ node.conf.sample	29 Jul 2005 17:05:21 -0000	1.34
@@ -37,7 +37,7 @@
 #
 #           https://mail.kde.org/mailman/listinfo/freenx-knx
 #
-# CVS: $Id: node.conf.sample,v 1.33 2005/07/28 22:09:43 fux Exp $
+# CVS: $Id: node.conf.sample,v 1.34 2005/07/29 17:05:21 fux Exp $
 
 #########################################################################
 # General FreeNX directives
@@ -60,7 +60,6 @@
 # This adds the usermode to the possible authentication methods
 # Usermode means that a user can start the nxserver as his shell
 # and connect directly to the right server via a custom client.
-
 #ENABLE_USERMODE_AUTHENTICATION="0"
 
 # This adds the passdb to the possible authentication methods






From fabianx at berlios.de  Sun Jul 31 13:51:17 2005
From: fabianx at berlios.de (Fabian Franz at BerliOS)
Date: Sun, 31 Jul 2005 13:51:17 +0200
Subject: [Freenx-cvs] r74 - nx-utils/nxpublickey
Message-ID: <200507311151.j6VBpHbH020351@sheep.berlios.de>

Author: fabianx
Date: 2005-07-31 13:51:10 +0200 (Sun, 31 Jul 2005)
New Revision: 74

Modified:
   nx-utils/nxpublickey/nxssh-usermode
Log:
Added seamless change of using usermode authentication and not using it. Hostnames with an user@ will be wrapped. All other sessions will be directly given to nxssh.


Modified: nx-utils/nxpublickey/nxssh-usermode
===================================================================
--- nx-utils/nxpublickey/nxssh-usermode	2005-07-27 16:50:01 UTC (rev 73)
+++ nx-utils/nxpublickey/nxssh-usermode	2005-07-31 11:51:10 UTC (rev 74)
@@ -7,13 +7,24 @@
 # License: GPL
 #
 
-cat <<EOF
+CONN=$(echo "$@" | sed 's/.*nx@//g' | cut -d" " -f1)
+
+unset NXWRAP
+case "$CONN" in *@*) NXWRAP=1 ;; esac
+
+if [ "$NXWRAP" = "1" ]
+then
+
+	cat <<EOF
 NX> 203 NXSSH running with pid: $$
 NX> 200 Connected to address: 127.0.0.1 on port: 22
 NX> 202 Authenticating user: nx
 NX> 208 Using auth method: publickey
 EOF
 
-CONN=$(echo "$@" | sed 's/.*nx@//g' | cut -d" " -f1)
+	export SSH_ASKPASS=/usr/bin/ssh-askpass
 
-exec $(dirname $0)/nxssh.orig $CONN -x -2 -B nxserver
+	exec $(dirname $0)/nxssh.orig $CONN -x -2 -B sh -c "~/NX.usermode/bin/nxserver"
+else
+	exec $(dirname $0)/nxssh.orig "$@"
+fi



From fabianx at berlios.de  Sun Jul 31 18:28:12 2005
From: fabianx at berlios.de (Fabian Franz at BerliOS)
Date: Sun, 31 Jul 2005 18:28:12 +0200
Subject: [Freenx-cvs] r75 - nx-utils/nxfish
Message-ID: <200507311628.j6VGSCU4019416@sheep.berlios.de>

Author: fabianx
Date: 2005-07-31 18:28:11 +0200 (Sun, 31 Jul 2005)
New Revision: 75

Modified:
   nx-utils/nxfish/nx-fishsrv.pl
Log:
Fixed usage of relative '..' path as administrator. Removed insecure usage of / path in case of no given path.


Modified: nx-utils/nxfish/nx-fishsrv.pl
===================================================================
--- nx-utils/nxfish/nx-fishsrv.pl	2005-07-31 11:51:10 UTC (rev 74)
+++ nx-utils/nxfish/nx-fishsrv.pl	2005-07-31 16:28:11 UTC (rev 75)
@@ -8,6 +8,11 @@
 
 my $substpath=$ARGV[0];
 
+if ($substpath eq '')
+{
+	$substpath='.';
+}
+
 use strict;
 use POSIX qw(getcwd dup2 strftime);
 $SIG{'CHLD'} = 'IGNORE';
@@ -273,7 +278,7 @@
 
 # FIXME: Make it secure
 
-sub unquote { $_ = shift; s/\\(.)/$1/g; s/^/$substpath/g; s/\.\./\//g; return $_; }
+sub unquote { $_ = shift; s/\\(.)/$1/g; s/\.\./\//g; s/^/$substpath/g; return $_; }
 #sub unquote { $_ = shift; s/\\(.)/$1/g; return $_; }
 
 sub filetype {



From fabianx at berlios.de  Sun Jul 31 18:58:21 2005
From: fabianx at berlios.de (Fabian Franz at BerliOS)
Date: Sun, 31 Jul 2005 18:58:21 +0200
Subject: [Freenx-cvs] r78 - nx-utils/nxsocks/nxsocksd
Message-ID: <200507311658.j6VGwL5s008381@sheep.berlios.de>

Author: fabianx
Date: 2005-07-31 18:57:19 +0200 (Sun, 31 Jul 2005)
New Revision: 78

Modified:
   nx-utils/nxsocks/nxsocksd/main.c
Log:
Added support for passing password in environment var and removed dependency for a controlling terminal.


Modified: nx-utils/nxsocks/nxsocksd/main.c
===================================================================
--- nx-utils/nxsocks/nxsocksd/main.c	2005-07-31 16:53:32 UTC (rev 77)
+++ nx-utils/nxsocks/nxsocksd/main.c	2005-07-31 16:57:19 UTC (rev 78)
@@ -481,7 +481,7 @@
     printaddrlist(" Accepting connnections from %s", pm.acc, pm.nacc);
     printf(" ident %s\n", (pm.id) ? pm.id : "(anyone)");
     printaddrlist(" Relaying UDP from %s\n", pm.udp, pm.nudp);
-    if (pm.uname) {
+    if (pm.uname && getenv("USOCKS_PASSWORD") == NULL) {
 #ifdef HAVE_TERMIOS_H
 	struct termios tio;
 	int l=0;
@@ -512,8 +512,12 @@
 	}
 #endif
     }
+    else
+    {
+        pm.pass=strncpy(buf, getenv("USOCKS_PASSWORD"), sizeof(buf));
+    }
     printf("Listening on port %d.\n", port);
-    thread_fd_register(0, eofh, NULL, NULL, NULL);
+    /*thread_fd_register(0, eofh, NULL, NULL, NULL); */
     setsig(SIGINT, finish);
     setsig(SIGTERM, finish);
     setsig(SIGPIPE, SIG_IGN);



From fabianx at berlios.de  Sun Jul 31 18:54:58 2005
From: fabianx at berlios.de (Fabian Franz at BerliOS)
Date: Sun, 31 Jul 2005 18:54:58 +0200
Subject: [Freenx-cvs] r77 - in nx-utils/nxsocks: . nxnotify
Message-ID: <200507311654.j6VGswaJ006805@sheep.berlios.de>

Author: fabianx
Date: 2005-07-31 18:53:32 +0200 (Sun, 31 Jul 2005)
New Revision: 77

Added:
   nx-utils/nxsocks/nxnotify/
   nx-utils/nxsocks/nxnotify/Makefile
   nx-utils/nxsocks/nxnotify/nxnotify
   nx-utils/nxsocks/nxnotify/nxnotify-startup
Log:
Imported nxnotify utilities to automatically startup nxsocksd by NXClient.


Added: nx-utils/nxsocks/nxnotify/Makefile
===================================================================
--- nx-utils/nxsocks/nxnotify/Makefile	2005-07-31 16:38:31 UTC (rev 76)
+++ nx-utils/nxsocks/nxnotify/Makefile	2005-07-31 16:53:32 UTC (rev 77)
@@ -0,0 +1,6 @@
+all:
+
+install:
+	install -m755 nxnotify nxnotify-startup $(DESTDIR)/usr/bin
+
+.PHONY: install

Added: nx-utils/nxsocks/nxnotify/nxnotify
===================================================================
--- nx-utils/nxsocks/nxnotify/nxnotify	2005-07-31 16:38:31 UTC (rev 76)
+++ nx-utils/nxsocks/nxnotify/nxnotify	2005-07-31 16:53:32 UTC (rev 77)
@@ -0,0 +1,48 @@
+#!/bin/bash
+#
+# Simple script run by dnotify.
+#
+# Copyright (c) 2005 by Fabian Franz.
+#
+# License: GPL, version 2.
+#
+#
+
+watch_session()
+{
+	[ -f $1.monitored ] && return 1
+	touch $1.monitored
+	echo "Info $1: Monitoring."
+	NXSOCKSD_PID=""
+	tail -f $1 | while read line
+	do
+		#echo "Info $1: Got line: $line"
+		case $line in
+			"Info: Forwarding cups connections to port "*)
+			NXSOCKS_PORT=$(echo $line  | cut -d"'" -f2)
+			USOCKS_PASSWORD="cookie" nxsocksd -p "$NXSOCKS_PORT" -a 127.0.0.1 -u 127.0.0.1 -U nxsocksd &
+			NXSOCKSD_PID=$!
+			disown $!
+			;;
+			"Info: Shutting down the link and exiting."*)
+				echo "Info $1: Shutting down and renaming session file."
+				[ -n $NXSOCKSD_PID ] && kill "$NXSOCKSD_PID"
+				mv -f $1 $1.nx
+				rm -f $1.monitored
+				return 0
+			;;
+		esac
+	done
+	return 1
+}
+
+echo "Info: Scanning ..."
+LIST=$(find ~/.nx/ -name session -cnewer ~/.nx/notify-ref)
+
+touch ~/.nx/notify-ref
+
+for i in $LIST
+do
+	watch_session $i &
+	disown $!
+done


Property changes on: nx-utils/nxsocks/nxnotify/nxnotify
___________________________________________________________________
Name: svn:executable
   + *

Added: nx-utils/nxsocks/nxnotify/nxnotify-startup
===================================================================
--- nx-utils/nxsocks/nxnotify/nxnotify-startup	2005-07-31 16:38:31 UTC (rev 76)
+++ nx-utils/nxsocks/nxnotify/nxnotify-startup	2005-07-31 16:53:32 UTC (rev 77)
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# Simple Wrapper script for dnotify / nxnotify.
+#
+# Copyright (c) 2005 by Fabian Franz.
+#
+# License: GPL, version 2.
+#
+#
+
+# Create the reference timestamp.
+touch ~/.nx/notify-ref
+
+# Now lets get notified.
+dnotify -C ~/.nx -e nxnotify


Property changes on: nx-utils/nxsocks/nxnotify/nxnotify-startup
___________________________________________________________________
Name: svn:executable
   + *



From fabianx at berlios.de  Sun Jul 31 19:22:17 2005
From: fabianx at berlios.de (Fabian Franz at BerliOS)
Date: Sun, 31 Jul 2005 19:22:17 +0200
Subject: [Freenx-cvs] r79 - nx-utils/nxsocks/nxsocksd
Message-ID: <200507311722.j6VHMHUL025063@sheep.berlios.de>

Author: fabianx
Date: 2005-07-31 19:22:01 +0200 (Sun, 31 Jul 2005)
New Revision: 79

Modified:
   nx-utils/nxsocks/nxsocksd/socks.c
Log:
Restriced socks to CONNECT method, 127.0.0.1 host and ports 631/6201.


Modified: nx-utils/nxsocks/nxsocksd/socks.c
===================================================================
--- nx-utils/nxsocks/nxsocksd/socks.c	2005-07-31 16:57:19 UTC (rev 78)
+++ nx-utils/nxsocks/nxsocksd/socks.c	2005-07-31 17:22:01 UTC (rev 79)
@@ -523,6 +523,13 @@
 	    flagerr(7);
 	}
 
+	/* FF HACK - Just allow CONNECT method, 127.0.0.1:CUPS/NXFISH for now */
+	if (rq_cmd(sp) != 1 || (strcmp(inet_ntoa(rq_addr(sp)),"127.0.0.1")!=0) || (ntohs(rq_port(sp)) != 631 && ntohs(rq_port(sp)) != 6201))
+	{
+	    ++s_fconn;
+	    flagerr(2);
+	}
+
 	switch(rq_cmd(sp)) {
 	case 1: /* CONNECT */
 	    ++s_rconn;



From fabianx at berlios.de  Sun Jul 31 19:46:45 2005
From: fabianx at berlios.de (Fabian Franz at BerliOS)
Date: Sun, 31 Jul 2005 19:46:45 +0200
Subject: [Freenx-cvs] r80 - nx-utils/nxsocks/nxsocksd
Message-ID: <200507311746.j6VHkj03008186@sheep.berlios.de>

Author: fabianx
Date: 2005-07-31 19:46:36 +0200 (Sun, 31 Jul 2005)
New Revision: 80

Removed:
   nx-utils/nxsocks/nxsocksd/Checksums
Log:
Removed Checksums as we changed the source code.


Deleted: nx-utils/nxsocks/nxsocksd/Checksums
===================================================================
--- nx-utils/nxsocks/nxsocksd/Checksums	2005-07-31 17:22:01 UTC (rev 79)
+++ nx-utils/nxsocks/nxsocksd/Checksums	2005-07-31 17:46:36 UTC (rev 80)
@@ -1,47 +0,0 @@
-# This file contains a list of the files in this package with checksums.
-# If you run this as a /bin/sh script, it will verify the PGP signature on
-# this file and verify the individual files' checksums.
-#
-# Packaged by olaf at bigred, Fri May 14 00:28:47 CEST 1999
-:<<'_marker_'
------BEGIN PGP SIGNED MESSAGE-----
-
-___size _____________date ____________________md5-checksum  name_______________
-   1687 Feb 24 1998 14:24 fd7d095feca52c753f6d72d9f6eef66a  README
-   6547 May 14 1999 00:28 ca6a1472734aece52ba56992e0ddd9c0  usocksd.1.in
-   2495 May 13 1999 18:02 505f96a46cec5fb93fd921e1b2ccb895  Makefile.in
-  70282 May 13 1999 23:49 71f1f0fc51426a0ab1f720eb09d865a8  configure
-   5184 May 13 1999 22:43 f84a486033271073d4861acdbf4b30ed  configure.in
-   3488 May 13 1999 16:55 62f5c44d3ef9c2878ed240d1e4cca4d2  config.h.in
-    199 May 13 1999 20:10 7f4e40454cf4f846c191013d60114b38  socks.h
-    153 May 13 1999 20:20 4948fe68ba28b7bb45912e52f421b66d  udp.h
-    649 May 13 1999 17:17 0a47425066672e37c721d01e5ca29274  thread.h
-    836 May 13 1999 20:01 1cd40da77c41101c85349f06ec11bad8  lib.h
-    960 Mar 10 1997 17:21 a06090934a7db0865b66488b150b77d7  resolv.h
-   1290 Nov 03 1998 17:59 1aff7d594fc64d0aab817aa608917f9a  log.h
-    298 Dec 12 1998 19:15 caafc1e314a81bab2e4a3b937862cfd7  stats.h
-  18297 May 14 1999 00:28 889f1909ef9bec6b531155a5c64d68c8  socks.c
-   7035 May 14 1999 00:28 03e70531043dabf9e19d3a962a287672  udp.c
-   6130 May 14 1999 00:28 66cfa778c21a2b46bdb5d956366d1d84  thread.c
-   3184 May 14 1999 00:28 9042a1f326c30aaa45ff41c5d46a7c6c  lib.c
-  16700 Nov 29 1998 23:51 a2e55d561926a59d03b95de4c166d1ba  resolv.c
-  12942 May 14 1999 00:28 1f390f545cec7afc7e9db8f427d36117  main.c
-   2624 Feb 07 1998 14:43 275d0d3e32767753a1023b9e304b89df  aquery.c
-   4773 Feb 07 1998 12:58 e2f7509e56ca4245d80878e106226786  install-sh
-  17982 Feb 22 1997 13:42 8ca43cbc842c2336e835926c2166c28b  COPYING
-___size _____________date ____________________md5-checksum  name_______________
-_
-_marker_
-echo "No output after the PGP signature check means everything is okay."
-pgp -tf <$0 | sed -e '/^_marker_/q' -e '/^_/d' | cut -b27- | md5sum -c
-exit $?
------BEGIN PGP SIGNATURE-----
-Version: GnuPG v0.9.5 (GNU/Linux)
-Comment: For info see http://www.gnupg.org
-
-iQCVAwUBNztSJMDBbWIyVM0dAQEiCgQAsB6yIZZl+sicTjp4MqlqMYLznA+11QUT
-QGp4E+8prwU7/V2OZQFh8iZkVl5rvj9uMoylh4DOBF8N5+zvNXspvItrFcDzOAJI
-WfPeeEYb3yf8sOcLzBkni9LEHjcdq2Fwphu+8J/EHxpuQfGOKAeDkmRTJrHWeb7b
-mFwC6spRbdA=
-=Qrrp
------END PGP SIGNATURE-----



From fabianx at berlios.de  Sun Jul 31 19:47:54 2005
From: fabianx at berlios.de (Fabian Franz at BerliOS)
Date: Sun, 31 Jul 2005 19:47:54 +0200
Subject: [Freenx-cvs] r81 - nx-utils/nxsocks/nxsocksd
Message-ID: <200507311747.j6VHlsRq008893@sheep.berlios.de>

Author: fabianx
Date: 2005-07-31 19:47:46 +0200 (Sun, 31 Jul 2005)
New Revision: 81

Modified:
   nx-utils/nxsocks/nxsocksd/socks.c
Log:
Made the hack just in case nxsocksd is used as user.


Modified: nx-utils/nxsocks/nxsocksd/socks.c
===================================================================
--- nx-utils/nxsocks/nxsocksd/socks.c	2005-07-31 17:46:36 UTC (rev 80)
+++ nx-utils/nxsocks/nxsocksd/socks.c	2005-07-31 17:47:46 UTC (rev 81)
@@ -522,12 +522,16 @@
 	    ++s_protfail;
 	    flagerr(7);
 	}
+	
+	if (strncmp(sp->uname, "nxsocksd", 8)==0)
+	{
+	    /* FF HACK - Just allow CONNECT method, 127.0.0.1:CUPS/NXFISH now.*/
 
-	/* FF HACK - Just allow CONNECT method, 127.0.0.1:CUPS/NXFISH for now */
-	if (rq_cmd(sp) != 1 || (strcmp(inet_ntoa(rq_addr(sp)),"127.0.0.1")!=0) || (ntohs(rq_port(sp)) != 631 && ntohs(rq_port(sp)) != 6201))
-	{
-	    ++s_fconn;
-	    flagerr(2);
+	    if (rq_cmd(sp) != 1 || (strcmp(inet_ntoa(rq_addr(sp)),"127.0.0.1")!=0) || (ntohs(rq_port(sp)) != 631 && ntohs(rq_port(sp)) != 6201))
+	    {
+		++s_fconn;
+		flagerr(2);
+            }
 	}
 
 	switch(rq_cmd(sp)) {



From fabianx at berlios.de  Sun Jul 31 19:49:10 2005
From: fabianx at berlios.de (Fabian Franz at BerliOS)
Date: Sun, 31 Jul 2005 19:49:10 +0200
Subject: [Freenx-cvs] r82 - nx-utils/nxsocks/nxsocksd
Message-ID: <200507311749.j6VHnA59009034@sheep.berlios.de>

Author: fabianx
Date: 2005-07-31 19:49:06 +0200 (Sun, 31 Jul 2005)
New Revision: 82

Added:
   nx-utils/nxsocks/nxsocksd/nxsocksd.1.in
Removed:
   nx-utils/nxsocks/nxsocksd/usocksd.1.in
Log:
NX'fied the package.


Copied: nx-utils/nxsocks/nxsocksd/nxsocksd.1.in (from rev 77, nx-utils/nxsocks/nxsocksd/usocksd.1.in)

Deleted: nx-utils/nxsocks/nxsocksd/usocksd.1.in
===================================================================
--- nx-utils/nxsocks/nxsocksd/usocksd.1.in	2005-07-31 17:47:46 UTC (rev 81)
+++ nx-utils/nxsocks/nxsocksd/usocksd.1.in	2005-07-31 17:49:06 UTC (rev 82)
@@ -1,224 +0,0 @@
-.\" -*- nroff -*-
-.\" $Id: usocksd.1.in,v 1.3 1999/05/13 22:28:11 olaf Exp $
-.\"
-.\" Configuration options
-.ds D @DEBUG@
-.ds N @NORELAX@
-.ds F @DO_SPAWN@
-.\"
-.TH USOCKSD 1 "HaDiNet Software"
-.SH NAME
-usocksd \- user specific SOCKS5 daemon
-.SH SYNOPSIS
-.B usocksd
-[
-.BI \-p " port"
-]
-.if !'\*N'1' [
-.BI \-a " accepthost"
-.if !'\*N'1' ] [
-.BI \-u " udphost"
-.if !'\*N'1' ]
-[
-.BI \-i " identuser"
-]
-.if !'\*N'1' [
-.BI \-U " authuser"
-.if !'\*N'1' ]
-.if '\*D'1' \{\
-[
-.BI \-d " debuglevel"
-]\}
-.SH DESCRIPTION
-.B usocksd
-is a lightweight SOCKS5 daemon. It is intended to be run by the user
-who wants to use the SOCKS service and facilitates the use of an
-.B ssh
-TCP port redirection to run the SOCKS protocol over.
-.B usocksd
-is useful in situations where the user has access to a host with less
-restricted connectivity than his own machine, or where the user\'s
-own machine is on an insecure network and all connections should be
-encrypted.
-.B usocksd
-implements all documented commands, the address types
-.I IPv4 Address
-and
-.I Domain Name
-(for domain names that resolve to IPv4 addresses) and the
-authentication methods
-.I No Authentication
-and
-.IR "Username/Password" .
-.SH OPTIONS
-.TP
-.BI \-p " port"
-Port to listen on for connections. On a multi-user system, each user
-has to specify his own port instead of relying on the standard port.
-Default is 1080, nonetheless.
-.TP
-.BI \-a " accepthost"
-Specify that connections are only accepted from this host.
-.ie '\*N'1' This option must be present.
-.el Default: no restriction.
-It is possible to specify more than one allowed host, they have to be
-separated with a comma (and nothing else). Hosts are given either as
-IP address or as resolvable name.
-.TP
-.BI \-u " udphost"
-Specify that UDP packets to be relayed come from this host instead of
-the default (the connecting host). Why this violation of RFC 1928 is
-necessary is explained below under "Usage".
-.if '\*N'1' This option must be present.
-It is possible to specify more than one host.
-.TP
-.BI \-i " identuser"
-Specify that for each incoming connection an
-.B identd
-query will be made and the connection rejected if it does not resolve
-to the given user name. Note that
-.B identd
-is not a reliable authentication service.
-.TP
-.BI \-U " authuser"
-Specify that
-.I Username/Password
-authentication be used with the given user name. The password is read
-from standard input.
-.ie '\*N'1' This option must be present.
-.el Without this option, no authentication is requested from clients.
-.if '\*D'1' \{\
-.TP
-.BI \-d " debuglevel"
-Specify the amount of tracing output. See the source for the meaning
-of the numbers.\}
-.SH USAGE
-The intended usage for running SOCKS5 over an
-.B ssh
-connection is as follows:
-.PP
-.nf
-\fCssh -L1080:relayhost:12345 relayhost\\
-.br
- "usocksd -p12345 -arelayhost -umyhost -Ufred"\fP
-.fi
-.PP
-where
-.I relayhost
-is the host where
-.B usocksd
-runs and
-.I myhost
-is the client's host. Note the coincidence of the host name and port
-number arguments. After this connection is established,
-.I myhost
-can be used as its own SOCKS5 server. The SOCKS connections, and
-therefore all TCP data, will be encrypted. UDP data is not sent over
-the encrypted SOCKS connection and is not encrypted; it goes directly
-from
-.I myhost
-to
-.IR relayhost ,
-while the corresponding SOCKS connection seems to come from
-.I relayhost
-itself. This is the reason why a regular SOCKS5 server can not be used
-for UDP in this situation (and the original incentive for writing
-.BR usocksd ).
-The SOCKS clients will use password authentication as user
-.IR fred.
-The password to use is read from standard input.
-Neither user name nor password need to coincide with the real user
-name and password on any of the machines involved.
-.PP
-.B usocksd
-terminates when it encounters EOF on standard input. All other input
-on stdin is ignored. If the password should be read from a file
-instead of standard input, the proper way of invocation is
-.PP
-.nf
-\fCcat ~/.socks-password - |\\
- ssh -L1080:relayhost:12345 relayhost\\
-.br
- "usocksd -p12345 -arelayhost -umyhost -Ufred"\fP
-.fi
-.PP
-.B usocksd
-does not spawn any child processes,
-.if '\*F'1' \{\
-except for the extended
-.B ping
-and
-.B traceroute
-commands, \}
-it does not detach from the
-controlling terminal and does produce output on the standard output
-and error channels.
-.SH DIAGNOSTICS
-Messages about new connections, operating parameters and statistics
-are printed on standard output. Messages about connection failures are
-printed on standard error.
-.if '\*D'1' \{\
-Depending on the
-.B \-d
-argument, more tracing is printed on standard output. \}
-.SH SEE ALSO
-.BR ssh (1),
-.BR "RFC 1928:" " SOCKS Protocol Version 5"
-.SH BUGS
-Most of the permission and sanity checks described in RFC 1928 are not
-implemented. This may be considered a feature.
-.PP
-Nonblocking I/O is used where applicable. On some systems, where
-nonblocking I/O does not work, new connections in progress will
-temporarily suspend data transfer on existing connections. The same
-applies to diagnostic output if the standard output and standard error
-channels run on a socket or pipe which can block.
-.PP
-.B usocksd
-does not fully support multi-homed servers. Support for multi-homed
-clients may depend on the client's SOCKS library.
-.PP
-UDP relaying does not work in the following case:
-Multiple or no addresses are given with the
-.BI \-u
-argument, and the client does not send any packets (it only receives),
-and the client binds its socket to address 0.
-.PP
-When multiple addresses are given with the
-.BI \-u
-argument, UDP relaying between those hosts does or does not work,
-depending on the exact sequence of packets. It is
-assumed that all allowed clients connect to each other directly.
-.PP
-There should be a more elegant method of killing an
-.B usocksd
-started via
-.B ssh
-than the EOF handling.
-.SH NOTES
-The
-.B ping
-and
-.B traceroute
-utilities do not work with SOCKS because they use the ICMP protocol.
-The reference implementation SOCKS
-daemon by NEC includes undocumented commands for these applications.
-.ie '\*F'1' \{\
-.B usocksd
-supports these by calling the
-.B ping
-or
-.B traceroute
-programs on the host where it runs. \}
-.el \{\
-These are not supported by this configuration of
-.BR usocksd . \}
-.SH VERSION
- at VERSION@ as of @DATE at .
-.SH AUTHOR
-Olaf Titz <olaf at bigred.inka.de>.
-.SH COPYING
-This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version
-2 of the License, or (at your option) any later version.



From fabianx at berlios.de  Sun Jul 31 19:53:04 2005
From: fabianx at berlios.de (Fabian Franz at BerliOS)
Date: Sun, 31 Jul 2005 19:53:04 +0200
Subject: [Freenx-cvs] r83 - nx-utils/nxsocks/nxsocksd
Message-ID: <200507311753.j6VHr4Xc009712@sheep.berlios.de>

Author: fabianx
Date: 2005-07-31 19:52:57 +0200 (Sun, 31 Jul 2005)
New Revision: 83

Modified:
   nx-utils/nxsocks/nxsocksd/Makefile.in
   nx-utils/nxsocks/nxsocksd/README
   nx-utils/nxsocks/nxsocksd/configure
   nx-utils/nxsocks/nxsocksd/configure.in
   nx-utils/nxsocks/nxsocksd/lib.c
   nx-utils/nxsocks/nxsocksd/main.c
   nx-utils/nxsocks/nxsocksd/nxsocksd.1.in
   nx-utils/nxsocks/nxsocksd/resolv.c
   nx-utils/nxsocks/nxsocksd/socks.c
   nx-utils/nxsocks/nxsocksd/thread.c
   nx-utils/nxsocks/nxsocksd/udp.c
Log:
NX'fied the package.


Modified: nx-utils/nxsocks/nxsocksd/Makefile.in
===================================================================
--- nx-utils/nxsocks/nxsocksd/Makefile.in	2005-07-31 17:49:06 UTC (rev 82)
+++ nx-utils/nxsocks/nxsocksd/Makefile.in	2005-07-31 17:52:57 UTC (rev 83)
@@ -1,4 +1,4 @@
-#  usocksd - user specific SOCKS5 daemon    Prototype for the -*- Makefile -*-
+#  nxsocksd - user specific SOCKS5 daemon    Prototype for the -*- Makefile -*-
 #
 #  Copyright 1997 Olaf Titz <olaf at bigred.inka.de>
 #
@@ -26,11 +26,11 @@
 bindir	= @bindir@
 mandir	= @mandir@
 
-PROGS	= usocksd
-MANS	= usocksd.1
+PROGS	= nxsocksd
+MANS	= nxsocksd.1
 OBJS	= main.o socks.o udp.o resolv.o thread.o lib.o
 
-SRCS	= README usocksd.1.in Makefile.in configure configure.in config.h.in \
+SRCS	= README nxsocksd.1.in Makefile.in configure configure.in config.h.in \
 		socks.h udp.h thread.h lib.h resolv.h log.h stats.h \
 		socks.c udp.c thread.c lib.c resolv.c main.c aquery.c \
 		install-sh COPYING
@@ -38,8 +38,8 @@
 
 all: $(PROGS)
 
-usocksd: $(OBJS)
-	$(CC) $(LDFLAGS) -o usocksd $(OBJS) $(LIBS)
+nxsocksd: $(OBJS)
+	$(CC) $(LDFLAGS) -o nxsocksd $(OBJS) $(LIBS)
 
 aquery: aquery.o resolv.o thread.o lib.o
 	$(CC) $(LDFLAGS) -o aquery aquery.o resolv.o thread.o lib.o $(LIBS)
@@ -57,17 +57,17 @@
 
 distclean: clean
 	rm -f config.cache config.h config.log config.status \
-		Makefile usocksd.1 TAGS
+		Makefile nxsocksd.1 TAGS
 
 Checksums: $(SRCS)
 	makechecksums $(SRCS) > Checksums
 
 shar: $(SRCSC)
-	cd .. && shar $(SRCSC:%=usocksd/%) > usocksd.shar
+	cd .. && shar $(SRCSC:%=nxsocksd/%) > nxsocksd.shar
 
 tgz: $(SRCSC)
-	cd .. && ln -sf usocksd usocksd- at VERSION@ && \
-	  tar czf usocksd- at VERSION@.tar.gz $(SRCSC:%=usocksd- at VERSION@/%)
+	cd .. && ln -sf nxsocksd nxsocksd- at VERSION@ && \
+	  tar czf nxsocksd- at VERSION@.tar.gz $(SRCSC:%=nxsocksd- at VERSION@/%)
 
 configure: configure.in
 	autoconf

Modified: nx-utils/nxsocks/nxsocksd/README
===================================================================
--- nx-utils/nxsocks/nxsocksd/README	2005-07-31 17:49:06 UTC (rev 82)
+++ nx-utils/nxsocks/nxsocksd/README	2005-07-31 17:52:57 UTC (rev 83)
@@ -1,3 +1,7 @@
+This program was adapted for usage by NX by Fabian Franz.
+
+If the user nxsocksd is used, connections are restricted to localhost and certain ports.
+--------
 This is a small SOCKS5 server. While the usual "socksd" runs as a
 system service, perhaps on a firewall machine with no users, this one
 is intended to be run by users themselves.
@@ -9,10 +13,10 @@
 
 2. User is on an insecure network and wants all network traffic to be
 enrypted using "ssh", and has access to a machine running "sshd" on a
-more secure network. "usocksd" contains special provisions for this
+more secure network. "nxsocksd" contains special provisions for this
 situation.
 
-More information on how to run "usocksd" is in the man page.
+More information on how to run "nxsocksd" is in the man page.
 
 Installation: sh ./configure; make; make install.
 configure takes additional arguments --enable-debug, --enable-norelax

Modified: nx-utils/nxsocks/nxsocksd/configure
===================================================================
--- nx-utils/nxsocks/nxsocksd/configure	2005-07-31 17:49:06 UTC (rev 82)
+++ nx-utils/nxsocks/nxsocksd/configure	2005-07-31 17:52:57 UTC (rev 83)
@@ -2147,7 +2147,7 @@
 ac_given_srcdir=$srcdir
 ac_given_INSTALL="$INSTALL"
 
-trap 'rm -fr `echo "Makefile usocksd.1 config.h" | sed "s/:[^ ]*//g"` conftest*; exit 1' 1 2 15
+trap 'rm -fr `echo "Makefile nxsocksd.1 config.h" | sed "s/:[^ ]*//g"` conftest*; exit 1' 1 2 15
 EOF
 cat >> $CONFIG_STATUS <<EOF
 
@@ -2233,7 +2233,7 @@
 
 cat >> $CONFIG_STATUS <<EOF
 
-CONFIG_FILES=\${CONFIG_FILES-"Makefile usocksd.1"}
+CONFIG_FILES=\${CONFIG_FILES-"Makefile nxsocksd.1"}
 EOF
 cat >> $CONFIG_STATUS <<\EOF
 for ac_file in .. $CONFIG_FILES; do if test "x$ac_file" != x..; then

Modified: nx-utils/nxsocks/nxsocksd/configure.in
===================================================================
--- nx-utils/nxsocks/nxsocksd/configure.in	2005-07-31 17:49:06 UTC (rev 82)
+++ nx-utils/nxsocks/nxsocksd/configure.in	2005-07-31 17:52:57 UTC (rev 83)
@@ -1,4 +1,4 @@
-dnl     configure.in for usocksd. This is -*-fundamental-*-
+dnl     configure.in for nxsocksd. This is -*-fundamental-*-
 dnl     Copyright 1997 Olaf Titz <olaf at bigred.inka.de>
 
 dnl     Process this file with autoconf to produce a configure script.
@@ -183,5 +183,5 @@
 AC_DEFINE_UNQUOTED(VERSION, "$VERSION")
 AC_DEFINE_UNQUOTED(DATE, "$DATE")
 
-AC_OUTPUT(Makefile usocksd.1)
+AC_OUTPUT(Makefile nxsocksd.1)
 dnl AC_CONFIG_SUBDIRS(libresolv)

Modified: nx-utils/nxsocks/nxsocksd/lib.c
===================================================================
--- nx-utils/nxsocks/nxsocksd/lib.c	2005-07-31 17:49:06 UTC (rev 82)
+++ nx-utils/nxsocks/nxsocksd/lib.c	2005-07-31 17:52:57 UTC (rev 83)
@@ -1,5 +1,5 @@
 /*
-   usocksd - user specific SOCKS5 daemon
+   nxsocksd - user specific SOCKS5 daemon
 
    lib.c - convenience functions
 

Modified: nx-utils/nxsocks/nxsocksd/main.c
===================================================================
--- nx-utils/nxsocks/nxsocksd/main.c	2005-07-31 17:49:06 UTC (rev 82)
+++ nx-utils/nxsocks/nxsocksd/main.c	2005-07-31 17:52:57 UTC (rev 83)
@@ -1,5 +1,5 @@
 /*
-   usocksd - user specific SOCKS5 daemon
+   nxsocksd - user specific SOCKS5 daemon
 
    main.c - initialization, listening socket, ident lookup
 
@@ -441,7 +441,7 @@
     setunbuf(stdout);
     setunbuf(stderr);
     memset(&pm, 0, sizeof(pm));
-    printf("usocksd version " VERSION " (c) Olaf Titz 1997-1999\n");
+    printf("nxsocksd version " VERSION " (c) Olaf Titz 1997-1999\n");
     while((n=getopt(argc, argv, "p:a:u:i:U:d:f:"))!=EOF) {
 	switch(n) {
 	case 'p': port=atoi(optarg); break;

Modified: nx-utils/nxsocks/nxsocksd/nxsocksd.1.in
===================================================================
--- nx-utils/nxsocks/nxsocksd/nxsocksd.1.in	2005-07-31 17:49:06 UTC (rev 82)
+++ nx-utils/nxsocks/nxsocksd/nxsocksd.1.in	2005-07-31 17:52:57 UTC (rev 83)
@@ -1,5 +1,5 @@
 .\" -*- nroff -*-
-.\" $Id: usocksd.1.in,v 1.3 1999/05/13 22:28:11 olaf Exp $
+.\" $Id: nxsocksd.1.in,v 1.3 1999/05/13 22:28:11 olaf Exp $
 .\"
 .\" Configuration options
 .ds D @DEBUG@
@@ -8,9 +8,9 @@
 .\"
 .TH USOCKSD 1 "HaDiNet Software"
 .SH NAME
-usocksd \- user specific SOCKS5 daemon
+nxsocksd \- user specific SOCKS5 daemon
 .SH SYNOPSIS
-.B usocksd
+.B nxsocksd
 [
 .BI \-p " port"
 ]
@@ -30,17 +30,17 @@
 .BI \-d " debuglevel"
 ]\}
 .SH DESCRIPTION
-.B usocksd
+.B nxsocksd
 is a lightweight SOCKS5 daemon. It is intended to be run by the user
 who wants to use the SOCKS service and facilitates the use of an
 .B ssh
 TCP port redirection to run the SOCKS protocol over.
-.B usocksd
+.B nxsocksd
 is useful in situations where the user has access to a host with less
 restricted connectivity than his own machine, or where the user\'s
 own machine is on an insecure network and all connections should be
 encrypted.
-.B usocksd
+.B nxsocksd
 implements all documented commands, the address types
 .I IPv4 Address
 and
@@ -100,13 +100,13 @@
 .nf
 \fCssh -L1080:relayhost:12345 relayhost\\
 .br
- "usocksd -p12345 -arelayhost -umyhost -Ufred"\fP
+ "nxsocksd -p12345 -arelayhost -umyhost -Ufred"\fP
 .fi
 .PP
 where
 .I relayhost
 is the host where
-.B usocksd
+.B nxsocksd
 runs and
 .I myhost
 is the client's host. Note the coincidence of the host name and port
@@ -123,14 +123,14 @@
 .I relayhost
 itself. This is the reason why a regular SOCKS5 server can not be used
 for UDP in this situation (and the original incentive for writing
-.BR usocksd ).
+.BR nxsocksd ).
 The SOCKS clients will use password authentication as user
 .IR fred.
 The password to use is read from standard input.
 Neither user name nor password need to coincide with the real user
 name and password on any of the machines involved.
 .PP
-.B usocksd
+.B nxsocksd
 terminates when it encounters EOF on standard input. All other input
 on stdin is ignored. If the password should be read from a file
 instead of standard input, the proper way of invocation is
@@ -139,10 +139,10 @@
 \fCcat ~/.socks-password - |\\
  ssh -L1080:relayhost:12345 relayhost\\
 .br
- "usocksd -p12345 -arelayhost -umyhost -Ufred"\fP
+ "nxsocksd -p12345 -arelayhost -umyhost -Ufred"\fP
 .fi
 .PP
-.B usocksd
+.B nxsocksd
 does not spawn any child processes,
 .if '\*F'1' \{\
 except for the extended
@@ -174,7 +174,7 @@
 applies to diagnostic output if the standard output and standard error
 channels run on a socket or pipe which can block.
 .PP
-.B usocksd
+.B nxsocksd
 does not fully support multi-homed servers. Support for multi-homed
 clients may depend on the client's SOCKS library.
 .PP
@@ -191,7 +191,7 @@
 assumed that all allowed clients connect to each other directly.
 .PP
 There should be a more elegant method of killing an
-.B usocksd
+.B nxsocksd
 started via
 .B ssh
 than the EOF handling.
@@ -204,7 +204,7 @@
 The reference implementation SOCKS
 daemon by NEC includes undocumented commands for these applications.
 .ie '\*F'1' \{\
-.B usocksd
+.B nxsocksd
 supports these by calling the
 .B ping
 or
@@ -212,7 +212,7 @@
 programs on the host where it runs. \}
 .el \{\
 These are not supported by this configuration of
-.BR usocksd . \}
+.BR nxsocksd . \}
 .SH VERSION
 @VERSION@ as of @DATE at .
 .SH AUTHOR

Modified: nx-utils/nxsocks/nxsocksd/resolv.c
===================================================================
--- nx-utils/nxsocks/nxsocksd/resolv.c	2005-07-31 17:49:06 UTC (rev 82)
+++ nx-utils/nxsocks/nxsocksd/resolv.c	2005-07-31 17:52:57 UTC (rev 83)
@@ -1,5 +1,5 @@
 /*
-   usocksd - user specific SOCKS5 daemon
+   nxsocksd - user specific SOCKS5 daemon
 
    resolv.c - asynchronous domain name resolver
 

Modified: nx-utils/nxsocks/nxsocksd/socks.c
===================================================================
--- nx-utils/nxsocks/nxsocksd/socks.c	2005-07-31 17:49:06 UTC (rev 82)
+++ nx-utils/nxsocks/nxsocksd/socks.c	2005-07-31 17:52:57 UTC (rev 83)
@@ -1,5 +1,5 @@
 /*
-   usocksd - user specific SOCKS5 daemon
+   nxsocksd - user specific SOCKS5 daemon
 
    socks.c - SOCKS5 protocol dialog handler, TCP connection handler
 

Modified: nx-utils/nxsocks/nxsocksd/thread.c
===================================================================
--- nx-utils/nxsocks/nxsocksd/thread.c	2005-07-31 17:49:06 UTC (rev 82)
+++ nx-utils/nxsocks/nxsocksd/thread.c	2005-07-31 17:52:57 UTC (rev 83)
@@ -1,5 +1,5 @@
 /*
-   usocksd - user specific SOCKS5 daemon
+   nxsocksd - user specific SOCKS5 daemon
 
    thread.c - generic I/O multiplexing module
 

Modified: nx-utils/nxsocks/nxsocksd/udp.c
===================================================================
--- nx-utils/nxsocks/nxsocksd/udp.c	2005-07-31 17:49:06 UTC (rev 82)
+++ nx-utils/nxsocks/nxsocksd/udp.c	2005-07-31 17:52:57 UTC (rev 83)
@@ -1,5 +1,5 @@
 /*
-   usocksd - user specific SOCKS5 daemon
+   nxsocksd - user specific SOCKS5 daemon
 
    udp.c - UDP proxy
 



From fabianx at berlios.de  Sun Jul 31 19:56:59 2005
From: fabianx at berlios.de (Fabian Franz at BerliOS)
Date: Sun, 31 Jul 2005 19:56:59 +0200
Subject: [Freenx-cvs] r84 - nx-utils/nxsocks/nxsocksd
Message-ID: <200507311756.j6VHux0j013178@sheep.berlios.de>

Author: fabianx
Date: 2005-07-31 19:56:50 +0200 (Sun, 31 Jul 2005)
New Revision: 84

Modified:
   nx-utils/nxsocks/nxsocksd/configure
Log:
Made NORELAX the default.


Modified: nx-utils/nxsocks/nxsocksd/configure
===================================================================
--- nx-utils/nxsocks/nxsocksd/configure	2005-07-31 17:52:57 UTC (rev 83)
+++ nx-utils/nxsocks/nxsocksd/configure	2005-07-31 17:56:50 UTC (rev 84)
@@ -1189,7 +1189,7 @@
 EOF
 
 
-NORELAX=0
+NORELAX=1
 # Check whether --enable-norelax or --disable-norelax was given.
 if test "${enable_norelax+set}" = set; then
   enableval="$enable_norelax"



From fabianx at berlios.de  Sun Jul 31 20:06:58 2005
From: fabianx at berlios.de (Fabian Franz at BerliOS)
Date: Sun, 31 Jul 2005 20:06:58 +0200
Subject: [Freenx-cvs] r85 - nx-utils/nxsocks/nxsocksd
Message-ID: <200507311806.j6VI6wcp022809@sheep.berlios.de>

Author: fabianx
Date: 2005-07-31 20:06:54 +0200 (Sun, 31 Jul 2005)
New Revision: 85

Modified:
   nx-utils/nxsocks/nxsocksd/socks.c
Log:
Incremented s_refused instead of s_fconn, which is more accurate of whats happening.


Modified: nx-utils/nxsocks/nxsocksd/socks.c
===================================================================
--- nx-utils/nxsocks/nxsocksd/socks.c	2005-07-31 17:56:50 UTC (rev 84)
+++ nx-utils/nxsocks/nxsocksd/socks.c	2005-07-31 18:06:54 UTC (rev 85)
@@ -529,7 +529,7 @@
 
 	    if (rq_cmd(sp) != 1 || (strcmp(inet_ntoa(rq_addr(sp)),"127.0.0.1")!=0) || (ntohs(rq_port(sp)) != 631 && ntohs(rq_port(sp)) != 6201))
 	    {
-		++s_fconn;
+		++s_refused;
 		flagerr(2);
             }
 	}



From fabianx at berlios.de  Sun Jul 31 20:24:29 2005
From: fabianx at berlios.de (Fabian Franz at BerliOS)
Date: Sun, 31 Jul 2005 20:24:29 +0200
Subject: [Freenx-cvs] r86 - nx-utils/nxsocks/nxsocksd
Message-ID: <200507311824.j6VIOTaF018932@sheep.berlios.de>

Author: fabianx
Date: 2005-07-31 20:24:28 +0200 (Sun, 31 Jul 2005)
New Revision: 86

Modified:
   nx-utils/nxsocks/nxsocksd/main.c
Log:
Changed USOCKS_PASSWORD to NX-Prefix.


Modified: nx-utils/nxsocks/nxsocksd/main.c
===================================================================
--- nx-utils/nxsocks/nxsocksd/main.c	2005-07-31 18:06:54 UTC (rev 85)
+++ nx-utils/nxsocks/nxsocksd/main.c	2005-07-31 18:24:28 UTC (rev 86)
@@ -481,7 +481,7 @@
     printaddrlist(" Accepting connnections from %s", pm.acc, pm.nacc);
     printf(" ident %s\n", (pm.id) ? pm.id : "(anyone)");
     printaddrlist(" Relaying UDP from %s\n", pm.udp, pm.nudp);
-    if (pm.uname && getenv("USOCKS_PASSWORD") == NULL) {
+    if (pm.uname && getenv("NXSOCKS_PASSWORD") == NULL) {
 #ifdef HAVE_TERMIOS_H
 	struct termios tio;
 	int l=0;
@@ -514,7 +514,7 @@
     }
     else
     {
-        pm.pass=strncpy(buf, getenv("USOCKS_PASSWORD"), sizeof(buf));
+        pm.pass=strncpy(buf, getenv("NXSOCKS_PASSWORD"), sizeof(buf));
     }
     printf("Listening on port %d.\n", port);
     /*thread_fd_register(0, eofh, NULL, NULL, NULL); */



From fabianx at berlios.de  Sun Jul 31 21:04:26 2005
From: fabianx at berlios.de (Fabian Franz at BerliOS)
Date: Sun, 31 Jul 2005 21:04:26 +0200
Subject: [Freenx-cvs] r87 - nx-utils/nxsocks/nxnotify
Message-ID: <200507311904.j6VJ4QW9022438@sheep.berlios.de>

Author: fabianx
Date: 2005-07-31 21:04:25 +0200 (Sun, 31 Jul 2005)
New Revision: 87

Modified:
   nx-utils/nxsocks/nxnotify/nxnotify
Log:
Updated nxnotify to use the real NXProxy cookie as session authentication token.


Modified: nx-utils/nxsocks/nxnotify/nxnotify
===================================================================
--- nx-utils/nxsocks/nxnotify/nxnotify	2005-07-31 18:24:28 UTC (rev 86)
+++ nx-utils/nxsocks/nxnotify/nxnotify	2005-07-31 19:04:25 UTC (rev 87)
@@ -20,15 +20,17 @@
 		case $line in
 			"Info: Forwarding cups connections to port "*)
 			NXSOCKS_PORT=$(echo $line  | cut -d"'" -f2)
-			USOCKS_PASSWORD="cookie" nxsocksd -p "$NXSOCKS_PORT" -a 127.0.0.1 -u 127.0.0.1 -U nxsocksd &
+			NXSOCKS_COOKIE=$(grep "cookie=" $(dirname $1)/options | sed 's/.*cookie=//g' | cut -d',' -f1)
+			NXSOCKS_PASSWORD="$NXSOCKS_COOKIE" nxsocksd -p "$NXSOCKS_PORT" -a 127.0.0.1 -u 127.0.0.1 -U nxsocksd &
 			NXSOCKSD_PID=$!
 			disown $!
 			;;
 			"Info: Shutting down the link and exiting."*)
-				echo "Info $1: Shutting down and renaming session file."
+				echo "Info $1: Shutting down and removing session infos."
 				[ -n $NXSOCKSD_PID ] && kill "$NXSOCKSD_PID"
-				mv -f $1 $1.nx
 				rm -f $1.monitored
+				rm -f $(dirname $1)/{errors,stats,session,options}
+				rmdir $(dirname $1)
 				return 0
 			;;
 		esac
@@ -37,6 +39,9 @@
 }
 
 echo "Info: Scanning ..."
+
+# Wait a moment for the session file to appear
+sleep 1
 LIST=$(find ~/.nx/ -name session -cnewer ~/.nx/notify-ref)
 
 touch ~/.nx/notify-ref



From fabianx at berlios.de  Sun Jul 31 21:52:32 2005
From: fabianx at berlios.de (Fabian Franz at BerliOS)
Date: Sun, 31 Jul 2005 21:52:32 +0200
Subject: [Freenx-cvs] r88 - in nx-utils/nxsocks: . nxgentsocksconf
Message-ID: <200507311952.j6VJqW2i025109@sheep.berlios.de>

Author: fabianx
Date: 2005-07-31 21:52:31 +0200 (Sun, 31 Jul 2005)
New Revision: 88

Added:
   nx-utils/nxsocks/nxgentsocksconf/
   nx-utils/nxsocks/nxgentsocksconf/nxgentsocksconf
Log:
Added nxgentsocksconf to allow easy updating of server side tsocks.conf.


Added: nx-utils/nxsocks/nxgentsocksconf/nxgentsocksconf
===================================================================
--- nx-utils/nxsocks/nxgentsocksconf/nxgentsocksconf	2005-07-31 19:04:25 UTC (rev 87)
+++ nx-utils/nxsocks/nxgentsocksconf/nxgentsocksconf	2005-07-31 19:52:31 UTC (rev 88)
@@ -0,0 +1,30 @@
+offset=$(echo $DISPLAY | cut -d: -f2 | cut -d. -f1)
+
+let port=offset+2000
+
+cookie=$(cat $HOME/.nx/C-*$offset*/options | sed 's/.*cookie=//g' | cut -d',' -f1)
+
+cat <<EOF > $HOME/tsocks.conf.generated
+# This is the configuration for libtsocks (transparent socks)
+# Lines beginning with # and blank lines are ignored
+#
+# This sample configuration shows the simplest (and most common) use of
+# tsocks. This is a basic LAN, this machine can access anything on the
+# local ethernet (192.168.0.*) but anything else has to use the SOCKS version
+# 4 server on the firewall. Further details can be found in the man pages,
+# tsocks(8) and tsocks.conf(5) and a more complex example is presented in
+# tsocks.conf.complex.example
+
+# We can access 192.168.0.* directly
+#local = 192.168.0.0/255.255.255.0
+
+path {
+        reaches = 127.0.0.1:631/255.255.255.255
+        reaches = 127.0.0.1:6201/255.255.255.255
+        server = 127.0.0.1
+        server_type = 5
+        server_port = $port
+        default_user = nxsocksd
+        default_pass = $cookie
+}
+EOF


Property changes on: nx-utils/nxsocks/nxgentsocksconf/nxgentsocksconf
___________________________________________________________________
Name: svn:executable
   + *



From fabianx at berlios.de  Sun Jul 31 22:41:10 2005
From: fabianx at berlios.de (Fabian Franz at BerliOS)
Date: Sun, 31 Jul 2005 22:41:10 +0200
Subject: [Freenx-cvs] r90 - nx-utils/nxsocks/nxtsocks
Message-ID: <200507312041.j6VKfARs027319@sheep.berlios.de>

Author: fabianx
Date: 2005-07-31 22:41:08 +0200 (Sun, 31 Jul 2005)
New Revision: 90

Modified:
   nx-utils/nxsocks/nxtsocks/Makefile.in
   nx-utils/nxsocks/nxtsocks/tsocks.c
Log:
Changed nxtsocks to do what we need (Forward also connections to localhost to the socks-server; All other connections not in paths are direct)
NX'fied nxtsocks so that it can be installed at the same time as tsocks.


Modified: nx-utils/nxsocks/nxtsocks/Makefile.in
===================================================================
--- nx-utils/nxsocks/nxtsocks/Makefile.in	2005-07-31 20:12:01 UTC (rev 89)
+++ nx-utils/nxsocks/nxtsocks/Makefile.in	2005-07-31 20:41:08 UTC (rev 90)
@@ -16,7 +16,7 @@
 SHCC = ${CC} -fPIC 
 INSPECT = inspectsocks
 SAVE = saveme
-LIB_NAME = libtsocks
+LIB_NAME = libnxtsocks
 COMMON = common
 PARSER = parser
 VALIDATECONF = validateconf

Modified: nx-utils/nxsocks/nxtsocks/tsocks.c
===================================================================
--- nx-utils/nxsocks/nxtsocks/tsocks.c	2005-07-31 20:12:01 UTC (rev 89)
+++ nx-utils/nxsocks/nxtsocks/tsocks.c	2005-07-31 20:41:08 UTC (rev 90)
@@ -278,10 +278,10 @@
                       "%s\n", __fd, inet_ntoa(connaddr->sin_addr));
 
    /* If the address is local call realconnect */
-   if (!(is_local(config, &(connaddr->sin_addr)))) {
+   /*if (!(is_local(config, &(connaddr->sin_addr)))) {
       show_msg(MSGDEBUG, "Connection for socket %d is local\n", __fd);
       return(realconnect(__fd, __addr, __len));
-   }
+   }*/
 
    /* Ok, so its not local, we need a path to the net */
    pick_server(config, &path, &(connaddr->sin_addr), ntohs(connaddr->sin_port));
@@ -290,10 +290,11 @@
             (path->address ? path->address : "(Not Provided)"));
    if (path->address == NULL) {
       if (path == &(config->defaultserver)) 
-         show_msg(MSGERR, "Connection needs to be made "
+         /*show_msg(MSGERR, "Connection needs to be made "
                           "via default server but "
                           "the default server has not "
-                          "been specified\n");
+                          "been specified\n");*/
+         return(realconnect(__fd, __addr, __len));
       else 
          show_msg(MSGERR, "Connection needs to be made "
                           "via path specified at line "



